diff --git a/bt-app/a2dp_sink/include/A2dp_Sink.hpp b/bt-app/a2dp_sink/include/A2dp_Sink.hpp
index 192640a..3a5ae22 100644
--- a/bt-app/a2dp_sink/include/A2dp_Sink.hpp
+++ b/bt-app/a2dp_sink/include/A2dp_Sink.hpp
@@ -1,5 +1,5 @@
  /*
-  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+  * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
@@ -31,15 +31,11 @@
 #define A2DP_SINK_APP_H
 
 #include <map>
+#include <list>
 #include <string>
 #include <hardware/bluetooth.h>
 #include <hardware/bt_av.h>
-#include <hardware/bt_rc.h>
 #include <pthread.h>
-#if (defined BT_AUDIO_HAL_INTEGRATION)
-#include <hardware/audio.h>
-#include <hardware/hardware.h>
-#endif
 
 #include "osi/include/log.h"
 #include "osi/include/thread.h"
@@ -48,16 +44,49 @@
 #include "osi/include/alarm.h"
 #include "ipc.h"
 #include "utils.h"
+#include "hardware/bt_av_vendor.h"
+#include "A2dp_Sink_Streaming.hpp"
+
+using namespace std;
+using std::list;
+using std::string;
 
+typedef enum {
+    DEVICE_STATE_DISCONNECTED = 0,
+    DEVICE_STATE_PENDING,
+    DEVICE_STATE_CONNECTED,
+}A2dpSinkDeviceState;
 
 typedef enum {
-    STATE_NOT_STARTED = 0,
-    STATE_DISCONNECTED,
-    STATE_PENDING,
-    STATE_CONNECTED,
+    SINK_STATE_NOT_STARTED = 0,
+    SINK_STATE_STARTED,
 }A2dpSinkState;
 
-#define A2DP_SINK_PCM_FETCH_TIMER_DURATION     40
+typedef struct {
+    uint32_t sample_rate;
+    uint8_t channel_count;
+}A2dpSinkConfig_t;
+
+class A2dp_Device {
+
+  public:
+    config_t *config;
+    bt_bdaddr_t mDevice;
+    bt_bdaddr_t mConnectingDevice;
+    bt_bdaddr_t mConnectedDevice;
+    A2dpSinkDeviceState mSinkDeviceState;
+    A2dpSinkConfig_t av_config;
+    btav_codec_config_t dev_codec_config;
+    uint16_t dev_codec_type;
+    pthread_mutex_t lock;
+    bool mAvrcpConnected;
+    int mNotificationLabel;
+    bool mAbsVolNotificationRequested;
+    bool mAbsoluteVolumeChangeInProgress;
+  public:
+    A2dp_Device(config_t *config, bt_bdaddr_t dev);
+    ~A2dp_Device();
+};
 
 class A2dp_Sink {
 
@@ -65,42 +94,27 @@ class A2dp_Sink {
     config_t *config;
     const bt_interface_t * bluetooth_interface;
     const btav_interface_t *sBtA2dpSinkInterface;
-    const btrc_ctrl_interface_t *sBtAvrcpCtrlInterface;
     A2dpSinkState mSinkState;
-    bool mAvrcpConnected;
+    const btav_sink_vendor_interface_t *sBtA2dpSinkVendorInterface;
 
   public:
     A2dp_Sink(const bt_interface_t *bt_interface, config_t *config);
     ~A2dp_Sink();
-    void ProcessEvent(BtEvent* pEvent);
-    void state_disconnected_handler(BtEvent* pEvent);
-    void state_pending_handler(BtEvent* pEvent);
-    void state_connected_handler(BtEvent* pEvent);
-    void change_state(A2dpSinkState mState);
+    void ProcessEvent(BtEvent* pEvent, list<A2dp_Device>::iterator iter);
+    void state_disconnected_handler(BtEvent* pEvent, list<A2dp_Device>::iterator iter);
+    void state_pending_handler(BtEvent* pEvent, list<A2dp_Device>::iterator iter);
+    void state_connected_handler(BtEvent* pEvent, list<A2dp_Device>::iterator iter);
+    void change_state(list<A2dp_Device>::iterator iter, A2dpSinkDeviceState mState);
     char* dump_message(BluetoothEventId event_id);
     pthread_mutex_t lock;
-    bt_bdaddr_t mConnectingDevice;
-    bt_bdaddr_t mConnectedDevice;
-    bt_bdaddr_t mConnectedAvrcpDevice;
-    void HandleAvrcpEvents(BtEvent* pEvent);
+    uint32_t max_a2dp_conn;
     void HandleEnableSink();
     void HandleDisableSink();
-    void SendPassThruCommandNative(uint8_t key_id);
-    ControlStatusType controlStatus;
-    uint32_t sample_rate;
-    uint8_t channel_count;
-    alarm_t *pcm_data_fetch_timer;
-#if (defined BT_AUDIO_HAL_INTEGRATION)
-    audio_stream_out_t* out_stream;
-#endif
-    void ConfigureAudioHal();
-    void CloseAudioStream();
-    size_t pcm_buf_size;
-    uint8_t* pcm_buf;
-    bool pcm_timer;
-    void StartPcmTimer();
-    void StopPcmTimer();
-    void OnDisconnected();
+    void HandleSinkStreamingDisableDone();
+    void ConnectionManager(BtEvent* pEvent, bt_bdaddr_t dev);
+    void EventManager(BtEvent* pEvent, bt_bdaddr_t dev);
+    bool isConnectionEvent(BluetoothEventId event_id);
+    list<A2dp_Device> pA2dpDeviceList;
 };
 
 #endif
diff --git a/bt-app/a2dp_sink/include/A2dp_Sink_Streaming.hpp b/bt-app/a2dp_sink/include/A2dp_Sink_Streaming.hpp
new file mode 100644
index 0000000..2f4bab9
--- /dev/null
+++ b/bt-app/a2dp_sink/include/A2dp_Sink_Streaming.hpp
@@ -0,0 +1,144 @@
+ /*
+  * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#ifndef A2DP_SINK_STREAMING_APP_H
+#define A2DP_SINK_STREAMING_APP_H
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_av.h>
+#include <pthread.h>
+#if (defined BT_AUDIO_HAL_INTEGRATION)
+#include "qahw_api.h"
+#include "qahw_defs.h"
+
+#endif
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/allocator.h"
+#include "osi/include/alarm.h"
+#include "ipc.h"
+#include "utils.h"
+#include "hardware/bt_av_vendor.h"
+
+
+typedef void (*A2dpSinkStreamingThreadHandler) (void *msg);
+
+typedef struct {
+    thread_t *thread_id;
+    A2dpSinkStreamingThreadHandler thread_handler;
+    char *thread_name;
+} A2dpSinkStreamingThreadInfo;
+
+#define A2DP_SINK_PCM_FETCH_TIMER_DURATION         35
+#define A2DP_SINK_COMPRESS_FEED_TIMER_DURATION     40
+#define A2DP_SINK_GBUF_MAX_SIZE 65535
+
+class A2dp_Sink_Streaming {
+
+  private:
+    config_t *config;
+
+  public:
+    A2dp_Sink_Streaming(config_t *config);
+    ~A2dp_Sink_Streaming();
+    char* dump_message(BluetoothEventId event_id);
+    void HandleEnableSinkStreaming();
+    void HandleDisableSinkStreaming();
+    pthread_mutex_t lock;
+    bt_bdaddr_t mStreamingDevice;
+    bt_bdaddr_t mResumingDevice;
+    const btav_sink_vendor_interface_t *mBtA2dpSinkStreamingVendorInterface;
+    ControlStatusType controlStatus;
+    A2dpSinkStreamingThreadInfo threadInfo;
+    uint32_t sample_rate;
+    uint8_t channel_count;
+    alarm_t *pcm_data_fetch_timer;
+    alarm_t *compress_audio_feed_timer;
+#if (defined BT_AUDIO_HAL_INTEGRATION)
+    // structure for output stream
+    qahw_stream_handle_t *out_stream;
+    // structures used for loading A2DP HAL
+    qahw_module_handle_t *a2dp_input_device;
+    qahw_stream_handle_t *input_stream;
+#endif
+#if (defined USE_GST)
+    uint8_t *gbuff;
+#endif
+    //apis for in_stream bt a2dp HAL, to read data.
+    void LoadBtA2dpHAL();
+    void UnLoadBtA2dpHAL();
+    void OpenInputStream();
+    void SuspendInputStream();
+    void CloseInputStream();
+    uint32_t ReadInputStream(uint8_t* data, uint32_t size);
+    uint32_t GetInputStreamBufferSize();
+    bool use_bt_a2dp_hal;
+    bool sbc_decoding;
+    bool fetch_rtp_info;
+    bool enable_delay_report;
+    bool relay_sink_data; /* if this is enabled, we relay Sink data to Src */
+    // apis for out_stream Audio HAL, to write data.
+    void ConfigureAudioHal();
+    void CloseAudioStream();
+    size_t pcm_buf_size;
+    size_t cuml_data_written_to_audio;
+    size_t residual_compress_data;
+    uint8_t* pcm_buf;
+    bool pcm_timer;
+    bool compress_offload_timer;
+    int current_vol_idx;
+    void StartPcmTimer();
+    void StopDataFetchTimer();
+    void OnDisconnected();
+    void GetLibInterface(const btav_sink_vendor_interface_t *sBtA2dpSinkStrVendorInterface);
+    uint16_t codec_type;
+    btav_codec_config_t codec_config;
+    uint32_t get_a2dp_sbc_sampling_rate(uint8_t frequency);
+    uint8_t get_a2dp_sbc_channel_mode(uint8_t channel_count);
+    uint32_t get_a2dp_aac_sampling_rate(uint16_t frequency);
+    uint8_t get_a2dp_aac_channel_mode(uint8_t channel_count);
+    uint32_t get_a2dp_mp3_sampling_rate(uint16_t frequency);
+    uint8_t get_a2dp_mp3_channel_mode(uint8_t channel_count);
+    uint32_t get_a2dp_aptx_sampling_rate(uint8_t frequency);
+    uint8_t get_a2dp_aptx_channel_mode(uint8_t channel_count);
+    void FillCompressBuffertoAudioOutHal();
+    void StartCompressAudioFeedTimer();
+    void StopCompressAudioFeedTimer();
+    void SetStreamVol(int curr_audio_index);
+};
+
+#endif
diff --git a/bt-app/a2dp_sink/src/A2dp_Sink.cpp b/bt-app/a2dp_sink/src/A2dp_Sink.cpp
index 634ce07..c56bcb2 100644
--- a/bt-app/a2dp_sink/src/A2dp_Sink.cpp
+++ b/bt-app/a2dp_sink/src/A2dp_Sink.cpp
@@ -1,5 +1,5 @@
  /*
-  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+  * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
@@ -34,29 +34,24 @@
 #include <hardware/bluetooth.h>
 #include <hardware/hardware.h>
 #include <hardware/bt_av.h>
-#include "Audio_Manager.hpp"
-
+#include "A2dp_Sink_Streaming.hpp"
 #include "A2dp_Sink.hpp"
+#include "Avrcp.hpp"
 #include "Gap.hpp"
+#include "hardware/bt_av_vendor.h"
+#include <algorithm>
 
 #define LOGTAG "A2DP_SINK"
-#define LOGTAG_CTRL "AVRCP_CTRL"
 
 using namespace std;
 using std::list;
 using std::string;
 
 A2dp_Sink *pA2dpSink = NULL;
-extern BT_Audio_Manager *pBTAM;
-
-#if (!defined(BT_AUDIO_HAL_INTEGRATION))
-#define DUMP_PCM_DATA TRUE
-#endif
+A2dp_Sink_Streaming *pA2dpSinkStream;
+extern Avrcp *pAvrcp;
 
-#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
-FILE *outputPcmSampleFile;
-char outputFilename [50] = "/etc/bluetooth/output_sample.pcm";
-#endif
+static const bt_bdaddr_t bd_addr_null= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 
 #ifdef __cplusplus
 extern "C" {
@@ -65,6 +60,7 @@ extern "C" {
 void BtA2dpSinkMsgHandler(void *msg) {
     BtEvent* pEvent = NULL;
     BtEvent* pCleanupEvent = NULL;
+    BtEvent *pCleanupSinkStreaming = NULL;
     if(!msg) {
         printf("Msg is NULL, return.\n");
         return;
@@ -86,24 +82,26 @@ void BtA2dpSinkMsgHandler(void *msg) {
             break;
         case A2DP_SINK_CLEANUP_REQ:
             ALOGD(LOGTAG " cleanup a2dp sink");
-            if (pA2dpSink) {
-                pA2dpSink->CloseAudioStream();
-                pA2dpSink->StopPcmTimer();
+            pCleanupSinkStreaming = new BtEvent;
+            pCleanupSinkStreaming->a2dpSinkStreamingEvent.event_id =
+                    A2DP_SINK_STREAMING_CLEANUP_REQ;
+            if (pA2dpSinkStream) {
+                thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                pA2dpSinkStream->threadInfo.thread_handler, (void*)pCleanupSinkStreaming);
             }
             pCleanupEvent = new BtEvent;
             pCleanupEvent->event_id = A2DP_SINK_CLEANUP_DONE;
             PostMessage(THREAD_ID_GAP, pCleanupEvent);
             break;
-        case AVRCP_CTRL_CONNECTED_CB:
-        case AVRCP_CTRL_DISCONNECTED_CB:
-        case AVRCP_CTRL_PASS_THRU_CMD_REQ:
+        case A2DP_SINK_STREAMING_DISABLE_DONE:
+            ALOGD(LOGTAG " a2dp sink streaming disable done");
             if (pA2dpSink) {
-                pA2dpSink->HandleAvrcpEvents(( BtEvent *) msg);
+                pA2dpSink->HandleSinkStreamingDisableDone();
             }
             break;
         default:
             if(pA2dpSink) {
-               pA2dpSink->ProcessEvent(( BtEvent *) msg);
+               pA2dpSink->EventManager(( BtEvent *) msg, pEvent->a2dpSinkEvent.bd_addr);
             }
             break;
     }
@@ -114,32 +112,49 @@ void BtA2dpSinkMsgHandler(void *msg) {
 }
 #endif
 
-
-void pcm_fetch_timer_handler(void *context) {
-    ALOGV(LOGTAG, " pcm_fetch_timer_handler ");
-
-    BtEvent *pEvent = new BtEvent;
-    pEvent->a2dpSinkEvent.event_id = A2DP_SINK_FETCH_PCM_DATA;
-    PostMessage(THREAD_ID_A2DP_SINK, pEvent);
+list<A2dp_Device>::iterator FindDeviceByAddr(list<A2dp_Device>& pA2dpDev, bt_bdaddr_t dev) {
+    list<A2dp_Device>::iterator p = pA2dpDev.begin();
+    while(p != pA2dpDev.end()) {
+        if (memcmp(&dev, &p->mDevice, sizeof(bt_bdaddr_t)) == 0) {
+            break;
+        }
+        p++;
+    }
+    return p;
 }
 
-void A2dp_Sink::StartPcmTimer() {
-    if(pcm_timer) {
-        ALOGD(LOGTAG " PCM Timer still running + ");
-        return;
+bool GetCodecInfoByAddr(bt_bdaddr_t* bd_addr, uint16_t *dev_codec_type, btav_codec_config_t* codec_config)
+{
+    ALOGD(LOGTAG "enter func GetCodecINfo ===>");
+    if(bd_addr == NULL)
+    {
+        bd_addr= &pA2dpSinkStream->mStreamingDevice;
+        ALOGD(LOGTAG " check the steramding device codec");
+        if (!memcmp(&pA2dpSinkStream->mStreamingDevice, &bd_addr_null, sizeof(bt_bdaddr_t)))
+        {
+            ALOGD(LOGTAG " the steaming device is empty ");
+            return false;
+        }
     }
-    alarm_set(pcm_data_fetch_timer, A2DP_SINK_PCM_FETCH_TIMER_DURATION,
-           pcm_fetch_timer_handler, NULL);
-    pcm_timer = true;
-}
-void A2dp_Sink::StopPcmTimer() {
-    if((pcm_data_fetch_timer != NULL) && (pcm_timer)) {
-        alarm_cancel(pcm_data_fetch_timer);
-        pcm_timer = false;
+    list<A2dp_Device>::iterator iter = FindDeviceByAddr(pA2dpSink->pA2dpDeviceList, *bd_addr);
+    if(iter != pA2dpSink->pA2dpDeviceList.end())
+    {
+        ALOGD(LOGTAG " Audio Config CB: found matching device");
+        *dev_codec_type = iter->dev_codec_type;
+        memcpy((void*)codec_config,(void *) &iter->dev_codec_config, sizeof(iter->dev_codec_config));
+        //for(int i=0;i<7;i++)
+        ALOGE(LOGTAG "codec_type = %u", *dev_codec_type);
+        return true;
+    }
+    else
+    {
+        ALOGE(LOGTAG " ERROR: Audio Config CB: No matching device");
+        return false;
     }
 }
+
 static void bta2dp_connection_state_callback(btav_connection_state_t state, bt_bdaddr_t* bd_addr) {
-    ALOGD(LOGTAG " Connection State CB");
+    ALOGD(LOGTAG " Connection State CB state = %d", state);
     BtEvent *pEvent = new BtEvent;
     memcpy(&pEvent->a2dpSinkEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
     switch( state ) {
@@ -160,7 +175,7 @@ static void bta2dp_connection_state_callback(btav_connection_state_t state, bt_b
 }
 
 static void bta2dp_audio_state_callback(btav_audio_state_t state, bt_bdaddr_t* bd_addr) {
-    ALOGD(LOGTAG " Audio State CB");
+    ALOGD(LOGTAG " Audio State CB state = %d", state);
     BtEvent *pEvent = new BtEvent;
     memcpy(&pEvent->a2dpSinkEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
     switch( state ) {
@@ -180,148 +195,68 @@ static void bta2dp_audio_state_callback(btav_audio_state_t state, bt_bdaddr_t* b
 static void bta2dp_audio_config_callback(bt_bdaddr_t *bd_addr, uint32_t sample_rate,
         uint8_t channel_count) {
     ALOGD(LOGTAG " Audio Config CB sample_rate %d, channel_count %d", sample_rate, channel_count);
-    if(pA2dpSink)
+    list<A2dp_Device>::iterator iter = FindDeviceByAddr(pA2dpSink->pA2dpDeviceList, *bd_addr);
+    if(iter != pA2dpSink->pA2dpDeviceList.end())
+    {
+        ALOGD(LOGTAG " Audio Config CB: found matching device");
+        iter->av_config.sample_rate = sample_rate;
+        iter->av_config.channel_count = channel_count;
+    }
+    else
     {
-        pA2dpSink->sample_rate = sample_rate;
-        pA2dpSink->channel_count = channel_count;
+        ALOGE(LOGTAG " ERROR: Audio Config CB: No matching device");
     }
 }
-static void bta2dp_audio_focus_request_callback(bt_bdaddr_t *bd_addr) {
-    ALOGD(LOGTAG " bta2dp_audio_focus_request_callback ");
+static void bta2dp_audio_focus_request_vendor_callback(bt_bdaddr_t *bd_addr) {
+    ALOGD(LOGTAG " bta2dp_audio_focus_request_vendor_callback ");
     BtEvent *pEvent = new BtEvent;
     pEvent->a2dpSinkEvent.event_id = A2DP_SINK_FOCUS_REQUEST_CB;
     memcpy(&pEvent->a2dpSinkEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
     PostMessage(THREAD_ID_A2DP_SINK, pEvent);
 }
 
+static void bta2dp_audio_codec_config_vendor_callback(bt_bdaddr_t *bd_addr, uint16_t codec_type,
+        btav_codec_config_t codec_config) {
+    ALOGD(LOGTAG " bta2dp_audio_codec_config_vendor_callback codec_type=%d",codec_type);
+
+    BtEvent *pEvent = new BtEvent;
+    pEvent->a2dpSinkEvent.event_id = A2DP_SINK_CODEC_CONFIG;
+    memcpy(&pEvent->a2dpSinkEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->a2dpSinkEvent.buf_size = sizeof(btav_codec_config_t);
+    pEvent->a2dpSinkEvent.buf_ptr = (uint8_t*)osi_malloc(pEvent->a2dpSinkEvent.buf_size);
+    memcpy(pEvent->a2dpSinkEvent.buf_ptr, &codec_config, pEvent->a2dpSinkEvent.buf_size);
+    pEvent->a2dpSinkEvent.arg1 = codec_type;
+    PostMessage(THREAD_ID_A2DP_SINK, pEvent);
+}
+
 static btav_callbacks_t sBluetoothA2dpSinkCallbacks = {
     sizeof(sBluetoothA2dpSinkCallbacks),
     bta2dp_connection_state_callback,
     bta2dp_audio_state_callback,
     bta2dp_audio_config_callback,
-    NULL,
-    NULL,
-    bta2dp_audio_focus_request_callback,
 };
 
-static void btavrcpctrl_passthru_rsp_callback(int id, int key_state) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_passthru_rsp_callback id = %d key_state = %d", id, key_state);
-}
-
-static void btavrcpctrl_connection_state_callback(bool state, bt_bdaddr_t* bd_addr) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_connection_state_callback state = %d", state);
-    BtEvent *pEvent = new BtEvent;
-    memcpy(&pEvent->avrcpCtrlEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
-    if (state == true)
-        pEvent->avrcpCtrlEvent.event_id = AVRCP_CTRL_CONNECTED_CB;
-    else
-        pEvent->avrcpCtrlEvent.event_id = AVRCP_CTRL_DISCONNECTED_CB;
-    PostMessage(THREAD_ID_A2DP_SINK, pEvent);
-}
-
-static void btavrcpctrl_rcfeatures_callback( bt_bdaddr_t* bd_addr, int features) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_rcfeatures_callback features = %d", features);
-}
-
-static void btavrcpctrl_getcap_rsp_callback( bt_bdaddr_t *bd_addr, int cap_id,
-                uint32_t* supported_values, int num_supported, uint8_t rsp_type) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_getcap_rsp_callback");
-}
-
-static void btavrcpctrl_listplayerappsettingattrib_rsp_callback( bt_bdaddr_t *bd_addr,
-                          uint8_t* supported_attribs, int num_attrib, uint8_t rsp_type) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_listplayerappsettingattrib_rsp_callback");
-}
-
-static void btavrcpctrl_listplayerappsettingvalue_rsp_callback( bt_bdaddr_t *bd_addr,
-                       uint8_t* supported_val, uint8_t num_supported, uint8_t rsp_type) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_listplayerappsettingvalue_rsp_callback");
-}
-
-static void btavrcpctrl_currentplayerappsetting_rsp_callback( bt_bdaddr_t *bd_addr,
-        uint8_t* supported_ids, uint8_t* supported_val, uint8_t num_attrib, uint8_t rsp_type) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_currentplayerappsetting_rsp_callback");
-}
-
-static void btavrcpctrl_setplayerappsetting_rsp_callback( bt_bdaddr_t *bd_addr,uint8_t rsp_type) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_setplayerappsetting_rsp_callback");
-}
-
-static void btavrcpctrl_notification_rsp_callback( bt_bdaddr_t *bd_addr, uint8_t rsp_type,
-        int rsp_len, uint8_t* notification_rsp) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_notification_rsp_callback");
-}
-
-static void btavrcpctrl_getelementattrib_rsp_callback(bt_bdaddr_t *bd_addr, uint8_t num_attributes,
-       int rsp_len, uint8_t* attrib_rsp, uint8_t rsp_type) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_getelementattrib_rsp_callback");
-}
-
-static void btavrcpctrl_getplaystatus_rsp_callback(bt_bdaddr_t *bd_addr, int param_len,
-        uint8_t* play_status_rsp, uint8_t rsp_type) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_getplaystatus_rsp_callback");
-}
-
-static void btavrcpctrl_setabsvol_cmd_callback(bt_bdaddr_t *bd_addr, uint8_t abs_vol) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_setabsvol_cmd_callback");
-}
-
-static void btavrcpctrl_registernotification_absvol_callback(bt_bdaddr_t *bd_addr) {
-    ALOGD(LOGTAG_CTRL " btavrcpctrl_registernotification_absvol_callback");
-}
-
-static btrc_ctrl_callbacks_t sBluetoothAvrcpCtrlCallbacks = {
-   sizeof(sBluetoothAvrcpCtrlCallbacks),
-   btavrcpctrl_passthru_rsp_callback,
-   btavrcpctrl_connection_state_callback,
-   btavrcpctrl_rcfeatures_callback,
-   btavrcpctrl_getcap_rsp_callback,
-   btavrcpctrl_listplayerappsettingattrib_rsp_callback,
-   btavrcpctrl_listplayerappsettingvalue_rsp_callback,
-   btavrcpctrl_currentplayerappsetting_rsp_callback,
-   btavrcpctrl_setplayerappsetting_rsp_callback,
-   btavrcpctrl_notification_rsp_callback,
-   btavrcpctrl_getelementattrib_rsp_callback,
-   btavrcpctrl_getplaystatus_rsp_callback,
-   btavrcpctrl_setabsvol_cmd_callback,
-   btavrcpctrl_registernotification_absvol_callback,
+static btav_sink_vendor_callbacks_t sBluetoothA2dpSinkVendorCallbacks = {
+    sizeof(sBluetoothA2dpSinkVendorCallbacks),
+    bta2dp_audio_focus_request_vendor_callback,
+    bta2dp_audio_codec_config_vendor_callback,
 };
 
-void A2dp_Sink::SendPassThruCommandNative(uint8_t key_id) {
-    if (sBtAvrcpCtrlInterface != NULL) {
-        sBtAvrcpCtrlInterface->send_pass_through_cmd(&mConnectedAvrcpDevice, key_id, 0);
-        sBtAvrcpCtrlInterface->send_pass_through_cmd(&mConnectedAvrcpDevice, key_id, 1);
-    }
-}
-void A2dp_Sink::HandleAvrcpEvents(BtEvent* pEvent) {
-    ALOGD(LOGTAG_CTRL " HandleAvrcpEvents event = %s", dump_message(pEvent->avrcpCtrlEvent.event_id));
-    switch(pEvent->avrcpCtrlEvent.event_id) {
-    case AVRCP_CTRL_CONNECTED_CB:
-        mAvrcpConnected = true;
-        memcpy(&mConnectedAvrcpDevice, &pEvent->avrcpCtrlEvent.bd_addr,
-                sizeof(bt_bdaddr_t));
-        break;
-    case AVRCP_CTRL_DISCONNECTED_CB:
-        mAvrcpConnected = false;
-        memset(&mConnectedAvrcpDevice, 0, sizeof(bt_bdaddr_t));
-        break;
-    case AVRCP_CTRL_PASS_THRU_CMD_REQ:
-        if (!mAvrcpConnected || (memcmp(&mConnectedAvrcpDevice, &mConnectedDevice,
-                                                          sizeof(bt_bdaddr_t)) != 0)) {
-            ALOGD(LOGTAG_CTRL " Avrcp Not connected/ Not to A2DP Sink ");
-            break;
-        }
-        SendPassThruCommandNative(pEvent->avrcpCtrlEvent.key_id);
-        break;
-    }
-}
-
 void A2dp_Sink::HandleEnableSink(void) {
+    ALOGD(LOGTAG " HandleEnableSink ");
+
+    uint8_t streaming_prarm = 0;
     BtEvent *pEvent = new BtEvent;
+    max_a2dp_conn = config_get_int (config,
+            CONFIG_DEFAULT_SECTION, "BtMaxA2dpConn", 1);
+
     if (bluetooth_interface != NULL)
     {
         sBtA2dpSinkInterface = (btav_interface_t *)bluetooth_interface->
                 get_profile_interface(BT_PROFILE_ADVANCED_AUDIO_SINK_ID);
+        sBtA2dpSinkVendorInterface = (btav_sink_vendor_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_ADVANCED_AUDIO_SINK_VENDOR_ID);
+
         if (sBtA2dpSinkInterface == NULL)
         {
              pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
@@ -330,57 +265,221 @@ void A2dp_Sink::HandleEnableSink(void) {
              PostMessage(THREAD_ID_GAP, pEvent);
              return;
         }
-        change_state(STATE_DISCONNECTED);
-        sBtA2dpSinkInterface->init(&sBluetoothA2dpSinkCallbacks, 1, 0);
+        pA2dpSink->mSinkState = SINK_STATE_STARTED;
+        pA2dpSinkStream->fetch_rtp_info = config_get_bool (config,
+                         CONFIG_DEFAULT_SECTION, "BtFetchRTPForSink", false);
+        pA2dpSinkStream->sbc_decoding = config_get_bool (config,
+            CONFIG_DEFAULT_SECTION, "BtEnableSBCDecoding", true);
+        ALOGD(LOGTAG " Fetch RTP Info %d", pA2dpSinkStream->fetch_rtp_info);
+
+        pA2dpSinkStream->enable_delay_report = config_get_bool (config,CONFIG_DEFAULT_SECTION, "BtA2dpDelayReportEnable", false);
+        ALOGD(LOGTAG " ~~ enable_delay_report  %d ", pA2dpSinkStream->enable_delay_report);
+#ifdef USE_LIBHW_AOSP
+        sBtA2dpSinkInterface->init(&sBluetoothA2dpSinkCallbacks);
+#else
+        sBtA2dpSinkInterface->init(&sBluetoothA2dpSinkCallbacks, max_a2dp_conn, 0);
+#endif
+        if (pA2dpSinkStream->fetch_rtp_info)
+            streaming_prarm |= A2DP_SINK_RETREIVE_RTP_HEADER;
+        if(pA2dpSinkStream->sbc_decoding)
+            streaming_prarm |= A2DP_SINK_ENABLE_SBC_DECODING;
+        if (pA2dpSinkStream->enable_delay_report)
+            streaming_prarm |= A2DP_SINK_ENABLE_DELAY_REPORTING;
+
+        sBtA2dpSinkVendorInterface->init_vendor(&sBluetoothA2dpSinkVendorCallbacks,
+                    max_a2dp_conn, 0,
+                    streaming_prarm);
+
         pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
         pEvent->profile_start_event.profile_id = PROFILE_ID_A2DP_SINK;
         pEvent->profile_start_event.status = true;
-        // AVRCP Initialization
-        sBtAvrcpCtrlInterface = (btrc_ctrl_interface_t *)bluetooth_interface->
-                get_profile_interface(BT_PROFILE_AV_RC_CTRL_ID);
-        if (sBtAvrcpCtrlInterface != NULL) {
-            sBtAvrcpCtrlInterface->init(&sBluetoothAvrcpCtrlCallbacks);
-        }
+        pA2dpSinkStream->GetLibInterface(sBtA2dpSinkVendorInterface);
+
         PostMessage(THREAD_ID_GAP, pEvent);
     }
+    BtEvent *pEnableSinkStreaming = new BtEvent;
+    pEnableSinkStreaming->a2dpSinkStreamingEvent.event_id = A2DP_SINK_STREAMING_API_START;
+    if (pA2dpSinkStream) {
+        thread_post(pA2dpSinkStream->threadInfo.thread_id,
+        pA2dpSinkStream->threadInfo.thread_handler, (void*)pEnableSinkStreaming);
+    }
 }
 
 void A2dp_Sink::HandleDisableSink(void) {
-   change_state(STATE_NOT_STARTED);
-   CloseAudioStream();
-   StopPcmTimer();
-   if(sBtA2dpSinkInterface != NULL) {
-       sBtA2dpSinkInterface->cleanup();
-       sBtA2dpSinkInterface = NULL;
-   }
-   if (sBtAvrcpCtrlInterface != NULL) {
-       sBtAvrcpCtrlInterface->cleanup();
-       sBtAvrcpCtrlInterface = NULL;
-   }
-   BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " HandleDisableSink ");
+    pA2dpSink->mSinkState = SINK_STATE_NOT_STARTED;
+
+    BtEvent *pDisableSinkStreaming = new BtEvent;
+    pDisableSinkStreaming->a2dpSinkStreamingEvent.event_id = A2DP_SINK_STREAMING_API_STOP;
+    if (pA2dpSinkStream) {
+        thread_post(pA2dpSinkStream->threadInfo.thread_id,
+        pA2dpSinkStream->threadInfo.thread_handler, (void*)pDisableSinkStreaming);
+    }
+}
+
+void A2dp_Sink::HandleSinkStreamingDisableDone(void) {
+    ALOGD(LOGTAG " HandleSinkStreamingDisableDone ");
+    if (pA2dpSink->pA2dpDeviceList.size() != 0)
+        pA2dpSink->pA2dpDeviceList.clear();
+
+    if (sBtA2dpSinkInterface != NULL) {
+        sBtA2dpSinkInterface->cleanup();
+        sBtA2dpSinkInterface = NULL;
+    }
+    if (sBtA2dpSinkVendorInterface != NULL) {
+        sBtA2dpSinkVendorInterface->cleanup_vendor();
+        sBtA2dpSinkVendorInterface = NULL;
+    }
+
+    BtEvent *pEvent = new BtEvent;
     pEvent->profile_stop_event.event_id = PROFILE_EVENT_STOP_DONE;
-        pEvent->profile_stop_event.profile_id = PROFILE_ID_A2DP_SINK;
-        pEvent->profile_stop_event.status = true;
-        PostMessage(THREAD_ID_GAP, pEvent);
+    pEvent->profile_stop_event.profile_id = PROFILE_ID_A2DP_SINK;
+    pEvent->profile_stop_event.status = true;
+    PostMessage(THREAD_ID_GAP, pEvent);
 }
 
-void A2dp_Sink::ProcessEvent(BtEvent* pEvent) {
-    switch(mSinkState) {
-        case STATE_DISCONNECTED:
-            state_disconnected_handler(pEvent);
+void A2dp_Sink::ProcessEvent(BtEvent* pEvent, list<A2dp_Device>::iterator iter) {
+    switch(iter->mSinkDeviceState) {
+        case DEVICE_STATE_DISCONNECTED:
+            state_disconnected_handler(pEvent, iter);
             break;
-        case STATE_PENDING:
-            state_pending_handler(pEvent);
+        case DEVICE_STATE_PENDING:
+            state_pending_handler(pEvent, iter);
             break;
-        case STATE_CONNECTED:
-            state_connected_handler(pEvent);
+        case DEVICE_STATE_CONNECTED:
+            state_connected_handler(pEvent, iter);
             break;
-        case STATE_NOT_STARTED:
-            ALOGE(LOGTAG " STATE UNINITIALIZED, return");
+    }
+}
+
+void A2dp_Sink::ConnectionManager(BtEvent* pEvent, bt_bdaddr_t dev) {
+    ALOGD(LOGTAG " ConnectionManager ");
+    A2dp_Device *newNode = NULL;
+    list<A2dp_Device>::iterator iter;
+
+    switch(pEvent->event_id) {
+        case A2DP_SINK_API_CONNECT_REQ:
+            if (pA2dpDeviceList.size() == max_a2dp_conn) {
+                ALOGE(LOGTAG " already max devices connected");
+                fprintf(stdout, "Already %d device connected\n", max_a2dp_conn);
+                return;
+            }
+            if (pA2dpDeviceList.size() != 0) {
+                ALOGD(LOGTAG " Atleast 1 remote device connected/connecting ");
+                iter = FindDeviceByAddr(pA2dpDeviceList, dev);
+                if (iter != pA2dpDeviceList.end())
+                {
+                    ALOGE(LOGTAG " Connect req for already connected/connecting device");
+                    fprintf(stdout, "Connect req for already connected/connecting device\n");
+                    return;
+                }
+            }
+            if (pA2dpDeviceList.size() < max_a2dp_conn) {
+                ALOGD(LOGTAG " pA2dpDeviceList.size() < max_a2dp_conn ");
+                pA2dpDeviceList.push_back(A2dp_Device(config, dev));
+                iter = pA2dpDeviceList.end();
+                --iter;
+            }
+            break;
+        case A2DP_SINK_CONNECTING_CB:
+        case A2DP_SINK_CONNECTED_CB:
+            iter = FindDeviceByAddr(pA2dpDeviceList, dev);
+            bdstr_t bd_str;
+            if (iter != pA2dpDeviceList.end())
+            {
+                ALOGD(LOGTAG " found a match, donot alloc new");
+            }
+            else if (pA2dpDeviceList.size() < max_a2dp_conn)
+            {
+                ALOGD(LOGTAG " reached end of list without a match, alloc new");
+                pA2dpDeviceList.push_back(A2dp_Device(config, dev));
+                iter = pA2dpDeviceList.end();
+                --iter;
+            }
+            else
+            {
+                ALOGE(LOGTAG " already max devices connected");
+                fprintf(stdout, "Already %d device connected\n", max_a2dp_conn);
+                return;
+            }
+            if (!pAvrcp->rc_only_devices.empty())
+            {
+                bdaddr_to_string(&iter->mDevice, &bd_str[0], sizeof(bd_str));
+                std::string deviceAddress(bd_str);
+                std::list<std::string>::iterator bdstring;
+                bdstring = std::find(pAvrcp->rc_only_devices.begin(), pAvrcp->rc_only_devices.end(), deviceAddress);
+                if (bdstring != pAvrcp->rc_only_devices.end())
+                {
+                    ALOGE(LOGTAG "RC already connected earlier for this AV connected device, set RC connected");
+                    iter->mAvrcpConnected = true;
+                    pAvrcp->rc_only_devices.remove(deviceAddress);
+                }
+                else
+                {
+                    ALOGE(LOGTAG "RC not already connected with this device ");
+                }
+            }
+            break;
+        case A2DP_SINK_API_DISCONNECT_REQ:
+        case A2DP_SINK_DISCONNECTING_CB:
+        case A2DP_SINK_DISCONNECTED_CB:
+            if (pA2dpDeviceList.size() == 0) {
+                ALOGE(LOGTAG " no device to disconnect");
+                fprintf(stdout, "No device connected\n");
+                return;
+            }
+            else
+            {
+                iter = FindDeviceByAddr(pA2dpDeviceList, dev);
+                if (iter == pA2dpDeviceList.end())
+                {
+                    ALOGE(LOGTAG " reached end of list without a match, cannot disconnect");
+                    return;
+                }
+                else
+                {
+                    ALOGE(LOGTAG " found a match, disconnect this device iter = %x", iter);
+                }
+            }
             break;
     }
+    ProcessEvent(pEvent, iter);
 }
 
+void A2dp_Sink::EventManager(BtEvent* pEvent, bt_bdaddr_t dev) {
+    ALOGD(LOGTAG " EventManager ");
+
+    if (pA2dpSink->mSinkState == SINK_STATE_NOT_STARTED)
+    {
+       ALOGE(LOGTAG " SINK STATE UNINITIALIZED, return");
+       return;
+    }
+
+    if(isConnectionEvent(pEvent->event_id))
+    {
+        ConnectionManager(pEvent, dev);
+    }
+    else
+    {
+        list<A2dp_Device>::iterator iter = FindDeviceByAddr(pA2dpDeviceList, dev);
+        if (iter != pA2dpDeviceList.end())
+        {
+            ProcessEvent(pEvent, iter);
+        }
+        else
+        {
+            ALOGE(LOGTAG " no matching device ignore process event");
+        }
+    }
+}
+
+bool A2dp_Sink::isConnectionEvent(BluetoothEventId event_id) {
+    bool ret = false;
+    if (event_id >= A2DP_SINK_API_CONNECT_REQ && event_id <= A2DP_SINK_DISCONNECTING_CB)
+        ret = true;
+    ALOGD(LOGTAG " isConnectionEvent: %d", ret);
+    return ret;
+}
 char* A2dp_Sink::dump_message(BluetoothEventId event_id) {
     switch(event_id) {
     case A2DP_SINK_API_CONNECT_REQ:
@@ -403,72 +502,92 @@ char* A2dp_Sink::dump_message(BluetoothEventId event_id) {
         return "AUDIO_STOPPED_CB";
     case A2DP_SINK_AUDIO_STARTED:
         return "AUDIO_STARTED_CB";
-    case AVRCP_CTRL_CONNECTED_CB:
-        return "AVRCP_CTRL_CONNECTED_CB";
-    case AVRCP_CTRL_DISCONNECTED_CB:
-        return "AVRCP_CTRL_DISCONNECTED_CB";
-    case AVRCP_CTRL_PASS_THRU_CMD_REQ:
-        return "PASS_THRU_CMD_REQ";
-    case BT_AM_CONTROL_STATUS:
-        return "AM_CONTROL_STATUS";
-    case A2DP_SINK_FETCH_PCM_DATA:
-        return "A2DP_SINK_FETCH_PCM_DATA";
+    case A2DP_SINK_CODEC_CONFIG:
+        return "A2DP_SINK_CODEC_CONFIG";
     }
     return "UNKNOWN";
 }
 
-void A2dp_Sink::state_disconnected_handler(BtEvent* pEvent) {
+void A2dp_Sink::state_disconnected_handler(BtEvent* pEvent, list<A2dp_Device>::iterator iter) {
     char str[18];
+    BtEvent *pOpenInputStream = NULL;
     ALOGD(LOGTAG "state_disconnected_handler Processing event %s", dump_message(pEvent->event_id));
     switch(pEvent->event_id) {
         case A2DP_SINK_API_CONNECT_REQ:
-            memcpy(&mConnectingDevice, &pEvent->a2dpSinkEvent.bd_addr, sizeof(bt_bdaddr_t));
+            memcpy(&iter->mConnectingDevice, &iter->mDevice, sizeof(bt_bdaddr_t));
             if (sBtA2dpSinkInterface != NULL) {
-                sBtA2dpSinkInterface->connect(&pEvent->a2dpSinkEvent.bd_addr);
+                sBtA2dpSinkInterface->connect(&iter->mDevice);
             }
-            change_state(STATE_PENDING);
+            change_state(iter, DEVICE_STATE_PENDING);
             break;
         case A2DP_SINK_CONNECTING_CB:
-            memcpy(&mConnectingDevice, &pEvent->a2dpSinkEvent.bd_addr, sizeof(bt_bdaddr_t));
-            bdaddr_to_string(&mConnectingDevice, str, 18);
-            cout << "A2DP Sink Connecting to " << str << endl;
-            change_state(STATE_PENDING);
+            memcpy(&iter->mConnectingDevice, &iter->mDevice, sizeof(bt_bdaddr_t));
+            bdaddr_to_string(&iter->mConnectingDevice, str, 18);
+            fprintf(stdout, "A2DP Sink Connecting to %s\n", str);
+            change_state(iter, DEVICE_STATE_PENDING);
             break;
         case A2DP_SINK_CONNECTED_CB:
-            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
-            memcpy(&mConnectedDevice, &pEvent->a2dpSinkEvent.bd_addr, sizeof(bt_bdaddr_t));
-            bdaddr_to_string(&mConnectedDevice, str, 18);
-            cout << "A2DP Sink Connected to " << str << endl;
-            change_state(STATE_CONNECTED);
+            memset(&iter->mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            memcpy(&iter->mConnectedDevice, &iter->mDevice, sizeof(bt_bdaddr_t));
+            bdaddr_to_string(&iter->mConnectedDevice, str, 18);
+            fprintf(stdout, "A2DP Sink Connected to %s\n", str);
+            change_state(iter, DEVICE_STATE_CONNECTED);
+            pOpenInputStream = new BtEvent;
+            pOpenInputStream->a2dpSinkStreamingEvent.event_id =
+                    A2DP_SINK_STREAMING_OPEN_INPUT_STREAM;
+            if (pA2dpSinkStream) {
+                thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                pA2dpSinkStream->threadInfo.thread_handler, (void*)pOpenInputStream);
+            }
             break;
         default:
             ALOGD(LOGTAG " event not handled %d ", pEvent->event_id);
             break;
     }
 }
-void A2dp_Sink::state_pending_handler(BtEvent* pEvent) {
+void A2dp_Sink::state_pending_handler(BtEvent* pEvent, list<A2dp_Device>::iterator iter) {
     char str[18];
-    ALOGD(LOGTAG "state_pending_handler Processing event %s", dump_message(pEvent->event_id));
+    BtEvent *pOpenInputStream = NULL;
+    ALOGD(LOGTAG " state_pending_handler Processing event %s", dump_message(pEvent->event_id));
     switch(pEvent->event_id) {
         case A2DP_SINK_CONNECTING_CB:
+            ALOGD(LOGTAG " dummy event A2DP_SINK_CONNECTING_CB");
             break;
         case A2DP_SINK_CONNECTED_CB:
-            memcpy(&mConnectedDevice, &pEvent->a2dpSinkEvent.bd_addr, sizeof(bt_bdaddr_t));
-            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
-            bdaddr_to_string(&mConnectedDevice, str, 18);
-            cout << "A2DP Sink Connected to " << str << endl;
-            change_state(STATE_CONNECTED);
+            memcpy(&iter->mConnectedDevice, &iter->mDevice, sizeof(bt_bdaddr_t));
+            memset(&iter->mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            bdaddr_to_string(&iter->mConnectedDevice, str, 18);
+            fprintf(stdout,  "A2DP Sink Connected to %s\n", str);
+            change_state(iter, DEVICE_STATE_CONNECTED);
+            pOpenInputStream = new BtEvent;
+            pOpenInputStream->a2dpSinkStreamingEvent.event_id =
+                    A2DP_SINK_STREAMING_OPEN_INPUT_STREAM;
+            if (pA2dpSinkStream) {
+                thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                pA2dpSinkStream->threadInfo.thread_handler, (void*)pOpenInputStream);
+            }
             break;
         case A2DP_SINK_DISCONNECTED_CB:
-            cout << "A2DP Sink DisConnected "<< endl;
-            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
-            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
-
-            change_state(STATE_DISCONNECTED);
+            fprintf(stdout, "A2DP Sink DisConnected %s\n", str);
+            memset(&iter->mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&iter->mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            change_state(iter, DEVICE_STATE_DISCONNECTED);
             break;
         case A2DP_SINK_API_CONNECT_REQ:
-            bdaddr_to_string(&mConnectingDevice, str, 18);
-            cout << "A2DP Sink Connecting to " << str << endl;
+            bdaddr_to_string(&iter->mConnectingDevice, str, 18);
+            fprintf(stdout, "A2DP Sink Connecting to %s\n", str);
+            break;
+        case A2DP_SINK_DISCONNECTING_CB:
+            ALOGD(LOGTAG " dummy event A2DP_SINK_DISCONNECTING_CB");
+            break;
+        case A2DP_SINK_CODEC_CONFIG:
+            iter->dev_codec_type = pEvent->a2dpSinkEvent.arg1;
+            if (pEvent->a2dpSinkEvent.buf_ptr == NULL) {
+                break;
+            }
+            memcpy(&iter->dev_codec_config, pEvent->a2dpSinkEvent.buf_ptr,
+                    pEvent->a2dpSinkEvent.buf_size);
+            osi_free(pEvent->a2dpSinkEvent.buf_ptr);
             break;
         default:
             ALOGD(LOGTAG " event not handled %d ", pEvent->event_id);
@@ -476,147 +595,157 @@ void A2dp_Sink::state_pending_handler(BtEvent* pEvent) {
     }
 }
 
-void A2dp_Sink::state_connected_handler(BtEvent* pEvent) {
+void A2dp_Sink::state_connected_handler(BtEvent* pEvent, list<A2dp_Device>::iterator iter) {
     char str[18];
     uint32_t pcm_data_read = 0;
-    BtEvent *pControlRequest, *pReleaseControlReq;
+    BtEvent *pAMReleaseControl = NULL, *pCloseAudioStream = NULL, *pAMRequestControl = NULL;
     ALOGD(LOGTAG " state_connected_handler Processing event %s", dump_message(pEvent->event_id));
     switch(pEvent->event_id) {
         case A2DP_SINK_API_CONNECT_REQ:
-            bdaddr_to_string(&mConnectedDevice, str, 18);
-            cout << "A2DP Sink Connected to " << str << endl;
+            bdaddr_to_string(&iter->mConnectedDevice, str, 18);
+            fprintf(stdout, "A2DP Sink Connected to %s\n", str);
             break;
         case A2DP_SINK_API_DISCONNECT_REQ:
-            CloseAudioStream();
-            // release control
-            pReleaseControlReq = new BtEvent;
-            pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
-            pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_A2DP_SINK;
-            PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
-
-            bdaddr_to_string(&mConnectedDevice, str, 18);
-            cout << "A2DP Sink DisConnecting from " << str << endl;
-            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
-            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            if (!memcmp(&pA2dpSinkStream->mStreamingDevice, &iter->mDevice, sizeof(bt_bdaddr_t)))
+            {
+                pCloseAudioStream = new BtEvent;
+                pCloseAudioStream->a2dpSinkStreamingEvent.event_id =
+                        A2DP_SINK_STREAMING_CLOSE_AUDIO_STREAM;
+                if (pA2dpSinkStream) {
+                    thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                    pA2dpSinkStream->threadInfo.thread_handler, (void*)pCloseAudioStream);
+                }
+            }
+            bdaddr_to_string(&iter->mConnectedDevice, str, 18);
+            fprintf(stdout, "A2DP Sink DisConnecting from %s\n", str);
+            memset(&iter->mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&iter->mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+
             if (sBtA2dpSinkInterface != NULL) {
-                sBtA2dpSinkInterface->disconnect(&pEvent->a2dpSinkEvent.bd_addr);
+                sBtA2dpSinkInterface->disconnect(&iter->mDevice);
             }
-            change_state(STATE_PENDING);
+            change_state(iter, DEVICE_STATE_PENDING);
             break;
         case A2DP_SINK_DISCONNECTED_CB:
-            CloseAudioStream();
-            // release control
-            pReleaseControlReq = new BtEvent;
-            pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
-            pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_A2DP_SINK;
-            PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
-
-            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
-            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
-            cout << "A2DP Sink DisConnected " << endl;
-            change_state(STATE_DISCONNECTED);
+            if (!memcmp(&pA2dpSinkStream->mStreamingDevice, &iter->mDevice, sizeof(bt_bdaddr_t)))
+            {
+                pCloseAudioStream = new BtEvent;
+                pCloseAudioStream->a2dpSinkStreamingEvent.event_id =
+                        A2DP_SINK_STREAMING_CLOSE_AUDIO_STREAM;
+                if (pA2dpSinkStream) {
+                    thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                    pA2dpSinkStream->threadInfo.thread_handler, (void*)pCloseAudioStream);
+                }
+            }
+            memset(&iter->mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&iter->mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            fprintf(stdout, "A2DP Sink DisConnected \n");
+            change_state(iter, DEVICE_STATE_DISCONNECTED);
             break;
         case A2DP_SINK_DISCONNECTING_CB:
-            CloseAudioStream();
-            // release control
-            pReleaseControlReq = new BtEvent;
-            pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
-            pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_A2DP_SINK;
-            PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
-
-            cout << "A2DP Sink DisConnecting " << endl;
-            change_state(STATE_PENDING);
+            if (!memcmp(&pA2dpSinkStream->mStreamingDevice, &iter->mDevice, sizeof(bt_bdaddr_t)))
+            {
+                pCloseAudioStream = new BtEvent;
+                pCloseAudioStream->a2dpSinkStreamingEvent.event_id =
+                        A2DP_SINK_STREAMING_CLOSE_AUDIO_STREAM;
+                if (pA2dpSinkStream) {
+                    thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                    pA2dpSinkStream->threadInfo.thread_handler, (void*)pCloseAudioStream);
+                }
+            }
+            fprintf(stdout, "A2DP Sink DisConnecting\n");
+            change_state(iter, DEVICE_STATE_PENDING);
             break;
+        case A2DP_SINK_CODEC_CONFIG:
+             iter->dev_codec_type = pEvent->a2dpSinkEvent.arg1;
+             if (pEvent->a2dpSinkEvent.buf_ptr == NULL) {
+                 break;
+             }
+             memcpy(&iter->dev_codec_config, pEvent->a2dpSinkEvent.buf_ptr,
+                     pEvent->a2dpSinkEvent.buf_size);
+             osi_free(pEvent->a2dpSinkEvent.buf_ptr);
+             if (iter->dev_codec_type == A2DP_SINK_AUDIO_CODEC_SBC) {
+                 iter->av_config.sample_rate = pA2dpSinkStream->
+                     get_a2dp_sbc_sampling_rate(iter->dev_codec_config.sbc_config.samp_freq);
+                 iter->av_config.channel_count = pA2dpSinkStream->
+                     get_a2dp_sbc_channel_mode(iter->dev_codec_config.sbc_config.ch_mode);
+             }
+             break;
         case A2DP_SINK_AUDIO_STARTED:
         case A2DP_SINK_FOCUS_REQUEST_CB:
-            pControlRequest = new BtEvent;
-            pControlRequest->btamControlReq.event_id = BT_AM_REQUEST_CONTROL;
-            pControlRequest->btamControlReq.profile_id = PROFILE_ID_A2DP_SINK;
-            pControlRequest->btamControlReq.request_type = REQUEST_TYPE_PERMANENT;
-            PostMessage(THREAD_ID_BT_AM, pControlRequest);
-            break;
-        case A2DP_SINK_FETCH_PCM_DATA:
-           pcm_timer = false;
-           // first start next timer
-           StartPcmTimer();
-
-            // fetch PCM data from fluoride
-            if ((sBtA2dpSinkInterface != NULL) && ( pcm_buf != NULL)) {
-                pcm_data_read =  sBtA2dpSinkInterface->get_pcm_data(pcm_buf, pcm_buf_size);
-                ALOGD(LOGTAG " pcm_data_read = %d", pcm_data_read);
-            }
-#if (defined(BT_AUDIO_HAL_INTEGRATION))
-            if ((pBTAM->GetAudioDevice() != NULL) && (out_stream != NULL)) {
-                out_stream->write(out_stream, pcm_buf, pcm_data_read);
-            }
-#endif
-#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
-           if ((outputPcmSampleFile) && (pcm_buf != NULL))
-           {
-              fwrite ((void*)pcm_buf, 1, (size_t)(pcm_data_read), outputPcmSampleFile);
-           }
-#endif
-            break;
-        case BT_AM_CONTROL_STATUS:
-            ALOGD(LOGTAG "earlier status = %d  new status = %d", controlStatus,
-                                                      pEvent->btamControlStatus.status_type);
-            controlStatus = pEvent->btamControlStatus.status_type;
-            switch(controlStatus) {
-                case STATUS_LOSS:
-                    // inform bluedroid
-                    if (sBtA2dpSinkInterface != NULL) {
-                        sBtA2dpSinkInterface->audio_focus_state(0);
-                    }
-                    // send pause to remote
-                    SendPassThruCommandNative(CMD_ID_PAUSE);
-                    // release control
-                    pReleaseControlReq = new BtEvent;
-                    pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
-                    pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_A2DP_SINK;
-                    PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
-                    CloseAudioStream();
-                    StopPcmTimer();
-                    break;
-                case STATUS_LOSS_TRANSIENT:
-                    // inform bluedroid
-                    if (sBtA2dpSinkInterface != NULL) {
-                        sBtA2dpSinkInterface->audio_focus_state(0);
+            bdaddr_to_string(&pA2dpSinkStream->mStreamingDevice, str, 18);
+            ALOGD(LOGTAG " current streaming device %s", str);
+
+            if (memcmp(&pA2dpSinkStream->mStreamingDevice, &bd_addr_null, sizeof(bt_bdaddr_t)) &&
+                    memcmp(&pA2dpSinkStream->mStreamingDevice, &iter->mDevice, sizeof(bt_bdaddr_t)))
+            {
+                ALOGD(LOGTAG " another dev started streaming, pause previous one");
+                if (pAvrcp != NULL)
+                    pAvrcp->SendPassThruCommandNative(CMD_ID_PAUSE,
+                            &pA2dpSinkStream->mStreamingDevice, 1);
+                if (pA2dpSinkStream && !pA2dpSinkStream->use_bt_a2dp_hal)
+                {
+                    memset(&pA2dpSinkStream->mStreamingDevice, 0, sizeof(bt_bdaddr_t));
+                    pAMReleaseControl = new BtEvent;
+                    pAMReleaseControl->a2dpSinkStreamingEvent.event_id =
+                            A2DP_SINK_STREAMING_AM_RELEASE_CONTROL;
+                    if (pA2dpSinkStream) {
+                        thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                        pA2dpSinkStream->threadInfo.thread_handler, (void*)pAMReleaseControl);
                     }
-                    // send pause to remote
-                    SendPassThruCommandNative(CMD_ID_PAUSE);
-                    CloseAudioStream();
-                    StopPcmTimer();
-                    break;
-                case STATUS_GAIN:
-                    // inform bluedroid
-                    if (sBtA2dpSinkInterface != NULL) {
-                        sBtA2dpSinkInterface->audio_focus_state(3);
+                }
+                else
+                {
+                    pCloseAudioStream = new BtEvent;
+                    pCloseAudioStream->a2dpSinkStreamingEvent.event_id =
+                            A2DP_SINK_STREAMING_CLOSE_AUDIO_STREAM;
+                    if (pA2dpSinkStream) {
+                        thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                        pA2dpSinkStream->threadInfo.thread_handler, (void*)pCloseAudioStream);
                     }
-                    ConfigureAudioHal();
-                    StartPcmTimer();
-                    break;
-                case STATUS_REGAINED:
-                    // inform bluedroid
-                    if (sBtA2dpSinkInterface != NULL) {
-                        sBtA2dpSinkInterface->audio_focus_state(3);
-                    }
-                    ConfigureAudioHal();
-                    StartPcmTimer();
-                    // send play to remote
-                    SendPassThruCommandNative(CMD_ID_PLAY);
-                    break;
+                }
+            }
+            ALOGE(LOGTAG " updating avconfig parameters for this device");
+            if (iter->dev_codec_type == A2DP_SINK_AUDIO_CODEC_SBC) {
+                pA2dpSinkStream->sample_rate = iter->av_config.sample_rate;
+                pA2dpSinkStream->channel_count = iter->av_config.channel_count;
+            }
+            pA2dpSinkStream->codec_type = iter->dev_codec_type;
+            memcpy(&pA2dpSinkStream->codec_config, &iter->dev_codec_config,
+                    sizeof(btav_codec_config_t));
+
+            memcpy(&pA2dpSinkStream->mStreamingDevice, &pEvent->a2dpSinkEvent.bd_addr,
+                    sizeof(bt_bdaddr_t));
+            bdaddr_to_string(&pA2dpSinkStream->mStreamingDevice, str, 18);
+            ALOGD(LOGTAG " A2DP_SINK_AUDIO_STARTED - set current streaming device as %s", str);
+
+            sBtA2dpSinkVendorInterface->
+                    update_streaming_device_vendor(&pA2dpSinkStream->mStreamingDevice);
+
+            pAMRequestControl = new BtEvent;
+            pAMRequestControl->a2dpSinkStreamingEvent.event_id =
+                    A2DP_SINK_STREAMING_AM_REQUEST_CONTROL;
+            if (pA2dpSinkStream) {
+                thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                pA2dpSinkStream->threadInfo.thread_handler, (void*)pAMRequestControl);
             }
             break;
         case A2DP_SINK_AUDIO_SUSPENDED:
         case A2DP_SINK_AUDIO_STOPPED:
-            // release focus in this case.
-            CloseAudioStream();
-            StopPcmTimer();
-            if (controlStatus != STATUS_LOSS_TRANSIENT) {
-                pReleaseControlReq = new BtEvent;
-                pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
-                pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_A2DP_SINK;
-                PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
+            if(memcmp(&pA2dpSinkStream->mStreamingDevice, &pEvent->a2dpSinkEvent.bd_addr,
+                    sizeof(bt_bdaddr_t)))
+            {
+                ALOGD(LOGTAG " A2DP_SINK_AUDIO_SUSPENDED/STOPPED for non streaming device, ignore");
+                break;
+            }
+            memset(&pA2dpSinkStream->mStreamingDevice, 0, sizeof(bt_bdaddr_t));
+
+            pAMReleaseControl = new BtEvent;
+            pAMReleaseControl->a2dpSinkStreamingEvent.event_id =
+                    A2DP_SINK_STREAMING_AM_RELEASE_CONTROL;
+            if (pA2dpSinkStream) {
+                thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                pA2dpSinkStream->threadInfo.thread_handler, (void*)pAMReleaseControl);
             }
             break;
         default:
@@ -624,142 +753,65 @@ void A2dp_Sink::state_connected_handler(BtEvent* pEvent) {
             break;
     }
 }
-void A2dp_Sink::ConfigureAudioHal() {
-#if (defined BT_AUDIO_HAL_INTEGRATION)
-    audio_hw_device_t* audio_device;
-    audio_config_t config;
-    audio_io_handle_t handle = 0x07;
-
-    ALOGD(LOGTAG " sample_rate = %d, channel_count = %d", sample_rate, channel_count);
-    if (!sample_rate || !channel_count) {
-        return;
-    }
 
-    if (out_stream != NULL) {
-        ALOGD(LOGTAG " HAL already configured ");
-        return;
-    }
-    // HAL is not yet configured, configure it now.
-   config.offload_info.size = sizeof(audio_offload_info_t);
-   config.offload_info.sample_rate = sample_rate;
-   config.offload_info.format = AUDIO_FORMAT_PCM_16_BIT;
-   config.offload_info.version = AUDIO_OFFLOAD_INFO_VERSION_CURRENT;
-   config.channel_mask = audio_channel_out_mask_from_count(channel_count);
-   config.offload_info.channel_mask = audio_channel_out_mask_from_count(channel_count);
-    if (pBTAM != NULL) {
-        audio_device = pBTAM->GetAudioDevice();
-        if(audio_device != NULL) {
-            // 2 refers to speaker
-            ALOGD(LOGTAG, " opening output stream ");
-            audio_device->open_output_stream(audio_device, handle, 2, AUDIO_OUTPUT_FLAG_DIRECT_PCM,
-                   &config, &out_stream, "bt_a2dp_sink");
-        }
-        if (out_stream != NULL) {
-            pcm_buf_size = out_stream->common.get_buffer_size(&out_stream->common);
-            ALOGD(LOGTAG " pcm buf size %d", pcm_buf_size);
-            pcm_buf = (uint8_t*)osi_malloc(pcm_buf_size);
-        }
-    }
-#endif
-#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
-    if (!sample_rate || !channel_count) {
-        return;
-    }
-    switch(sample_rate) {
-    case 44100:
-        pcm_buf_size = 7065;
-        break;
-    case 48000:
-        pcm_buf_size = 7680;
-        break;
-    }
-    pcm_buf = (uint8_t*)osi_malloc(pcm_buf_size);
-    if (outputPcmSampleFile == NULL)
-        outputPcmSampleFile = fopen(outputFilename, "ab");
-#endif
-}
-void A2dp_Sink::CloseAudioStream() {
-#if (defined BT_AUDIO_HAL_INTEGRATION)
-    audio_hw_device_t* audio_device;
-    if (pBTAM != NULL) {
-        audio_device = pBTAM->GetAudioDevice();
-        if((audio_device != NULL) && (out_stream != NULL)) {
-            // 2 refers to speaker
-            ALOGD(LOGTAG, " closing output stream ");
-            audio_device->close_output_stream(audio_device, out_stream);
-            out_stream = NULL;
-        }
-        if (pcm_buf != NULL) {
-            osi_free(pcm_buf);
-            pcm_buf = NULL;
-        }
-    }
-#endif
-#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
-    if (outputPcmSampleFile)
-    {
-        fclose(outputPcmSampleFile);
-    }
-    outputPcmSampleFile = NULL;
-    if (pcm_buf != NULL) {
-        osi_free(pcm_buf);
-        pcm_buf = NULL;
-    }
-#endif
-}
-void A2dp_Sink::OnDisconnected() {
-    ALOGD(LOGTAG " onDisconnected ");
-    StopPcmTimer();
-    CloseAudioStream();
-}
-void A2dp_Sink::change_state(A2dpSinkState mState) {
-   ALOGD(LOGTAG " current State = %d, new state = %d", mSinkState, mState);
+void A2dp_Sink::change_state(list<A2dp_Device>::iterator iter, A2dpSinkDeviceState mState) {
+   BtEvent *pA2dpSinkDisconnected = NULL;
+   ALOGD(LOGTAG " current State = %d, new state = %d", iter->mSinkDeviceState, mState);
    pthread_mutex_lock(&lock);
-   mSinkState = mState;
-   if (mSinkState == STATE_DISCONNECTED)
+   iter->mSinkDeviceState = mState;
+   if (iter->mSinkDeviceState == DEVICE_STATE_DISCONNECTED)
    {
-        OnDisconnected();
+       if (!memcmp(&pA2dpSinkStream->mStreamingDevice, &iter->mDevice, sizeof(bt_bdaddr_t)))
+       {
+           memset(&pA2dpSinkStream->mStreamingDevice, 0, sizeof(bt_bdaddr_t));
+
+           pA2dpSinkDisconnected = new BtEvent;
+           pA2dpSinkDisconnected->a2dpSinkStreamingEvent.event_id =
+                   A2DP_SINK_STREAMING_DISCONNECTED;
+           if (pA2dpSinkStream) {
+               thread_post(pA2dpSinkStream->threadInfo.thread_id,
+               pA2dpSinkStream->threadInfo.thread_handler, (void*)pA2dpSinkDisconnected);
+           }
+       }
+       pA2dpDeviceList.erase(iter);
+       ALOGD(LOGTAG " iter %x deleted from list", iter);
    }
-   ALOGD(LOGTAG " state changes to %d ", mState);
+   ALOGD(LOGTAG " iter %x state changes to %d ", iter, mState);
    pthread_mutex_unlock(&lock);
 }
+
 A2dp_Sink :: A2dp_Sink(const bt_interface_t *bt_interface, config_t *config) {
 
     this->bluetooth_interface = bt_interface;
     this->config = config;
     sBtA2dpSinkInterface = NULL;
-    sBtAvrcpCtrlInterface = NULL;
-    mSinkState = STATE_NOT_STARTED;
-    controlStatus = STATUS_LOSS;
-    mAvrcpConnected = false;
-    channel_count = 0;
-    sample_rate = 0;
-    memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
-    memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
-    memset(&mConnectedAvrcpDevice, 0, sizeof(bt_bdaddr_t));
+    mSinkState = SINK_STATE_NOT_STARTED;
     pthread_mutex_init(&this->lock, NULL);
-    pcm_data_fetch_timer = alarm_new();
-    pcm_buf = NULL;
-    pcm_timer = false;
-#if (defined BT_AUDIO_HAL_INTEGRATION)
-    out_stream =  NULL;
-#endif
-#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
-    outputPcmSampleFile =  NULL;
-#endif
+    pA2dpSinkStream = new A2dp_Sink_Streaming(config);
+    pA2dpSinkStream->threadInfo.thread_id = thread_new (pA2dpSinkStream->threadInfo.thread_name);
+    max_a2dp_conn = 0;
 }
 
 A2dp_Sink :: ~A2dp_Sink() {
     pthread_mutex_destroy(&lock);
+}
+
+A2dp_Device :: A2dp_Device(config_t *config, bt_bdaddr_t dev) {
+    this->config = config;
+    memset(&mDevice, 0, sizeof(bt_bdaddr_t));
+    memcpy(&mDevice, &dev, sizeof(bt_bdaddr_t));
+    memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+    memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+    mSinkDeviceState = DEVICE_STATE_DISCONNECTED;
+    memset(&av_config, 0, sizeof(A2dpSinkConfig_t));
+    pthread_mutex_init(&this->lock, NULL);
     mAvrcpConnected = false;
-    controlStatus = STATUS_LOSS;
-    alarm_free(pcm_data_fetch_timer);
-    pcm_data_fetch_timer = NULL;
-#if (defined BT_AUDIO_HAL_INTEGRATION)
-    out_stream = NULL;
-#endif
-    if (pcm_buf != NULL) {
-        osi_free(pcm_buf);
-        pcm_buf = NULL;
-    }
+    mNotificationLabel = -1;
+    mAbsVolNotificationRequested = false;
+    mAbsoluteVolumeChangeInProgress = false;
+}
+
+A2dp_Device :: ~A2dp_Device() {
+    pthread_mutex_destroy(&lock);
 }
+
diff --git a/bt-app/a2dp_sink/src/A2dp_Sink_Streaming.cpp b/bt-app/a2dp_sink/src/A2dp_Sink_Streaming.cpp
new file mode 100644
index 0000000..bd1424e
--- /dev/null
+++ b/bt-app/a2dp_sink/src/A2dp_Sink_Streaming.cpp
@@ -0,0 +1,1171 @@
+ /*
+  * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#include <list>
+#include <map>
+#include <iostream>
+#include <string.h>
+#include <hardware/bluetooth.h>
+#include <hardware/hardware.h>
+#include <hardware/bt_av.h>
+#include "Audio_Manager.hpp"
+#include "A2dp_Sink.hpp"
+
+#include "A2dp_Sink_Streaming.hpp"
+#include "Gap.hpp"
+#include "hardware/bt_av_vendor.h"
+#include "Avrcp.hpp"
+
+#if (defined USE_GST)
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <gst/gstbthelper.h>
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+#if (defined USE_GST)
+
+gstbt gstbtobj;
+
+#endif
+
+#define LOGTAG "A2DP_SINK_STREAMING"
+
+using namespace std;
+using std::list;
+using std::string;
+
+extern A2dp_Sink_Streaming *pA2dpSinkStream;
+extern BT_Audio_Manager *pBTAM;
+extern Avrcp *pAvrcp;
+extern Gap *g_gap;
+
+#if (!defined(BT_AUDIO_HAL_INTEGRATION))
+#define DUMP_PCM_DATA TRUE
+#endif
+
+//#define DUMP_COMPRESSED_DATA TRUE
+#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
+FILE *outputPcmSampleFile;
+char outputFilename [50] = "/etc/bluetooth/output_sample.pcm";
+#endif
+
+#if (defined(DUMP_COMPRESSED_DATA) && (DUMP_COMPRESSED_DATA == TRUE))
+FILE *outputPcmSampleFile;
+char outputFilename [50] = "/etc/bluetooth/output_sample.pcm";
+#endif
+
+static const bt_bdaddr_t bd_addr_null= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+extern void enque_relay_data(uint8_t* buffer, size_t size, uint8_t codec_type);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define BE_STREAM_TO_UINT16(u16, p) {u16 = (uint16_t)(((uint16_t)(*(p)) << 8) + (uint16_t)(*((p) + 1))); (p) += 2;}
+#define BE_STREAM_TO_UINT32(u32, p) {u32 = ((uint32_t)(*((p) + 3)) + ((uint32_t)(*((p) + 2)) << 8) +((uint32_t)(*((p) + 1)) << 16) + ((uint32_t)(*(p)) << 24)); (p) += 4;}
+
+ uint8_t get_rtp_offset(uint8_t* p_start, uint16_t codec_type);
+void BtA2dpSinkStreamingMsgHandler(void *msg) {
+    BtEvent* pEvent = NULL;
+    BtEvent* pCleanupEvent = NULL, *pControlRequest = NULL, *pReleaseControlReq = NULL;
+    uint32_t pcm_data_read = 0;
+    uint8_t rtp_offset = 0;
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    qahw_out_buffer_t out_buf;
+#endif
+    if(!msg) {
+        printf("Msg is NULL, return.\n");
+        return;
+    }
+
+    pEvent = ( BtEvent *) msg;
+    switch(pEvent->a2dpSinkStreamingEvent.event_id) {
+        case A2DP_SINK_STREAMING_API_START:
+            ALOGD(LOGTAG " enable a2dp sink streaming");
+            if (pA2dpSinkStream) {
+                pA2dpSinkStream->HandleEnableSinkStreaming();
+            }
+            break;
+        case A2DP_SINK_STREAMING_API_STOP:
+            ALOGD(LOGTAG " disable a2dp sink streaming");
+            if (pA2dpSinkStream) {
+                pA2dpSinkStream->HandleDisableSinkStreaming();
+            }
+            break;
+        case A2DP_SINK_STREAMING_CLEANUP_REQ:
+            ALOGD(LOGTAG " cleanup a2dp sink streaming");
+            if (pA2dpSinkStream) {
+                if (pA2dpSinkStream->use_bt_a2dp_hal) {
+                    pA2dpSinkStream->CloseInputStream();
+                }
+                pA2dpSinkStream->CloseAudioStream();
+                pA2dpSinkStream->StopDataFetchTimer();
+            }
+            break;
+        case A2DP_SINK_STREAMING_OPEN_INPUT_STREAM:
+            ALOGD(LOGTAG " A2DP_SINK_STREAMING_OPEN_INPUT_STREAM");
+            if(pA2dpSinkStream && pA2dpSinkStream->use_bt_a2dp_hal)
+                pA2dpSinkStream->OpenInputStream();
+            break;
+        case A2DP_SINK_STREAMING_CLOSE_AUDIO_STREAM:
+            ALOGD(LOGTAG " A2DP_SINK_STREAMING_CLOSE_AUDIO_STREAM");
+            pA2dpSinkStream->CloseAudioStream();
+            pA2dpSinkStream->StopDataFetchTimer();
+            // release control
+            pReleaseControlReq = new BtEvent;
+            pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
+            pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_A2DP_SINK;
+            PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
+            break;
+        case A2DP_SINK_STREAMING_AM_REQUEST_CONTROL:
+            ALOGD(LOGTAG " A2DP_SINK_STREAMING_AM_REQUEST_CONTROL");
+            pControlRequest = new BtEvent;
+            pControlRequest->btamControlReq.event_id = BT_AM_REQUEST_CONTROL;
+            pControlRequest->btamControlReq.profile_id = PROFILE_ID_A2DP_SINK;
+            pControlRequest->btamControlReq.request_type = REQUEST_TYPE_PERMANENT;
+            PostMessage(THREAD_ID_BT_AM, pControlRequest);
+            break;
+        case A2DP_SINK_STREAMING_FETCH_PCM_DATA:
+            ALOGD(LOGTAG " A2DP_SINK_STREAMING_FETCH_PCM_DATA");
+            if (!pA2dpSinkStream->pcm_timer) {
+                ALOGD(LOGTAG " pcm_timer already false, don't fetch data");
+                break;
+            }
+            pA2dpSinkStream->pcm_timer = false;
+#if (defined USE_GST)
+            uint8_t * data;
+            int size;
+            pA2dpSinkStream->StartPcmTimer();
+            size = allocate_gst_buffer(&gstbtobj, &data);
+            if ((pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL) &&
+                    (data != NULL)) {
+                if(pA2dpSinkStream->use_bt_a2dp_hal) {
+                    // read data from BT A2DP HAL
+                    pcm_data_read =  pA2dpSinkStream->ReadInputStream(data, size);
+                }
+                else
+                {
+                    // fetch PCM data from fluoride
+                    pcm_data_read =  pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface->
+                    get_a2dp_sink_streaming_data_vendor(A2DP_SINK_AUDIO_CODEC_PCM,data, size);
+                }
+                ALOGD(LOGTAG " pcm_data_read = %d", pcm_data_read);
+            }
+            send_gst_data(&gstbtobj, pcm_data_read, 0);
+#else
+            if ((pA2dpSinkStream->pcm_buf == NULL) || !memcmp(&pA2dpSinkStream->mStreamingDevice,
+                    &bd_addr_null, sizeof(bt_bdaddr_t))) {
+                // pcm buffer is null, closeStream or streaming device null have been called earlier
+                break;
+            }
+            // first start next timer
+            pA2dpSinkStream->StartPcmTimer();
+
+            if ((pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL) &&
+                    (pA2dpSinkStream->pcm_buf != NULL)) {
+                if(pA2dpSinkStream->use_bt_a2dp_hal) {
+                    // read data from BT A2DP HAL
+                    pcm_data_read =  pA2dpSinkStream->ReadInputStream(pA2dpSinkStream->pcm_buf,
+                            pA2dpSinkStream->pcm_buf_size);
+                }
+                else
+                {
+                    // fetch PCM data from fluoride
+                    if(pA2dpSinkStream->sbc_decoding)
+                    {
+                        ALOGD(LOGTAG"sbc_decdoing is true, capture the pcm data");
+                        pcm_data_read =  pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface->
+                        get_a2dp_sink_streaming_data_vendor(A2DP_SINK_AUDIO_CODEC_PCM,
+                        pA2dpSinkStream->pcm_buf, pA2dpSinkStream->pcm_buf_size);
+                    }
+                    else
+                    {
+                        pcm_data_read =  pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface->
+                        get_a2dp_sink_streaming_data_vendor(A2DP_SINK_AUDIO_CODEC_SBC,
+                        pA2dpSinkStream->pcm_buf, (pA2dpSinkStream->pcm_buf_size)/4);
+                    }
+                }
+
+                if (pA2dpSinkStream->fetch_rtp_info && ( pcm_data_read > 12)) {
+                     if(!pA2dpSinkStream->sbc_decoding)
+                     {
+                         rtp_offset = get_rtp_offset( pA2dpSinkStream->pcm_buf, A2DP_SINK_AUDIO_CODEC_SBC);
+                     }
+                 }
+                ALOGD(LOGTAG " fluoried stored_data_read = %d", pcm_data_read);
+             }
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+            if ((pBTAM->GetAudioDevice() != NULL) && (pA2dpSinkStream->out_stream != NULL) &&
+                    (pcm_data_read)) {
+                out_buf.buffer = pA2dpSinkStream->pcm_buf;
+                out_buf.bytes = pcm_data_read;
+                if (pA2dpSinkStream->relay_sink_data) {
+                    if(!pA2dpSinkStream->sbc_decoding)
+                    {
+                        enque_relay_data(pA2dpSinkStream->pcm_buf, pcm_data_read, A2DP_SINK_AUDIO_CODEC_SBC);//using sbc
+                    }
+                    else
+                    {
+                        enque_relay_data(pA2dpSinkStream->pcm_buf, pcm_data_read, A2DP_SINK_AUDIO_CODEC_PCM);
+                    }
+                }
+                if(pA2dpSinkStream->sbc_decoding)
+                    qahw_out_write(pA2dpSinkStream->out_stream, &out_buf);
+            }
+#endif
+#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
+            if ((outputPcmSampleFile) && (pA2dpSinkStream->pcm_buf != NULL))
+            {
+                fwrite ((void*)pA2dpSinkStream->pcm_buf, 1, (size_t)(pcm_data_read), outputPcmSampleFile);
+            }
+#endif
+#endif
+            break;
+        case A2DP_SINK_STREAMING_AM_RELEASE_CONTROL:
+            ALOGD(LOGTAG " A2DP_SINK_STREAMING_AM_RELEASE_CONTROL");
+            // release focus in this case.
+            pA2dpSinkStream->CloseAudioStream();
+            pA2dpSinkStream->StopDataFetchTimer();
+            if (pA2dpSinkStream->use_bt_a2dp_hal) {
+                pA2dpSinkStream->SuspendInputStream();
+            }
+            if (pA2dpSinkStream->controlStatus != STATUS_LOSS_TRANSIENT) {
+                pReleaseControlReq = new BtEvent;
+                pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
+                pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_A2DP_SINK;
+                PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
+            }
+            break;
+
+        case BT_AM_CONTROL_STATUS:
+            ALOGD(LOGTAG " BT_AM_CONTROL_STATUS");
+            ALOGD(LOGTAG " earlier status = %d  new status = %d", pA2dpSinkStream->controlStatus,
+                    pEvent->btamControlStatus.status_type);
+            pA2dpSinkStream->controlStatus = pEvent->btamControlStatus.status_type;
+            switch(pA2dpSinkStream->controlStatus) {
+                case STATUS_LOSS:
+                    // inform bluedroid
+                    if (pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL) {
+                        pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface->
+                        audio_focus_state_vendor(0, &pA2dpSinkStream->mStreamingDevice);
+                    }
+                    // send pause to remote
+                    if (pAvrcp != NULL)
+                        pAvrcp->SendPassThruCommandNative(CMD_ID_PAUSE,
+                        &pA2dpSinkStream->mStreamingDevice, 0);
+                    // release control
+                    pReleaseControlReq = new BtEvent;
+                    pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
+                    pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_A2DP_SINK;
+                    PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
+                    pA2dpSinkStream->CloseAudioStream();
+                    pA2dpSinkStream->StopDataFetchTimer();
+                    break;
+                case STATUS_LOSS_TRANSIENT:
+                    // inform bluedroid
+                    if (pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL) {
+                        pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface->
+                        audio_focus_state_vendor(0, &pA2dpSinkStream->mStreamingDevice);
+                    }
+                    // send pause to remote
+                    if (pAvrcp != NULL) {
+                        ALOGD(LOGTAG " copy resuming device");
+                        memcpy(&pA2dpSinkStream->mResumingDevice,
+                            &pA2dpSinkStream->mStreamingDevice, sizeof(bt_bdaddr_t));
+                        ALOGD(LOGTAG " sending pause copy resuming device");
+                        pAvrcp->SendPassThruCommandNative(CMD_ID_PAUSE,
+                            &pA2dpSinkStream->mStreamingDevice, 0);
+                    }
+                    pA2dpSinkStream->CloseAudioStream();
+                    pA2dpSinkStream->StopDataFetchTimer();
+                    break;
+                case STATUS_GAIN:
+                    // inform bluedroid
+                    if (pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL) {
+                        pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface->
+                        audio_focus_state_vendor(3, &pA2dpSinkStream->mStreamingDevice);
+                    }
+                    pA2dpSinkStream->ConfigureAudioHal();
+                    if (pA2dpSinkStream->codec_type == A2DP_SINK_AUDIO_CODEC_SBC)
+                        pA2dpSinkStream->StartPcmTimer();
+                    else {
+                        BtEvent *pEvent = new BtEvent;
+                        pEvent->a2dpSinkStreamingEvent.event_id = A2DP_SINK_FILL_COMPRESS_BUFFER;
+                        if (pA2dpSinkStream) {
+                            thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                            pA2dpSinkStream->threadInfo.thread_handler, (void*)pEvent);
+                        }
+                    }
+                    break;
+                case STATUS_REGAINED:
+                    // inform bluedroid
+                    ALOGD(LOGTAG " STATUS_REGAINED");
+                    if (pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL) {
+                        pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface->
+                        audio_focus_state_vendor(3, &pA2dpSinkStream->mStreamingDevice);
+                    }
+                    pA2dpSinkStream->ConfigureAudioHal();
+                    if (pA2dpSinkStream->codec_type == A2DP_SINK_AUDIO_CODEC_SBC)
+                        pA2dpSinkStream->StartPcmTimer();
+                    else {
+                        BtEvent *pEvent = new BtEvent;
+                        pEvent->a2dpSinkStreamingEvent.event_id = A2DP_SINK_FILL_COMPRESS_BUFFER;
+                        if (pA2dpSinkStream) {
+                            thread_post(pA2dpSinkStream->threadInfo.thread_id,
+                            pA2dpSinkStream->threadInfo.thread_handler, (void*)pEvent);
+                        }
+                    }
+                    // send play to remote
+                    if (pAvrcp != NULL && memcmp(&pA2dpSinkStream->mResumingDevice, &bd_addr_null,
+                            sizeof(bt_bdaddr_t))) {
+                        ALOGD(LOGTAG " STATUS_REGAINED, sending play");
+                        pAvrcp->SendPassThruCommandNative(CMD_ID_PLAY,
+                                &pA2dpSinkStream->mResumingDevice, 1);
+                        memset(&pA2dpSinkStream->mResumingDevice, 0, sizeof(bt_bdaddr_t));
+                    }
+                    break;
+            }
+            break;
+        case A2DP_SINK_FILL_COMPRESS_BUFFER:
+            pA2dpSinkStream->FillCompressBuffertoAudioOutHal();
+            break;
+        case A2DP_SINK_STREAMING_DISCONNECTED:
+            ALOGD(LOGTAG " A2DP_SINK_STREAMING_DISCONNECTED");
+            pA2dpSinkStream->StopDataFetchTimer();
+            if (pA2dpSinkStream->use_bt_a2dp_hal) {
+                pA2dpSinkStream->CloseInputStream();
+            }
+            pA2dpSinkStream->CloseAudioStream();
+            break;
+        case A2DP_SINK_STREAMING_FLUSH_AUDIO:
+            ALOGD(LOGTAG " A2DP_SINK_STREAMING_FLUSH_AUDIO");
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+            qahw_out_pause(pA2dpSinkStream->out_stream);
+            qahw_out_flush(pA2dpSinkStream->out_stream);
+#endif
+            pA2dpSinkStream->StopDataFetchTimer();
+            if (pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL)
+            {
+                pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface->
+                    update_flushing_device_vendor(&pEvent->a2dpSinkStreamingEvent.bd_addr);
+            }
+            break;
+        default:
+            break;
+    }
+    delete pEvent;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#if (defined BT_AUDIO_HAL_INTEGRATION)
+void parse_aptx_dec_bd_addr(char *value, struct qahw_aptx_dec_param *aptx_cfg)
+{
+    int ba[6];
+    char *str, *tok;
+    uint32_t addr[3];
+    int i = 0;
+
+    tok = strtok_r(value, ":", &str);
+    while (tok != NULL) {
+        ba[i] = strtol(tok, NULL, 16);
+        i++;
+        tok = strtok_r(NULL, ":", &str);
+    }
+    addr[0] = (ba[0] << 8) | ba[1];
+    addr[1] = ba[2];
+    addr[2] = (ba[3] << 16) | (ba[4] << 8) | ba[5];
+
+    aptx_cfg->bt_addr.nap = addr[0];
+    aptx_cfg->bt_addr.uap = addr[1];
+    aptx_cfg->bt_addr.lap = addr[2];
+}
+
+
+int compressed_callback(qahw_stream_callback_event_t event, void *param,
+                  void *cookie) {
+    BtEvent *pEvent = new BtEvent;
+    switch (event) {
+    case QAHW_STREAM_CBK_EVENT_WRITE_READY:
+        ALOGD(LOGTAG " EVENT_WRITE_READY");
+        pEvent->a2dpSinkStreamingEvent.event_id = A2DP_SINK_FILL_COMPRESS_BUFFER;
+        if (pA2dpSinkStream) {
+            thread_post(pA2dpSinkStream->threadInfo.thread_id,
+            pA2dpSinkStream->threadInfo.thread_handler, (void*)pEvent);
+        }
+        break;
+    case QAHW_STREAM_CBK_EVENT_DRAIN_READY:
+        ALOGD(LOGTAG " EVENT_DRAIN_READY");
+        break;
+    default:
+        break;
+    }
+    return 0;
+}
+#endif
+
+uint8_t get_rtp_offset(uint8_t* p_start, uint16_t codec_type)
+{
+    uint8_t   rtp_version, padding, extension, csrc_count, extension_len;
+    uint8_t offset = 0;
+    uint8_t* ptr = p_start;
+    uint16_t seq_num; uint32_t t_stamp;
+    // NO RTP Header for APTX classic
+    if (codec_type == A2DP_SINK_AUDIO_CODEC_APTX)
+        return 0;
+    rtp_version = *(p_start) >> 6;
+    padding = (*(p_start) >> 5) & 0x01;
+    extension = (*(p_start) >> 4) & 0x01;
+    csrc_count = *(p_start) & 0x0F;
+    p_start ++; p_start ++; // increment 2 byte
+    BE_STREAM_TO_UINT16(seq_num, p_start);
+    BE_STREAM_TO_UINT32(t_stamp, p_start);
+
+    ALOGD(LOGTAG " rtp_v = %d, padding = %d, xtn = %d, csrc_count = %d, seq = %d, t_stamp = %d",
+             rtp_version, padding, extension, csrc_count, seq_num, t_stamp);
+    offset =  12 + csrc_count *4;
+    if(extension)
+    {
+        ptr = ptr + offset + 2;
+        BE_STREAM_TO_UINT16(extension_len, ptr);
+        offset = offset + 4 + extension_len * 4;
+    }
+    ALOGD(LOGTAG " codec_type = %d offset = %d",codec_type, offset);
+    return offset;
+}
+
+void A2dp_Sink_Streaming::FillCompressBuffertoAudioOutHal() {
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    qahw_out_buffer_t out_buf;
+    uint32_t data_read_from_bt = 0;
+    uint32_t data_sent_to_audio = 0;
+    uint8_t rtp_offset = 0;
+#if (!defined (USE_GST))
+    if (pcm_buf == NULL) {
+       // pcm buffer is null, closeStream have been called earlier
+       ALOGE(LOGTAG " FillCOmpressBUffer, pcm buf null, bail out");
+       return;
+	}
+#endif
+    do {
+#if (defined USE_GST)
+        if (mBtA2dpSinkStreamingVendorInterface != NULL) {
+
+            if( residual_compress_data == 0) {
+            int size = 0;
+            uint8_t * tempbuf;
+
+            data_read_from_bt =  mBtA2dpSinkStreamingVendorInterface->
+                 get_a2dp_sink_streaming_data_vendor(codec_type, gbuff, A2DP_SINK_GBUF_MAX_SIZE);
+            gstbtobj.blocksize = data_read_from_bt;
+            allocate_gst_buffer(&gstbtobj, &tempbuf);
+            memcpy(tempbuf,gbuff,data_read_from_bt);
+
+            if (fetch_rtp_info && (data_read_from_bt > 12)) {
+                rtp_offset = get_rtp_offset(tempbuf, codec_type);
+                data_read_from_bt = data_read_from_bt - rtp_offset;
+                }
+            }
+            else {
+                data_read_from_bt =  residual_compress_data;
+            }
+        }
+#else
+        if ((mBtA2dpSinkStreamingVendorInterface != NULL) && ( pcm_buf != NULL)) {
+             // fetch PCM data from fluoride
+            if( residual_compress_data == 0) {
+            data_read_from_bt =  mBtA2dpSinkStreamingVendorInterface->
+                 get_a2dp_sink_streaming_data_vendor(codec_type, pcm_buf, pcm_buf_size);
+            if (fetch_rtp_info && (data_read_from_bt > 12)) {
+                rtp_offset = get_rtp_offset(pcm_buf, codec_type);
+                data_read_from_bt = data_read_from_bt - rtp_offset;
+                }
+            }
+            else {
+                data_read_from_bt =  residual_compress_data;
+            }
+        }
+#endif
+        if (data_read_from_bt <= 0) {
+           // in this case, we don't have data from bt, but we try after some time
+           ALOGD(LOGTAG " NO Data from BT , try after %d ms", A2DP_SINK_PCM_FETCH_TIMER_DURATION);
+           StartCompressAudioFeedTimer();
+           break;
+        }
+#if (defined USE_GST)
+        if (pBTAM->GetAudioDevice() != NULL) {
+             if (fetch_rtp_info)
+                 send_gst_data(&gstbtobj, data_read_from_bt, rtp_offset);
+             else
+                 send_gst_data(&gstbtobj, data_read_from_bt, 0);
+             data_sent_to_audio = data_read_from_bt;
+             cuml_data_written_to_audio = cuml_data_written_to_audio + data_sent_to_audio;
+
+        }
+#else
+        if (pA2dpSinkStream->relay_sink_data) {
+            ALOGD(LOGTAG " Enquee the data codec type = %d size = %d ", codec_type,data_read_from_bt);
+            enque_relay_data(pcm_buf,data_read_from_bt, codec_type);
+        }
+        if ((pBTAM->GetAudioDevice() != NULL) && (out_stream != NULL)) {
+             if (fetch_rtp_info) {
+                 out_buf.buffer = pcm_buf + rtp_offset;
+             } else {
+                 out_buf.buffer = pcm_buf;
+             }
+             out_buf.bytes = data_read_from_bt;
+#if (defined(DUMP_COMPRESSED_DATA) && (DUMP_COMPRESSED_DATA == TRUE))
+             if ((outputPcmSampleFile) && (pcm_buf != NULL))
+             {
+                fwrite ((void*)pcm_buf, 1, (size_t)(data_read_from_bt), outputPcmSampleFile);
+                data_sent_to_audio = data_read_from_bt;
+             }
+#else
+             data_sent_to_audio = qahw_out_write(out_stream, &out_buf);
+#endif
+             cuml_data_written_to_audio = cuml_data_written_to_audio + data_sent_to_audio;
+        }
+#endif
+        ALOGD(LOGTAG " data_read_from_bt = %d data_sent_to_audio = %d cuml_data = %d",
+                 data_read_from_bt, data_sent_to_audio, cuml_data_written_to_audio);
+        residual_compress_data = data_read_from_bt - data_sent_to_audio;
+        if (residual_compress_data > 0) {
+           /* This is the case for AUDIO buffers completely filled
+            * We should wait for EVENT_WRITE_READY from AUDIO */
+           ALOGE( LOGTAG " Residual Data, Wait for EVENT_WRITE_READY ");
+           memcpy(pcm_buf, pcm_buf + data_sent_to_audio, data_read_from_bt - data_sent_to_audio);
+           break;
+        }
+    }while(1);
+    ALOGD(LOGTAG " FillCompressBuffertoAudioOutHal - cum_data = %d", cuml_data_written_to_audio);
+    if(cuml_data_written_to_audio >= pcm_buf_size)//reset for next iteration.
+        cuml_data_written_to_audio = 0;
+#endif
+}
+
+void compress_audio_feed_handler(void *context) {
+    ALOGV(LOGTAG " compress_audio_feed_handler ");
+
+    pA2dpSinkStream->compress_offload_timer = false;
+    BtEvent *pEvent = new BtEvent;
+    pEvent->a2dpSinkStreamingEvent.event_id = A2DP_SINK_FILL_COMPRESS_BUFFER;
+    if (pA2dpSinkStream) {
+        thread_post(pA2dpSinkStream->threadInfo.thread_id,
+        pA2dpSinkStream->threadInfo.thread_handler, (void*)pEvent);
+    }
+}
+
+void A2dp_Sink_Streaming::StartCompressAudioFeedTimer() {
+    if(compress_offload_timer) {
+        ALOGV(LOGTAG " compressed timer already running, return ");
+        return;
+    }
+    compress_offload_timer = true;
+    alarm_set(compress_audio_feed_timer, A2DP_SINK_COMPRESS_FEED_TIMER_DURATION,
+            compress_audio_feed_handler, NULL);
+}
+
+void A2dp_Sink_Streaming::StopCompressAudioFeedTimer() {
+    if((compress_audio_feed_timer != NULL) && (compress_offload_timer)) {
+        alarm_cancel(compress_audio_feed_timer);
+        compress_offload_timer = false;
+    }
+}
+
+void pcm_fetch_timer_handler(void *context) {
+    ALOGV(LOGTAG " pcm_fetch_timer_handler ");
+
+    BtEvent *pEvent = new BtEvent;
+    pEvent->a2dpSinkStreamingEvent.event_id = A2DP_SINK_STREAMING_FETCH_PCM_DATA;
+    if (pA2dpSinkStream) {
+        thread_post(pA2dpSinkStream->threadInfo.thread_id,
+        pA2dpSinkStream->threadInfo.thread_handler, (void*)pEvent);
+    }
+}
+
+void A2dp_Sink_Streaming::StartPcmTimer() {
+    if(pcm_timer) {
+        ALOGD(LOGTAG " PCM Timer still running + ");
+        return;
+    }
+    alarm_set(pcm_data_fetch_timer, A2DP_SINK_PCM_FETCH_TIMER_DURATION,
+           pcm_fetch_timer_handler, NULL);
+    pcm_timer = true;
+}
+
+void A2dp_Sink_Streaming::StopDataFetchTimer() {
+    ALOGD(LOGTAG " StopDataFetchTimer ");
+    if((codec_type == A2DP_SINK_AUDIO_CODEC_SBC) && (pcm_data_fetch_timer != NULL) && (pcm_timer)) {
+        alarm_cancel(pcm_data_fetch_timer);
+        pcm_timer = false;
+    } else {
+        StopCompressAudioFeedTimer();
+    }
+}
+
+void A2dp_Sink_Streaming::HandleEnableSinkStreaming(void) {
+    ALOGD(LOGTAG " HandleEnableSinkStreaming");
+
+    BtEvent *pEvent = new BtEvent;
+    use_bt_a2dp_hal = config_get_bool (config,
+            CONFIG_DEFAULT_SECTION, "BtUseA2dpHalForSink", false);
+    ALOGD(LOGTAG " Use BT A2DP HAL ENabled %d", use_bt_a2dp_hal);
+    if(use_bt_a2dp_hal) {
+        LoadBtA2dpHAL();
+    }
+    relay_sink_data = config_get_bool (config,
+            CONFIG_DEFAULT_SECTION, "BtRelaySinkDatatoSrc", false);
+    ALOGD(LOGTAG " Sink Relay ENabled %d", relay_sink_data);
+}
+
+void A2dp_Sink_Streaming::HandleDisableSinkStreaming(void) {
+   BtEvent *pEvent = new BtEvent;
+   ALOGD(LOGTAG " HandleDisableSinkStreaming");
+
+   CloseAudioStream();
+   StopDataFetchTimer();
+   if(use_bt_a2dp_hal) {
+       UnLoadBtA2dpHAL();
+   }
+
+   ALOGD(LOGTAG " set the mStreamingDevice to zero");
+   memset(&mStreamingDevice, 0, sizeof(bt_bdaddr_t));
+   pEvent->a2dpSinkEvent.event_id = A2DP_SINK_STREAMING_DISABLE_DONE;
+   PostMessage(THREAD_ID_A2DP_SINK, pEvent);
+}
+
+char* A2dp_Sink_Streaming::dump_message(BluetoothEventId event_id) {
+    switch(event_id) {
+    case A2DP_SINK_FOCUS_REQUEST_CB:
+        return "FOCUS_REQUEST_CB";
+    case BT_AM_CONTROL_STATUS:
+        return "AM_CONTROL_STATUS";
+    case A2DP_SINK_FETCH_PCM_DATA:
+        return "A2DP_SINK_FETCH_PCM_DATA";
+    case A2DP_SINK_FILL_COMPRESS_BUFFER:
+        return "FILL_COMPRESS_BUFFER";
+    }
+    return "UNKNOWN";
+}
+
+uint32_t A2dp_Sink_Streaming::get_a2dp_sbc_sampling_rate(uint8_t frequency) {
+    uint32_t freq = 48000;
+    switch (frequency) {
+        case SBC_SAMP_FREQ_16:
+            freq = 16000;
+            break;
+        case SBC_SAMP_FREQ_32:
+            freq = 32000;
+            break;
+        case SBC_SAMP_FREQ_44:
+            freq = 44100;
+            break;
+        case SBC_SAMP_FREQ_48:
+            freq = 48000;
+            break;
+    }
+    return freq;
+}
+
+uint8_t A2dp_Sink_Streaming::get_a2dp_sbc_channel_mode(uint8_t channeltype) {
+    uint8_t count = 1;
+    switch (channeltype) {
+        case SBC_CH_MONO:
+            count = 1;
+            break;
+        case SBC_CH_DUAL:
+        case SBC_CH_STEREO:
+        case SBC_CH_JOINT:
+            count = 2;
+            break;
+    }
+    return count;
+}
+
+uint32_t A2dp_Sink_Streaming::get_a2dp_aac_sampling_rate(uint16_t frequency) {
+    uint32_t freq = 0;
+    switch (frequency) {
+        case AAC_SAMP_FREQ_44100:
+            freq = 44100;
+            break;
+        case AAC_SAMP_FREQ_48000:
+            freq = 48000;
+            break;
+    }
+    return freq;
+}
+
+uint8_t A2dp_Sink_Streaming::get_a2dp_aac_channel_mode(uint8_t channel_count) {
+    uint8_t count = 1;
+    switch (channel_count) {
+        case AAC_CHANNELS_1:
+            count = 1;
+            break;
+        case AAC_CHANNELS_2:
+            count = 2;
+            break;
+    }
+    return count;
+}
+
+uint32_t A2dp_Sink_Streaming::get_a2dp_mp3_sampling_rate(uint16_t frequency) {
+    uint32_t freq = 0;
+    switch (frequency) {
+        case MP3_SAMP_FREQ_44100:
+            freq = 44100;
+            break;
+        case MP3_SAMP_FREQ_48000:
+            freq = 48000;
+            break;
+    }
+    return freq;
+}
+
+uint8_t A2dp_Sink_Streaming::get_a2dp_mp3_channel_mode(uint8_t channel_count) {
+    uint8_t count = 1;
+    switch (channel_count) {
+        case MP3_CHANNEL_MONO:
+            count = 1;
+            break;
+        case MP3_CHANNEL_DUAL:
+        case MP3_CHANNEL_STEREO:
+        case MP3_CHANNEL_JOINT_STEREO:
+            count = 2;
+            break;
+    }
+    return count;
+}
+
+uint32_t A2dp_Sink_Streaming::get_a2dp_aptx_sampling_rate(uint8_t frequency) {
+    uint32_t freq = 0;
+    switch (frequency) {
+        case APTX_SAMPLERATE_44100:
+            freq = 44100;
+            break;
+        case APTX_SAMPLERATE_48000:
+            freq = 48000;
+            break;
+    }
+    return freq;
+}
+
+uint8_t A2dp_Sink_Streaming::get_a2dp_aptx_channel_mode(uint8_t channel_count) {
+    uint8_t count = 1;
+    switch (channel_count) {
+        case APTX_CHANNELS_MONO:
+            count = 1;
+            break;
+        case APTX_CHANNELS_STEREO:
+            count = 2;
+            break;
+    }
+    return count;
+}
+
+void A2dp_Sink_Streaming::ConfigureAudioHal() {
+#if (defined BT_AUDIO_HAL_INTEGRATION)
+    qahw_module_handle_t* audio_device;
+    audio_config_t config;
+    audio_io_handle_t handle = 0x07;
+    //audio_output_flags_t flags = AUDIO_OUTPUT_FLAG_NONE;
+    int flags = AUDIO_OUTPUT_FLAG_NONE;
+    struct qahw_aptx_dec_param aptx_params;
+    qahw_param_payload payload;
+    bdstr_t bd_str;
+    int rc = 0;
+
+    memset(&config, 0, sizeof(audio_config_t));
+    config.offload_info.size = sizeof(audio_offload_info_t);
+    ALOGD(LOGTAG " ConfigureAudioHal codec_type = %d", codec_type);
+    switch(codec_type) {
+    case A2DP_SINK_AUDIO_CODEC_SBC:
+        sample_rate = get_a2dp_sbc_sampling_rate(codec_config.sbc_config.samp_freq);
+        channel_count = get_a2dp_sbc_channel_mode(codec_config.sbc_config.ch_mode);
+        config.offload_info.format = AUDIO_FORMAT_PCM_16_BIT;
+        flags |= AUDIO_OUTPUT_FLAG_DIRECT_PCM;
+        break;
+    case A2DP_SINK_AUDIO_CODEC_AAC:
+        sample_rate = get_a2dp_aac_sampling_rate(codec_config.aac_config.sampling_freq);
+        channel_count = get_a2dp_aac_channel_mode(codec_config.aac_config.channel_count);
+        config.offload_info.format = AUDIO_FORMAT_AAC_LATM_LC;
+        flags |= AUDIO_OUTPUT_FLAG_NON_BLOCKING;
+        flags |= AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD;
+        break;
+    case A2DP_SINK_AUDIO_CODEC_MP3:
+        sample_rate = get_a2dp_mp3_sampling_rate(codec_config.mp3_config.sampling_freq);
+        channel_count = get_a2dp_mp3_channel_mode(codec_config.mp3_config.channel_count);
+        config.offload_info.format = AUDIO_FORMAT_MP3;
+        flags |= AUDIO_OUTPUT_FLAG_NON_BLOCKING;
+        flags |= AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD;
+        break;
+    case A2DP_SINK_AUDIO_CODEC_APTX:
+        #if (defined USE_GST)
+             gstbtobj.is_compressed = true;
+        #endif
+        sample_rate = get_a2dp_aptx_sampling_rate(codec_config.aptx_config.sampling_freq);
+        channel_count = get_a2dp_aptx_channel_mode(codec_config.aptx_config.channel_count);
+        config.offload_info.format = AUDIO_FORMAT_APTX;
+        flags |= AUDIO_OUTPUT_FLAG_NON_BLOCKING;
+        flags |= AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD;
+        break;
+    }
+    ALOGD(LOGTAG " sample_rate = %d, channel_count = %d", sample_rate, channel_count);
+#if (defined USE_GST)
+    if (gstbtobj.is_compressed == true){
+        bt_bdaddr_t *bd_addr = g_gap->GetBtAddress();
+        bdaddr_to_string(bd_addr, &bd_str[0], sizeof(bd_str));
+        ALOGD (LOGTAG " Local bdaddr %s", bd_str);
+        memcpy(gstbtobj.bt_addr,&bd_str[0], sizeof(bd_str));
+        gstbtobj.bt_addr[sizeof(bd_str)+1]='\0';
+        ALOGD (LOGTAG " gstobj bt_addr %s \n", gstbtobj.bt_addr);
+    }
+    init_gst_pipeline(&gstbtobj, config.offload_info.format, sample_rate, channel_count, flags, "bt_a2dp_sink");
+#else
+    if (out_stream != NULL) {
+        ALOGD(LOGTAG " HAL already configured ");
+        return;
+    }
+    // HAL is not yet configured, configure it now.
+   config.offload_info.version = AUDIO_OFFLOAD_INFO_VERSION_CURRENT;
+   config.sample_rate = sample_rate;
+   config.offload_info.sample_rate = sample_rate;
+   config.channel_mask = audio_channel_out_mask_from_count(channel_count);
+   config.offload_info.channel_mask = audio_channel_out_mask_from_count(channel_count);
+    if (pBTAM != NULL) {
+        audio_device = pBTAM->GetAudioDevice();
+        if (audio_device != NULL) {
+            if (codec_type == A2DP_SINK_AUDIO_CODEC_APTX) {
+                // send local bd_addr to audio
+                bt_bdaddr_t *bd_addr = g_gap->GetBtAddress();
+                bdaddr_to_string(bd_addr, &bd_str[0], sizeof(bd_str));
+                ALOGD (LOGTAG " Local bdaddr %s", bd_str);
+                parse_aptx_dec_bd_addr(&bd_str[0], &aptx_params);
+                payload.aptx_params = aptx_params;
+                rc = qahw_set_param_data(audio_device, QAHW_PARAM_APTX_DEC, &payload);
+                if (rc != 0)
+                    ALOGE(LOGTAG "Error. Failed to set Local bluetooth address to audio hal");
+            }
+            // 2 refers to speaker
+            ALOGD(LOGTAG " opening output stream ");
+            qahw_open_output_stream(audio_device, handle, 2, (audio_output_flags_t)flags,
+                   &config, &out_stream, "bt_a2dp_sink");
+        }
+        if (out_stream != NULL) {
+            pcm_buf_size = qahw_out_get_buffer_size(out_stream);
+            ALOGD(LOGTAG " pcm buf size %d", pcm_buf_size);
+            pcm_buf = (uint8_t*)osi_malloc(pcm_buf_size);
+            // Set initial volume level = 1 of output stream
+            SetStreamVol(current_vol_idx);
+        }
+        if (codec_type != A2DP_SINK_AUDIO_CODEC_SBC) {
+            qahw_out_set_callback(out_stream, compressed_callback, NULL);
+        }
+    }
+#endif
+#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
+    if (!sample_rate || !channel_count) {
+        return;
+    }
+    switch(sample_rate) {
+    case 44100:
+        pcm_buf_size = 7065;
+        break;
+    case 48000:
+        pcm_buf_size = 7680;
+        break;
+    }
+    pcm_buf = (uint8_t*)osi_malloc(pcm_buf_size);
+    if (outputPcmSampleFile == NULL)
+        outputPcmSampleFile = fopen(outputFilename, "ab");
+#endif
+#if (defined(DUMP_COMPRESSED_DATA) && (DUMP_COMPRESSED_DATA == TRUE))
+    if (outputPcmSampleFile == NULL)
+        outputPcmSampleFile = fopen(outputFilename, "ab");
+#endif
+#endif
+}
+
+void A2dp_Sink_Streaming::CloseAudioStream() {
+#if (defined BT_AUDIO_HAL_INTEGRATION)
+    qahw_module_handle_t* audio_device;
+    if (pBTAM != NULL) {
+        audio_device = pBTAM->GetAudioDevice();
+        if((audio_device != NULL) && (out_stream != NULL)) {
+            // 2 refers to speaker
+            ALOGD(LOGTAG " closing output stream ");
+            qahw_close_output_stream(out_stream);
+            cuml_data_written_to_audio = 0;
+            residual_compress_data = 0;
+            out_stream = NULL;
+        }
+        if (pcm_buf != NULL) {
+            osi_free(pcm_buf);
+            pcm_buf = NULL;
+        }
+    }
+#endif
+#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
+    if (outputPcmSampleFile)
+    {
+        fclose(outputPcmSampleFile);
+    }
+    outputPcmSampleFile = NULL;
+    if (pcm_buf != NULL) {
+        osi_free(pcm_buf);
+        pcm_buf = NULL;
+    }
+#endif
+#if (defined(DUMP_COMPRESSED_DATA) && (DUMP_COMPRESSED_DATA == TRUE))
+    if (outputPcmSampleFile)
+    {
+        fclose(outputPcmSampleFile);
+    }
+    outputPcmSampleFile = NULL;
+#endif
+}
+void A2dp_Sink_Streaming::LoadBtA2dpHAL() {
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    ALOGD(LOGTAG " Load A2dp HAL ");
+    a2dp_input_device = qahw_load_module(QAHW_MODULE_ID_A2DP);
+    if (a2dp_input_device == NULL) {
+        ALOGE(LOGTAG " A2dp Hal can not be opened ");
+        return;
+    }
+    ALOGD(LOGTAG " A2dp HAL successfully loaded ");
+#endif
+}
+
+void A2dp_Sink_Streaming::UnLoadBtA2dpHAL() {
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    int ret  =  0;
+    ALOGD(LOGTAG " Unload A2dp HAL");
+    if(!a2dp_input_device)
+    {
+        ALOGD(LOGTAG " A2dp_input_device not valid ");
+        return;
+    }
+    ret = qahw_unload_module(a2dp_input_device);
+    if (ret < 0) {
+        ALOGE(LOGTAG " A2dp HAL could not be closed gracefully");
+        a2dp_input_device = NULL;
+        return;
+    }
+    a2dp_input_device = NULL;
+    ALOGD(LOGTAG " A2dp HAL successfully Unloaded ");
+#endif
+}
+
+void A2dp_Sink_Streaming::OpenInputStream()
+{
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    int ret = -1;
+    ALOGD(LOGTAG " Open A2dp Input Stream ");
+    if (!a2dp_input_device) {
+        ALOGE(LOGTAG " Invalid A2dp HAL device. Bail out! ");
+        return;
+    }
+    ret = qahw_open_input_stream(a2dp_input_device, 0, AUDIO_DEVICE_OUT_ALL_A2DP,
+          NULL, &input_stream, AUDIO_INPUT_FLAG_NONE, "bt_a2dp_input_stream", AUDIO_SOURCE_DEFAULT);
+    if (ret < 0) {
+        input_stream = NULL;
+        ALOGE(LOGTAG " open input stream returned %d\n ", ret);
+    }
+    ALOGD(LOGTAG " A2dp Input Stream successfully opened ");
+#endif
+}
+
+void A2dp_Sink_Streaming::CloseInputStream()
+{
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    ALOGD(LOGTAG " Close A2dp Input Stream ");
+    if ((a2dp_input_device == NULL) || (input_stream == NULL)) {
+        ALOGE(LOGTAG " Invalid A2dp HAL device. Bail out! ");
+        return;
+    }
+    qahw_close_input_stream(input_stream);
+    input_stream = NULL;
+    ALOGD(LOGTAG " A2dp Input Stream successfully closed ");
+#endif
+}
+
+void A2dp_Sink_Streaming::SuspendInputStream()
+{
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    ALOGD(LOGTAG " Suspend Input Stream ");
+    if(!input_stream)
+    {
+        ALOGE(LOGTAG " Invalid Input Stream. Bail out! ");
+        return;
+    }
+    qahw_in_standby(input_stream);
+    ALOGD(LOGTAG " A2dp Stream suspended successfully");
+#endif
+}
+
+void A2dp_Sink_Streaming::SetStreamVol(int curr_audio_index)
+{
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    current_vol_idx = curr_audio_index;
+    ALOGD(LOGTAG " SetStreamVol current_vol_idx %d ", current_vol_idx);
+    if(!out_stream)
+    {
+        ALOGE(LOGTAG " Invalid output Stream. Bail out! ");
+        return;
+    }
+    qahw_out_set_volume(out_stream, (float)current_vol_idx/15, (float)current_vol_idx/15);
+    ALOGD(LOGTAG " SetStreamVol = %d successfully", current_vol_idx);
+#endif
+}
+
+uint32_t A2dp_Sink_Streaming::ReadInputStream(uint8_t* data, uint32_t size)
+{
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    uint32_t data_read;
+    qahw_in_buffer_t in_buf;
+    ALOGD(LOGTAG " Read Input Stream");
+    if(!input_stream)
+    {
+        ALOGE(LOGTAG " Invalid Input Stream. Bail out! ");
+        return 0 ;
+    }
+    in_buf.buffer = data;
+    in_buf.bytes = size;
+    data_read = qahw_in_read(input_stream, &in_buf);;
+    ALOGD(LOGTAG " A2dp Input Stream bytes read = %d", data_read);
+    return data_read;
+#endif
+}
+
+uint32_t A2dp_Sink_Streaming::GetInputStreamBufferSize()
+{
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    ALOGD(LOGTAG " GetInputStreamBufferSize + ");
+    if(!input_stream)
+    {
+        ALOGE(LOGTAG " Invalid Input Stream. Bail out! ");
+        return 0 ;
+    }
+    return qahw_in_get_buffer_size(input_stream);
+    ALOGD(LOGTAG " GetInputStreamBufferSize %d ");
+#endif
+}
+
+void A2dp_Sink_Streaming::OnDisconnected() {
+    ALOGD(LOGTAG " onDisconnected ");
+    StopDataFetchTimer();
+    if (use_bt_a2dp_hal) {
+        CloseInputStream();
+    }
+    CloseAudioStream();
+    pcm_buf_size = 0;
+    cuml_data_written_to_audio = 0;
+    residual_compress_data = 0;
+    codec_type = A2DP_SINK_AUDIO_CODEC_SBC;
+    memset(&codec_config, 0, sizeof(btav_codec_config_t));
+}
+
+void A2dp_Sink_Streaming::GetLibInterface(const btav_sink_vendor_interface_t *sBtA2dpSinkStrVendorInterface) {
+    ALOGD(LOGTAG " GetLibInterface ");
+    mBtA2dpSinkStreamingVendorInterface = sBtA2dpSinkStrVendorInterface;
+}
+
+A2dp_Sink_Streaming :: A2dp_Sink_Streaming( config_t *config) {
+    this->config = config;
+    controlStatus = STATUS_LOSS;
+    use_bt_a2dp_hal = false;
+    //sbc_decoding = true;
+    channel_count = 0;
+    sample_rate = 0;
+    current_vol_idx = 1;
+    threadInfo.thread_handler = &BtA2dpSinkStreamingMsgHandler;
+    threadInfo.thread_name = "A2dp_Sink_Streaming_Thread";
+    mBtA2dpSinkStreamingVendorInterface = NULL;
+    memset(&mStreamingDevice, 0, sizeof(bt_bdaddr_t));
+    memset(&mResumingDevice, 0, sizeof(bt_bdaddr_t));
+    pthread_mutex_init(&this->lock, NULL);
+    pcm_data_fetch_timer = alarm_new();
+    compress_audio_feed_timer = alarm_new();
+    pcm_buf = NULL;
+    pcm_timer = false;
+    compress_offload_timer = false;
+    residual_compress_data = 0;
+    codec_type = A2DP_SINK_AUDIO_CODEC_SBC;//by default make it SBC
+    memset(&codec_config, 0, sizeof(btav_codec_config_t));
+#if (defined BT_AUDIO_HAL_INTEGRATION)
+    out_stream =  NULL;
+    input_stream = NULL;
+    a2dp_input_device = NULL;
+#if (defined USE_GST)
+    gbuff = (uint8_t *)malloc(A2DP_SINK_GBUF_MAX_SIZE);
+#endif
+#endif
+#if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
+    outputPcmSampleFile =  NULL;
+#endif
+#if (defined(DUMP_COMPRESSED_DATA) && (DUMP_COMPRESSED_DATA == TRUE))
+    outputPcmSampleFile =  NULL;
+#endif
+
+}
+
+A2dp_Sink_Streaming :: ~A2dp_Sink_Streaming() {
+    pthread_mutex_destroy(&lock);
+    use_bt_a2dp_hal = false;
+    controlStatus = STATUS_LOSS;
+    current_vol_idx = 1;
+    threadInfo.thread_handler = &BtA2dpSinkStreamingMsgHandler;
+    threadInfo.thread_name = "A2dp_Sink_Streaming_Thread";
+    alarm_free(pcm_data_fetch_timer);
+    alarm_free(compress_audio_feed_timer);
+    pcm_data_fetch_timer = NULL;
+    compress_audio_feed_timer = NULL;
+    memset(&mStreamingDevice, 0, sizeof(bt_bdaddr_t));
+    memset(&mResumingDevice, 0, sizeof(bt_bdaddr_t));
+    mBtA2dpSinkStreamingVendorInterface = NULL;
+#if (defined BT_AUDIO_HAL_INTEGRATION)
+#if (defined USE_GST)
+    free(gbuff);
+#else
+    out_stream = NULL;
+#endif
+    input_stream = NULL;
+    a2dp_input_device = NULL;
+#endif
+    if (pcm_buf != NULL) {
+        osi_free(pcm_buf);
+        pcm_buf = NULL;
+    }
+    codec_type = A2DP_SINK_AUDIO_CODEC_SBC;//by default make it SBC
+    memset(&codec_config, 0, sizeof(btav_codec_config_t));
+}
diff --git a/bt-app/a2dp_src/include/A2dp_Src.hpp b/bt-app/a2dp_src/include/A2dp_Src.hpp
new file mode 100644
index 0000000..6826d0e
--- /dev/null
+++ b/bt-app/a2dp_src/include/A2dp_Src.hpp
@@ -0,0 +1,183 @@
+ /*
+  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#ifndef A2DP_SOURCE_APP_H
+#define A2DP_SOURCE_APP_H
+
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_av.h>
+#include <hardware/bt_rc.h>
+#include <pthread.h>
+#include "hardware/bt_av_vendor.h"
+#include "hardware/bt_rc_vendor.h"
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/allocator.h"
+#include "osi/include/alarm.h"
+#include "ipc.h"
+#include "utils.h"
+#include <list>
+
+using std::list;
+using std::string;
+
+#define A2DP_SOURCE_SET_ABS_VOL_TIMER_DURATION         4000
+
+typedef enum {
+    AVRC_RSP_NOT_IMPL = 8,
+    AVRC_RSP_ACCEPT,
+    AVRC_RSP_REJ,
+    AVRC_RSP_IN_TRANS,
+    AVRC_RSP_IMPL_STBL,
+    AVRC_RSP_CHANGED,
+    AVRC_RSP_INTERIM = 15,
+}AvrcRspType;
+
+typedef enum {
+    AVRC_KEY_DOWN = 0,
+    AVRC_KEY_UP,
+}AvrcKeyDir;
+
+typedef enum {
+    ATTR_TRACK_NUM = 0,
+    ATTR_TITLE,
+    ATTR_ARTIST_NAME,
+    ATTR_ALBUM_NAME,
+    ATTR_MEDIA_NUMBER,
+    ATTR_MEDIA_TOTAL_NUMBER,
+    ATTR_GENRE,
+    ATTR_PLAYING_TIME_MS,
+}AttrType;
+
+typedef enum {
+    STATE_A2DP_SOURCE_NOT_STARTED = 0,
+    STATE_A2DP_SOURCE_DISCONNECTED,
+    STATE_A2DP_SOURCE_PENDING,
+    STATE_A2DP_SOURCE_CONNECTED,
+}A2dpSourceState;
+
+
+class MediaPlayerInfo {
+  public:
+    short mPlayerId;
+    char mMajorPlayerType;
+    int mPlayerSubType;
+    char mPlayState;
+    short mCharsetId;
+    short mDisplayableNameLength;
+    char* mDisplayableName;
+    char* mPlayerPackageName;
+    bool mIsAvailable;
+    bool mIsFocussed;
+    char mItemType;
+    bool mIsRemoteAddressable;
+    short mItemLength;
+    short mEntryLength;
+    char mFeatureMask[16];
+
+
+  public:
+    MediaPlayerInfo(short playerId, char majorPlayerType, int playerSubType, char playState,
+                        short charsetId, short displayableNameLength, char* displayableName,
+                        char* playerPackageName, bool isAvailable, bool isFocussed, char itemType,
+                        bool isRemoteAddressable, short itemLength, short entryLength,
+                        char featureMask[]);
+    int RetrievePlayerEntryLength();
+    char* RetrievePlayerItemEntry();
+    ~MediaPlayerInfo();
+};
+
+typedef struct  {
+    btrc_media_attr_t *p_attr;
+    long mUid;
+    int mSize;
+}ItemAttr;
+
+typedef struct  {
+    uint32_t mStart;
+    uint32_t mEnd;
+    uint32_t mSize;
+    uint8_t mNumAttr;
+    uint32_t p_attr[BTRC_MAX_ELEM_ATTR_SIZE];
+}FolderListEntries;
+
+class A2dp_Source {
+
+  private:
+    config_t *config;
+    const bt_interface_t * bluetooth_interface;
+    const btav_interface_t *sBtA2dpSourceInterface;
+    const btrc_interface_t *sBtAvrcpTargetInterface;
+    A2dpSourceState mSourceState;
+    bool mAvrcpConnected;
+    const btav_vendor_interface_t *sBtA2dpSourceVendorInterface;
+    const btrc_vendor_interface_t *sBtAvrcpTargetVendorInterface;
+
+  public:
+    A2dp_Source(const bt_interface_t *bt_interface, config_t *config);
+    ~A2dp_Source();
+    void ProcessEvent(BtEvent* pEvent);
+    void state_disconnected_handler(BtEvent* pEvent);
+    void state_pending_handler(BtEvent* pEvent);
+    void state_connected_handler(BtEvent* pEvent);
+    void change_state(A2dpSourceState mState);
+    A2dpSourceState get_state(void);
+    bool get_codec_cfg(uint8_t* info, uint8_t* type);
+    char* dump_message(BluetoothEventId event_id);
+    pthread_mutex_t lock;
+    bool enable_delay_report;
+    bt_bdaddr_t mConnectingDevice;
+    bt_bdaddr_t mConnectedDevice;
+    bt_bdaddr_t mConnectedAvrcpDevice;
+    bool mVolCmdSetInProgress;
+    bool mVolCmdAdjustInProgress;
+    bool mAbsVolRemoteSupported;
+    int mInitialRemoteVolume;
+    int mLastRemoteVolume;
+    int mRemoteVolume;
+    int mLastLocalVolume;
+    int mLocalVolume;
+    alarm_t *set_abs_volume_timer;
+    bool abs_vol_timer;
+    uint16_t mPreviousAddrPlayerId;
+    uint16_t mCurrentAddrPlayerId;
+    void HandleAvrcpEvents(BtEvent* pEvent);
+    void HandleEnableSource();
+    void HandleDisableSource();
+    void StartSetAbsVolTimer();
+    void StopSetAbsVolTimer();
+    void updateResetNotification(btrc_event_id_t noti);
+    list<MediaPlayerInfo> pMediaPlayerList;
+};
+
+#endif
diff --git a/bt-app/a2dp_src/src/A2dp_Src.cpp b/bt-app/a2dp_src/src/A2dp_Src.cpp
new file mode 100644
index 0000000..f7ad27d
--- /dev/null
+++ b/bt-app/a2dp_src/src/A2dp_Src.cpp
@@ -0,0 +1,2011 @@
+/*
+  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#include <iostream>
+#include <string.h>
+#include <hardware/bluetooth.h>
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+#include <hardware/hardware.h>
+#include <hardware/audio.h>
+#endif
+#include <hardware/bt_av.h>
+#include <hardware/bt_rc.h>
+#include <list>
+#include <map>
+#include <dlfcn.h>
+#include "Avrcp.hpp"
+#include "A2dp_Src.hpp"
+#include "Gap.hpp"
+#include "hardware/bt_av_vendor.h"
+#include "hardware/bt_rc_vendor.h"
+#include <math.h>
+#include <algorithm>
+#include <cutils/properties.h>
+#include "osi/include/list.h"
+#include "osi/include/allocator.h"
+
+#define LOGTAG_A2DP "A2DP_SRC "
+#define LOGTAG_AVRCP "AVRCP_TG "
+
+using namespace std;
+using std::list;
+using std::string;
+
+
+extern Avrcp *pAvrcp;
+A2dp_Source *pA2dpSource = NULL;
+static pthread_t playback_thread = NULL;
+AttrType mAttrType;
+bool media_playing = false;
+bool use_bigger_metadata = false;
+btrc_play_status_t playStatus = BTRC_PLAYSTATE_ERROR;
+btrc_notification_type_t mPlayStatusNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+btrc_notification_type_t mTrackChangeNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+btrc_notification_type_t mAddrPlayerChangedNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+btrc_notification_type_t mAvailPlayerChangedNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+static uint32_t a2dp_playstatus = A2DP_SOURCE_AUDIO_STOPPED;
+long NO_TRACK_SELECTED = -1L;
+long TRACK_IS_SELECTED = 0L;
+long mCurrentTrackID = NO_TRACK_SELECTED;
+
+#define AVRCP_MAX_VOL 127
+int mAudioStreamMax = 15;
+bool is_sink_relay_enabled = false;
+
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+audio_hw_device_t *a2dp_device = NULL;
+struct audio_stream_out *output_stream = NULL;
+static pthread_mutex_t a2dp_hal_mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
+typedef enum
+{
+    SRC_STREAMING,
+    SRC_NO_STREAMING,
+}SrcStreamStatus;
+
+#define AUDIO_STREAM_OUTPUT_BUFFER_SZ      (20*512)
+#define INVALID_CODEC    -1
+#define NON_A2DP_MEDIA_CT    0xFF
+#define DEBUGPRINTBIT
+#ifdef DEBUGPRINTBIT
+#define PRINTBIT(s,num)   do{ ALOGD("IN Function %s The content of %s:",__func__,#s);\
+                              for(int i=0;i<num;i++) ALOGD(" %hhu",*((uint8_t*)(s)+i));}while(0)
+#else
+#define PRINTBIT(s,num)
+#endif
+
+typedef struct
+{
+    uint16_t codec_type;
+    uint16_t len;
+    uint16_t offset;
+} t_SINK_RELAY_DATA;
+list_t *a2dp_sink_relay_data_list;
+static pthread_mutex_t a2dp_sink_relay_mutex = PTHREAD_MUTEX_INITIALIZER;
+extern bool GetCodecInfoByAddr(bt_bdaddr_t* bd_addr, uint16_t *dev_codec_type, btav_codec_config_t* codec_config);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void registerMediaPlayers () {
+    ALOGD(LOGTAG_AVRCP "registerMediaPlayers");
+
+    char* playerName1 = "Music";/*Music*/;
+    char* playerName2 = "Music2";/*Music2*/;
+
+    char featureMasks[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+    char featureMasks2[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+    featureMasks[5] = featureMasks[5] | 0x01;
+    featureMasks[5] = featureMasks[5] | 0x04;
+    featureMasks[5] = featureMasks[5] | 0x02;
+    featureMasks[7] = featureMasks[7] | 0x04;
+
+    featureMasks2[5] = featureMasks2[5] | 0x01;
+    featureMasks2[5] = featureMasks2[5] | 0x04;
+    featureMasks2[5] = featureMasks2[5] | 0x02;
+    featureMasks2[7] = featureMasks2[7] | 0x04;
+
+    pA2dpSource->pMediaPlayerList.push_back(MediaPlayerInfo (0, 1, 0, 2, 0x006A, 5,
+            playerName1, "com.default.music", false, false, 0x01, true, 0, 0, featureMasks));
+
+    pA2dpSource->pMediaPlayerList.push_back(MediaPlayerInfo (1, 1, 0, 2, 0x006A, 6,
+            playerName2, "com.external.music", false, false, 0x01, true, 0, 0, featureMasks2));
+
+    ALOGD(LOGTAG_AVRCP "Exit registerMediaPlayers()");
+}
+
+void A2dp_Source:: updateResetNotification(btrc_event_id_t noti) {
+    ALOGD(LOGTAG_AVRCP "updateResetNotification for %d", noti);
+    btrc_register_notification_t param;
+    long TrackNumberRsp = -1L;
+    switch(noti)
+    {
+        case BTRC_EVT_PLAY_STATUS_CHANGED:
+            if (mPlayStatusNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                mPlayStatusNotiType = BTRC_NOTIFICATION_TYPE_REJECT;
+                param.play_status = BTRC_PLAYSTATE_PAUSED;
+                sBtAvrcpTargetInterface->register_notification_rsp(BTRC_EVT_PLAY_STATUS_CHANGED,
+                        mPlayStatusNotiType, &param, &pA2dpSource->mConnectedAvrcpDevice);
+            }
+            break;
+        case BTRC_EVT_TRACK_CHANGE:
+            if (mTrackChangeNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                mTrackChangeNotiType = BTRC_NOTIFICATION_TYPE_REJECT;
+                mCurrentTrackID = TRACK_IS_SELECTED;
+                TrackNumberRsp = mCurrentTrackID;
+                ALOGD(LOGTAG_AVRCP " TrackNumberRsp = %l", TrackNumberRsp);
+                for (int i = 0; i < 8; ++i) {
+                    param.track[i] = (uint8_t) (TrackNumberRsp >> (56 - 8 * i));
+                }
+                sBtAvrcpTargetInterface->register_notification_rsp(BTRC_EVT_TRACK_CHANGE,
+                        mTrackChangeNotiType, &param, &pA2dpSource->mConnectedAvrcpDevice);
+            }
+            break;
+        default:
+            ALOGD(LOGTAG_AVRCP "Invalid Noti");
+            break;
+    }
+}
+
+void resetAndSendPlayerStatusReject() {
+    ALOGD(LOGTAG_A2DP "resetAndSendPlayerStatusReject");
+    pA2dpSource->updateResetNotification(BTRC_EVT_PLAY_STATUS_CHANGED);
+    pA2dpSource->updateResetNotification(BTRC_EVT_TRACK_CHANGE);
+}
+
+void BtA2dpSourceMsgHandler(void *msg) {
+    BtEvent* pEvent = NULL;
+    if(!msg) {
+        ALOGE("Msg is NULL, bail out!!");
+        return;
+    }
+
+    pEvent = ( BtEvent *) msg;
+    switch(pEvent->event_id) {
+        case PROFILE_API_START:
+            ALOGD(LOGTAG_A2DP "enable a2dp source");
+            if (pA2dpSource) {
+                pA2dpSource->HandleEnableSource();
+            }
+            break;
+        case PROFILE_API_STOP:
+            ALOGD(LOGTAG_A2DP "disable a2dp source");
+            if (pA2dpSource) {
+                pA2dpSource->HandleDisableSource();
+            }
+            break;
+        case AVRCP_TARGET_CONNECTED_CB:
+        case AVRCP_TARGET_DISCONNECTED_CB:
+        case A2DP_SOURCE_AUDIO_CMD_REQ:
+        case AVRCP_TARGET_GET_ELE_ATTR:
+        case AVRCP_TARGET_GET_PLAY_STATUS:
+        case AVRCP_TARGET_REG_NOTI:
+        case AVRCP_TARGET_TRACK_CHANGED:
+        case AVRCP_TARGET_VOLUME_CHANGED:
+        case AVRCP_TARGET_ADDR_PLAYER_CHANGED:
+        case AVRCP_TARGET_AVAIL_PLAYER_CHANGED:
+        case AVRCP_TARGET_SET_ABS_VOL:
+        case AVRCP_TARGET_ABS_VOL_TIMEOUT:
+        case AVRCP_TARGET_SEND_VOL_UP_DOWN:
+        case AVRCP_TARGET_GET_FOLDER_ITEMS_CB:
+        case AVRCP_TARGET_SET_ADDR_PLAYER_CB:
+        case AVRCP_TARGET_USE_BIGGER_METADATA:
+            if (pA2dpSource) {
+                pA2dpSource->HandleAvrcpEvents(( BtEvent *) msg);
+            }
+            break;
+        default:
+            if(pA2dpSource) {
+               pA2dpSource->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+    }
+    delete pEvent;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+static void BtA2dpLoadA2dpHal() {
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    const hw_module_t *module;
+    ALOGD(LOGTAG_A2DP "Load A2dp HAL");
+    if (hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID,
+                               AUDIO_HARDWARE_MODULE_ID_A2DP,
+                               &module)) {
+        ALOGE(LOGTAG_A2DP "A2dp Hal module not found");
+        return;
+    }
+    pthread_mutex_lock(&a2dp_hal_mutex);
+    if (audio_hw_device_open(module, &a2dp_device)) {
+        a2dp_device = NULL;
+        ALOGE(LOGTAG_A2DP "A2dp Hal device can not be opened");
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    pthread_mutex_unlock(&a2dp_hal_mutex);
+#endif
+    ALOGD(LOGTAG_A2DP "A2dp HAL successfully loaded");
+}
+
+static void BtA2dpStopStreaming()
+{
+    ALOGD(LOGTAG_A2DP "Stop A2dp Streaming");
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    pthread_mutex_lock(&a2dp_hal_mutex);
+    if(!output_stream)
+    {
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    output_stream->common.set_parameters(&output_stream->common, "A2dpSuspended=false");
+    output_stream->common.standby(&output_stream->common);
+    pthread_mutex_unlock(&a2dp_hal_mutex);
+#endif
+    ALOGD(LOGTAG_A2DP "A2dp stream successfully stopped");
+}
+
+static void BtA2dpCloseOutputStream()
+{
+    ALOGD(LOGTAG_A2DP "Close A2dp Output Stream");
+    media_playing = false;
+    if (playback_thread != NULL)
+    {
+        pthread_join(playback_thread, NULL);
+        playback_thread = NULL;
+    }
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    pthread_mutex_lock(&a2dp_hal_mutex);
+    if(!a2dp_device)
+    {
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    if(!output_stream)
+    {
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    a2dp_device->close_output_stream(a2dp_device, output_stream);
+    output_stream = NULL;
+    pthread_mutex_unlock(&a2dp_hal_mutex);
+#endif
+    ALOGD(LOGTAG_A2DP "A2dp Output Stream successfully closed");
+}
+
+static void BtA2dpUnloadA2dpHal() {
+    ALOGD(LOGTAG_A2DP "Unload A2dp HAL");
+    BtA2dpCloseOutputStream();
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    pthread_mutex_lock(&a2dp_hal_mutex);
+    if(!a2dp_device)
+    {
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    if (audio_hw_device_close(a2dp_device) < 0) {
+        ALOGE(LOGTAG_A2DP "A2dp HAL could not be closed gracefully");
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    a2dp_device = NULL;
+    pthread_mutex_unlock(&a2dp_hal_mutex);
+#endif
+    ALOGD(LOGTAG_A2DP "A2dp HAL successfully Unloaded");
+}
+
+static void BtA2dpOpenOutputStream()
+{
+    int ret = -1;
+    ALOGD(LOGTAG_A2DP "Open A2dp Output Stream");
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    pthread_mutex_lock(&a2dp_hal_mutex);
+    if (!a2dp_device) {
+        ALOGE(LOGTAG_A2DP "Invalid A2dp HAL device. Bail out!");
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    ret = a2dp_device->open_output_stream(a2dp_device, 0, AUDIO_DEVICE_OUT_ALL_A2DP,
+            AUDIO_OUTPUT_FLAG_NONE, NULL, &output_stream, NULL);
+    if (ret < 0) {
+        output_stream = NULL;
+        ALOGE(LOGTAG_A2DP "open output stream returned %d\n", ret);
+    }
+    pthread_mutex_unlock(&a2dp_hal_mutex);
+#endif
+    ALOGD(LOGTAG_A2DP "A2dp Output Stream successfully opened");
+}
+
+static void BtA2dpSuspendStreaming()
+{
+    ALOGD(LOGTAG_A2DP "Suspend A2dp Stream");
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    pthread_mutex_lock(&a2dp_hal_mutex);
+    if(!output_stream)
+    {
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    output_stream->common.set_parameters(&output_stream->common, "A2dpSuspended=true");
+    pthread_mutex_unlock(&a2dp_hal_mutex);
+#endif
+    ALOGD(LOGTAG_A2DP "A2dp Stream suspended successfully");
+}
+
+static void BtA2dpResumeStreaming()
+{
+    ALOGD(LOGTAG_A2DP "Resume A2dp Stream");
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    pthread_mutex_lock(&a2dp_hal_mutex);
+    if(!output_stream)
+    {
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return;
+    }
+    output_stream->common.set_parameters(&output_stream->common, "A2dpSuspended=false");
+    pthread_mutex_unlock(&a2dp_hal_mutex);
+#endif
+    ALOGD(LOGTAG_A2DP "A2dp Stream resumed successfully");
+}
+
+int get_codec_relay_data(void)
+{
+    pthread_mutex_lock(&a2dp_sink_relay_mutex);
+    if(list_is_empty(a2dp_sink_relay_data_list)) {
+        pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+        return INVALID_CODEC;
+    }
+    t_SINK_RELAY_DATA* ptr = (t_SINK_RELAY_DATA*)list_front(a2dp_sink_relay_data_list);
+    pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+    return ptr->codec_type;
+}
+
+void enque_relay_data(uint8_t* buffer, size_t size, uint8_t codec_type)
+{
+    ALOGD(" enque_relay_data size %d list_len = %d codec=%d", size, list_length(a2dp_sink_relay_data_list),codec_type);
+    pthread_mutex_lock(&a2dp_sink_relay_mutex);
+    if (list_length(a2dp_sink_relay_data_list) > 10) {
+        ALOGE(LOGTAG_A2DP "%s:a2dp sink relay queue is full",__func__);
+        pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+        return;
+    }
+    /* allocate memory, first 4 bytes will have size, next 4 bytes will have offset */
+    t_SINK_RELAY_DATA* ptr = (t_SINK_RELAY_DATA*)osi_malloc(size + sizeof(t_SINK_RELAY_DATA));
+    uint8_t* data_ptr;
+    if(ptr != NULL)
+    {
+        data_ptr  = (uint8_t*)(ptr+1);
+        memcpy(data_ptr, (uint8_t*)buffer, size);
+        ptr->codec_type = codec_type;// 0 is for SBC
+        ptr->offset = 0;
+        ptr->len = size;
+        ALOGD(" enque data codec = %d, size=%d",codec_type,size);
+    }
+    else
+    {
+        ALOGE(LOGTAG_A2DP "%s:can not alloc t_SINK_RELAY_DATA",__func__);
+        pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+        return;
+    }
+    list_append(a2dp_sink_relay_data_list, ptr);
+    pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+}
+
+size_t get_sbc_data(uint8_t* buffer, size_t size)
+{
+    ALOGD("revise1 get SBC Data size %d list_len = %d", size, list_length(a2dp_sink_relay_data_list));
+    uint8_t* start_buf_ptr = buffer;
+    uint8_t* end_buf_ptr = buffer + size;
+    uint8_t* data_ptr;
+    size_t data_len=0;
+    pthread_mutex_lock(&a2dp_sink_relay_mutex);
+    if(list_is_empty(a2dp_sink_relay_data_list)) {
+            pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+            return 0;
+    }
+    t_SINK_RELAY_DATA* ptr = (t_SINK_RELAY_DATA*)list_front(a2dp_sink_relay_data_list);
+    //ALOGD("len=%d,offset=%d, end-stat=%d",ptr->len,ptr->offset,end_buf_ptr - start_buf_ptr);
+    while((start_buf_ptr < end_buf_ptr) && (!list_is_empty(a2dp_sink_relay_data_list)))
+    {
+        data_ptr = (uint8_t*)(ptr + 1);
+        /* packets in topmost element are more than what is to be written */
+        if((ptr->len - ptr->offset) > (end_buf_ptr - start_buf_ptr))
+        {
+            ALOGD("packet is more than left buffer len=%d, gap=%d",ptr->len,end_buf_ptr - start_buf_ptr);
+            break;
+            memcpy(start_buf_ptr, data_ptr + ptr->offset, (end_buf_ptr - start_buf_ptr));
+            ptr->offset += (end_buf_ptr -  start_buf_ptr);
+            start_buf_ptr += (end_buf_ptr -  start_buf_ptr);
+        }
+        else /* packets in topmost element is lesser than what is required */
+        {
+            memcpy(start_buf_ptr, data_ptr + ptr->offset, (ptr->len - ptr->offset));
+            data_len+=(ptr->len - ptr->offset);
+            PRINTBIT(start_buf_ptr,4);
+            start_buf_ptr += (ptr->len - ptr->offset);
+            ptr->offset += (ptr->len - ptr->offset);
+           //ALOGD("ptr->len=%d,ptr->offset=%d, end-stat=%d,data_len=%d",ptr->len,ptr->offset,end_buf_ptr - start_buf_ptr,data_len);
+            list_remove(a2dp_sink_relay_data_list, ptr);
+            osi_free(ptr);
+            if (!list_is_empty(a2dp_sink_relay_data_list)) {
+                ptr = (t_SINK_RELAY_DATA*)list_front(a2dp_sink_relay_data_list);
+            }
+        }
+    }
+    pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+    if(start_buf_ptr == end_buf_ptr)
+        return size;
+    else
+        return data_len;
+
+}
+
+size_t get_pcm_data(uint8_t* buffer, size_t size)
+{
+    ALOGD(" get PCM Data size %d list_len = %d", size, list_length(a2dp_sink_relay_data_list));
+    uint8_t* start_buf_ptr = buffer;
+    uint8_t* end_buf_ptr = buffer + size;
+    uint8_t* data_ptr;
+    pthread_mutex_lock(&a2dp_sink_relay_mutex);
+    if(list_is_empty(a2dp_sink_relay_data_list)) {
+        pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+        return 0;
+    }
+    t_SINK_RELAY_DATA* ptr = (t_SINK_RELAY_DATA*)list_front(a2dp_sink_relay_data_list);
+    if(ptr->codec_type != A2DP_SINK_AUDIO_CODEC_PCM)
+    {
+        list_remove(a2dp_sink_relay_data_list, ptr);
+        osi_free(ptr);
+        pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+        return 0;
+    }
+
+    while((start_buf_ptr < end_buf_ptr) && (!list_is_empty(a2dp_sink_relay_data_list)))
+    {
+        data_ptr = (uint8_t*)(ptr + 1);
+        /* packets in topmost element are more than what is to be written */
+        if((ptr->len - ptr->offset) > (end_buf_ptr - start_buf_ptr))
+        {
+            memcpy(start_buf_ptr, data_ptr + ptr->offset, (end_buf_ptr - start_buf_ptr));
+            ptr->offset += (end_buf_ptr -  start_buf_ptr);
+            start_buf_ptr += (end_buf_ptr -  start_buf_ptr);
+        }
+        else /* packets in topmost element is lesser than what is required */
+        {
+            memcpy(start_buf_ptr, data_ptr + ptr->offset, (ptr->len - ptr->offset));
+            start_buf_ptr += (ptr->len - ptr->offset);
+            ptr->offset += (ptr->len - ptr->offset);
+            list_remove(a2dp_sink_relay_data_list, ptr);
+            osi_free(ptr);
+            if (!list_is_empty(a2dp_sink_relay_data_list)) {
+                ptr = (t_SINK_RELAY_DATA*)list_front(a2dp_sink_relay_data_list);
+            }
+        }
+    }
+    pthread_mutex_unlock(&a2dp_sink_relay_mutex);
+    if(start_buf_ptr == end_buf_ptr)
+        return size;
+    else
+        return(end_buf_ptr - start_buf_ptr);
+}
+
+static void *thread_func(void *in_param)
+{
+    SrcStreamStatus srcStream = SRC_NO_STREAMING;
+    size_t len = 0;
+    ssize_t write_len = 0;
+    FILE *in_file = (FILE *)in_param;
+    size_t out_buffer_size = 0;
+    int codec_type;
+    short buffer[AUDIO_STREAM_OUTPUT_BUFFER_SZ];
+    btav_codec_config_t src_codec_cfg;
+    btav_codec_config_t snk_codec_cfg;
+    int src_codec_type = A2DP_SINK_AUDIO_CODEC_SBC;
+    uint16_t snk_codec_type;
+    uint16_t use_file_stream =0;
+    uint8_t codecinfo[20];
+    uint8_t tmpval;
+    ALOGD(LOGTAG_A2DP "Streaming thread started");
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+    pthread_mutex_lock(&a2dp_hal_mutex);
+    if(!output_stream)
+    {
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+        return NULL;
+    }
+    out_buffer_size = output_stream->common.get_buffer_size(&output_stream->common);
+    pthread_mutex_unlock(&a2dp_hal_mutex);
+    if (out_buffer_size <= 0 || out_buffer_size > AUDIO_STREAM_OUTPUT_BUFFER_SZ) {
+        ALOGE(LOGTAG_A2DP "Wrong buffer size. Bail out %u!!", out_buffer_size);
+       if (in_file) fclose(in_file);
+          return NULL;
+    }
+#endif
+    for(int i=0;i<5;i++)
+    {
+        if ( pA2dpSource->get_codec_cfg((uint8_t *)codecinfo,&tmpval))
+        {
+            ALOGD("Got codec type = %d",tmpval);
+            src_codec_type = (int) tmpval;
+            if( tmpval == A2DP_SINK_AUDIO_CODEC_SBC)
+            {
+                //due to the codecinfo is type of tA2D_SBC_CIE
+                // the last two bitpool value is reverse of btav_sbc_codec_config_t
+                tmpval = codecinfo[5];
+                codecinfo[5] = codecinfo[6];
+                codecinfo[6] = tmpval;
+                memcpy(&src_codec_cfg,codecinfo,sizeof(btav_sbc_codec_config_t));
+                src_codec_type = A2DP_SINK_AUDIO_CODEC_SBC;
+                break;
+            }
+            PRINTBIT(codecinfo,10);
+        }
+    }
+
+    while (media_playing) {
+        if(is_sink_relay_enabled)
+        {
+            ALOGD(LOGTAG_A2DP "try to get the codec information of snk side");
+            if( GetCodecInfoByAddr(NULL,&snk_codec_type,&snk_codec_cfg))
+            {
+                if((a2dp_playstatus == A2DP_SOURCE_AUDIO_SUSPENDED) &&(srcStream != SRC_STREAMING))
+                {
+                    ALOGD(LOGTAG_A2DP" resume: playStatus = %d  srcStreamStatus=%d",playStatus,srcStream);
+                    BtA2dpResumeStreaming();
+                }
+                srcStream = SRC_STREAMING;
+                if (snk_codec_type != A2DP_SINK_AUDIO_CODEC_SBC)
+                    use_file_stream = 1;
+                else
+                {
+                        codec_type = get_codec_relay_data();
+                        if(codec_type == INVALID_CODEC)
+                        {
+                            //ALOGD(LOGTAG_A2DP "enque relay empty");
+                            len = 0;
+                        }
+                        else if(codec_type == A2DP_SINK_AUDIO_CODEC_PCM)
+                        {
+                             use_file_stream = 0;
+                             len = get_pcm_data((uint8_t*)buffer, out_buffer_size);
+                        }
+                        else if(codec_type == A2DP_SINK_AUDIO_CODEC_SBC)//pcm data
+                        {
+                            if(src_codec_type == A2DP_SINK_AUDIO_CODEC_SBC)
+                            {
+                                PRINTBIT(&snk_codec_cfg,7);
+                                PRINTBIT(&src_codec_cfg,7);
+                                //if src and snk codec match, compare codec config here;
+                                //if(src_codec_type == A2DP_SINK_AUDIO_CODEC_SBC
+                                if (!memcmp(&src_codec_cfg,&snk_codec_cfg,sizeof(btav_sbc_codec_config_t)))
+                                    len = get_sbc_data((uint8_t*)buffer, out_buffer_size);
+                                else
+                                {
+                                    ALOGD(LOGTAG_A2DP "sbc codec not match, and decoding is not enabled. using file");
+                                    use_file_stream = 1;
+                                }
+                            }
+                            else
+                            {
+                                len=0;
+                                use_file_stream = 1;
+                            }
+                        }
+                 }
+            }
+            else
+            {
+                use_file_stream = 0;
+                ALOGD(LOGTAG_A2DP "cannot get the snk info, may be no streaming ");
+                if((a2dp_playstatus == A2DP_SOURCE_AUDIO_STARTED) &&( srcStream != SRC_NO_STREAMING))
+                {
+                    ALOGD(LOGTAG_A2DP" suspend: playStatus = %d  srcStreamStatus=%d",playStatus,srcStream);
+                    BtA2dpSuspendStreaming();
+                }
+                srcStream= SRC_NO_STREAMING;
+                len =0;
+            }
+            if (len == 0 && (use_file_stream ==0)) {
+                ALOGD(LOGTAG_A2DP "Read %d bytes from file sleep 20ms", len);
+                usleep(20000);
+                continue;
+            }
+        }
+        ALOGD("use file steaming %d relay %d",use_file_stream,is_sink_relay_enabled);
+        if(!is_sink_relay_enabled || use_file_stream)
+        {
+             /* Use file for streaming */
+             ALOGD(LOGTAG_A2DP "use file steaming Read %d buffer size", out_buffer_size);
+             len = fread(buffer, out_buffer_size, 1, in_file);
+             if (len == 0) {
+                 ALOGD(LOGTAG_A2DP "Read %d bytes from file", len);
+                 fseek(in_file, 0, SEEK_SET);
+                 continue;
+             }
+             codec_type = A2DP_SINK_AUDIO_CODEC_PCM;
+             len = out_buffer_size;
+        }
+        ALOGD(LOGTAG_A2DP "Read %d bytes from file   ==%d ", len,sizeof(len));
+#if (defined(BT_AUDIO_HAL_INTEGRATION))
+        pthread_mutex_lock(&a2dp_hal_mutex);
+        if (!output_stream) {
+            pthread_mutex_unlock(&a2dp_hal_mutex);
+            break;
+        }
+        //ALOGD(LOGTAG_A2DP"list the content of buffer send to the device");
+        //PRINTBIT(buffer,7);
+        //ALOGD(LOGTAG_A2DP"**QCOM** size wanna to write =%d, acctully = %d",len,write_len);
+        if(len!=0)
+        {
+            if(src_codec_type == NON_A2DP_MEDIA_CT)
+            {
+                write_len = output_stream->write(output_stream, buffer, len);
+            }
+            else
+            {
+                write_len = output_stream->write(output_stream, &codec_type, sizeof(codec_type));
+                write_len = output_stream->write(output_stream, &len, sizeof(len));
+                write_len = output_stream->write(output_stream, buffer, len);
+            }
+        }
+        pthread_mutex_unlock(&a2dp_hal_mutex);
+#endif
+        ALOGD(LOGTAG_A2DP "codec_type %d Wrote %d bytes to A2dp Hal",codec_type, write_len);
+    };
+    media_playing = false;
+    if (in_file) fclose(in_file);
+    ALOGD(LOGTAG_A2DP "Streaming thread about to finish");
+    return NULL;
+}
+
+static void BtA2dpStartStreaming()
+{
+    FILE *in_file = NULL;
+
+    ALOGD(LOGTAG_A2DP "Start A2dp Stream");
+    if (true || !is_sink_relay_enabled) {
+        in_file = fopen("/data/misc/bluetooth/pcmtest.wav", "r");
+        if (!in_file) {
+            ALOGE(LOGTAG_A2DP "Cannot open input file. Bail out!!");
+            return;
+        }
+    }
+    ALOGD(LOGTAG_A2DP "Successfully opened input file for playback");
+    media_playing = true;
+    if (pthread_create(&playback_thread, NULL, thread_func, in_file) != 0) {
+        ALOGD(LOGTAG_A2DP "Cannot create playback thread!\n");
+        if (in_file) fclose(in_file);
+        return;
+    }
+    return;
+}
+
+static void bta2dp_connection_state_callback(btav_connection_state_t state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG_A2DP " Connection State CB");
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->a2dpSourceEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    switch( state ) {
+        case BTAV_CONNECTION_STATE_DISCONNECTED:
+            pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_DISCONNECTED_CB;
+        break;
+        case BTAV_CONNECTION_STATE_CONNECTING:
+            pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_CONNECTING_CB;
+        break;
+        case BTAV_CONNECTION_STATE_CONNECTED:
+            pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_CONNECTED_CB;
+        break;
+        case BTAV_CONNECTION_STATE_DISCONNECTING:
+            pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_DISCONNECTING_CB;
+        break;
+    }
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void bta2dp_audio_state_callback(btav_audio_state_t state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG_A2DP " Audio State CB");
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->a2dpSourceEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    switch( state ) {
+        case BTAV_AUDIO_STATE_REMOTE_SUSPEND:
+            pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_AUDIO_SUSPENDED;
+            a2dp_playstatus = A2DP_SOURCE_AUDIO_SUSPENDED;
+        break;
+        case BTAV_AUDIO_STATE_STOPPED:
+            pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_AUDIO_STOPPED;
+            a2dp_playstatus = A2DP_SOURCE_AUDIO_STOPPED;
+        break;
+        case BTAV_AUDIO_STATE_STARTED:
+            pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_AUDIO_STARTED;
+            a2dp_playstatus = A2DP_SOURCE_AUDIO_STARTED;
+        break;
+    }
+    ALOGD(LOGTAG_A2DP " Audio State = %d",a2dp_playstatus);
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void bta2dp_connection_priority_vendor_callback(bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->a2dpSourceEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_CONNECTION_PRIORITY_REQ;
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void bta2dp_multicast_state_vendor_callback(int state) {
+    ALOGD(LOGTAG_A2DP " Multicast State CB");
+}
+
+static void bta2dp_delay_report_vendor_callback(bt_bdaddr_t *bd_addr, uint16_t report_delay) {
+    char str[18];
+    bdaddr_to_string(bd_addr,str, 18);
+    ALOGD(LOGTAG_A2DP "Received delay report! [%s] the delay is [%d]", str, report_delay);
+    fprintf(stdout, "Received delay report! the delay is %d ms\n", report_delay);
+}
+static btav_callbacks_t sBluetoothA2dpSourceCallbacks = {
+    sizeof(sBluetoothA2dpSourceCallbacks),
+    bta2dp_connection_state_callback,
+    bta2dp_audio_state_callback,
+    NULL,
+};
+
+static btav_vendor_callbacks_t sBluetoothA2dpSourceVendorCallbacks = {
+    sizeof(sBluetoothA2dpSourceVendorCallbacks),
+    bta2dp_connection_priority_vendor_callback,
+    bta2dp_multicast_state_vendor_callback,
+    NULL,
+    NULL,
+    bta2dp_delay_report_vendor_callback,
+};
+
+static void btavrc_target_passthrough_cmd_vendor_callback(int id, int key_state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_passthrough_cmd_callback id = %d key_state = %d", id, key_state);
+    if (key_state == KEY_PRESSED) {
+        BtEvent *event = new BtEvent;
+        event->avrcpTargetEvent.event_id = A2DP_SOURCE_AUDIO_CMD_REQ;
+        /*As there is no player impl available at this point hence STOP/PAUSE has got same functionality*/
+        if(id == CMD_ID_PAUSE)
+            id = CMD_ID_STOP;
+        event->avrcpTargetEvent.key_id = id;
+        PostMessage (THREAD_ID_A2DP_SOURCE, event);
+    }
+}
+
+static void btavrc_target_setaddrplayer_cmd_vendor_callback(uint32_t player_id, bt_bdaddr_t *bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrc_target_setaddrplayer_cmd_vendor_callback ");
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_SET_ADDR_PLAYER_CB;
+    pEvent->avrcpTargetEvent.arg1 = (uint16_t)player_id;
+    memcpy(&pEvent->avrcpTargetEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    PostMessage (THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void btavrc_target_getfolderitems_cmd_vendor_callback(btrc_vendor_browse_folderitem_t id,
+                  btrc_vendor_getfolderitem_t *param, bt_bdaddr_t *bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrc_target_getfolderitems_cmd_vendor_callback ");
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_GET_FOLDER_ITEMS_CB;
+
+    FolderListEntries* folderItem = (FolderListEntries*)osi_malloc(sizeof(FolderListEntries));
+    memcpy(&folderItem->p_attr, &param->attrs, sizeof(param->attrs));
+    folderItem->mStart = param->start_item;
+    folderItem->mEnd = param->end_item;
+    folderItem->mSize = param->size;
+    folderItem->mNumAttr = param->attr_count;
+
+    pEvent->avrcpTargetEvent.buf_size = sizeof(folderItem);
+    pEvent->avrcpTargetEvent.buf_ptr = (uint8_t*)osi_malloc(pEvent->avrcpTargetEvent.buf_size);
+    memcpy(pEvent->avrcpTargetEvent.buf_ptr, &folderItem, pEvent->avrcpTargetEvent.buf_size);
+    pEvent->avrcpTargetEvent.arg1 = (uint16_t)id;
+    memcpy(&pEvent->avrcpTargetEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    PostMessage (THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void btavrc_target_connection_state_vendor_callback(bool state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_connection_state_callback state = %d", state);
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->avrcpTargetEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    if (state == true)
+        pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_CONNECTED_CB;
+    else
+        pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_DISCONNECTED_CB;
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void btavrcp_target_rcfeatures_callback( bt_bdaddr_t* bd_addr, btrc_remote_features_t features) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_rcfeatures_callback features = %d", features);
+    if ((features & BTRC_FEAT_ABSOLUTE_VOLUME) != 0) {
+        ALOGD(LOGTAG_AVRCP " Abs vol supported for dev ");
+        pA2dpSource->mAbsVolRemoteSupported = true;
+    } else {
+        ALOGD(LOGTAG_AVRCP " Abs vol NOT supported for dev ");
+    }
+    pA2dpSource->mVolCmdSetInProgress = false;
+    pA2dpSource->mVolCmdAdjustInProgress = false;
+    pA2dpSource->mInitialRemoteVolume = -1;
+    pA2dpSource->mLastRemoteVolume = -1;
+    pA2dpSource->mRemoteVolume = -1;
+    pA2dpSource->mLastLocalVolume = -1;
+    pA2dpSource->mLocalVolume = -1;
+}
+
+static void btavrcp_target_getelemattr_vendor_callback(uint8_t num_attr,
+        btrc_vendor_media_attr_t *p_attrs, bt_bdaddr_t *bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_getelemattr_vendor_callback ");
+    int i;
+    for (i = 0; i < num_attr; ++i) {
+        ALOGD(LOGTAG_AVRCP " btavrcp_target_getelemattr_callback features = %d", p_attrs[i]);
+    }
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_GET_ELE_ATTR;
+
+    ItemAttr* itemAttr = (ItemAttr*)osi_malloc(sizeof(ItemAttr));
+    itemAttr->p_attr = (btrc_media_attr_t*)osi_malloc(num_attr * sizeof(btrc_media_attr_t));
+    memcpy(itemAttr->p_attr, p_attrs, num_attr * sizeof(btrc_media_attr_t));
+    itemAttr->mUid = 0;
+    itemAttr->mSize = 0;
+
+    pEvent->avrcpTargetEvent.buf_size = sizeof(ItemAttr);
+    pEvent->avrcpTargetEvent.buf_ptr = (uint8_t*)osi_malloc(pEvent->avrcpTargetEvent.buf_size);
+    memcpy(pEvent->avrcpTargetEvent.buf_ptr, itemAttr, pEvent->avrcpTargetEvent.buf_size);
+    ItemAttr* pAttr = (ItemAttr*)pEvent->avrcpTargetEvent.buf_ptr;
+    pAttr->p_attr = (btrc_media_attr_t*)osi_malloc(num_attr * sizeof(btrc_media_attr_t));
+    memcpy(pAttr->p_attr, itemAttr->p_attr, num_attr * sizeof(btrc_media_attr_t));
+    pEvent->avrcpTargetEvent.arg1 = (uint16_t)num_attr;
+    memcpy(&pEvent->avrcpTargetEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+    osi_free(itemAttr->p_attr);
+    osi_free(itemAttr);
+}
+
+static void btavrcp_target_getplaystatus_vendor_callback(bt_bdaddr_t *bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_getplaystatus_vendor_callback ");
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_GET_PLAY_STATUS;
+    memcpy(&pEvent->avrcpTargetEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void btavrcp_target_regnoti_vendor_callback(btrc_vendor_event_id_t event_id, uint32_t param,
+        bt_bdaddr_t *bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_regnoti_vendor_callback ");
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_REG_NOTI;
+    memcpy(&pEvent->avrcpTargetEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->avrcpTargetEvent.arg1 = (uint16_t)event_id;
+    pEvent->avrcpTargetEvent.arg2 = param;
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void btavrcp_target_volchanged_vendor_callback(uint8_t volume, uint8_t ctype,
+        bt_bdaddr_t *bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_volchanged_vendor_callback ");
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_VOLUME_CHANGED;
+    memcpy(&pEvent->avrcpTargetEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->avrcpTargetEvent.arg3 = volume;
+    pEvent->avrcpTargetEvent.arg4 = (AvrcRspType)ctype;
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static btrc_callbacks_t sBluetoothAvrcpTargetCallbacks = {
+   sizeof(sBluetoothAvrcpTargetCallbacks),
+   btavrcp_target_rcfeatures_callback,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+};
+
+static btrc_vendor_callbacks_t sBluetoothAvrcpTargetVendorCallbacks = {
+   sizeof(sBluetoothAvrcpTargetVendorCallbacks),
+   btavrcp_target_getplaystatus_vendor_callback,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   btavrcp_target_getelemattr_vendor_callback,
+   btavrcp_target_regnoti_vendor_callback,
+   btavrcp_target_volchanged_vendor_callback,
+   btavrc_target_passthrough_cmd_vendor_callback,
+   btavrc_target_getfolderitems_cmd_vendor_callback,
+   btavrc_target_setaddrplayer_cmd_vendor_callback,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   btavrc_target_connection_state_vendor_callback,
+   NULL,
+};
+
+const char* getString(int mAttrType) {
+    const char* new_str = "";
+    const char* title1 = "Here, on the other hand, I've gone crazy \
+        and really let the literal span several lines, \
+        without bothering with quoting each line's \
+        and really let the literal span several lines";
+    const char* artistName1 = "Here, on the other hand, I've gone crazy \
+        and really let the literal span several lines, \
+        without bothering with quoting each line's \
+        and really let the literal span several lines";
+    const char* title = "abc1";
+    const char* artistName = "abc2";
+    const char* albumName = "abc3";
+    const char* mediaNumber = "abc4";
+    const char* mediaTotalNumber = "abc5";
+    const char* genre = "abc6";
+    const char* playingTimeMs = "abc7";
+    const char* tracknum = "abc8";
+
+    switch (mAttrType) {
+        case ATTR_TRACK_NUM:
+            return tracknum;
+        case ATTR_TITLE:
+            if (use_bigger_metadata)
+                return title1;
+            else
+                return title;
+        case ATTR_ARTIST_NAME:
+            if (use_bigger_metadata)
+                return artistName1;
+            else
+                return artistName;
+        case ATTR_ALBUM_NAME:
+            return albumName;
+        case ATTR_MEDIA_NUMBER:
+            return mediaNumber;
+        case ATTR_MEDIA_TOTAL_NUMBER:
+            return mediaTotalNumber;
+        case ATTR_GENRE:
+            return genre;
+        case ATTR_PLAYING_TIME_MS:
+            return playingTimeMs;
+        default:
+            return new_str;
+    }
+}
+
+void set_abs_volume_timer_handler(void *context) {
+    ALOGD(LOGTAG_AVRCP " set_abs_volume_timer_handler ");
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_ABS_VOL_TIMEOUT;
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+void A2dp_Source::StartSetAbsVolTimer() {
+    if(abs_vol_timer) {
+        ALOGD(LOGTAG_AVRCP " Abs Vol Timer still running + ");
+        return;
+    }
+    alarm_set(set_abs_volume_timer, A2DP_SOURCE_SET_ABS_VOL_TIMER_DURATION,
+           set_abs_volume_timer_handler, NULL);
+    abs_vol_timer = true;
+}
+
+void A2dp_Source::StopSetAbsVolTimer() {
+    ALOGD(LOGTAG_AVRCP " StopSetAbsVolTimer ");
+    if((set_abs_volume_timer != NULL) && (abs_vol_timer)) {
+        alarm_cancel(set_abs_volume_timer);
+        ALOGD(LOGTAG_AVRCP " StopSetAbsVolTimer -1");
+        abs_vol_timer = false;
+    }
+}
+
+int convertToAudioStreamVolume(int volume) {
+    // Rescale volume to match AudioSystem's volume
+    return (int) round((double) volume*mAudioStreamMax/AVRCP_MAX_VOL);
+}
+
+int convertToAvrcpVolume(int volume) {
+    return (int) ceil((double) volume*AVRCP_MAX_VOL/mAudioStreamMax);
+}
+
+bool isAbsoluteVolumeSupported() {
+    ALOGD(LOGTAG_AVRCP " isAbsoluteVolumeSupported() %d ", pA2dpSource->mAbsVolRemoteSupported);
+    return pA2dpSource->mAbsVolRemoteSupported;
+}
+
+void A2dp_Source::HandleAvrcpEvents(BtEvent* pEvent) {
+    ALOGD(LOGTAG_AVRCP " HandleAvrcpEvents event = %s",
+            dump_message(pEvent->avrcpTargetEvent.event_id));
+    uint8_t absvol, avrcpVolume;
+    long TrackNumberRsp = -1L, pecentVolChanged;
+    char *folderItems, *playerEntry;
+    uint16_t num_attr, scope, set_addr_player_id = 0;
+    bool isSetVol, volAdj = false, player_found = false;
+    int i, pos = 0, song_len = 0, volIndex, start = 0, count = 0, countElementLength = 0;
+    int countTotalBytes = 0, countTemp = 0, checkLength = 0, folderItemLengths[32];
+    int availableMediaPlayers = 0, positionItemStart = 0;
+    AvrcRspType ctype;
+    AvrcKeyDir dir;
+    ItemAttr *item = NULL;
+    FolderListEntries *folderitem = NULL;
+    btrc_element_attr_val_t *pAttrs = NULL;
+    btrc_register_notification_t param;
+    btrc_vendor_folder_list_entries_t *p_param;
+
+    switch(pEvent->avrcpTargetEvent.event_id) {
+        case AVRCP_TARGET_USE_BIGGER_METADATA:
+            ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_USE_BIGGER_METADATA ");
+            use_bigger_metadata = true;
+            break;
+        case AVRCP_TARGET_SET_ADDR_PLAYER_CB:
+            set_addr_player_id = pEvent->avrcpTargetEvent.arg1;
+            if (pMediaPlayerList.size() > 0) {
+                list<MediaPlayerInfo>::iterator p = pMediaPlayerList.begin();
+                while (p != pMediaPlayerList.end()) {
+                    if (p->mPlayerId == set_addr_player_id)
+                    {
+                        player_found = true;
+                        ALOGD(LOGTAG_AVRCP " valid player found for set addr player ");
+                        break;
+                    }
+                    p++;
+                }
+            }
+            else {
+                ALOGE(LOGTAG_AVRCP "  No media players");
+            }
+
+            if (!player_found)
+            {
+                ALOGE(LOGTAG_AVRCP " Since not a valid player %d send error", set_addr_player_id);
+                sBtAvrcpTargetVendorInterface->set_addressed_player_response_vendor(
+                        (btrc_status_t)0x11, &pEvent->avrcpTargetEvent.bd_addr);
+                break;
+            }
+
+            ALOGD(LOGTAG_AVRCP " Send response for set addressed player %d", set_addr_player_id);
+            sBtAvrcpTargetVendorInterface->set_addressed_player_response_vendor((btrc_status_t)0x04,
+                    &pEvent->avrcpTargetEvent.bd_addr);
+
+            if (mCurrentAddrPlayerId == set_addr_player_id)
+            {
+                ALOGD(LOGTAG_AVRCP " Player already addresssed %d", set_addr_player_id);
+            }
+            else
+            {
+                mPreviousAddrPlayerId = mCurrentAddrPlayerId;
+                mCurrentAddrPlayerId = set_addr_player_id;
+                ALOGD(LOGTAG_AVRCP " mPreviousAddrPlayerId %d mCurrentAddrPlayerId = %d",
+                                     mPreviousAddrPlayerId, mCurrentAddrPlayerId);
+                if (mAddrPlayerChangedNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                    mAddrPlayerChangedNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+                    param.player_id = mCurrentAddrPlayerId;
+                    sBtAvrcpTargetInterface->register_notification_rsp(
+                            BTRC_EVT_ADDRESSED_PLAYER_CHANGED,
+                            mAddrPlayerChangedNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                    if (mPreviousAddrPlayerId != -1)
+                        resetAndSendPlayerStatusReject();
+                }
+            }
+            break;
+        case AVRCP_TARGET_GET_FOLDER_ITEMS_CB:
+            scope = pEvent->avrcpTargetEvent.arg1;
+            ALOGD(LOGTAG_AVRCP " Send response for get folder items for scope %d", scope);
+            if (pEvent->avrcpTargetEvent.buf_ptr == NULL) {
+                break;
+            }
+            folderitem = (FolderListEntries*)osi_malloc(sizeof(FolderListEntries));
+            memcpy(&folderitem, pEvent->avrcpTargetEvent.buf_ptr, pEvent->avrcpTargetEvent.buf_size);
+            ALOGD(LOGTAG_AVRCP "  %d %d %d %d", folderitem->mStart, folderitem->mEnd,
+                                                folderitem->mSize, folderitem->mNumAttr);
+            start = folderitem->mStart;
+            folderItems = (char*) osi_malloc(folderitem->mSize * sizeof(char));
+            if (scope == 0x00) {
+                if (pMediaPlayerList.size() > 0) {
+                    list<MediaPlayerInfo>::iterator p = pMediaPlayerList.begin();
+                    while (p != pMediaPlayerList.end()) {
+                        if (start == 0) {
+                            playerEntry = (char*)osi_malloc(p->RetrievePlayerEntryLength()*
+                                                               sizeof(char));
+                            playerEntry = p->RetrievePlayerItemEntry();
+                            int length = p->RetrievePlayerEntryLength();
+                            folderItemLengths[availableMediaPlayers ++] = length;
+                            for (count = 0; count < length; count ++) {
+                                folderItems[positionItemStart + count] = playerEntry[count];
+                            }
+                            positionItemStart += length; // move start to next item star
+                            osi_free(playerEntry);
+                        }
+                        else if (start > 0) {
+                            --start;
+                        }
+                        p++;
+                    }
+                }
+                else {
+                    ALOGE(LOGTAG_AVRCP "  No media players");
+                }
+            }
+            else {
+                ALOGE(LOGTAG_AVRCP " Incorrect scope");
+            }
+            p_param = (btrc_vendor_folder_list_entries_t*)osi_malloc(
+                                    sizeof(btrc_vendor_folder_list_entries_t));
+            p_param->status = 0x04;
+            p_param->uid_counter = 0;
+            p_param->item_count = availableMediaPlayers;
+            p_param->p_item_list =
+               (btrc_vendor_folder_list_item_t*) osi_malloc (p_param->item_count*
+                                      sizeof(btrc_vendor_folder_list_item_t));
+            for (count = 0; count < p_param->item_count; count++) {
+                p_param->p_item_list[count].item_type =
+                    folderItems[countTotalBytes]; countTotalBytes++;
+                p_param->p_item_list[count].u.player.player_id =
+                    (uint16_t)(folderItems[countTotalBytes] & 0x00ff); countTotalBytes++;
+                p_param->p_item_list[count].u.player.player_id +=
+                    (uint16_t)((folderItems[countTotalBytes] << 8) & 0xff00); countTotalBytes++;
+                p_param->p_item_list[count].u.player.major_type =
+                    folderItems[countTotalBytes]; countTotalBytes++;
+                p_param->p_item_list[count].u.player.sub_type =
+                    (uint32_t)(folderItems[countTotalBytes] & 0x000000ff); countTotalBytes++;
+                p_param->p_item_list[count].u.player.sub_type +=
+                    (uint32_t)((folderItems[countTotalBytes] << 8) & 0x0000ff00); countTotalBytes++;
+                p_param->p_item_list[count].u.player.sub_type +=
+                    (uint32_t)((folderItems[countTotalBytes] << 16) & 0x00ff0000); countTotalBytes++;
+                p_param->p_item_list[count].u.player.sub_type +=
+                    (uint32_t)((folderItems[countTotalBytes] << 24) & 0xff000000); countTotalBytes++;
+                p_param->p_item_list[count].u.player.play_status =
+                    folderItems[countTotalBytes]; countTotalBytes++;
+                for (countTemp = 0; countTemp < 16; countTemp ++) {
+                    p_param->p_item_list[count].u.player.features[countTemp] =
+                    folderItems[countTotalBytes];
+                    ALOGD(LOGTAG_A2DP "player feat sending in resp %d",
+                        p_param->p_item_list[count].u.player.features[countTemp]);
+                    countTotalBytes++;
+                }
+                p_param->p_item_list[count].u.player.name.charset_id =
+                    (uint16_t)(folderItems[countTotalBytes] & 0x00ff); countTotalBytes++;
+                p_param->p_item_list[count].u.player.name.charset_id +=
+                    (uint16_t)((folderItems[countTotalBytes] << 8) & 0xff00); countTotalBytes++;
+                p_param->p_item_list[count].u.player.name.str_len =
+                    (uint16_t)(folderItems[countTotalBytes] & 0x00ff); countTotalBytes++;
+                p_param->p_item_list[count].u.player.name.str_len +=
+                    (uint16_t)((folderItems[countTotalBytes] << 8) & 0xff00); countTotalBytes++;
+                p_param->p_item_list[count].u.player.name.p_str =
+                    new uint8_t[p_param->p_item_list[count].u.player.name.str_len];
+                for (countTemp = 0; countTemp < p_param->p_item_list[count].u.player.name.str_len;
+                              countTemp ++) {
+                    p_param->p_item_list[count].u.player.name.p_str[countTemp] =
+                        folderItems[countTotalBytes]; countTotalBytes++;
+                }
+                /*To check if byte feeding went well*/
+                checkLength += folderItemLengths[count];
+                ALOGD(LOGTAG_AVRCP "checkLength = %u countTotalBytes = %u", checkLength,
+                        countTotalBytes);
+                if (checkLength != countTotalBytes) {
+                    ALOGE(LOGTAG_AVRCP "Error Populating Intermediate Folder Entry");
+                }
+            }
+            sBtAvrcpTargetVendorInterface->get_folder_items_response_vendor(p_param,
+                                           &pEvent->avrcpTargetEvent.bd_addr);
+            osi_free(pEvent->avrcpTargetEvent.buf_ptr);
+            osi_free(folderitem);
+            osi_free(folderItems);
+            osi_free(p_param->p_item_list);
+            osi_free(p_param);
+            break;
+        case AVRCP_TARGET_ABS_VOL_TIMEOUT:
+            ALOGD(LOGTAG_AVRCP " MESSAGE_ABS_VOL_TIMEOUT: Volume change cmd timed out");
+            mVolCmdSetInProgress = false;
+            mVolCmdAdjustInProgress = false;
+            break;
+        case AVRCP_TARGET_SEND_VOL_UP_DOWN:
+            dir = (AvrcKeyDir)pEvent->avrcpTargetEvent.arg3;
+            ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_SEND_VOL_UP_DOWN, dir = %d ", dir);
+            if (dir == AVRC_KEY_UP)
+            {
+                sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice, CMD_ID_VOL_UP, 0);
+                sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice, CMD_ID_VOL_UP, 1);
+            }
+            else if (dir == AVRC_KEY_DOWN)
+            {
+                sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice,
+                                                                        CMD_ID_VOL_DOWN, 0);
+                sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice,
+                                                                        CMD_ID_VOL_DOWN, 1);
+            }
+            else
+            {
+                ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_SEND_VOL_UP_DOWN: Invalid value");
+            }
+            break;
+        case AVRCP_TARGET_VOLUME_CHANGED:
+            if (!isAbsoluteVolumeSupported()) {
+                ALOGD(LOGTAG_AVRCP "ignore AVRCP_TARGET_VOLUME_CHANGED");
+                break;
+            }
+            absvol = pEvent->avrcpTargetEvent.arg3 & 0x7f; // discard MSB as it is RFD
+            ctype = (AvrcRspType)pEvent->avrcpTargetEvent.arg4;
+            ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_VOLUME_CHANGED, vol = %d absvol = %d ctype = %x",
+                    pEvent->avrcpTargetEvent.arg3, absvol, ctype);
+
+            if (ctype == AVRC_RSP_ACCEPT || ctype == AVRC_RSP_REJ) {
+                if ((mVolCmdSetInProgress == false) && (mVolCmdAdjustInProgress == false)) {
+                    ALOGD(LOGTAG_AVRCP "Unsolicited response, ignored");
+                    break;
+                }
+                pA2dpSource->StopSetAbsVolTimer();
+                volAdj = mVolCmdAdjustInProgress;
+                mVolCmdSetInProgress = false;
+                mVolCmdAdjustInProgress = false;
+            }
+
+            volIndex = convertToAudioStreamVolume(absvol);
+            ALOGD(LOGTAG_AVRCP " Volume Index = %d", volIndex);
+
+            if (mInitialRemoteVolume == -1) {
+                mInitialRemoteVolume = absvol;
+            }
+
+            if (mLocalVolume != volIndex && (ctype == AVRC_RSP_ACCEPT ||
+                    ctype == AVRC_RSP_CHANGED || ctype == AVRC_RSP_INTERIM)) {
+                /* If the volume has successfully changed */
+                mLocalVolume = volIndex;
+                if (mLastLocalVolume != -1 && ctype == AVRC_RSP_ACCEPT) {
+                    if (mLastLocalVolume != volIndex) {
+                        /* remote volume changed more than requested due to
+                                      * local and remote has different volume steps */
+                        ALOGD(LOGTAG_AVRCP "Remote returned vol does not match desired volume %d",
+                        mLastLocalVolume, " vs %d", volIndex);
+                        mLastLocalVolume = mLocalVolume;
+                    }
+                }
+
+                // remember the remote volume value, as it's the one supported by remote
+                if (volAdj) {
+                    ALOGD(LOGTAG_AVRCP "TODO : remember the remote volume value,"
+                                             "as it's the one supported by remote");
+                }
+
+                mRemoteVolume = absvol;
+                pecentVolChanged = ((long)absvol * 100) / 0x7f;
+                ALOGD(LOGTAG_AVRCP " percent volume changed: %d", pecentVolChanged, "%");
+            }
+            else if (ctype == AVRC_RSP_REJ) {
+                ALOGD(LOGTAG_AVRCP "setAbsoluteVolume call rejected");
+            }
+            break;
+        case AVRCP_TARGET_SET_ABS_VOL:
+            ALOGD(LOGTAG_AVRCP "AVRCP_TARGET_SET_ABS_VOL, vol step = %d",
+                                               pEvent->avrcpTargetEvent.arg3);
+            if (!isAbsoluteVolumeSupported()) {
+                ALOGD(LOGTAG_AVRCP "ignore MESSAGE_SET_ABSOLUTE_VOLUME");
+                break;
+            }
+            if (pEvent->avrcpTargetEvent.arg3 < 0 ||
+                           pEvent->avrcpTargetEvent.arg3 > mAudioStreamMax) {
+                ALOGD(LOGTAG_AVRCP "wrong vol step input");
+                break;
+            }
+            if (mVolCmdSetInProgress || mVolCmdAdjustInProgress){
+                ALOGD(LOGTAG_AVRCP "There is already a volume command in progress.");
+                break;
+            }
+            if (mInitialRemoteVolume == -1) {
+                ALOGD(LOGTAG_AVRCP "remote never tell us initial volume, black list it.");
+                break;
+            }
+            avrcpVolume = std::min(AVRCP_MAX_VOL,
+                          std::max(0, convertToAvrcpVolume(pEvent->avrcpTargetEvent.arg3)));
+            isSetVol = sBtAvrcpTargetInterface->set_volume(avrcpVolume,
+                                                &pEvent->avrcpTargetEvent.bd_addr);
+            if (isSetVol == BT_STATUS_SUCCESS) {
+                pA2dpSource->StartSetAbsVolTimer();
+                mVolCmdSetInProgress = true;
+                mLastRemoteVolume = avrcpVolume;
+                mLastLocalVolume = pEvent->avrcpTargetEvent.arg3;
+            } else {
+                ALOGE(LOGTAG_AVRCP "setVolumeNative failed");
+            }
+            break;
+        case AVRCP_TARGET_TRACK_CHANGED:
+            ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_TRACK_CHANGED");
+            if (mTrackChangeNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                mCurrentTrackID = TRACK_IS_SELECTED;
+                TrackNumberRsp = mCurrentTrackID;
+                mTrackChangeNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+                ALOGD(LOGTAG_AVRCP " TrackNumberRsp = %l", TrackNumberRsp);
+                for (int i = 0; i < 8; ++i) {
+                    param.track[i] = (uint8_t) (TrackNumberRsp >> (56 - 8 * i));
+                }
+                sBtAvrcpTargetInterface->register_notification_rsp(BTRC_EVT_TRACK_CHANGE,
+                        mTrackChangeNotiType,
+                        &param, &pEvent->avrcpTargetEvent.bd_addr);
+            }
+            break;
+        case AVRCP_TARGET_ADDR_PLAYER_CHANGED:
+            ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_ADDR_PLAYER_CHANGED %d",
+                                         pEvent->avrcpTargetEvent.arg3);
+            if (mCurrentAddrPlayerId != pEvent->avrcpTargetEvent.arg3) {
+                mPreviousAddrPlayerId = mCurrentAddrPlayerId;
+                mCurrentAddrPlayerId = pEvent->avrcpTargetEvent.arg3;
+                ALOGD(LOGTAG_AVRCP " mPreviousAddrPlayerId = %d mCurrentAddrPlayerId = %d",
+                                     mPreviousAddrPlayerId, mCurrentAddrPlayerId);
+                if (mAddrPlayerChangedNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                    mAddrPlayerChangedNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+                    param.player_id = mCurrentAddrPlayerId;
+                    sBtAvrcpTargetInterface->register_notification_rsp(
+                            BTRC_EVT_ADDRESSED_PLAYER_CHANGED,
+                            mAddrPlayerChangedNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                    if (mPreviousAddrPlayerId != -1)
+                        resetAndSendPlayerStatusReject();
+                }
+            }
+            break;
+        case AVRCP_TARGET_AVAIL_PLAYER_CHANGED:
+            ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_AVAIL_PLAYER_CHANGED");
+            if (mAvailPlayerChangedNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                mAvailPlayerChangedNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+                sBtAvrcpTargetInterface->register_notification_rsp(
+                        BTRC_EVT_AVAILABLE_PLAYERS_CHANGED,
+                        mAvailPlayerChangedNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+            }
+            break;
+        case AVRCP_TARGET_GET_ELE_ATTR:
+            num_attr = pEvent->avrcpTargetEvent.arg1;
+            if (pEvent->avrcpTargetEvent.buf_ptr == NULL) {
+                break;
+            }
+            ALOGD(LOGTAG_AVRCP " Send response for Get element attribute, num_attr %d", num_attr);
+            item = (ItemAttr*)osi_malloc(sizeof(ItemAttr));
+            memcpy(item, pEvent->avrcpTargetEvent.buf_ptr, pEvent->avrcpTargetEvent.buf_size);
+            ALOGD(LOGTAG_AVRCP " Uid %d Size %d", item->mUid, item->mSize);
+            for (i = 0; i < num_attr; ++i) {
+                ALOGD(LOGTAG_AVRCP " attr[%d] %d", i, item->p_attr[i]);
+            }
+            pAttrs = (btrc_element_attr_val_t*)osi_malloc(num_attr*sizeof(btrc_element_attr_val_t));
+            for (int i = 0; i < num_attr; ++i) {
+                pAttrs[i].attr_id = item->p_attr[i];
+                memcpy(pAttrs[i].text, getString(pAttrs[i].attr_id),
+                                strlen(getString(pAttrs[i].attr_id))+1);
+                ALOGD(LOGTAG_AVRCP " %d %s", pAttrs[i].attr_id, pAttrs[i].text);
+            }
+            sBtAvrcpTargetInterface->get_element_attr_rsp((uint8_t)num_attr, pAttrs,
+                                                 &pEvent->avrcpTargetEvent.bd_addr);
+            osi_free(pEvent->avrcpTargetEvent.buf_ptr);
+            osi_free(item->p_attr);
+            osi_free(item);
+            osi_free(pAttrs);
+            use_bigger_metadata = false;
+            break;
+        case AVRCP_TARGET_GET_PLAY_STATUS:
+            ALOGD(LOGTAG_AVRCP " Send response for Get play status = %d",playStatus);
+            pos = 10L;
+            song_len = 100L;
+            if(playStatus == BTRC_PLAYSTATE_ERROR)
+            {
+                playStatus = BTRC_PLAYSTATE_STOPPED;
+                ALOGD(LOGTAG_AVRCP " set  play status as stopped = %d",playStatus);
+            }
+            sBtAvrcpTargetInterface->get_play_status_rsp(playStatus,
+                    song_len, pos, &pEvent->avrcpTargetEvent.bd_addr);
+            break;
+        case AVRCP_TARGET_REG_NOTI:
+            switch(pEvent->avrcpTargetEvent.arg1) {
+                case BTRC_EVT_PLAY_STATUS_CHANGED :
+                    ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_REG_NOTI: BTRC_EVT_PLAY_STATUS_CHANGED %d",playStatus);
+                    mPlayStatusNotiType = BTRC_NOTIFICATION_TYPE_INTERIM;
+                    param.play_status = playStatus;
+                    sBtAvrcpTargetInterface->register_notification_rsp(BTRC_EVT_PLAY_STATUS_CHANGED,
+                            mPlayStatusNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                    break;
+                case BTRC_EVT_TRACK_CHANGE:
+                    ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_REG_NOTI: BTRC_EVT_TRACK_CHANGE");
+                    mTrackChangeNotiType = BTRC_NOTIFICATION_TYPE_INTERIM;
+                    TrackNumberRsp = mCurrentTrackID;
+                    ALOGD(LOGTAG_AVRCP " TrackNumberRsp = %l", TrackNumberRsp);
+                    for (int i = 0; i < 8; ++i) {
+                        param.track[i] = (uint8_t) (TrackNumberRsp >> (56 - 8 * i));
+                    }
+                    sBtAvrcpTargetInterface->register_notification_rsp(BTRC_EVT_TRACK_CHANGE,
+                            mTrackChangeNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                    break;
+                case BTRC_EVT_ADDRESSED_PLAYER_CHANGED:
+                    ALOGD(LOGTAG_AVRCP "AVRCP_TARGET_REG_NOTI: BTRC_EVT_ADDRESSED_PLAYER_CHANGED ");
+                    mAddrPlayerChangedNotiType = BTRC_NOTIFICATION_TYPE_INTERIM;
+                    param.player_id = (uint16_t)mCurrentAddrPlayerId;
+                    sBtAvrcpTargetInterface->register_notification_rsp(
+                            BTRC_EVT_ADDRESSED_PLAYER_CHANGED,
+                            mAddrPlayerChangedNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                    break;
+                case BTRC_EVT_AVAILABLE_PLAYERS_CHANGED:
+                    ALOGD(LOGTAG_AVRCP "AVRCP_TARGET_REG_NOTI: BTRC_EVT_AVAILABLE_PLAYERS_CHANGED ");
+                    mAvailPlayerChangedNotiType = BTRC_NOTIFICATION_TYPE_INTERIM;
+                    sBtAvrcpTargetInterface->register_notification_rsp(
+                            BTRC_EVT_AVAILABLE_PLAYERS_CHANGED,
+                            mAvailPlayerChangedNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                    break;
+                default:
+                    ALOGE(LOGTAG_AVRCP "AVRCP_TARGET_REG_NOTI: unhandled event ");
+                    break;
+            }
+            break;
+        case AVRCP_TARGET_CONNECTED_CB:
+            mAvrcpConnected = true;
+            memcpy(&mConnectedAvrcpDevice, &pEvent->avrcpTargetEvent.bd_addr, sizeof(bt_bdaddr_t));
+            break;
+        case AVRCP_TARGET_DISCONNECTED_CB:
+            mAvrcpConnected = false;
+            memset(&mConnectedAvrcpDevice, 0, sizeof(bt_bdaddr_t));
+            break;
+        case A2DP_SOURCE_AUDIO_CMD_REQ:
+            uint8_t key_id = pEvent->avrcpTargetEvent.key_id;
+            if (!mAvrcpConnected || (memcmp(&mConnectedAvrcpDevice, &mConnectedDevice,
+                           sizeof(bt_bdaddr_t)) != 0)) {
+                ALOGD(LOGTAG_AVRCP " No Active connection. Bail out!! ");
+                break;
+            }
+            switch(key_id) {
+                case CMD_ID_PLAY:
+                    if (media_playing)
+                        BtA2dpResumeStreaming();
+                    else
+                        BtA2dpStartStreaming();
+                    if (playStatus != BTRC_PLAYSTATE_PLAYING)
+                    {
+                        playStatus = BTRC_PLAYSTATE_PLAYING;
+                        if (mPlayStatusNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                            param.play_status = playStatus;
+                            mPlayStatusNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+                            sBtAvrcpTargetInterface->register_notification_rsp(
+                                    BTRC_EVT_PLAY_STATUS_CHANGED,
+                                    mPlayStatusNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                        }
+                    }
+                    if (mTrackChangeNotiType == BTRC_NOTIFICATION_TYPE_INTERIM)
+                    {
+                        mCurrentTrackID = TRACK_IS_SELECTED;
+                        TrackNumberRsp = mCurrentTrackID;
+                        mTrackChangeNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+                        ALOGD(LOGTAG_AVRCP " TrackNumberRsp = %l", TrackNumberRsp);
+                        for (int i = 0; i < 8; ++i) {
+                            param.track[i] = (uint8_t) (TrackNumberRsp >> (56 - 8 * i));
+                        }
+                        sBtAvrcpTargetInterface->register_notification_rsp(
+                                BTRC_EVT_TRACK_CHANGE,
+                                mTrackChangeNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                    }
+                    break;
+                case CMD_ID_PAUSE:
+                    /*Pause key id is mapped to A2dp suspend*/
+                    BtA2dpSuspendStreaming();
+                    if (playStatus != BTRC_PLAYSTATE_PAUSED)
+                    {
+                        playStatus = BTRC_PLAYSTATE_PAUSED;
+                        if (mPlayStatusNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                            param.play_status = playStatus;
+                            mPlayStatusNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+                            sBtAvrcpTargetInterface->register_notification_rsp(
+                                    BTRC_EVT_PLAY_STATUS_CHANGED,
+                                    mPlayStatusNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                        }
+                    }
+                    break;
+                case CMD_ID_STOP:
+                    /*Pause and Stop passthrough commands are handled here*/
+                    media_playing = false;
+                    BtA2dpStopStreaming();
+                    if (playStatus != BTRC_PLAYSTATE_STOPPED)
+                    {
+                        playStatus = BTRC_PLAYSTATE_STOPPED;
+                        if (mPlayStatusNotiType == BTRC_NOTIFICATION_TYPE_INTERIM) {
+                            param.play_status = playStatus;
+                            mPlayStatusNotiType = BTRC_NOTIFICATION_TYPE_CHANGED;
+                            sBtAvrcpTargetInterface->register_notification_rsp(
+                                    BTRC_EVT_PLAY_STATUS_CHANGED,
+                                    mPlayStatusNotiType, &param, &pEvent->avrcpTargetEvent.bd_addr);
+                        }
+                    }
+                    break;
+                default:
+                   ALOGE(LOGTAG_AVRCP " Command not supported ");
+                   break;
+            }
+            break;
+    }
+}
+
+void A2dp_Source::HandleEnableSource(void) {
+    BtEvent *pEvent = new BtEvent;
+    char value[PROPERTY_VALUE_MAX] = {'\0'};
+    if (bluetooth_interface != NULL)
+    {
+        sBtA2dpSourceInterface = (btav_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_ADVANCED_AUDIO_ID);
+        sBtA2dpSourceVendorInterface = (btav_vendor_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_ADVANCED_AUDIO_VENDOR_ID);
+        if (sBtA2dpSourceInterface == NULL)
+        {
+             pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+             pEvent->profile_start_event.profile_id = PROFILE_ID_A2DP_SOURCE;
+             pEvent->profile_start_event.status = false;
+             PostMessage(THREAD_ID_GAP, pEvent);
+             return;
+        }
+        enable_delay_report = config_get_bool (config, CONFIG_DEFAULT_SECTION, "BtA2dpDelayReportEnable", false);
+        ALOGD(LOGTAG_A2DP " ~~ Try to get config , enable_delay_report %d", enable_delay_report);
+        //TODO: check and update
+#ifdef USE_LIBHW_AOSP
+        sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks);
+#else
+        sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks, 1, 0);
+#endif
+        property_get("persist.bt.a2dp_offload_cap", value, "false");
+        ALOGD(LOGTAG_A2DP "offload_cap:%s", value);
+        if (strcmp(value, "false") == 0)
+        {
+            if(enable_delay_report)
+                sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, A2DP_SRC_ENABLE_DELAY_REPORTING, NULL);
+            else
+                sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, 0, NULL);
+        }
+        else
+        {
+            if(enable_delay_report)
+                sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, A2DP_SRC_ENABLE_DELAY_REPORTING, value);
+            else
+                sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, 0, value);
+        }
+        //sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, NULL);
+        pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+        pEvent->profile_start_event.profile_id = PROFILE_ID_A2DP_SOURCE;
+        pEvent->profile_start_event.status = true;
+        // AVRCP TG Initialization
+        sBtAvrcpTargetInterface = (btrc_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_AV_RC_ID);
+        if (sBtAvrcpTargetInterface != NULL) {
+        //TODO: check and update
+#ifdef USE_LIBHW_AOSP
+            sBtAvrcpTargetInterface->init(&sBluetoothAvrcpTargetCallbacks);
+#else
+            sBtAvrcpTargetInterface->init(&sBluetoothAvrcpTargetCallbacks, 1);
+#endif
+        }
+        // AVRCP TG vendor Initialization
+        sBtAvrcpTargetVendorInterface = (btrc_vendor_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_AV_RC_VENDOR_ID);
+        if (sBtAvrcpTargetVendorInterface != NULL) {
+            ALOGD(LOGTAG_A2DP "init_vendor for TG");
+            sBtAvrcpTargetVendorInterface->init_vendor(&sBluetoothAvrcpTargetVendorCallbacks, 1);
+        }
+        change_state(STATE_A2DP_SOURCE_DISCONNECTED);
+        PostMessage(THREAD_ID_GAP, pEvent);
+        ALOGD(LOGTAG_A2DP "Calling BtA2dpLoadA2dpHal");
+        BtA2dpLoadA2dpHal();
+        media_playing = false;
+        playStatus = BTRC_PLAYSTATE_ERROR;
+        mCurrentTrackID = NO_TRACK_SELECTED;
+        registerMediaPlayers();
+    }
+    a2dp_sink_relay_data_list = list_new(NULL);
+}
+
+void A2dp_Source::HandleDisableSource(void) {
+   change_state(STATE_A2DP_SOURCE_NOT_STARTED);
+   BtA2dpUnloadA2dpHal();
+   if(sBtA2dpSourceInterface != NULL) {
+       sBtA2dpSourceInterface->cleanup();
+       sBtA2dpSourceInterface = NULL;
+   }
+   if (sBtAvrcpTargetInterface != NULL) {
+       sBtAvrcpTargetInterface->cleanup();
+       sBtAvrcpTargetInterface = NULL;
+   }
+   BtEvent *pEvent = new BtEvent;
+   pEvent->profile_stop_event.event_id = PROFILE_EVENT_STOP_DONE;
+   pEvent->profile_stop_event.profile_id = PROFILE_ID_A2DP_SOURCE;
+   pEvent->profile_stop_event.status = true;
+   PostMessage(THREAD_ID_GAP, pEvent);
+   media_playing = false;
+   playStatus = BTRC_PLAYSTATE_ERROR;
+   mCurrentTrackID = NO_TRACK_SELECTED;
+   if(a2dp_sink_relay_data_list != NULL)
+   list_free(a2dp_sink_relay_data_list);
+}
+
+void A2dp_Source::ProcessEvent(BtEvent* pEvent) {
+    switch(mSourceState) {
+        case STATE_A2DP_SOURCE_DISCONNECTED:
+            state_disconnected_handler(pEvent);
+            break;
+        case STATE_A2DP_SOURCE_PENDING:
+            state_pending_handler(pEvent);
+            break;
+        case STATE_A2DP_SOURCE_CONNECTED:
+            state_connected_handler(pEvent);
+            break;
+        case STATE_A2DP_SOURCE_NOT_STARTED:
+            fprintf(stdout, "Ignore!! Make sure BT is turned on!!\n");
+            ALOGE(LOGTAG_A2DP " STATE UNINITIALIZED, return");
+            break;
+    }
+}
+
+char* A2dp_Source::dump_message(BluetoothEventId event_id) {
+    switch(event_id) {
+    case A2DP_SOURCE_API_CONNECT_REQ:
+        return"API_CONNECT_REQ";
+    case A2DP_SOURCE_API_DISCONNECT_REQ:
+        return "API_DISCONNECT_REQ";
+    case A2DP_SOURCE_DISCONNECTED_CB:
+        return "DISCONNECTED_CB";
+    case A2DP_SOURCE_CONNECTING_CB:
+        return "CONNECING_CB";
+    case A2DP_SOURCE_CONNECTED_CB:
+        return "CONNECTED_CB";
+    case A2DP_SOURCE_DISCONNECTING_CB:
+        return "DISCONNECTING_CB";
+    case A2DP_SOURCE_AUDIO_SUSPENDED:
+        return "AUDIO_SUSPENDED_CB";
+    case A2DP_SOURCE_AUDIO_STOPPED:
+        return "AUDIO_STOPPED_CB";
+    case A2DP_SOURCE_AUDIO_STARTED:
+        return "AUDIO_STARTED_CB";
+    case AVRCP_TARGET_CONNECTED_CB:
+        return "AVRCP_TARGET_CONNECTED_CB";
+    case AVRCP_TARGET_DISCONNECTED_CB:
+        return "AVRCP_TARGET_DISCONNECTED_CB";
+    case A2DP_SOURCE_AUDIO_CMD_REQ:
+        return "AUDIO_CMD_REQ";
+    case AVRCP_TARGET_GET_ELE_ATTR:
+        return "AVRCP_TARGET_GET_ELE_ATTR";
+    case AVRCP_TARGET_GET_PLAY_STATUS:
+        return "AVRCP_TARGET_GET_PLAY_STATUS";
+    case AVRCP_TARGET_REG_NOTI:
+        return "AVRCP_TARGET_REG_NOTI";
+    case AVRCP_TARGET_TRACK_CHANGED:
+        return "AVRCP_TARGET_TRACK_CHANGED";
+    case AVRCP_TARGET_VOLUME_CHANGED:
+        return "AVRCP_TARGET_VOLUME_CHANGED";
+    case AVRCP_TARGET_SET_ABS_VOL:
+        return "AVRCP_TARGET_SET_ABS_VOL";
+    case AVRCP_TARGET_ABS_VOL_TIMEOUT:
+        return "AVRCP_TARGET_ABS_VOL_TIMEOUT";
+    case AVRCP_TARGET_SEND_VOL_UP_DOWN:
+        return "AVRCP_TARGET_SEND_VOL_UP_DOWN";
+    case AVRCP_TARGET_GET_FOLDER_ITEMS_CB:
+        return "AVRCP_TARGET_GET_FOLDER_ITEMS_CB";
+    case AVRCP_TARGET_SET_ADDR_PLAYER_CB:
+        return "AVRCP_TARGET_SET_ADDR_PLAYER_CB";
+    case AVRCP_TARGET_USE_BIGGER_METADATA:
+        return "AVRCP_TARGET_USE_BIGGER_METADATA";
+    case A2DP_SOURCE_CONNECTION_PRIORITY_REQ:
+        return "CONNECTION_PRIORITY_REQ";
+    }
+    return "UNKNOWN";
+}
+
+void A2dp_Source::state_disconnected_handler(BtEvent* pEvent) {
+    char str[18];
+    ALOGD(LOGTAG_A2DP "state_disconnected_handler Processing event %s", dump_message(pEvent->event_id));
+    switch(pEvent->event_id) {
+        case A2DP_SOURCE_API_CONNECT_REQ:
+            memcpy(&mConnectingDevice, &pEvent->a2dpSourceEvent.bd_addr, sizeof(bt_bdaddr_t));
+            if (sBtA2dpSourceInterface != NULL) {
+                sBtA2dpSourceInterface->connect(&pEvent->a2dpSourceEvent.bd_addr);
+            }
+            bdaddr_to_string(&mConnectingDevice, str, 18);
+            fprintf(stdout, "A2DP Source Connecting to %s\n", str);
+            change_state(STATE_A2DP_SOURCE_PENDING);
+            break;
+        case A2DP_SOURCE_API_DISCONNECT_REQ:
+            fprintf(stdout, "A2DP Source Disconnect can not be processed\n");
+            break;
+        case A2DP_SOURCE_CONNECTING_CB:
+            memcpy(&mConnectingDevice, &pEvent->a2dpSourceEvent.bd_addr, sizeof(bt_bdaddr_t));
+            bdaddr_to_string(&mConnectingDevice, str, 18);
+            fprintf(stdout, "A2DP Source Connecting to %s\n", str);
+            change_state(STATE_A2DP_SOURCE_PENDING);
+            break;
+        case A2DP_SOURCE_CONNECTED_CB:
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            memcpy(&mConnectedDevice, &pEvent->a2dpSourceEvent.bd_addr, sizeof(bt_bdaddr_t));
+            bdaddr_to_string(&mConnectedDevice, str, 18);
+            fprintf(stdout, "A2DP Source Connected to %s\n", str);
+            change_state(STATE_A2DP_SOURCE_CONNECTED);
+            BtA2dpOpenOutputStream();
+            break;
+        case A2DP_SOURCE_CONNECTION_PRIORITY_REQ:
+            if (sBtA2dpSourceVendorInterface != NULL) {
+                sBtA2dpSourceVendorInterface->allow_connection_vendor(1, &pEvent->a2dpSourceEvent.bd_addr);
+            }
+            break;
+        default:
+            fprintf(stdout, "Event not processed in disconnected state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_A2DP " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+void A2dp_Source::state_pending_handler(BtEvent* pEvent) {
+    char str[18];
+    ALOGD(LOGTAG_A2DP "state_pending_handler Processing event %s", dump_message(pEvent->event_id));
+    switch(pEvent->event_id) {
+        case A2DP_SOURCE_CONNECTED_CB:
+            memcpy(&mConnectedDevice, &pEvent->a2dpSourceEvent.bd_addr, sizeof(bt_bdaddr_t));
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            bdaddr_to_string(&mConnectedDevice, str, 18);
+            fprintf(stdout, "A2DP Source Connected to %s\n", str);
+            change_state(STATE_A2DP_SOURCE_CONNECTED);
+            BtA2dpOpenOutputStream();
+            break;
+        case A2DP_SOURCE_DISCONNECTED_CB:
+            fprintf(stdout, "A2DP Source DisConnected \n");
+            media_playing = false;
+            playStatus = BTRC_PLAYSTATE_ERROR;
+            mCurrentTrackID = NO_TRACK_SELECTED;
+            pA2dpSource->mAbsVolRemoteSupported = false;
+            BtA2dpCloseOutputStream();
+            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            change_state(STATE_A2DP_SOURCE_DISCONNECTED);
+            break;
+        case A2DP_SOURCE_API_CONNECT_REQ:
+            bdaddr_to_string(&mConnectingDevice, str, 18);
+            fprintf(stdout, "A2DP Source already Connecting to %s\n", str);
+            break;
+        case A2DP_SOURCE_API_DISCONNECT_REQ:
+            fprintf(stdout, "A2DP Source Disconnect can not be processed\n");
+            break;
+        case A2DP_SOURCE_CONNECTION_PRIORITY_REQ:
+            if (sBtA2dpSourceVendorInterface != NULL) {
+                sBtA2dpSourceVendorInterface->allow_connection_vendor(1, &pEvent->a2dpSourceEvent.bd_addr);
+            }
+            break;
+        default:
+            fprintf(stdout, "Event not processed in pending state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_A2DP " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+void A2dp_Source::state_connected_handler(BtEvent* pEvent) {
+    char str[18];
+
+    BtEvent *pControlRequest, *pReleaseControlReq;
+    ALOGD(LOGTAG_A2DP "state_connected_handler Processing event %s", dump_message(pEvent->event_id));
+    switch(pEvent->event_id) {
+        case A2DP_SOURCE_API_CONNECT_REQ:
+            bdaddr_to_string(&mConnectedDevice, str, 18);
+            fprintf(stdout, "A2DP Source Already Connected to %s\n", str);
+            break;
+        case A2DP_SOURCE_API_DISCONNECT_REQ:
+            if (memcmp(&mConnectedDevice, &pEvent->a2dpSourceEvent.bd_addr, sizeof(bt_bdaddr_t)))
+            {
+                bdaddr_to_string(&pEvent->a2dpSourceEvent.bd_addr, str, 18);
+                fprintf(stdout, "Device not connected: %s\n", str);
+                break;
+            }
+            bdaddr_to_string(&mConnectedDevice, str, 18);
+            fprintf(stdout, "A2DP Source DisConnecting: %s\n", str);
+            media_playing = false;
+            playStatus = BTRC_PLAYSTATE_ERROR;
+            mCurrentTrackID = NO_TRACK_SELECTED;
+            pA2dpSource->mAbsVolRemoteSupported = false;
+            if (sBtA2dpSourceInterface != NULL) {
+                sBtA2dpSourceInterface->disconnect(&pEvent->a2dpSourceEvent.bd_addr);
+            }
+            change_state(STATE_A2DP_SOURCE_PENDING);
+            break;
+        case A2DP_SOURCE_CONNECTION_PRIORITY_REQ:
+            if (sBtA2dpSourceVendorInterface != NULL) {
+                sBtA2dpSourceVendorInterface->allow_connection_vendor(1, &pEvent->a2dpSourceEvent.bd_addr);
+            }
+            break;
+        case A2DP_SOURCE_DISCONNECTED_CB:
+            media_playing = false;
+            playStatus = BTRC_PLAYSTATE_ERROR;
+            mCurrentTrackID = NO_TRACK_SELECTED;
+            pA2dpSource->mAbsVolRemoteSupported = false;
+            BtA2dpCloseOutputStream();
+            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            fprintf(stdout, "A2DP Source DisConnected \n");
+            change_state(STATE_A2DP_SOURCE_DISCONNECTED);
+            break;
+        case A2DP_SOURCE_DISCONNECTING_CB:
+            fprintf(stdout, "A2DP Source DisConnecting \n");
+            change_state(STATE_A2DP_SOURCE_PENDING);
+            break;
+        case A2DP_SOURCE_AUDIO_STARTED:
+            fprintf(stdout, "A2DP Source Audio state changes to: %d	\n",pEvent->event_id);
+            break;
+
+        case A2DP_SOURCE_AUDIO_SUSPENDED:
+            fprintf(stdout, "A2DP Source Audio state changes to: %d	\n",pEvent->event_id);
+            break;
+        case A2DP_SOURCE_AUDIO_STOPPED:
+            fprintf(stdout, "A2DP Source Audio state changes to: %d ", pEvent->event_id);
+            break;
+        default:
+            fprintf(stdout, "Event not processed in connected state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_A2DP " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+A2dpSourceState A2dp_Source::get_state() {
+   ALOGD(LOGTAG_A2DP "current state changed to %d ", mSourceState);
+   return mSourceState;
+}
+
+bool A2dp_Source::get_codec_cfg(uint8_t* info, uint8_t* type)
+{
+    return sBtA2dpSourceVendorInterface-> get_src_codec_config(info,type);
+}
+
+void A2dp_Source::change_state(A2dpSourceState mState) {
+   ALOGD(LOGTAG_A2DP " current State = %d, new state = %d", mSourceState, mState);
+   pthread_mutex_lock(&lock);
+   mSourceState = mState;
+   pthread_mutex_unlock(&lock);
+   ALOGD(LOGTAG_A2DP " state changed to %d ", mState);
+}
+
+A2dp_Source :: A2dp_Source(const bt_interface_t *bt_interface, config_t *config) {
+    this->bluetooth_interface = bt_interface;
+    this->config = config;
+    sBtA2dpSourceInterface = NULL;
+    sBtAvrcpTargetInterface = NULL;
+    mSourceState = STATE_A2DP_SOURCE_NOT_STARTED;
+    mAvrcpConnected = false;
+    set_abs_volume_timer = alarm_new();
+    abs_vol_timer = false;
+    mVolCmdSetInProgress = false;
+    mVolCmdAdjustInProgress = false;
+    mInitialRemoteVolume = -1;
+    mLastRemoteVolume = -1;
+    mRemoteVolume = -1;
+    mLastLocalVolume = -1;
+    mLocalVolume = -1;
+    mPreviousAddrPlayerId = 0;
+    mCurrentAddrPlayerId = 0;
+    mAbsVolRemoteSupported = false;
+    memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+    memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+    memset(&mConnectedAvrcpDevice, 0, sizeof(bt_bdaddr_t));
+    pthread_mutex_init(&this->lock, NULL);
+    is_sink_relay_enabled = config_get_bool (config,
+            CONFIG_DEFAULT_SECTION, "BtRelaySinkDatatoSrc", false);
+    ALOGD(LOGTAG_A2DP " Sink Relay Enabled %d ", is_sink_relay_enabled);
+}
+
+A2dp_Source :: ~A2dp_Source() {
+    mAvrcpConnected = false;
+    mVolCmdSetInProgress = false;
+    mVolCmdAdjustInProgress = false;
+    mInitialRemoteVolume = -1;
+    mLastRemoteVolume = -1;
+    mRemoteVolume = -1;
+    mLastLocalVolume = -1;
+    mLocalVolume = -1;
+    mPreviousAddrPlayerId = 0;
+    mCurrentAddrPlayerId = 0;
+    alarm_free(set_abs_volume_timer);
+    set_abs_volume_timer = NULL;
+    mAbsVolRemoteSupported = false;
+    pthread_mutex_destroy(&lock);
+}
+
+MediaPlayerInfo :: MediaPlayerInfo(short playerId, char majorPlayerType, int playerSubType,
+                                      char playState, short charsetId, short displayableNameLength,
+                                      char* displayableName, char* playerPackageName,
+                                      bool isAvailable, bool isFocussed, char itemType,
+                                      bool isRemoteAddressable, short itemLength, short entryLength,
+                                      char featureMask[]) {
+    int i;
+    mPlayerId = playerId;
+    mMajorPlayerType = majorPlayerType;
+    mPlayerSubType = playerSubType;
+    mPlayState = playState;
+    mCharsetId = charsetId;
+    mDisplayableNameLength = displayableNameLength;
+    memcpy(&mDisplayableName, &displayableName, strlen(displayableName)+1);
+    memcpy(&mPlayerPackageName, &playerPackageName, strlen(playerPackageName)+1);
+    ALOGD(LOGTAG_AVRCP "  %s %s", mDisplayableName, mPlayerPackageName);
+
+    mIsAvailable = isAvailable;
+    mIsFocussed = isFocussed;
+    mItemType = itemType;
+    mIsRemoteAddressable = isRemoteAddressable;
+    mItemLength = (short)(mDisplayableNameLength + 2 + 1 + 4 + 1 + 2 + 2 + 16);
+    mEntryLength = (short)(mItemLength + /* ITEM_LENGTH_LENGTH +*/ 1);
+    memcpy(mFeatureMask, featureMask, 16);
+
+    for (i = 0; i < 16; i++)
+        ALOGD(LOGTAG_AVRCP " %d", mFeatureMask[i]);
+}
+
+int MediaPlayerInfo :: RetrievePlayerEntryLength() {
+    return mEntryLength;
+}
+
+char* MediaPlayerInfo :: RetrievePlayerItemEntry() {
+    int position = 0;
+    int count;
+    char* playerEntry1 = (char*)osi_malloc(mEntryLength * sizeof(char));
+
+    playerEntry1[position] = (char)mItemType;
+    ALOGD(LOGTAG_AVRCP "RetrievePlayerItemEntry type %d", playerEntry1[position]);
+    position++;
+
+    playerEntry1[position] = (char)(mPlayerId & 0xff);
+    ALOGD(LOGTAG_AVRCP "RetrievePlayerItemEntry playerid %d", playerEntry1[position]);
+    position++;
+
+    playerEntry1[position] = (char)((mPlayerId >> 8) & 0xff);
+    ALOGD(LOGTAG_AVRCP "RetrievePlayerItemEntry playerid %d", playerEntry1[position]);
+    position++;
+
+    playerEntry1[position] = (char)mMajorPlayerType;
+    ALOGD(LOGTAG_AVRCP "RetrievePlayerItemEntry MajorPlayerType %d", playerEntry1[position]);
+    position++;
+
+    for (count = 0; count < 4; count++) {
+        playerEntry1[position] = (char)((mPlayerSubType >> (8 * count)) & 0xff); position++;
+    }
+
+    playerEntry1[position] = (char)mPlayState; position++;
+    for (count = 0; count < 16; count++) {
+        playerEntry1[position] = (char)mFeatureMask[count];
+        ALOGD(LOGTAG_AVRCP "RetrievePlayerItemEntry playerEntry1[%d] position %d,  %d", count,
+                            position, playerEntry1[position]);
+        position++;
+    }
+    playerEntry1[position] = (char)(mCharsetId & 0xff); position++;
+    playerEntry1[position] = (char)((mCharsetId >> 8) & 0xff); position++;
+    playerEntry1[position] = (char)(mDisplayableNameLength & 0xff); position++;
+    playerEntry1[position] = (char)((mDisplayableNameLength >> 8) & 0xff); position++;
+
+    for (count = 0; count < mDisplayableNameLength; count++) {
+        playerEntry1[position] = (char)mDisplayableName[count]; position++;
+    }
+    if (position != mEntryLength) {
+        ALOGE(LOGTAG_AVRCP "ERROR populating PlayerItemEntry: position: %d mEntryLength: %d",
+                            position, mEntryLength);
+    }
+    return playerEntry1;
+}
+
+MediaPlayerInfo :: ~MediaPlayerInfo() {
+}
diff --git a/bt-app/audio_manager/include/Audio_Manager.hpp b/bt-app/audio_manager/include/Audio_Manager.hpp
index 90c02a7..9537ca9 100644
--- a/bt-app/audio_manager/include/Audio_Manager.hpp
+++ b/bt-app/audio_manager/include/Audio_Manager.hpp
@@ -40,8 +40,8 @@
 #include "ipc.h"
 
 #if (defined(BT_AUDIO_HAL_INTEGRATION))
-#include <hardware/audio.h>
-#include <hardware/hardware.h>
+#include "qahw_api.h"
+#include "qahw_defs.h"
 #endif
 
 #define MAX_PROFILE_ENTRIES 2
@@ -73,9 +73,8 @@ class BT_Audio_Manager {
     void LoadAudioHal();
     void UnloadAudioHal();
 #if (defined BT_AUDIO_HAL_INTEGRATION)
-    audio_hw_device_t* GetAudioDevice();
-    const hw_module_t* HwModule;
-    audio_hw_device_t* audio_device;
+    qahw_module_handle_t* GetAudioDevice();
+    qahw_module_handle_t *qahw_mod_handle;
 #endif
 };
 
diff --git a/bt-app/audio_manager/src/Audio_Manager.cpp b/bt-app/audio_manager/src/Audio_Manager.cpp
index c5cb526..92ca852 100644
--- a/bt-app/audio_manager/src/Audio_Manager.cpp
+++ b/bt-app/audio_manager/src/Audio_Manager.cpp
@@ -1,5 +1,5 @@
  /*
-  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+  * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
@@ -32,6 +32,7 @@
 #include <string.h>
 
 #include "Audio_Manager.hpp"
+#include "A2dp_Sink_Streaming.hpp"
 
 #define LOGTAG "BT_AM"
 
@@ -40,6 +41,7 @@ using std::list;
 using std::string;
 
 BT_Audio_Manager *pBTAM = NULL;
+extern A2dp_Sink_Streaming *pA2dpSinkStream;
 
 #ifdef __cplusplus
 extern "C" {
@@ -92,12 +94,12 @@ char* BT_Audio_Manager::dump_message(BluetoothEventId event_id) {
 }
 
 void BT_Audio_Manager::HandleEnableBTAM(void) {
-    UnloadAudioHal();
     BtEvent *pEvent = new BtEvent;
     pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
     pEvent->profile_start_event.profile_id = PROFILE_ID_BT_AM;
     pEvent->profile_start_event.status = true;
     PostMessage(THREAD_ID_GAP, pEvent);
+    LoadAudioHal();
 }
 
 void BT_Audio_Manager::HandleDisableBTAM(void) {
@@ -132,29 +134,14 @@ int BT_Audio_Manager::GetTopIndex(void) {
 void BT_Audio_Manager::LoadAudioHal()
 {
 #if (defined(BT_AUDIO_HAL_INTEGRATION))
-     int ret = 0;
     ALOGD(LOGTAG " Load Audio HAL +");
-    if (HwModule != NULL) {
-        ALOGD(" HW already loaded");
+    if (qahw_mod_handle != NULL) {
+        ALOGD(" Audio HAL already loaded");
     } else {
-    ret = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID,
-                                    AUDIO_HARDWARE_MODULE_ID_PRIMARY, &HwModule);
+        qahw_mod_handle = qahw_load_module(QAHW_MODULE_ID_PRIMARY);
     }
-    ALOGD(" get_module_by_class +%d ", ret);
-    if (ret) {
-        ALOGD("  get_module_by_class failed +%d ", ret);
-        HwModule = NULL;
-        return;
-    }
-    if (audio_device != NULL) {
-        ALOGD(" Audio Device already Open ");
-    } else {
-        ret = audio_hw_device_open(HwModule, &audio_device);
-    }
-    ALOGD(" audio_hw_device_open +%d ", ret);
-    if (ret) {
-        ALOGD("  audio_hw_device_open failed +%d ", ret);
-        HwModule = NULL;
+    if (qahw_mod_handle == NULL) {
+        ALOGD("  qahw_load_module failed");
         return;
     }
     ALOGD(LOGTAG "Load Audio HAL -");
@@ -163,22 +150,26 @@ void BT_Audio_Manager::LoadAudioHal()
 void BT_Audio_Manager::UnloadAudioHal()
 {
 #if (defined(BT_AUDIO_HAL_INTEGRATION))
+    int ret = 0;
     ALOGD(LOGTAG "UnLoad Audio HAL +");
-    if(audio_device != NULL)
-        audio_hw_device_close(audio_device);
-    audio_device = NULL;
-    HwModule = NULL;
+    if(qahw_mod_handle != NULL)
+        ret = qahw_unload_module(qahw_mod_handle);
+
+    if (ret)
+        ALOGE(LOGTAG "Unloading audio hal failed");
+
+    qahw_mod_handle = NULL;
     ALOGD(LOGTAG "UnLoad Audio HAL -");
 #endif
 }
 #if (defined(BT_AUDIO_HAL_INTEGRATION))
-audio_hw_device_t* BT_Audio_Manager::GetAudioDevice()
+qahw_module_handle_t* BT_Audio_Manager::GetAudioDevice()
 {
-    if (audio_device != NULL) {
-        return audio_device;
+    if (qahw_mod_handle != NULL) {
+        return qahw_mod_handle;
     }
     else {
-        ALOGD(" audio device is NULL ");
+        ALOGD(" audio hw module handle is NULL ");
         return NULL;
     }
 }
@@ -198,6 +189,8 @@ ThreadIdType BT_Audio_Manager::GetThreadId(ProfileIdType profile_id) {
 // adds a new controlEntry node on the top
 void BT_Audio_Manager::AddNewNode(ProfileIdType profile, ControlRequestType ctrlStatus) {
     int index = GetTopIndex();
+    if (index == (MAX_PROFILE_ENTRIES - 1))
+        return;
     if (index < 0)
         index = 0;
     else
@@ -240,7 +233,15 @@ void BT_Audio_Manager::SendControlStatusMessage(ControlStatusType ctrlStatus,
     BtEvent *pControlResponse = new BtEvent;
     pControlResponse->btamControlStatus.event_id = BT_AM_CONTROL_STATUS;
     pControlResponse->btamControlStatus.status_type = ctrlStatus;
-    PostMessage(GetThreadId(profile_id), pControlResponse);
+    if (profile_id != PROFILE_ID_A2DP_SINK) {
+        PostMessage(GetThreadId(profile_id), pControlResponse);
+    }
+    else {
+        if (pA2dpSinkStream != NULL) {
+            thread_post(pA2dpSinkStream->threadInfo.thread_id,
+            pA2dpSinkStream->threadInfo.thread_handler, (void*)pControlResponse);
+        }
+    }
 }
 void BT_Audio_Manager::ProcessEvent(BtEvent* pEvent) {
     ALOGD(LOGTAG " Processing event %s", dump_message(pEvent->event_id));
@@ -253,7 +254,6 @@ void BT_Audio_Manager::ProcessEvent(BtEvent* pEvent) {
             top = GetTopIndex();
             if (top < 0) {
                 // fresh request, load Audio HAL TODO:BTAM Load Audio HAL
-                LoadAudioHal();
                 AddNewNode(pEvent->btamControlReq.profile_id, pEvent->btamControlReq.request_type);
                 if (pEvent->btamControlReq.request_type == REQUEST_TYPE_PERMANENT)
                     SendControlStatusMessage(STATUS_GAIN, pEvent->btamControlReq.profile_id);
@@ -280,6 +280,10 @@ void BT_Audio_Manager::ProcessEvent(BtEvent* pEvent) {
                     break;
                 case REQUEST_TYPE_PERMANENT:
                     if (pEvent->btamControlReq.request_type == REQUEST_TYPE_TRANSIENT) {
+                        if(top == (MAX_PROFILE_ENTRIES - 1)) {
+                           SendControlStatusMessage(STATUS_LOSS, pEvent->btamControlReq.profile_id);
+                           break;
+                        }
                         SendControlStatusMessage(STATUS_LOSS_TRANSIENT,
                                                       audio_control_stack[top].profile_id);
                         AddNewNode(pEvent->btamControlReq.profile_id,
@@ -312,9 +316,6 @@ void BT_Audio_Manager::ProcessEvent(BtEvent* pEvent) {
                                        audio_control_stack[top-1].profile_id);
             }
             RemoveNode(profile_index);
-            if (GetTopIndex() < 0) {
-                UnloadAudioHal();
-            }
             break;
     }
 }
@@ -325,8 +326,7 @@ BT_Audio_Manager :: BT_Audio_Manager(const bt_interface_t *bt_interface, config_
         audio_control_stack[i].control_status = REQUEST_TYPE_DEFAULT;
     }
 #if (defined(BT_AUDIO_HAL_INTEGRATION))
-    HwModule = NULL;
-    audio_device = NULL;
+    qahw_mod_handle = NULL;
 #endif
 }
 
diff --git a/bt-app/avrcp/include/Avrcp.hpp b/bt-app/avrcp/include/Avrcp.hpp
new file mode 100644
index 0000000..245a5f7
--- /dev/null
+++ b/bt-app/avrcp/include/Avrcp.hpp
@@ -0,0 +1,73 @@
+ /*
+  * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#ifndef AVRCP_APP_H
+#define AVRCP_APP_H
+
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_rc.h>
+#include <pthread.h>
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/allocator.h"
+#include "ipc.h"
+#include "utils.h"
+#include "hardware/bt_rc_vendor.h"
+#include <list>
+
+class Avrcp {
+
+  private:
+    config_t *config;
+    const bt_interface_t * bluetooth_interface;
+    const btrc_ctrl_interface_t *sBtAvrcpCtrlInterface;
+    const btrc_ctrl_vendor_interface_t *sBtAvrcpCtrlVendorInterface;
+    int mPreviousPercentageVol;
+    bool mFirstAbsVolCmdRecvd;
+  public:
+    Avrcp(const bt_interface_t *bt_interface, config_t *config);
+    ~Avrcp();
+    char* dump_message(BluetoothEventId event_id);
+    pthread_mutex_t lock;
+    std::list <std::string> rc_only_devices;
+    bt_bdaddr_t mConnectedAvrcpDevice;
+    uint32_t max_avrcp_conn;
+    void HandleAvrcpEvents(BtEvent* pEvent);
+    void HandleEnableAvrcp();
+    void HandleDisableAvrcp();
+    void SendPassThruCommandNative(uint8_t key_id, bt_bdaddr_t* addr, uint8_t direct);
+    void OnDisconnected();
+    void setAbsVolume(bt_bdaddr_t* dev, int absVol, int label);
+};
+
+#endif
diff --git a/bt-app/avrcp/src/Avrcp.cpp b/bt-app/avrcp/src/Avrcp.cpp
new file mode 100644
index 0000000..6eb3039
--- /dev/null
+++ b/bt-app/avrcp/src/Avrcp.cpp
@@ -0,0 +1,578 @@
+ /*
+  * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#include <list>
+#include <map>
+#include <iostream>
+#include <string.h>
+#include <hardware/bluetooth.h>
+#include <hardware/hardware.h>
+#include <hardware/bt_rc.h>
+
+#include "Avrcp.hpp"
+#include "A2dp_Sink_Streaming.hpp"
+#include "Gap.hpp"
+#include "hardware/bt_rc_vendor.h"
+#include "A2dp_Sink.hpp"
+#include <math.h>
+#include <algorithm>
+
+#define LOGTAG "AVRCP"
+#define LOGTAG_CTRL "AVRCP_CTRL"
+
+using namespace std;
+using std::list;
+using std::string;
+
+Avrcp *pAvrcp = NULL;
+extern A2dp_Sink_Streaming *pA2dpSinkStream;
+extern A2dp_Sink *pA2dpSink;
+
+static const bt_bdaddr_t bd_addr_null= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+#define ABS_VOL_BASE 127
+#define AUDIO_MAX_VOL_LEVEL 15
+int curr_audio_index = 1;
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void BtAvrcpMsgHandler(void *msg) {
+    BtEvent* pEvent = NULL;
+    BtEvent* pCleanupEvent = NULL;
+    if(!msg) {
+        printf("Msg is NULL, return.\n");
+        return;
+    }
+
+    pEvent = ( BtEvent *) msg;
+    switch(pEvent->event_id) {
+        case PROFILE_API_START:
+            ALOGD(LOGTAG " enable avrcp");
+            if (pAvrcp) {
+                pAvrcp->HandleEnableAvrcp();
+            }
+            break;
+        case PROFILE_API_STOP:
+            ALOGD(LOGTAG " disable avrcp");
+            if (pAvrcp) {
+                pAvrcp->HandleDisableAvrcp();
+            }
+            break;
+        case AVRCP_CLEANUP_REQ:
+            ALOGD(LOGTAG " cleanup a2dp avrcp");
+            pCleanupEvent = new BtEvent;
+            pCleanupEvent->event_id = AVRCP_CLEANUP_DONE;
+            PostMessage(THREAD_ID_GAP, pCleanupEvent);
+            break;
+        case AVRCP_CTRL_CONNECTED_CB:
+        case AVRCP_CTRL_DISCONNECTED_CB:
+        case AVRCP_CTRL_PASS_THRU_CMD_REQ:
+        case AVRCP_CTRL_REG_NOTI_ABS_VOL_CB:
+        case AVRCP_CTRL_VOL_CHANGED_NOTI_REQ:
+        case AVRCP_CTRL_SET_ABS_VOL_CMD_CB:
+            ALOGD( LOGTAG_CTRL " handle avrcp events ");
+            if (pAvrcp) {
+                pAvrcp->HandleAvrcpEvents(( BtEvent *) msg);
+            }
+            break;
+        default:
+            break;
+    }
+    delete pEvent;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+
+static void btavrcpctrl_passthru_rsp_vendor_callback(int id, int key_state, bt_bdaddr_t *bd_addr) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_passthru_rsp_vendor_callback id = %d key_state = %d",
+            id, key_state);
+    if (id == CMD_ID_PAUSE && key_state == 1 &&
+            !memcmp(&pA2dpSinkStream->mStreamingDevice, bd_addr, sizeof(bt_bdaddr_t)))
+    {
+        ALOGD(LOGTAG_CTRL " need to flush both stack queue and audio queue ");
+        BtEvent *pFlushAudioPackets = new BtEvent;
+        pFlushAudioPackets->a2dpSinkStreamingEvent.event_id = A2DP_SINK_STREAMING_FLUSH_AUDIO;
+        memcpy(&pFlushAudioPackets->a2dpSinkStreamingEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+        if (pA2dpSinkStream) {
+            thread_post(pA2dpSinkStream->threadInfo.thread_id,
+            pA2dpSinkStream->threadInfo.thread_handler, (void*)pFlushAudioPackets);
+        }
+    }
+}
+
+static void btavrcpctrl_passthru_rsp_callback(int id, int key_state) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_passthru_rsp_callback id = %d key_state = %d", id, key_state);
+}
+
+static void btavrcpctrl_groupnavigation_rsp_callback(int id, int key_state) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_groupnavigation_rsp_callback id = %d key_state = %d", id, key_state);
+}
+
+static void btavrcpctrl_setplayerapplicationsetting_rsp_callback(bt_bdaddr_t *bd_addr, uint8_t accepted) {
+    ALOGD(LOGTAG_CTRL " btavrcctrl_setplayerapplicationsetting_rsp_callback accepted = %d", accepted);
+}
+
+static void btavrcpctrl_playerapplicationsetting_callback(bt_bdaddr_t *bd_addr, uint8_t num_attr,
+                                                          btrc_player_app_attr_t *app_attrs,
+                                                          uint8_t num_ext_attr, btrc_player_app_ext_attr_t *ext_attrs) {
+     ALOGD(LOGTAG_CTRL " btavrcpctrl_playerapplicationsetting_callback");
+}
+ 
+static void btavrcpctrl_playerapplicationsetting_changed_callback(bt_bdaddr_t *bd_addr, btrc_player_settings_t *p_vals) {
+     ALOGD(LOGTAG_CTRL " btrc_ctrl_playerapplicationsetting_changed_callback");
+}
+
+static void btavrcpctrl_track_changed_callback(bt_bdaddr_t *bd_addr, uint8_t num_attr,
+                                                     btrc_element_attr_val_t *p_attrs) {
+    ALOGD(LOGTAG_CTRL "btrc_ctrl_track_changed_callback");
+}
+
+static void btavrcpctrl_play_position_changed_callback(bt_bdaddr_t *bd_addr,
+                                                          uint32_t song_len, uint32_t song_pos, btrc_play_status_t play_status) {
+    ALOGD(LOGTAG_CTRL "btrc_ctrl_play_position_changed_callback");
+}
+
+static void btavrcpctrl_play_status_changed_callback(bt_bdaddr_t *bd_addr, btrc_play_status_t play_status) {
+    ALOGD(LOGTAG_CTRL "btrc_ctrl_play_status_changed_callback");
+}
+
+static void btavrcpctrl_connection_state_callback(bool state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_connection_state_callback state = %d", state);
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->avrcpCtrlEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    if (state == true)
+        pEvent->avrcpCtrlEvent.event_id = AVRCP_CTRL_CONNECTED_CB;
+    else
+        pEvent->avrcpCtrlEvent.event_id = AVRCP_CTRL_DISCONNECTED_CB;
+    PostMessage(THREAD_ID_AVRCP, pEvent);
+}
+
+static void btavrcpctrl_getrcfeatures_callback( bt_bdaddr_t* bd_addr, int features) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_rcfeatures_vendor_callback features = %d", features);
+}
+
+static void btavrcpctrl_getcap_rsp_vendor_callback( bt_bdaddr_t *bd_addr, int cap_id,
+                uint32_t* supported_values, int num_supported, uint8_t rsp_type) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_getcap_rsp_vendor_callback");
+}
+
+static void btavrcpctrl_listplayerappsettingattrib_rsp_vendor_callback( bt_bdaddr_t *bd_addr,
+                          uint8_t* supported_attribs, int num_attrib, uint8_t rsp_type) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_listplayerappsettingattrib_rsp_vendor_callback");
+}
+
+static void btavrcpctrl_listplayerappsettingvalue_rsp_vendor_callback( bt_bdaddr_t *bd_addr,
+                       uint8_t* supported_val, uint8_t num_supported, uint8_t rsp_type) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_listplayerappsettingvalue_rsp_vendor_callback");
+}
+
+static void btavrcpctrl_currentplayerappsetting_rsp_vendor_callback( bt_bdaddr_t *bd_addr,
+        uint8_t* supported_ids, uint8_t* supported_val, uint8_t num_attrib, uint8_t rsp_type) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_currentplayerappsetting_rsp_vendor_callback");
+}
+
+static void btavrcpctrl_notification_rsp_vendor_callback( bt_bdaddr_t *bd_addr, uint8_t rsp_type,
+        int rsp_len, uint8_t* notification_rsp) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_notification_rsp_vendor_callback");
+}
+
+static void btavrcpctrl_getelementattrib_rsp_vendor_callback(bt_bdaddr_t *bd_addr, uint8_t num_attributes,
+       int rsp_len, uint8_t* attrib_rsp, uint8_t rsp_type) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_getelementattrib_rsp_vendor_callback");
+}
+
+static void btavrcpctrl_getplaystatus_rsp_vendor_callback(bt_bdaddr_t *bd_addr, int param_len,
+        uint8_t* play_status_rsp, uint8_t rsp_type) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_getplaystatus_rsp_vendor_callback");
+}
+
+static void btavrcpctrl_setabsvol_cmd_callback(bt_bdaddr_t *bd_addr, uint8_t abs_vol, uint8_t label) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_setabsvol_cmd_vendor_callback");
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpCtrlEvent.event_id = AVRCP_CTRL_SET_ABS_VOL_CMD_CB;
+    pEvent->avrcpCtrlEvent.arg1 = label;
+    pEvent->avrcpCtrlEvent.arg2 = abs_vol;
+    memcpy(&pEvent->avrcpCtrlEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    PostMessage(THREAD_ID_AVRCP, pEvent);
+}
+
+static void btavrcpctrl_registernotification_absvol_callback(bt_bdaddr_t *bd_addr, uint8_t label) {
+    ALOGD(LOGTAG_CTRL " btavrcpctrl_registernotification_absvol_vendor_callback");
+    BtEvent *pEvent = new BtEvent;
+    pEvent->avrcpCtrlEvent.event_id = AVRCP_CTRL_REG_NOTI_ABS_VOL_CB;
+    pEvent->avrcpCtrlEvent.arg1 = label;
+    memcpy(&pEvent->avrcpCtrlEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    PostMessage(THREAD_ID_AVRCP, pEvent);
+}
+
+static btrc_ctrl_callbacks_t sBluetoothAvrcpCtrlCallbacks = {
+   sizeof(sBluetoothAvrcpCtrlCallbacks),
+   btavrcpctrl_passthru_rsp_callback,
+   btavrcpctrl_groupnavigation_rsp_callback,
+   btavrcpctrl_connection_state_callback,
+   btavrcpctrl_getrcfeatures_callback,
+   btavrcpctrl_setplayerapplicationsetting_rsp_callback,
+   btavrcpctrl_playerapplicationsetting_callback,
+   btavrcpctrl_playerapplicationsetting_changed_callback,
+   btavrcpctrl_setabsvol_cmd_callback,
+   btavrcpctrl_registernotification_absvol_callback,
+   btavrcpctrl_track_changed_callback,
+   btavrcpctrl_play_position_changed_callback,
+   btavrcpctrl_play_status_changed_callback,
+};
+
+static btrc_ctrl_vendor_callbacks_t sBluetoothAvrcpCtrlVendorCallbacks = {
+   sizeof(sBluetoothAvrcpCtrlVendorCallbacks),
+   btavrcpctrl_getcap_rsp_vendor_callback,
+   btavrcpctrl_listplayerappsettingattrib_rsp_vendor_callback,
+   btavrcpctrl_listplayerappsettingvalue_rsp_vendor_callback,
+   btavrcpctrl_currentplayerappsetting_rsp_vendor_callback,
+   btavrcpctrl_notification_rsp_vendor_callback,
+   btavrcpctrl_getelementattrib_rsp_vendor_callback,
+   btavrcpctrl_getplaystatus_rsp_vendor_callback,
+   btavrcpctrl_passthru_rsp_vendor_callback,
+};
+
+void Avrcp::SendPassThruCommandNative(uint8_t key_id, bt_bdaddr_t* addr, uint8_t direct) {
+    ALOGD(LOGTAG_CTRL " SendPassThruCommandNative ");
+    if (memcmp(&pA2dpSinkStream->mStreamingDevice, &bd_addr_null, sizeof(bt_bdaddr_t)) &&
+            memcmp(&pA2dpSinkStream->mStreamingDevice, addr, sizeof(bt_bdaddr_t)) &&
+            (key_id == CMD_ID_PLAY))
+        direct = 1;
+
+    if (!direct && pA2dpSinkStream && pA2dpSinkStream->use_bt_a2dp_hal &&
+            ((key_id == CMD_ID_PAUSE) || (key_id == CMD_ID_PLAY))) {
+        ALOGD(LOGTAG_CTRL " SendPassThruCommandNative: using bt_a2dp_hal ");
+        if (CMD_ID_PAUSE == key_id)
+        {
+            ALOGD( LOGTAG_CTRL " sending stopped event ");
+
+            if (!memcmp(&pA2dpSinkStream->mStreamingDevice, addr, sizeof(bt_bdaddr_t)))
+            {
+                pA2dpSinkStream->StopDataFetchTimer();
+                pA2dpSinkStream->SuspendInputStream();
+            }
+
+        }
+        if (CMD_ID_PLAY == key_id)
+        {
+            ALOGD( LOGTAG_CTRL " sending started event ");
+            BtEvent *pEvent = new BtEvent;
+            pEvent->a2dpSinkEvent.event_id = A2DP_SINK_AUDIO_STARTED;
+            memcpy(&pEvent->a2dpSinkEvent.bd_addr, addr, sizeof(bt_bdaddr_t));
+            PostMessage(THREAD_ID_A2DP_SINK, pEvent);
+        }
+    }
+    else if (sBtAvrcpCtrlInterface != NULL) {
+        ALOGD(LOGTAG_CTRL " SendPassThruCommandNative send_pass_through_cmd");
+
+        sBtAvrcpCtrlInterface->send_pass_through_cmd(addr, key_id, 0);
+        sBtAvrcpCtrlInterface->send_pass_through_cmd(addr, key_id, 1);
+    }
+}
+
+list<A2dp_Device>::iterator FindAvDeviceByAddr(list<A2dp_Device>& pA2dpDev, bt_bdaddr_t dev) {
+    list<A2dp_Device>::iterator p = pA2dpDev.begin();
+    while(p != pA2dpDev.end()) {
+        if (memcmp(&dev, &p->mDevice, sizeof(bt_bdaddr_t)) == 0) {
+            break;
+        }
+        p++;
+    }
+    return p;
+}
+
+int getVolumePercentage() {
+    int maxVolume = AUDIO_MAX_VOL_LEVEL;
+                  //mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+    int currIndex = curr_audio_index;
+                  //mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
+    int percentageVol = ((currIndex * ABS_VOL_BASE) / maxVolume);
+    return percentageVol;
+}
+
+void Avrcp::setAbsVolume(bt_bdaddr_t* dev, int absVol, int label) {
+    int maxVolume = AUDIO_MAX_VOL_LEVEL;
+                  //mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+    int currIndex = curr_audio_index;
+                  //mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
+
+    // Ignore first volume command since phone may not know difference between stream volume
+    // and amplifier volume.
+    if (mFirstAbsVolCmdRecvd) {
+        int newIndex =(int) round((double) absVol * maxVolume / ABS_VOL_BASE);
+        ALOGD(LOGTAG_CTRL " setAbsVol = %d maxVol = %d cur = %d new = %d", absVol,
+                                                  maxVolume, currIndex, newIndex);
+        /*
+              * In some cases change in percentage is not sufficient enough to warrant
+              * change in index values which are in range of 0-15. For such cases
+              * no action is required
+              */
+        if (newIndex != currIndex) {
+            curr_audio_index = newIndex;
+            pA2dpSinkStream->SetStreamVol(curr_audio_index);
+        }
+    } else {
+        mFirstAbsVolCmdRecvd = true;
+        absVol = (currIndex * ABS_VOL_BASE) / maxVolume;
+        ALOGD(LOGTAG_CTRL " SetAbsVol recvd for first time, respond with absVol %d", absVol);
+    }
+    sBtAvrcpCtrlInterface->set_volume_rsp(dev, absVol, label);
+}
+
+void Avrcp::HandleAvrcpEvents(BtEvent* pEvent) {
+    list<A2dp_Device>::iterator iter;
+    int perVol;
+    bdstr_t bd_str;
+    std::list<std::string>::iterator bdstring;
+    ALOGD(LOGTAG_CTRL " HandleAvrcpEvents event = %s",
+            dump_message(pEvent->avrcpCtrlEvent.event_id));
+    switch(pEvent->avrcpCtrlEvent.event_id) {
+    case AVRCP_CTRL_CONNECTED_CB:
+        iter = FindAvDeviceByAddr(pA2dpSink->pA2dpDeviceList, pEvent->avrcpCtrlEvent.bd_addr);
+        if (iter != pA2dpSink->pA2dpDeviceList.end())
+        {
+            ALOGD(LOGTAG_CTRL " Rc connection for AV connected dev, mark avrcp connected");
+            iter->mAvrcpConnected = true;
+        }
+        else
+        {
+            ALOGE(LOGTAG_CTRL " Rc connection from device without AV connection");
+            bdaddr_to_string(&pEvent->avrcpCtrlEvent.bd_addr, &bd_str[0], sizeof(bd_str));
+            std::string deviceAddress(bd_str);
+            bdstring = std::find(rc_only_devices.begin(), rc_only_devices.end(), deviceAddress);
+            if (bdstring == rc_only_devices.end())
+            {
+                ALOGE(LOGTAG_CTRL " RC connected for this dev w/o AV, cache this device in list");
+                rc_only_devices.push_back(deviceAddress);
+            }
+            else
+            {
+                ALOGE(LOGTAG_CTRL " this RC device already in list, should never hit here, ERROR!!!");
+            }
+        }
+        break;
+    case AVRCP_CTRL_DISCONNECTED_CB:
+        iter = FindAvDeviceByAddr(pA2dpSink->pA2dpDeviceList, pEvent->avrcpCtrlEvent.bd_addr);
+        if (iter != pA2dpSink->pA2dpDeviceList.end())
+        {
+            ALOGD(LOGTAG_CTRL " Rc disconnection for AV connected dev, mark avrcp disconnected");
+            iter->mAvrcpConnected = false;
+        }
+        else
+        {
+            ALOGE(LOGTAG_CTRL " Rc disconnection from device without AV connection");
+            bdaddr_to_string(&pEvent->avrcpCtrlEvent.bd_addr, &bd_str[0], sizeof(bd_str));
+            std::string deviceAddress(bd_str);
+            bdstring = std::find(rc_only_devices.begin(), rc_only_devices.end(), deviceAddress);
+            if (bdstring != rc_only_devices.end())
+            {
+                ALOGD (LOGTAG " found match for RC only disconnection, remove from list");
+                rc_only_devices.remove(deviceAddress);
+            }
+            else
+            {
+                ALOGD (LOGTAG " found no match for RC only disconnection, entry was removed during AV connection");
+            }
+        }
+        break;
+    case AVRCP_CTRL_PASS_THRU_CMD_REQ:
+        iter = FindAvDeviceByAddr(pA2dpSink->pA2dpDeviceList, pEvent->avrcpCtrlEvent.bd_addr);
+        if (iter != pA2dpSink->pA2dpDeviceList.end() && (iter->mAvrcpConnected == true))
+        {
+            ALOGD(LOGTAG_CTRL " passthrough cmd for AV & RC connected device, send to stack");
+            SendPassThruCommandNative(pEvent->avrcpCtrlEvent.key_id,
+            &pEvent->avrcpCtrlEvent.bd_addr, 0);
+        }
+        else
+        {
+            ALOGD(LOGTAG_CTRL " Avrcp not connected or AV not connected");
+        }
+        break;
+    case AVRCP_CTRL_SET_ABS_VOL_CMD_CB:
+        iter = FindAvDeviceByAddr(pA2dpSink->pA2dpDeviceList, pEvent->avrcpCtrlEvent.bd_addr);
+        if (iter != pA2dpSink->pA2dpDeviceList.end() && (iter->mAvrcpConnected == true))
+        {
+            ALOGD(LOGTAG_CTRL " setabsvol cmd cb for AV & RC connected device, send to stack");
+            iter->mAbsoluteVolumeChangeInProgress = true;
+            setAbsVolume(&iter->mDevice, (int)pEvent->avrcpCtrlEvent.arg2,
+                                         (int)pEvent->avrcpCtrlEvent.arg1);
+        }
+        else
+        {
+            ALOGD(LOGTAG_CTRL " Avrcp not connected or AV not connected");
+        }
+        break;
+    case AVRCP_CTRL_REG_NOTI_ABS_VOL_CB:
+        iter = FindAvDeviceByAddr(pA2dpSink->pA2dpDeviceList, pEvent->avrcpCtrlEvent.bd_addr);
+        if (iter != pA2dpSink->pA2dpDeviceList.end() && (iter->mAvrcpConnected == true))
+        {
+            ALOGD(LOGTAG_CTRL " NOTI_ABS_VOL_CB for AV & RC connected device, send to stack");
+            iter->mNotificationLabel = (int)pEvent->avrcpCtrlEvent.arg1;
+            iter->mAbsVolNotificationRequested = true;
+            perVol = getVolumePercentage();
+            ALOGD(LOGTAG_CTRL " Sending Interim Response = %d label %d", perVol,
+                                                      iter->mNotificationLabel);
+            sBtAvrcpCtrlInterface->register_abs_vol_rsp(&pEvent->avrcpCtrlEvent.bd_addr,
+                    BTRC_NOTIFICATION_TYPE_INTERIM, perVol, iter->mNotificationLabel);
+        }
+        else
+        {
+            ALOGD(LOGTAG_CTRL " Avrcp not connected or AV not connected");
+        }
+        break;
+    case AVRCP_CTRL_VOL_CHANGED_NOTI_REQ:
+        ALOGD(LOGTAG_CTRL " AVRCP_CTRL_VOL_CHANGED_NOTI_REQ, vol level = %d",
+                                                 pEvent->avrcpCtrlEvent.arg1);
+        iter = pA2dpSink->pA2dpDeviceList.begin();
+        while(iter != pA2dpSink->pA2dpDeviceList.end()) {
+            if (iter->mAbsoluteVolumeChangeInProgress)
+            {
+                iter->mAbsoluteVolumeChangeInProgress = false;
+            }
+            else
+            {
+                ALOGD(LOGTAG_CTRL " iter->mAvrcpConnected %d ", iter->mAvrcpConnected);
+                ALOGD(LOGTAG_CTRL " iter->mAbsVolNotificationRequested %d",
+                                    iter->mAbsVolNotificationRequested);
+                if (iter->mAvrcpConnected && iter->mAbsVolNotificationRequested)
+                {
+                    perVol = (((int)pEvent->avrcpCtrlEvent.arg1*ABS_VOL_BASE)/AUDIO_MAX_VOL_LEVEL);
+                    curr_audio_index = (int)pEvent->avrcpCtrlEvent.arg1;
+                    ALOGD(LOGTAG_CTRL " perVol %d & mPreviousPercentageVol %d", perVol,
+                                                    mPreviousPercentageVol);
+                    if (perVol != mPreviousPercentageVol)
+                    {
+                        sBtAvrcpCtrlInterface->register_abs_vol_rsp(&iter->mDevice,
+                                BTRC_NOTIFICATION_TYPE_CHANGED, perVol, iter->mNotificationLabel);
+                        iter->mAbsVolNotificationRequested = false;
+                    }
+                }
+                else
+                    ALOGD(LOGTAG_CTRL " iter %x !conn to RC or !reg for Abs vol change noti", iter);
+            }
+            iter++;
+        }
+        mPreviousPercentageVol = perVol;
+        pA2dpSinkStream->SetStreamVol(curr_audio_index);
+        break;
+    }
+}
+
+void Avrcp::HandleEnableAvrcp(void) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG_CTRL " HandleEnableAvrcp ");
+
+    max_avrcp_conn = config_get_int (config,
+            CONFIG_DEFAULT_SECTION, "BtMaxA2dpConn", 1);
+
+    if (bluetooth_interface != NULL)
+    {
+        // AVRCP CT Initialization
+        sBtAvrcpCtrlInterface = (btrc_ctrl_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_AV_RC_CTRL_ID);
+
+        // AVRCP CT Vendor Initialization
+        sBtAvrcpCtrlVendorInterface = (btrc_ctrl_vendor_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_AV_RC_CTRL_VENDOR_ID);
+
+        if (sBtAvrcpCtrlInterface == NULL || sBtAvrcpCtrlVendorInterface == NULL)
+        {
+             pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+             pEvent->profile_start_event.profile_id = PROFILE_ID_AVRCP;
+             pEvent->profile_start_event.status = false;
+             PostMessage(THREAD_ID_GAP, pEvent);
+             return;
+        }
+
+        if (sBtAvrcpCtrlInterface != NULL) {
+            sBtAvrcpCtrlInterface->init(&sBluetoothAvrcpCtrlCallbacks);
+        }
+
+        if (sBtAvrcpCtrlVendorInterface != NULL) {
+            sBtAvrcpCtrlVendorInterface->
+                    init_vendor(&sBluetoothAvrcpCtrlVendorCallbacks, max_avrcp_conn);
+        }
+
+        pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+        pEvent->profile_start_event.profile_id = PROFILE_ID_AVRCP;
+        pEvent->profile_start_event.status = true;
+
+        PostMessage(THREAD_ID_GAP, pEvent);
+    }
+}
+
+void Avrcp::HandleDisableAvrcp(void) {
+    ALOGD(LOGTAG_CTRL " HandleDisableAvrcp ");
+
+   if (sBtAvrcpCtrlInterface != NULL) {
+       sBtAvrcpCtrlInterface->cleanup();
+       sBtAvrcpCtrlInterface = NULL;
+   }
+   if (sBtAvrcpCtrlVendorInterface != NULL) {
+       sBtAvrcpCtrlVendorInterface->cleanup_vendor();
+       sBtAvrcpCtrlVendorInterface = NULL;
+   }
+   BtEvent *pEvent = new BtEvent;
+   pEvent->profile_stop_event.event_id = PROFILE_EVENT_STOP_DONE;
+       pEvent->profile_stop_event.profile_id = PROFILE_ID_AVRCP;
+       pEvent->profile_stop_event.status = true;
+       PostMessage(THREAD_ID_GAP, pEvent);
+}
+
+char* Avrcp::dump_message(BluetoothEventId event_id) {
+    switch(event_id) {
+    case AVRCP_CTRL_CONNECTED_CB:
+        return "AVRCP_CTRL_CONNECTED_CB";
+    case AVRCP_CTRL_DISCONNECTED_CB:
+        return "AVRCP_CTRL_DISCONNECTED_CB";
+    case AVRCP_CTRL_PASS_THRU_CMD_REQ:
+        return "PASS_THRU_CMD_REQ";
+    }
+    return "UNKNOWN";
+}
+
+Avrcp :: Avrcp(const bt_interface_t *bt_interface, config_t *config) {
+    this->bluetooth_interface = bt_interface;
+    this->config = config;
+    sBtAvrcpCtrlInterface = NULL;
+    max_avrcp_conn = 0;
+    memset(&mConnectedAvrcpDevice, 0, sizeof(bt_bdaddr_t));
+    pthread_mutex_init(&this->lock, NULL);
+    mPreviousPercentageVol = -1;
+    mFirstAbsVolCmdRecvd = false;
+}
+
+Avrcp :: ~Avrcp() {
+    pthread_mutex_destroy(&lock);
+    rc_only_devices.clear();
+}
diff --git a/bt-app/conf/bt_app.conf b/bt-app/conf/bt_app.conf
index 36a481f..de952f7 100644
--- a/bt-app/conf/bt_app.conf
+++ b/bt-app/conf/bt_app.conf
@@ -25,12 +25,35 @@ BtPanNapRoleSupported=true
 
 # PANU role Support
 # valid value : true, false
-BtPanPanuRoleSupported=false
+BtPanPanuRoleSupported=true
 
 # Enable GATT by default
 # valid value : true, false
 BtGattEnable=true
 
+# Enable OBEX by default
+# valid value : true, false
+BtObexEnable=true
+
+# OBEX logging levels
+# valid value: 1-6
+# 0 - Application output
+# 1 - Error message output
+# 2 - Warning message output
+# 3 - User API function trace output
+# 4 - Catagory 1 debug print output
+# 5 - Catagory 2 debug print output
+# 6 - Error/Debug output header
+BtObexLogLevel=3
+
+# Enable Pbap Client by default
+# valid value : true, false
+BtPbapClientEnable=true
+
+# Enable OPP Client & Server by default
+# valid value : true, false
+BtOppEnable=true
+
 # Enable BLE Supported Profiles
 # valid value : Even Bits per profile
 # REMOTE_START_PROFILE            (0x01)
@@ -53,6 +76,34 @@ BtScanMode=2
 # valid value : true, false
 BtA2dpSinkEnable=true
 
+# AVRCP Enable
+# valid value : true, false
+BtAvrcpEnable=true
+
 # HFP client Enable
 # valid value : true, false
 BtHfClientEnable=true
+
+# HFP AG Enable
+# valid value : true, false
+# AG and HFP client are mutually exclusive. Enable only one at a time
+BtHfpAGEnable=false
+
+# A2DP Source Enable
+# valid value : true, false
+BtA2dpSourceEnable=false
+
+# Use A2DP HAL for A2DP Sink
+# valid value : true, false
+BtUseA2dpHalForSink=false
+
+# Fetch RTP info for A2DP Sink
+# valid value : true, false
+BtFetchRTPForSink = false;
+# Max a2dp sink and avrcp ct connections
+# valid value : 1 and 2
+BtMaxA2dpConn=1
+
+# Relay data from src to sink
+# valid value : true, false
+BtRelaySinkDatatoSrc=false 
diff --git a/bt-app/conf/ext_to_mimetype.conf b/bt-app/conf/ext_to_mimetype.conf
new file mode 100644
index 0000000..3865811
--- /dev/null
+++ b/bt-app/conf/ext_to_mimetype.conf
@@ -0,0 +1,34 @@
+# Extension to Mime Type Mapping Configuration File.
+
+#Format used in this file
+#<extension><,><mime type>
+
+ics,text/calendar
+vcs,text/x-vcalendar
+vcf,text/x-vcard
+vnt,text/x-vnote
+vmg,text/x-vmsg
+jpeg,image/jpeg
+tiff,image/tiff
+gif,image/gif
+jpg,image/jpeg
+bmp,image/jpeg
+mp3,audio/mpeg
+mp4,video/mpeg
+mpeg,video/mpeg
+qt,video/qt
+txt,text/plain
+pdf,application/pdf
+ppt,application/vnd.ms-powerpoint
+pptx,application/vnd.openxmlformats-officedocument.presentationml.presentation
+xls,application/vnd.ms-excel
+xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
+doc,application/msword
+docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document
+html,text/html
+xml,application/xml
+exe,application/octet-stream
+zip,application/zip
+tar.gz,application/x-tar
+tgz,application/x-tar
+apk,application/vnd.android.package-archive
\ No newline at end of file
diff --git a/bt-app/configure.ac b/bt-app/configure.ac
old mode 100755
new mode 100644
index 2c7f5ef..15f529c
--- a/bt-app/configure.ac
+++ b/bt-app/configure.ac
@@ -15,6 +15,38 @@ AC_PROG_LN_S
 AC_PROG_MAKE_SET
 PKG_PROG_PKG_CONFIG
 
+AC_ARG_WITH([glib],
+     AC_HELP_STRING([--with-glib],
+        [enable glib, building HLOS systems which use glib]))
+
+if (test "x${with_glib}" = "xyes"); then
+       PKG_CHECK_MODULES(GTHREAD, gthread-2.0 >= 2.16, dummy=yes,
+                               AC_MSG_ERROR(GThread >= 2.16 is required))
+       PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.16, dummy=yes,
+                               AC_MSG_ERROR(GLib >= 2.16 is required))
+       GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
+       GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
+
+       AC_SUBST(GLIB_CFLAGS)
+       AC_SUBST(GLIB_LIBS)
+
+       AC_ARG_WITH([gstreamer],
+           AS_HELP_STRING([--with-gstreamer],[use gstreamer pipeline for audio playback]))
+       USE_GST=NO
+       if test "x$with_gstreamer" = "xyes"; then
+           PKG_CHECK_MODULES(GSTREAMER, [gstreamer-1.0 gstreamer-tag-1.0], USE_GST=yes, USE_GST=no)
+       fi
+       AC_SUBST(GSTREAMER_LIBS)
+       AC_SUBST(GSTREAMER_CFLAGS)
+       AC_SUBST(USE_GST)
+       AM_CONDITIONAL(USE_GST, test "x$USE_GST" = "xyes")
+       if test "x$USE_GST" = "xyes"; then
+           AC_DEFINE(USE_GST, 1, [Define if use GStreamer])
+       fi
+fi
+
+AM_CONDITIONAL(USE_GLIB, test "x${with_glib}" = "xyes")
+
 # Library configs
 AC_ARG_WITH([common_includes],
       AC_HELP_STRING([--with-common-includes=@<:@dir@:>@],
@@ -26,7 +58,30 @@ if test "x$with_common_includes" != "xno"; then
    CFLAGS="${CFLAGS} -I${common_incdir}"
 fi
 
+AC_ARG_WITH([lib_path],
+      AC_HELP_STRING([--with-lib-path=@<:@dir@:>@],
+         [Specify the location of the libraries]),
+      [std_libdir=$withval],
+      with_lib_path=no)
+
+if test "x$with_lib_path" != "xno"; then
+   SYS_LIB=${std_libdir}
+fi
+
+AC_ARG_WITH([btobex],
+     AC_HELP_STRING([--with-btobex],
+        [enable btobex, building BT-APP which uses BTOBEX]))
+
+AM_CONDITIONAL(USE_BT_OBEX, test "x${with_btobex}" = "xyes")
+
+AC_ARG_ENABLE(target,
+  [AS_HELP_STRING([--enable-target=TARGET], [Specify the target product to build])],
+  [TARGET=$enableval],
+  [TARGET=none]
+)
+AM_CONDITIONAL([AUDIO_HAL_SUPPORTED], [test "x$TARGET" = "xapq8009" -o "x$TARGET" = "xapq8017" -o "x$TARGET" = "xapq8096" -o "x$TARGET" = "xapq8053" -o "x$TARGET" = "xapq8098"])
 
+AC_SUBST(SYS_LIB)
 AC_SUBST([CFLAGS])
 AC_SUBST([CC])
 AC_CONFIG_FILES([Makefile\
diff --git a/bt-app/gap/include/Gap.hpp b/bt-app/gap/include/Gap.hpp
index 3a68941..a0401d5 100644
--- a/bt-app/gap/include/Gap.hpp
+++ b/bt-app/gap/include/Gap.hpp
@@ -22,6 +22,8 @@
 #include <map>
 #include <string>
 #include <hardware/bluetooth.h>
+#include <hardware/vendor.h>
+#include <hardware/bt_sock.h>
 
 #include "osi/include/log.h"
 #include "osi/include/thread.h"
@@ -31,6 +33,11 @@
 #include "AdapterProperties.hpp"
 #include "RemoteDevices.hpp"
 
+#ifdef USE_GLIB
+#include <glib.h>
+#define strlcpy g_strlcpy
+#endif
+
 /**
  * @file Gap.hpp
  * @brief gap header file
@@ -108,6 +115,17 @@ class Gap {
      *  structure object for standard Bluetooth DM interface
      */
     const bt_interface_t *bluetooth_interface_;
+
+    /**
+     *  structure object for Vendor interface
+     */
+    const btvendor_interface_t *sBtVendorInterface;
+
+    /**
+     *  structure object for standard Bluetooth Socket interface
+     */
+    btsock_interface_t *sock_interface_;
+
     /**
      *  class object for @ref AdapterProperties class
      */
@@ -122,6 +140,13 @@ class Gap {
     int supported_profiles_count;
 
     bool is_user_input_enabled_;
+
+#ifdef USE_BT_OBEX
+    bool is_obex_enabled_;
+
+    int obex_logging_level_;
+#endif
+
     /**
      * @brief HandlePinRequestEvent
      *
diff --git a/bt-app/gap/src/Gap.cpp b/bt-app/gap/src/Gap.cpp
index 0388c2d..7e824f2 100644
--- a/bt-app/gap/src/Gap.cpp
+++ b/bt-app/gap/src/Gap.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  * Copyright (C) 2012 The Android Open Source Project
  *
@@ -28,14 +28,29 @@
 #include "osi/include/log.h"
 #include "Gap.hpp"
 #include "utils.h"
+#ifdef USE_BT_OBEX
+#include "oi_obex.h"
+#include "oi_obex_lower.h"
+#include "oi_wrapper.h"
+#include "oi_osinterface.h"
+#endif
 
 const char *BT_LOCAL_DEV_NAME = "BtLocalDeviceName";
 const char *BT_SCAN_MODE_TYPE = "BtScanMode";
 const char *BT_USR_INPUT     = "UserInteractionNeeded";
 const char *BT_A2DP_SINK_ENABLED_STRING  = "BtA2dpSinkEnable";
+const char *BT_A2DP_SOURCE_ENABLED_STRING  = "BtA2dpSourceEnable";
 const char *BT_HFP_CLIENT_ENABLED_STRING  = "BtHfClientEnable";
 const char *BT_PAN_ENABLED    = "BtPanEnable";
 const char *BT_GATT_ENABLED   = "BtGattEnable";
+#ifdef USE_BT_OBEX
+const char *BT_OBEX_ENABLED    = "BtObexEnable";
+const char *BT_OBEX_LOG_LEVEL    = "BtObexLogLevel";
+const char *BT_PBAP_CLIENT_ENABLED   = "BtPbapClientEnable";
+const char *BT_OPP_ENABLED   = "BtOppEnable";
+#endif
+const char *BT_HFP_AG_ENABLED_STRING  = "BtHfpAGEnable";
+const char *BT_AVRCP_ENABLED_STRING  = "BtAvrcpEnable";
 
 #define LOGTAG "GAP "
 
@@ -229,6 +244,7 @@ static void EnergyInfoRecvCb(bt_activity_energy_info *p_energy_info) {
     ALOGV (LOGTAG " EnergyInfoRecvCb: ");
 }
 
+//TODO: update the callbacks, made NULL to compile
 static bt_callbacks_t sBluetoothCallbacks = {
     sizeof(sBluetoothCallbacks),
     AdapterStateChangeCallback,
@@ -243,8 +259,21 @@ static bt_callbacks_t sBluetoothCallbacks = {
     CbThreadEvent,
     DutModeRecvCb,
     LeTestModeRecvCb,
-    EnergyInfoRecvCb,
     NULL,
+    NULL,
+};
+
+static void SsrCleanupCb() {
+    ALOGV (LOGTAG " SsrCleanupCb: ");
+    BtEvent *event = new BtEvent;
+    event->event_id = GAP_EVENT_SSR_CLEANUP;
+    PostMessage(THREAD_ID_GAP, event);
+}
+
+static btvendor_callbacks_t sVendorCallbacks = {
+    sizeof(sVendorCallbacks),
+    NULL,
+    SsrCleanupCb,
 };
 
 void BtGapMsgHandler(void *msg) {
@@ -379,7 +408,7 @@ void Gap::HandleBondStateEvent(DeviceBondStateEventInt *event) {
 void Gap::HandleEnable(void) {
     BtEvent  *bt_event  = NULL;
     if (adapter_properties_obj_->GetState() == BT_ADAPTER_STATE_OFF) {
-       if(bluetooth_interface_->enable() == BT_STATUS_SUCCESS) {
+       if(bluetooth_interface_->enable(false) == BT_STATUS_SUCCESS) {
            alarm_set(enable_timer, ENABLE_TIMEOUT_DELAY, enable_timer_expired, NULL);
            adapter_properties_obj_->SetState(BT_ADAPTER_STATE_TURNING_ON);
            return;
@@ -478,8 +507,8 @@ void Gap::ProcessEvent(BtEvent* event) {
                 bluetooth_interface_->set_adapter_property(&prop);
 
                 prop.type = BT_PROPERTY_BDNAME;
-                strcpy((char*)&bd_name.name[0], config_get_string (config_,
-                   CONFIG_DEFAULT_SECTION, BT_LOCAL_DEV_NAME, "MDM_Fluoride"));
+                strlcpy((char*)&bd_name.name[0], config_get_string (config_,
+                   CONFIG_DEFAULT_SECTION, BT_LOCAL_DEV_NAME, "MDM_Fluoride"), sizeof(bd_name));
                 prop.val = &bd_name;
                 prop.len = strlen((char*)bd_name.name);
                 bluetooth_interface_->set_adapter_property(&prop);
@@ -502,15 +531,22 @@ void Gap::ProcessEvent(BtEvent* event) {
                 prop.len = sizeof(bt_scan_mode_t);
                 bluetooth_interface_->set_adapter_property(&prop);
 
+                adapter_properties_obj_->FlushBondedDeviceList();
+                remote_devices_obj_->FlushDiscoveredDeviceList();
+                // cleanup the stack
+                bluetooth_interface_->cleanup();
+#ifdef USE_BT_OBEX
+                if (is_obex_enabled_) {
+                    OI_OBEX_LOWER_SetSocketInterface(NULL);
+                    OI_OBEX_Deinit();
+                    sock_interface_ = NULL;
+                }
+#endif
                 bt_event = new BtEvent;
                 bt_event->event_id = MAIN_EVENT_DISABLED;
                 bt_event->state_event.status = event->state_event.status;
                 PostMessage(THREAD_ID_MAIN, bt_event);
 
-                adapter_properties_obj_->FlushBondedDeviceList();
-                remote_devices_obj_->FlushDiscoveredDeviceList();
-                // cleanup the stack
-                bluetooth_interface_->cleanup();
             }
             break;
 
@@ -519,6 +555,19 @@ void Gap::ProcessEvent(BtEvent* event) {
             if (adapter_properties_obj_->GetState() == BT_ADAPTER_STATE_OFF) {
                 bluetooth_interface_->init(&sBluetoothCallbacks);
             }
+            else {
+                ALOGV (LOGTAG "Ignoring GAP_API_ENABLE command state : %d",
+                                adapter_properties_obj_->GetState());
+                fprintf(stdout, "Ignoring GAP_API_ENABLE command state : %d\n",
+                                adapter_properties_obj_->GetState());
+
+                //Sending update to the Main thread
+                bt_event = new BtEvent;
+                bt_event->event_id = MAIN_EVENT_ENABLED;
+                bt_event->state_event.status = BT_STATE_ON;
+                PostMessage(THREAD_ID_MAIN, bt_event);
+                break;
+            }
 
             // check if there are profiles enabled
             if(!supported_profiles_count) {
@@ -529,6 +578,20 @@ void Gap::ProcessEvent(BtEvent* event) {
             ALOGV (LOGTAG "Start QC BT Daemon");
             system("qcbtdaemon &");
 
+#ifdef USE_BT_OBEX
+            /* Initialize OBEX if enabled in config */
+            if (is_obex_enabled_) {
+                if ((sock_interface_ = (btsock_interface_t *)
+                    bluetooth_interface_->get_profile_interface(BT_PROFILE_SOCKETS_ID)) == NULL) {
+                    ALOGE(LOGTAG "%s: Failed to get Bluetooth socket interface", __FUNCTION__);
+                } else {
+                    OI_OBEX_Init(50);
+                    OI_OBEX_LOWER_SetSocketInterface(sock_interface_);
+                    OI_SetLogLevel(obex_logging_level_);
+                }
+            }
+#endif
+
             // reset start status for all supported profiles
             for(profile_id = PROFILE_ID_A2DP_SINK; profile_id < PROFILE_ID_MAX;
                                                                 profile_id++) {
@@ -546,6 +609,8 @@ void Gap::ProcessEvent(BtEvent* event) {
                 if(profile_config[profile_id].is_enabled) {
                     bt_event = new BtEvent;
                     bt_event->event_id = PROFILE_API_START;
+                    ALOGD(LOGTAG " sending start to Profile %d",
+                        profile_id);
                     PostMessage(profile_config[profile_id].thread_id, bt_event);
                 }
             }
@@ -559,6 +624,8 @@ void Gap::ProcessEvent(BtEvent* event) {
                 if((profile_config[profile_id].is_enabled)  &&
                    ((profile_config[profile_id].profile_id ==
                             event->profile_start_event.profile_id))) {
+                    ALOGD(LOGTAG " Profile %d started with status %d",
+                        profile_id, event->profile_stop_event.status);
                     profile_config[profile_id].start_status =
                     event->profile_start_event.status;
                 }
@@ -587,6 +654,8 @@ void Gap::ProcessEvent(BtEvent* event) {
                 if((profile_config[profile_id].is_enabled)  &&
                    ((profile_config[profile_id].profile_id ==
                         event->profile_stop_event.profile_id))) {
+                    ALOGD(LOGTAG " Profile %d stopped with status %d",
+                        profile_id, event->profile_stop_event.status);
                     profile_config[profile_id].stop_status =
                     event->profile_stop_event.status;
                 }
@@ -616,14 +685,35 @@ void Gap::ProcessEvent(BtEvent* event) {
             kill(getpid(), SIGKILL);
             break;
         case GAP_API_DISABLE:
-            bt_event = new BtEvent;
-            bt_event->event_id = A2DP_SINK_CLEANUP_REQ;
-            PostMessage(THREAD_ID_A2DP_SINK, bt_event);
-            break;
+            if (adapter_properties_obj_->GetState() != BT_ADAPTER_STATE_ON) {
+                ALOGV (LOGTAG "Ignoring GAP_API_DISABLE command state : %d",
+                                            adapter_properties_obj_->GetState());
+                fprintf(stdout, "Ignoring GAP_API_DISABLE command state : %d\n",
+                                            adapter_properties_obj_->GetState());
+
+                //Sending update to the Main thread
+                bt_event = new BtEvent;
+                bt_event->event_id = MAIN_EVENT_DISABLED;
+                bt_event->state_event.status = BT_STATE_OFF;
+                PostMessage(THREAD_ID_MAIN, bt_event);
+                break;
+
+            }
+            if (profile_config[PROFILE_ID_A2DP_SINK].is_enabled)
+            {
+                bt_event = new BtEvent;
+                bt_event->event_id = A2DP_SINK_CLEANUP_REQ;
+                PostMessage(THREAD_ID_A2DP_SINK, bt_event);
+                break;
+            }
+
+            /*Fall through*/
         case A2DP_SINK_CLEANUP_DONE:
             // check if there are profiles enabled
             if(!supported_profiles_count) {
                 HandleDisable();
+                ALOGV (LOGTAG "Stop QC BT Daemon");
+                system("killall -s SIGTERM qcbtdaemon");
                 break;
             }
 
@@ -655,6 +745,7 @@ void Gap::ProcessEvent(BtEvent* event) {
 
         case GAP_API_SET_BDNAME:
             SetBtName(&event->set_device_name_event.prop);
+            config_set_string(config_,CONFIG_DEFAULT_SECTION,BT_LOCAL_DEV_NAME,(char *)event->set_device_name_event.prop.val);
             break;
 
         case GAP_EVENT_DEVICE_FOUND_INT:
@@ -712,6 +803,12 @@ void Gap::ProcessEvent(BtEvent* event) {
             HandlePinReply(&event->pin_reply_event);
             break;
 
+        case GAP_EVENT_SSR_CLEANUP:
+            /* Audio related cleanup can be done here.*/
+            ALOGD(LOGTAG " Killing the proces after SSR_CLEANUP %d", event->event_id);
+            kill(getpid(), SIGKILL);
+            break;
+
         default:
             ALOGD(LOGTAG " Unhandled event %d", event->event_id);
             break;
@@ -734,6 +831,14 @@ Gap :: Gap(const bt_interface_t *bt_interface, config_t *config) {
     is_user_input_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
                                     BT_USR_INPUT, false);
 
+#ifdef USE_BT_OBEX
+    is_obex_enabled_ = config_get_bool (config,
+                     CONFIG_DEFAULT_SECTION, BT_OBEX_ENABLED, false);
+
+    obex_logging_level_ = config_get_int (config,
+                     CONFIG_DEFAULT_SECTION, BT_OBEX_LOG_LEVEL, OI_MSG_CODE_TRACE);
+#endif
+
     if ((bluetooth_interface_->init(&sBluetoothCallbacks) == BT_STATUS_SUCCESS))
         bt_interface->set_os_callouts(&callouts);
 
@@ -751,22 +856,46 @@ Gap :: Gap(const bt_interface_t *bt_interface, config_t *config) {
 
         if(profile_id == PROFILE_ID_BT_AM)
             this->profile_config[profile_id].thread_id = THREAD_ID_BT_AM;
-        if(profile_id == PROFILE_ID_A2DP_SINK)
+        else if(profile_id == PROFILE_ID_A2DP_SINK)
             this->profile_config[profile_id].thread_id = THREAD_ID_A2DP_SINK;
+        else if(profile_id == PROFILE_ID_A2DP_SOURCE)
+            this->profile_config[profile_id].thread_id = THREAD_ID_A2DP_SOURCE;
         else if(profile_id == PROFILE_ID_HFP_CLIENT)
             this->profile_config[profile_id].thread_id = THREAD_ID_HFP_CLIENT;
         else if (profile_id == PROFILE_ID_PAN)
             this->profile_config[profile_id].thread_id = THREAD_ID_PAN;
         else if (profile_id == PROFILE_ID_GATT)
             this->profile_config[profile_id].thread_id = THREAD_ID_GATT;
+        else if (profile_id == PROFILE_ID_SDP_CLIENT)
+            this->profile_config[profile_id].thread_id = THREAD_ID_SDP_CLIENT;
+#ifdef USE_BT_OBEX
+        else if (profile_id == PROFILE_ID_PBAP_CLIENT)
+            this->profile_config[profile_id].thread_id = THREAD_ID_PBAP_CLIENT;
+        else if (profile_id == PROFILE_ID_OPP)
+            this->profile_config[profile_id].thread_id = THREAD_ID_OPP;
+#endif
+        else if(profile_id == PROFILE_ID_HFP_AG)
+            this->profile_config[profile_id].thread_id = THREAD_ID_HFP_AG;
+        else if(profile_id == PROFILE_ID_AVRCP)
+            this->profile_config[profile_id].thread_id = THREAD_ID_AVRCP;
+
     }
 
     this->profile_config[PROFILE_ID_A2DP_SINK].is_enabled = config_get_bool (config,
                      CONFIG_DEFAULT_SECTION, BT_A2DP_SINK_ENABLED_STRING, false);
 
+    this->profile_config[PROFILE_ID_A2DP_SOURCE].is_enabled = config_get_bool (config,
+                     CONFIG_DEFAULT_SECTION, BT_A2DP_SOURCE_ENABLED_STRING, false);
+
     this->profile_config[PROFILE_ID_HFP_CLIENT].is_enabled = config_get_bool (config,
                      CONFIG_DEFAULT_SECTION, BT_HFP_CLIENT_ENABLED_STRING, false);
 
+    this->profile_config[PROFILE_ID_HFP_AG].is_enabled = config_get_bool (config,
+                     CONFIG_DEFAULT_SECTION, BT_HFP_AG_ENABLED_STRING, false);
+
+    this->profile_config[PROFILE_ID_AVRCP].is_enabled = config_get_bool (config,
+                     CONFIG_DEFAULT_SECTION, BT_AVRCP_ENABLED_STRING, false);
+
     if ((this->profile_config[PROFILE_ID_A2DP_SINK].is_enabled) ||
         (this->profile_config[PROFILE_ID_HFP_CLIENT].is_enabled)) {
         this->profile_config[PROFILE_ID_BT_AM].is_enabled = true;
@@ -778,12 +907,30 @@ Gap :: Gap(const bt_interface_t *bt_interface, config_t *config) {
     this->profile_config[PROFILE_ID_GATT].is_enabled = config_get_bool (config,
                      CONFIG_DEFAULT_SECTION, BT_GATT_ENABLED, false);
 
+    // SDP Client should be enabled and is not configurable to be disabled
+    this->profile_config[PROFILE_ID_SDP_CLIENT].is_enabled = true;
+
+#ifdef USE_BT_OBEX
+    this->profile_config[PROFILE_ID_PBAP_CLIENT].is_enabled = config_get_bool (config,
+                     CONFIG_DEFAULT_SECTION, BT_PBAP_CLIENT_ENABLED, false);
+
+    this->profile_config[PROFILE_ID_OPP].is_enabled = config_get_bool (config,
+                 CONFIG_DEFAULT_SECTION, BT_OPP_ENABLED, false);
+#endif
+
     for(profile_id = PROFILE_ID_A2DP_SINK; profile_id < PROFILE_ID_MAX;
                                                             profile_id++) {
         if(this->profile_config[profile_id].is_enabled) {
             this->supported_profiles_count++;
         }
     }
+    // Vendor interface
+    sBtVendorInterface = (btvendor_interface_t *)bluetooth_interface_->
+                            get_profile_interface(BT_PROFILE_VENDOR_ID);
+
+    if (sBtVendorInterface != NULL) {
+        sBtVendorInterface->init(&sVendorCallbacks);
+    }
 
     if( !(profile_startup_timer = alarm_new())) {
         ALOGE(LOGTAG, " unable to create profile_startup_timer timer.");
@@ -821,6 +968,11 @@ Gap :: ~Gap() {
 
     alarm_free(disable_timer);
     disable_timer = NULL;
+
+    if (sBtVendorInterface != NULL) {
+        sBtVendorInterface->cleanup();
+        sBtVendorInterface = NULL;
+    }
 }
 
 int Gap:: GetState() {
diff --git a/bt-app/gatt/include/Gatt.hpp b/bt-app/gatt/include/Gatt.hpp
deleted file mode 100755
index ab8817f..0000000
--- a/bt-app/gatt/include/Gatt.hpp
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (c) 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GATT_APP_H
-#define GATT_APP_H
-
-#pragma once
-#include <map>
-#include <string>
-#include <hardware/bluetooth.h>
-#include <hardware/bt_gatt.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "osi/include/log.h"
-#include "osi/include/thread.h"
-#include "osi/include/config.h"
-#include "osi/include/semaphore.h"
-#include "ipc.h"
-#include "Rsp.hpp"
-
-#define MAX_GATT_DEVICES    (1)
-
-#define REMOTE_START_PROFILE            (0x01)
-#define ALERT_NOTIFICATION_PROFILE      (0x02)
-#define CYCLING_SPEED__cADENCE_PROFILE  (0x04)
-#define CYCLING_POWER_PROFILE           (0x08)
-#define RUNNING_SPEED_CADENCE_PROFILE   (0x10)
-#define HUMAN_INTERFACE_DEVICE_PROFILE  (0x20)
-#define HEART_RATE_PROFILE              (0x40)
-
-extern const char *BT_GATT_ENABLED;
-
-#define CHECK_PARAM(x)                                                      \
-   if (!x) {                                                                \
-       ALOGE("'%s' Param is NULL - exiting from function ", __FUNCTION__);  \
-       return false;                                                        \
-   }
-
-#define CHECK_PARAM_VOID(x)                                                 \
-   if (!x) {                                                                \
-       ALOGE("'%s' Void Param is NULL - exiting from function ", __FUNCTION__);  \
-       return ;                                                              \
-   }
-
-class Gatt {
-    private:
-        config_t *config;
-        const bt_interface_t * bluetooth_interface;
-        btgatt_interface_t *gatt_interface;
-
-    public:
-        Rsp *rsp;
-        bt_uuid_t rsp_uuid;
-        int le_supported_profiles;
-
-        Gatt(const bt_interface_t *bt_interface, config_t *config);
-        ~Gatt();
-        void ProcessEvent(BtEvent* );
-        bool GattInterfaceInit(const bt_interface_t *);
-        void GattInterfaceCleanup(void);
-        void HandleGattIpcMsg(BtIpcMsg *);
-        void HandleGattsRegisterAppEvent(GattsRegisterAppEvent *);
-        void HandleGattsConnectionEvent(GattsConnectionEvent *);
-        void HandleGattsServiceAddedEvent(GattsServiceAddedEvent *);
-        void HandleGattsCharacteristicAddedEvent(GattsCharacteristicAddedEvent *);
-        void HandleGattsDescriptorAddedEvent(GattsDescriptorAddedEvent *);
-        void HandleGattsServiceStartedEvent(GattsServiceStartedEvent *);
-        void HandleGattsServiceStoppedEvent(GattsServiceStoppedEvent *);
-        void HandleGattsServiceDeletedEvent(GattsServiceDeletedEvent *);
-        void HandleGattsRequestWriteEvent(GattsRequestWriteEvent *);
-        void HandleGattcRegisterAppEvent(GattcRegisterAppEvent *);
-        void HandleRspEnableEvent(RspEnableEvent *);
-        void HandleRspDisableEvent(RspDisableEvent *);
-        bool HandleEnableGatt(void);
-        bool HandleDisableGatt(void);
-};
-#endif
-
diff --git a/bt-app/gatt/include/Rsp.hpp b/bt-app/gatt/include/Rsp.hpp
deleted file mode 100755
index ee23e20..0000000
--- a/bt-app/gatt/include/Rsp.hpp
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright (c) 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef RSP_APP_H
-#define RSP_APP_H
-
-#pragma once
-
-#include <hardware/bluetooth.h>
-#include <stdio.h>
-
-#include "osi/include/log.h"
-#include "osi/include/thread.h"
-#include "osi/include/config.h"
-#include "ipc.h"
-#include "Rsp.hpp"
-#include "Gatt.hpp"
-
-#define RSP_MIN_CI           (100)
-#define RSP_MAX_CI           (1000)
-
-#define GATT_PROP_READ       (0x02)
-#define GATT_PROP_WRITE      (0x08)
-
-#define GATT_PERM_READ       (0x01)
-#define GATT_PERM_WRITE      (0x10)
-
-#define LOGTAG "RSP "
-
-typedef enum
-{
-    WLAN_ACTIVE = 1,
-    WLAN_INACTIVE,
-    WLAN_TRANSACTION_PENDING,
-} rsp_power_state_t;
-
-class Rsp {
-    private:
-        config_t *config;
-        int wlan_state;
-
-        RspEnableEvent attr;
-        GattcRegisterAppEvent app_client_if;
-        GattsRegisterAppEvent app_if;
-        GattsServiceAddedEvent srvc_data;
-        GattsCharacteristicAddedEvent char_data;
-        GattsDescriptorAddedEvent desc_data;
-        GattsConnectionEvent conn_data;
-        btgatt_interface_t *gatt_interface;
-
-    public:
-        Rsp(btgatt_interface_t *);
-        ~Rsp();
-        bool EnableRSP();
-        bool DisableRSP(int server_if);
-        inline btgatt_interface_t* GetGattInterface()
-        {
-            return gatt_interface;
-        }
-        inline int GetDeviceState()
-        {
-            fprintf(stdout, "(%s) WLAN Current State (%d) \n",__FUNCTION__, wlan_state);
-            return wlan_state;
-        }
-        inline void SetDeviceState(int currentstate)
-        {
-            fprintf(stdout, "(%s) WLAN Prev State (%d) New State(%d) \n",__FUNCTION__, wlan_state,
-                    currentstate);
-            wlan_state = currentstate;
-        }
-        inline void SetRSPClientAppData(GattcRegisterAppEvent *event)
-        {
-            memset(&app_client_if, 0, sizeof(app_client_if));
-            memcpy(&app_client_if, event, sizeof(GattcRegisterAppEvent));
-        }
-        inline GattcRegisterAppEvent* GetRSPClientAppData()
-        {
-            return &app_client_if;
-        }
-        inline void SetRSPAttrData(RspEnableEvent *attrib)
-        {
-            memset (&attr, 0, sizeof(RspEnableEvent));
-            memcpy (&attr, attrib, sizeof(RspEnableEvent));
-        }
-        inline RspEnableEvent* GetRSPAttrData()
-        {
-            return &attr;
-        }
-        inline void SetRSPAppData(GattsRegisterAppEvent *event)
-        {
-            memset(&app_if, 0, sizeof(GattsRegisterAppEvent));
-            memcpy(&app_if, event, sizeof(GattsRegisterAppEvent));
-        }
-        inline GattsRegisterAppEvent* GetRSPAppData()
-        {
-            return &app_if;
-        }
-        inline void SetRSPSrvcData(GattsServiceAddedEvent *event)
-        {
-            memset(&srvc_data, 0, sizeof(GattsServiceAddedEvent));
-            memcpy(&srvc_data, event, sizeof(GattsServiceAddedEvent));
-        }
-        inline GattsServiceAddedEvent* GetRspSrvcData()
-        {
-            return &srvc_data;
-        }
-        inline void SetRSPCharacteristicData(GattsCharacteristicAddedEvent
-                *event)
-        {
-            memset(&char_data, 0, sizeof(GattsCharacteristicAddedEvent));
-            memcpy(&char_data, event, sizeof(GattsCharacteristicAddedEvent));
-        }
-        inline GattsCharacteristicAddedEvent* GetRSPCharacteristicData()
-        {
-            return &char_data;
-        }
-        inline void SetRSPDescriptorData(GattsDescriptorAddedEvent *event)
-        {
-            memset(&desc_data, 0, sizeof(GattsDescriptorAddedEvent));
-            memcpy(&desc_data, event, sizeof(GattsDescriptorAddedEvent));
-        }
-        inline GattsDescriptorAddedEvent* GetRSPDescriptorData()
-        {
-            return &desc_data;
-        }
-        inline void SetRSPConnectionData(GattsConnectionEvent *event)
-        {
-            memset(&conn_data, 0, sizeof(GattsConnectionEvent));
-            memcpy(&conn_data, event, sizeof(GattsConnectionEvent));
-        }
-        inline GattsConnectionEvent* GetRSPConnectionData()
-        {
-            return &conn_data;
-        }
-        bool SendResponse(GattsRequestWriteEvent *);
-        bool CopyUUID(bt_uuid_t *);
-        bool ClientSetAdvData(char *);
-        bool CopyParams(bt_uuid_t *, bt_uuid_t *);
-        bool MatchParams(bt_uuid_t *, bt_uuid_t *);
-        bool RegisterApp(void);
-        bool DisconnectServer(void);
-        bool UnregisterServer(int);
-        bool RegisterClient(void);
-        bool UnregisterClient(int);
-        bool StartAdvertisement(void);
-        bool StopAdvertisement(void);
-        bool AddService(void);
-        bool AddCharacteristics(void);
-        bool AddDescriptor(void);
-        bool StartService(void);
-        bool StopService(void);
-        bool DeleteService(void);
-        bool HandleWlanOn(void);
-        void CleanUp(int);
-};
-#endif
-
diff --git a/bt-app/gatt/src/Gatt.cpp b/bt-app/gatt/src/Gatt.cpp
deleted file mode 100755
index 694db94..0000000
--- a/bt-app/gatt/src/Gatt.cpp
+++ /dev/null
@@ -1,998 +0,0 @@
-/*
- * Copyright (c) 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <list>
-#include <map>
-#include "osi/include/log.h"
-#include "Gatt.hpp"
-#include "Rsp.hpp"
-
-#define LOGTAG "GATT "
-#define UNUSED
-#define MAX_NUM_HANDLES     (1)
-
-using namespace std;
-using std::list;
-using std::string;
-
-Gatt *g_gatt = NULL;
-static const bt_bdaddr_t bd_addr_null={0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-void btgattc_register_app_cb(int status, int clientIf, bt_uuid_t *app_uuid)
-{
-    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, clientIf);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTC_REGISTER_APP_EVENT;
-    event->gattc_register_app_event.status = status;
-    event->gattc_register_app_event.clientIf = clientIf;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgattc_scan_result_cb(bt_bdaddr_t* bda, int rssi, uint8_t* adv_data)
-{
-    UNUSED
-}
-
-void btgattc_open_cb(int conn_id, int status, int clientIf, bt_bdaddr_t* bda)
-{
-    UNUSED
-}
-
-void btgattc_close_cb(int conn_id, int status, int clientIf, bt_bdaddr_t* bda)
-{
-    UNUSED
-}
-
-void btgattc_search_complete_cb(int conn_id, int status)
-{
-    UNUSED
-}
-
-void btgattc_search_result_cb(int conn_id, btgatt_srvc_id_t *srvc_id)
-{
-    UNUSED
-}
-
-void btgattc_get_characteristic_cb(int conn_id, int status,
-                btgatt_srvc_id_t *srvc_id, btgatt_gatt_id_t *char_id,
-                int char_prop)
-{
-    UNUSED
-}
-
-void btgattc_get_descriptor_cb(int conn_id, int status,
-                btgatt_srvc_id_t *srvc_id, btgatt_gatt_id_t *char_id,
-                btgatt_gatt_id_t *descr_id)
-{
-    UNUSED
-}
-
-void btgattc_get_included_service_cb(int conn_id, int status,
-                btgatt_srvc_id_t *srvc_id, btgatt_srvc_id_t *incl_srvc_id)
-{
-    UNUSED
-}
-
-void btgattc_register_for_notification_cb(int conn_id, int registered,
-                                                    int status, btgatt_srvc_id_t *srvc_id,
-                                                    btgatt_gatt_id_t *char_id)
-{
-    UNUSED
-}
-
-void btgattc_notify_cb(int conn_id, btgatt_notify_params_t *p_data)
-{
-    UNUSED
-}
-
-void btgattc_read_characteristic_cb(int conn_id, int status,
-    btgatt_read_params_t *p_data)
-{
-    UNUSED
-}
-
-void btgattc_write_characteristic_cb(int conn_id, int status,
-    btgatt_write_params_t *p_data)
-{
-    UNUSED
-}
-
-void btgattc_execute_write_cb(int conn_id, int status)
-{
-    UNUSED
-}
-
-void btgattc_read_descriptor_cb(int conn_id, int status, btgatt_read_params_t *p_data)
-{
-    UNUSED
-}
-
-void btgattc_write_descriptor_cb(int conn_id, int status, btgatt_write_params_t *p_data)
-{
-    UNUSED
-}
-
-void btgattc_remote_rssi_cb(int client_if,bt_bdaddr_t* bda, int rssi, int status)
-{
-    UNUSED
-}
-
-void btgattc_advertise_cb(int status, int client_if)
-{
-    fprintf(stdout,"(%s): status (%d) client_if (%d)\n",__FUNCTION__,status, client_if);
-}
-
-void btgattc_configure_mtu_cb(int conn_id, int status, int mtu)
-{
-    UNUSED
-}
-
-void btgattc_scan_filter_cfg_cb(int action, int client_if, int status, int filt_type, int avbl_space)
-{
-    UNUSED
-}
-
-void btgattc_scan_filter_param_cb(int action, int client_if, int status, int avbl_space)
-{
-    UNUSED
-}
-
-void btgattc_scan_filter_status_cb(int action, int client_if, int status)
-{
-    UNUSED
-}
-
-void btgattc_multiadv_enable_cb(int client_if, int status)
-{
-    UNUSED
-}
-
-void btgattc_multiadv_update_cb(int client_if, int status)
-{
-    UNUSED
-}
-
-void btgattc_multiadv_setadv_data_cb(int client_if, int status)
-{
-    UNUSED
-}
-
-void btgattc_multiadv_disable_cb(int client_if, int status)
-{
-    UNUSED
-}
-
-void btgattc_congestion_cb(int conn_id, bool congested)
-{
-    UNUSED
-}
-
-void btgattc_batchscan_cfg_storage_cb(int client_if, int status)
-{
-    UNUSED
-}
-void btgattc_batchscan_startstop_cb(int startstop_action, int client_if, int status)
-{
-    UNUSED
-
-}
-
-void btgattc_batchscan_reports_cb(int client_if, int status, int report_format,
-                                            int num_records, int data_len, uint8_t *p_rep_data)
-{
-    UNUSED
-}
-
-void btgattc_batchscan_threshold_cb(int client_if)
-{
-    UNUSED
-}
-
-void btgattc_track_adv_event_cb(btgatt_track_adv_info_t *p_adv_track_info)
-{
-    UNUSED
-}
-
-void btgattc_scan_parameter_setup_completed_cb(int client_if, btgattc_error_t status)
-{
-    UNUSED
-}
-
-static const btgatt_client_callbacks_t sGattClientCallbacks = {
-    btgattc_register_app_cb,
-    btgattc_scan_result_cb,
-    btgattc_open_cb,
-    btgattc_close_cb,
-    btgattc_search_complete_cb,
-    btgattc_search_result_cb,
-    btgattc_get_characteristic_cb,
-    btgattc_get_descriptor_cb,
-    btgattc_get_included_service_cb,
-    btgattc_register_for_notification_cb,
-    btgattc_notify_cb,
-    btgattc_read_characteristic_cb,
-    btgattc_write_characteristic_cb,
-    btgattc_read_descriptor_cb,
-    btgattc_write_descriptor_cb,
-    btgattc_execute_write_cb,
-    btgattc_remote_rssi_cb,
-    btgattc_advertise_cb,
-    btgattc_configure_mtu_cb,
-    btgattc_scan_filter_cfg_cb,
-    btgattc_scan_filter_param_cb,
-    btgattc_scan_filter_status_cb,
-    btgattc_multiadv_enable_cb,
-    btgattc_multiadv_update_cb,
-    btgattc_multiadv_setadv_data_cb,
-    btgattc_multiadv_disable_cb,
-    btgattc_congestion_cb,
-    btgattc_batchscan_cfg_storage_cb,
-    btgattc_batchscan_startstop_cb,
-    btgattc_batchscan_reports_cb,
-    btgattc_batchscan_threshold_cb,
-    btgattc_track_adv_event_cb,
-    btgattc_scan_parameter_setup_completed_cb
-};
-
-/**
- * GATT Server Callback Implementation
- */
-void btgatts_register_app_cb(int status, int server_if, bt_uuid_t *uuid)
-{
-    ALOGD(LOGTAG "(%s) status (%d) server_if (%d)",__FUNCTION__, status, server_if);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_REGISTER_APP_EVENT;
-    event->gatts_register_app_event.status = status;
-    event->gatts_register_app_event.server_if = server_if;
-    event->gatts_register_app_event.uuid = uuid;
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_connection_cb(int conn_id, int server_if, int connected, bt_bdaddr_t *bda)
-{
-
-    char c_address[32];
-    sprintf(c_address, "%02X:%02X:%02X:%02X:%02X:%02X",
-            bda->address[0], bda->address[1], bda->address[2],
-            bda->address[3], bda->address[4], bda->address[5]);
-
-    fprintf(stdout, "(%s) connid (%d) server_if (%d) status (%d) bda (%s)\n",__FUNCTION__, conn_id,
-            server_if, connected, c_address);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_CONNECTION_EVENT;
-    event->gatts_connection_event.conn_id = conn_id;
-    event->gatts_connection_event.server_if = server_if;
-    event->gatts_connection_event.connected = connected;
-    event->gatts_connection_event.bda = bda;
-    PostMessage(THREAD_ID_GATT, event);
-
-}
-
-void btgatts_service_added_cb(int status, int server_if,
-                              btgatt_srvc_id_t *srvc_id, int srvc_handle)
-{
-    ALOGD (LOGTAG "(%s) status (%d) server_if (%d), srvc_handle(%d))",__FUNCTION__,
-                status, server_if, srvc_handle);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_SERVICE_ADDED_EVENT;
-    event->gatts_service_added_event.status = status;
-    event->gatts_service_added_event.server_if = server_if;
-    event->gatts_service_added_event.srvc_id = srvc_id ;
-    event->gatts_service_added_event.srvc_handle = srvc_handle ;
-
-    PostMessage(THREAD_ID_GATT, event);
-
-}
-
-void btgatts_included_service_added_cb(int status, int server_if, int srvc_handle,
-        int incl_srvc_handle)
-{
-    ALOGD (LOGTAG "(%s) Status:(%d)",__FUNCTION__, status);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_INCLUDED_SERVICE_ADDED_EVENT;
-    event->gatts_included_service_added_event.status = status;
-    event->gatts_included_service_added_event.server_if = server_if;
-    event->gatts_included_service_added_event.srvc_handle = srvc_handle ;
-    event->gatts_included_service_added_event.incl_srvc_handle = incl_srvc_handle ;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_characteristic_added_cb(int status, int server_if, bt_uuid_t *char_id,
-                                                int srvc_handle, int char_handle)
-{
-    ALOGD (LOGTAG "(%s) Status:(%d)",__FUNCTION__, status);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_CHARACTERISTIC_ADDED_EVENT;
-    event->gatts_characteristic_added_event.status = status;
-    event->gatts_characteristic_added_event.server_if = server_if;
-    event->gatts_characteristic_added_event.char_id = char_id;
-    event->gatts_characteristic_added_event.srvc_handle = srvc_handle ;
-    event->gatts_characteristic_added_event.char_handle = char_handle ;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_descriptor_added_cb(int status, int server_if, bt_uuid_t *descr_id,
-                                            int srvc_handle, int descr_handle)
-{
-    ALOGD (LOGTAG "(%s) Status:(%d)",__FUNCTION__, status);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_DESCRIPTOR_ADDED_EVENT;
-    event->gatts_descriptor_added_event.status = status;
-    event->gatts_descriptor_added_event.server_if = server_if;
-    event->gatts_descriptor_added_event.descr_id  = descr_id ;
-    event->gatts_descriptor_added_event.srvc_handle = srvc_handle ;
-    event->gatts_descriptor_added_event.descr_handle = descr_handle ;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_service_started_cb(int status, int server_if, int srvc_handle)
-{
-    ALOGD (LOGTAG "(%s) Status:(%d)",__FUNCTION__, status);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_SERVICE_STARTED_EVENT;
-    event->gatts_service_started_event.status = status;
-    event->gatts_service_started_event.server_if = server_if;
-    event->gatts_service_started_event.srvc_handle = srvc_handle ;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_service_stopped_cb(int status, int server_if, int srvc_handle)
-{
-    ALOGD (LOGTAG "(%s) Status:(%d)",__FUNCTION__, status);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_SERVICE_STOPPED_EVENT;
-    event->gatts_service_stopped_event.status = status;
-    event->gatts_service_stopped_event.server_if = server_if;
-    event->gatts_service_stopped_event.srvc_handle = srvc_handle ;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_service_deleted_cb(int status, int server_if, int srvc_handle)
-{
-    ALOGD (LOGTAG "(%s) Status:(%d)",__FUNCTION__, status);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_SERVICE_DELETED_EVENT;
-    event->gatts_service_deleted_event.status = status;
-    event->gatts_service_deleted_event.server_if = server_if;
-    event->gatts_service_deleted_event.srvc_handle = srvc_handle ;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_request_read_cb(int conn_id, int trans_id, bt_bdaddr_t *bda, int attr_handle,
-                                        int offset, bool is_long)
-{
-    char c_address[32];
-    sprintf(c_address, "%02X:%02X:%02X:%02X:%02X:%02X",
-            bda->address[0], bda->address[1], bda->address[2],
-            bda->address[3], bda->address[4], bda->address[5]);
-
-    ALOGD (LOGTAG "(%s) connid:(%d) bda (%s)",__FUNCTION__, conn_id, c_address);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_REQUEST_READ_EVENT;
-    event->gatts_request_read_event.conn_id = conn_id;
-    event->gatts_request_read_event.trans_id = trans_id;
-    event->gatts_request_read_event.bda = bda;
-    event->gatts_request_read_event.attr_handle = attr_handle;
-    event->gatts_request_read_event.offset = offset;
-    event->gatts_request_read_event.is_long = is_long ;
-
-    PostMessage(THREAD_ID_GATT, event);
-
-}
-
-void btgatts_request_write_cb(int conn_id, int trans_id, bt_bdaddr_t *bda, int attr_handle,
-                                        int offset, int length, bool need_rsp, bool is_prep,
-                                        uint8_t* value)
-{
-    char c_address[32];
-    sprintf(c_address, "%02X:%02X:%02X:%02X:%02X:%02X",
-            bda->address[0], bda->address[1], bda->address[2],
-           bda->address[3], bda->address[4], bda->address[5]);
-
-    fprintf(stdout, "(%s) connid:(%d) bdaddr:(%s) value (%s) need_rsp (%d)\n",__FUNCTION__, conn_id,
-            c_address, value, need_rsp);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_REQUEST_WRITE_EVENT;
-    event->gatts_request_write_event.conn_id = conn_id;
-    event->gatts_request_write_event.trans_id = trans_id;
-    event->gatts_request_write_event.bda = bda;
-    event->gatts_request_write_event.attr_handle = attr_handle;
-    event->gatts_request_write_event.offset = offset;
-    event->gatts_request_write_event.length = length;
-    event->gatts_request_write_event.need_rsp = need_rsp;
-    event->gatts_request_write_event.is_prep = is_prep;
-    event->gatts_request_write_event.value = value;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_request_exec_write_cb(int conn_id, int trans_id,
-                                                bt_bdaddr_t *bda, int exec_write)
-{
-
-    char c_address[32];
-    sprintf(c_address, "%02X:%02X:%02X:%02X:%02X:%02X",
-            bda->address[0], bda->address[1], bda->address[2],
-           bda->address[3], bda->address[4], bda->address[5]);
-
-    ALOGD (LOGTAG "(%s) connid:(%d) bda:(%s)",__FUNCTION__, conn_id, c_address);
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_REQUEST_EXEC_WRITE_EVENT;
-    event->gatts_request_exec_write_event.conn_id = conn_id;
-    event->gatts_request_exec_write_event.trans_id = trans_id;
-    event->gatts_request_exec_write_event.bda = bda;
-    event->gatts_request_exec_write_event.exec_write = exec_write;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_response_confirmation_cb(int status, int handle)
-{
-    ALOGD (LOGTAG "(%s) status:(%d) handle:(%d)",__FUNCTION__, status, handle);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_RESPONSE_CONFIRMATION_EVENT;
-    event->gatts_response_confirmation_event.status = status;
-    event->gatts_response_confirmation_event.handle = handle ;
-
-    PostMessage(THREAD_ID_GATT, event);
-
-}
-
-void btgatts_indication_sent_cb(int conn_id, int status)
-{
-    ALOGD (LOGTAG "(%s) conn_id (%d) status:(%d)",__FUNCTION__, conn_id, status);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_INDICATION_SENT_EVENT;
-    event->gatts_indication_sent_event.status = status;
-    event->gatts_indication_sent_event.conn_id = conn_id ;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_congestion_cb(int conn_id, bool congested)
-{
-    ALOGD (LOGTAG "(%s) contested (%d) conn_id:(%d)",__FUNCTION__, congested,conn_id);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_CONGESTION_EVENT;
-    event->gatts_congestion_event.congested = congested;
-    event->gatts_congestion_event.conn_id = conn_id ;
-
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-void btgatts_mtu_changed_cb(int conn_id, int mtu)
-{
-    ALOGD (LOGTAG "(%s) conn_id:(%d) Mtu (%d)",__FUNCTION__, conn_id, mtu);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM_VOID(event)
-
-    event->event_id = BTGATTS_MTU_CHANGED_EVENT;
-    event->gatts_mtu_changed_event.conn_id = conn_id;
-    event->gatts_mtu_changed_event.mtu = mtu ;
-
-    PostMessage(THREAD_ID_GATT, event);
-
-}
-
-static const btgatt_server_callbacks_t sGattServerCallbacks = {
-    btgatts_register_app_cb,
-    btgatts_connection_cb,
-    btgatts_service_added_cb,
-    btgatts_included_service_added_cb,
-    btgatts_characteristic_added_cb,
-    btgatts_descriptor_added_cb,
-    btgatts_service_started_cb,
-    btgatts_service_stopped_cb,
-    btgatts_service_deleted_cb,
-    btgatts_request_read_cb,
-    btgatts_request_write_cb,
-    btgatts_request_exec_write_cb,
-    btgatts_response_confirmation_cb,
-    btgatts_indication_sent_cb,
-    btgatts_congestion_cb,
-    btgatts_mtu_changed_cb
-};
-/**
- * GATT callbacks
- */
-static btgatt_callbacks_t sGattCallbacks = {
-    sizeof(btgatt_callbacks_t),
-    &sGattClientCallbacks,
-    &sGattServerCallbacks
-};
-
-void BtGattMsgHandler(void *msg) {
-    BtEvent* event = NULL;
-    bool status = false;
-    if(!msg)
-    {
-        ALOGE("(%s) Msg is null, return.\n",__FUNCTION__);
-        return;
-    }
-    event = ( BtEvent *) msg;
-    ALOGD (LOGTAG "(%s) event id (%d)",__FUNCTION__, (int) event->event_id);
-    switch(event->event_id) {
-        case PROFILE_API_START:
-            if (g_gatt) {
-                status = g_gatt->HandleEnableGatt();
-                BtEvent *start_event = new BtEvent;
-                CHECK_PARAM_VOID (start_event)
-
-                start_event->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
-                start_event->profile_start_event.profile_id = PROFILE_ID_GATT;
-                start_event->profile_start_event.status = status;
-                PostMessage(THREAD_ID_GAP, start_event);
-            }
-            break;
-       case PROFILE_API_STOP:
-            if (g_gatt) {
-                status = g_gatt->HandleDisableGatt();
-                BtEvent *stop_event = new BtEvent;
-                CHECK_PARAM_VOID (stop_event)
-
-                stop_event->profile_start_event.event_id = PROFILE_EVENT_STOP_DONE;
-                stop_event->profile_start_event.profile_id = PROFILE_ID_GATT;
-                stop_event->profile_start_event.status = status;
-                PostMessage(THREAD_ID_GAP, stop_event);
-            }
-            break;
-        default:
-            if(g_gatt) {
-                ALOGD (LOGTAG "(%s) Received Message %d",__FUNCTION__, (int) event->event_id);
-                g_gatt->ProcessEvent(( BtEvent *) msg);
-            }
-            break;
-    }
-    delete event;
-}
-#ifdef __cplusplus
-}
-#endif
-
-void Gatt::HandleGattIpcMsg(BtIpcMsg *ipc_msg)
-{
-
-    CHECK_PARAM_VOID(ipc_msg)
-    fprintf(stdout, "(%s) ipcMsg->type: %d, ipcMsg->status = %d wlan state (%d)\n",__FUNCTION__,
-            ipc_msg->type, ipc_msg->status, rsp->GetDeviceState());
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        int status = 0; //invalid. (1,,2,3 are valid states)
-        if (rsp->GetDeviceState() == WLAN_TRANSACTION_PENDING)
-        {
-            if (ipc_msg->type == BT_IPC_REMOTE_START_WLAN )
-            {
-                (ipc_msg->status == 0) ? status = WLAN_ACTIVE: status = WLAN_INACTIVE;
-            }
-            rsp->SetDeviceState(status);
-        }
-    }
-}
-
-void Gatt::HandleGattcRegisterAppEvent(GattcRegisterAppEvent *event)
-{
-    ALOGD(LOGTAG  "(%s) client_if =%d status =%d uuid =%x",__FUNCTION__, event->clientIf,
-            event->status, event->app_uuid);
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->SetRSPClientAppData(event);
-        if (event->status == BT_STATUS_SUCCESS)
-        {
-            rsp->ClientSetAdvData("Remote Start Profile");
-            rsp->StartAdvertisement();
-        } else {
-            ALOGE (LOGTAG "(%s) Failed to Register Client App",__FUNCTION__, event->clientIf);
-        }
-    }
-}
-
-void Gatt::HandleGattsRegisterAppEvent(GattsRegisterAppEvent *event)
-{
-    ALOGD(LOGTAG  "(%s) server_if =%d status =%d uuid =%x",__FUNCTION__, event->server_if,
-            event->status, event->uuid->uu);
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->SetRSPAppData(event);
-        if(event->status == BT_STATUS_SUCCESS)
-        {
-            rsp->AddService();
-        } else {
-        ALOGE (LOGTAG "(%s) Failed to Register Server App",__FUNCTION__, event->server_if);
-        }
-    }
-}
-
-void Gatt::HandleGattsConnectionEvent(GattsConnectionEvent *event)
-{
-    fprintf(stdout,"(%s) conn_id (%d) server_if (%d) connected (%d)\n",__FUNCTION__, event->conn_id,
-            event->server_if, event->connected);
-
-    char c_address[32];
-    sprintf(c_address, "%02X:%02X:%02X:%02X:%02X:%02X",
-                event->bda->address[0], event->bda->address[1], event->bda->address[2],
-                event->bda->address[3], event->bda->address[4], event->bda->address[5]);
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->SetRSPConnectionData(event);
-        if (event->connected)
-        {
-            rsp->StopAdvertisement();
-        }
-    }
-}
-
-void Gatt::HandleGattsServiceAddedEvent(GattsServiceAddedEvent *event)
-{
-    ALOGD(LOGTAG  "(%s) event_id =%d status =%d server_if =%d,service_handle =%d",__FUNCTION__,
-            event->event_id, event->status, event->server_if,event->srvc_handle);
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->SetRSPSrvcData(event);
-        if (event->status == BT_STATUS_SUCCESS)
-        {
-            rsp->AddCharacteristics();
-        } else {
-            ALOGE (LOGTAG "(%s) Failed to Add_Service",__FUNCTION__, event->server_if);
-        }
-    }
-}
-
-void Gatt::HandleGattsCharacteristicAddedEvent(GattsCharacteristicAddedEvent *event)
-{
-    ALOGD(LOGTAG  "(%s) char_handle =%d char_id =%d status =%d server_if =%d,service_handle =%d",
-            __FUNCTION__, event->char_handle, event->char_id, event->status,
-            event->server_if, event->srvc_handle);
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->SetRSPCharacteristicData(event);
-        if (event->status == BT_STATUS_SUCCESS)
-        {
-            rsp->AddDescriptor();
-        } else {
-            ALOGE (LOGTAG "(%s) Failed to Add Characteristics",__FUNCTION__, event->server_if);
-        }
-    }
-}
-
-void Gatt::HandleGattsDescriptorAddedEvent(GattsDescriptorAddedEvent *event)
-{
-    ALOGD(LOGTAG  "(%s) desc_handle =%d desc_id =%d status =%d server_if =%d, srvc_handle=%x,"
-            "service_handle =%d",__FUNCTION__, event->descr_handle, event->descr_id,
-            event->status, event->server_if,event->srvc_handle);
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->SetRSPDescriptorData(event);
-        if (event->status == BT_STATUS_SUCCESS)
-        {
-            rsp->StartService();
-        } else {
-            ALOGE (LOGTAG "(%s) Failed to Add Descriptor",__FUNCTION__, event->server_if);
-        }
-    }
-}
-void Gatt::HandleGattsServiceStartedEvent(GattsServiceStartedEvent *event)
-{
-    fprintf(stdout, "(%s) status =%d server_if =%d,service_handle =%d\n",__FUNCTION__,
-            event->status, event->server_if, event->srvc_handle);
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        if (event->status == BT_STATUS_SUCCESS)
-        {
-            rsp->RegisterClient();
-        } else {
-            ALOGE (LOGTAG "(%s) Failed to Start RSP Service",__FUNCTION__, event->server_if);
-        }
-    }
-}
-
-void Gatt::HandleGattsServiceStoppedEvent(GattsServiceStoppedEvent *event)
-{
-    ALOGD(LOGTAG  "Handler :(%s) status(%d) server_if(%d) srvc_handle(%d)",__FUNCTION__,
-            event->status, event->server_if, event->srvc_handle);
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        if (!event->status)
-            rsp->DeleteService();
-    }
-    ALOGD(LOGTAG  "RSP Service stopped successfully, deleting the service");
-}
-
-void Gatt::HandleGattsServiceDeletedEvent(GattsServiceDeletedEvent *event)
-{
-    ALOGD(LOGTAG  "Handler :(%s) status(%d) server_if(%d) srvc_handle(%d)",__FUNCTION__,
-            event->status, event->server_if, event->srvc_handle);
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        if (!event->status)
-        {
-            rsp->CleanUp(event->server_if);
-            delete rsp;
-            rsp = NULL;
-        }
-    }
-    fprintf(stdout,"RSP Service stopped & Unregistered successfully\n");
-}
-
-void Gatt::HandleGattsRequestWriteEvent(GattsRequestWriteEvent *event)
-{
-    char c_address[32];
-    sprintf(c_address, "%02X:%02X:%02X:%02X:%02X:%02X",
-                event->bda->address[0], event->bda->address[1], event->bda->address[2],
-                event->bda->address[3], event->bda->address[4], event->bda->address[5]);
-
-    ALOGD(LOGTAG "(%s) conn_id :(%d) bda: (%s)",__FUNCTION__, event->conn_id, c_address);
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->SendResponse(event);
-    }
-}
-
-void Gatt::HandleRspEnableEvent(RspEnableEvent *event)
-{
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->SetRSPAttrData(event);
-        rsp->RegisterApp();
-    }
-}
-
-void Gatt::HandleRspDisableEvent(RspDisableEvent *event)
-{
-    fprintf(stdout, "(%s) server_if (%d)\n",__FUNCTION__, event->server_if);
-
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp)
-    {
-        rsp->StopService();
-    }
-}
-
-void Gatt::ProcessEvent(BtEvent* event)
-{
-    CHECK_PARAM_VOID(event)
-    ALOGD(LOGTAG "(%s) Processing event %d",__FUNCTION__, event->event_id);
-
-    switch(event->event_id) {
-        case SKT_API_IPC_MSG_READ:
-            HandleGattIpcMsg((BtIpcMsg *)(&event->bt_ipc_msg_event.ipc_msg));
-            break;
-        case RSP_ENABLE_EVENT:
-            HandleRspEnableEvent((RspEnableEvent *)event);
-            break;
-        case RSP_DISABLE_EVENT:
-            HandleRspDisableEvent((RspDisableEvent *)event);
-            break;
-        case BTGATTS_REGISTER_APP_EVENT:
-            HandleGattsRegisterAppEvent((GattsRegisterAppEvent *)event);
-            break;
-        case BTGATTS_CONNECTION_EVENT:
-            HandleGattsConnectionEvent((GattsConnectionEvent *)event);
-            break;
-        case BTGATTS_SERVICE_ADDED_EVENT:
-            HandleGattsServiceAddedEvent((GattsServiceAddedEvent *)event);
-            break;
-        case BTGATTS_CHARACTERISTIC_ADDED_EVENT:
-            HandleGattsCharacteristicAddedEvent((GattsCharacteristicAddedEvent *)event);
-            break;
-        case BTGATTS_DESCRIPTOR_ADDED_EVENT:
-            HandleGattsDescriptorAddedEvent((GattsDescriptorAddedEvent *)event);
-            break;
-        case BTGATTS_SERVICE_STARTED_EVENT:
-            HandleGattsServiceStartedEvent((GattsServiceStartedEvent *)event);
-            break;
-        case BTGATTS_SERVICE_STOPPED_EVENT:
-            HandleGattsServiceStoppedEvent((GattsServiceStoppedEvent *)event);
-            break;
-        case BTGATTS_SERVICE_DELETED_EVENT:
-            HandleGattsServiceDeletedEvent((GattsServiceDeletedEvent *)event);
-            break;
-        case BTGATTS_REQUEST_WRITE_EVENT:
-            HandleGattsRequestWriteEvent((GattsRequestWriteEvent *)event);
-            break;
-        case BTGATTC_REGISTER_APP_EVENT:
-            HandleGattcRegisterAppEvent((GattcRegisterAppEvent *) event);
-            break;
-        case BTGATTS_REQUEST_READ_EVENT:
-        case BTGATTS_INCLUDED_SERVICE_ADDED_EVENT:
-        case BTGATTS_REQUEST_EXEC_WRITE_EVENT:
-        case BTGATTS_RESPONSE_CONFIRMATION_EVENT:
-        case BTGATTS_INDICATION_SENT_EVENT:
-        case BTGATTS_CONGESTION_EVENT:
-        case BTGATTS_MTU_CHANGED_EVENT:
-        case BTGATTC_SCAN_RESULT_EVENT:
-        case BTGATTC_OPEN_EVENT:
-        case BTGATTC_CLOSE_EVENT:
-        case BTGATTC_SEARCH_COMPLETE_EVENT:
-        case BTGATTC_SEARCH_RESULT_EVENT:
-        case BTGATTC_GET_CHARACTERISTIC_EVENT:
-        case BTGATTC_GET_DESCRIPTOR_EVENT:
-        case BTGATTC_GET_INCLUDED_SERVICE_EVENT:
-        case BTGATTC_REGISTER_FOR_NOTIFICATION_EVENT:
-        case BTGATTC_NOTIFY_EVENT:
-        case BTGATTC_READ_CHARACTERISTIC_EVENT:
-        case BTGATTC_WRITE_CHARACTERISTIC_EVENT:
-        case BTGATTC_READ_DESCRIPTOR_EVENT:
-        case BTGATTC_WRITE_DESCRIPTOR_EVENT:
-        case BTGATTC_EXECUTE_WRITE_EVENT:
-        case BTGATTC_REMOTE_RSSI_EVENT:
-        case BTGATTC_ADVERTISE_EVENT:
-        case BTGATTC_CONFIGURE_MTU_EVENT:
-        case BTGATTC_SCAN_FILTER_CFG_EVENT:
-        case BTGATTC_SCAN_FILTER_PARAM_EVENT:
-        case BTGATTC_SCAN_FILTER_STATUS_EVENT:
-        case BTGATTC_MULTIADV_ENABLE_EVENT:
-        case BTGATTC_MULTIADV_UPDATE_EVENT:
-        case BTGATTC_MULTIADV_SETADV_DATA_EVENT:
-        case BTGATTC_MULTIADV_DISABLE_EVENT:
-        case BTGATTC_CONGESTION_EVENT:
-        case BTGATTC_BATCHSCAN_CFG_STORAGE_EVENT:
-        case BTGATTC_BATCHSCAN_STARTSTOP_EVENT:
-        case BTGATTC_BATCHSCAN_REPORTS_EVENT:
-        case BTGATTC_BATCHSCAN_THRESHOLD_EVENT:
-        case BTGATTC_TRACK_ADV_EVENT_EVENT:
-        case BTGATTC_SCAN_PARAMETER_SETUP_COMPLETED_EVENT:
-        default: //All fall-through, enable as needed
-            ALOGD(LOGTAG  "(%s) Unhandled Event(%d)",__FUNCTION__, event->event_id);
-            break;
-    }
-}
-
-bool Gatt::GattInterfaceInit(const bt_interface_t *bt_interface)
-{
-    gatt_interface = (btgatt_interface_t*) bt_interface->get_profile_interface(BT_PROFILE_GATT_ID);
-    if (gatt_interface == NULL)
-    {
-        ALOGE(LOGTAG "(%s) Failed to init gatt profile",__FUNCTION__);
-        return false;
-    }
-    bt_status_t status = gatt_interface->init(&sGattCallbacks);
-    return (status != BT_STATUS_SUCCESS ? false : true);
-}
-
-void Gatt::GattInterfaceCleanup()
-{
-    if (gatt_interface) {
-        gatt_interface->cleanup();
-        gatt_interface = NULL;
-    }
-}
-
-Gatt::Gatt(const bt_interface_t *bt_interface, config_t *config)
-{
-    ALOGD(LOGTAG "(%s) Starting Up Gatt Instance",__FUNCTION__);
-    this->gatt_interface = NULL;
-    this->bluetooth_interface = bt_interface;
-    this->config = config;
-}
-Gatt::~Gatt()
-{
-    ALOGD(LOGTAG  "(%s) Cleaning up GATT Interface",__FUNCTION__);
-    GattInterfaceCleanup();
-}
-
-bool Gatt::HandleEnableGatt()
-{
-    if (GattInterfaceInit(bluetooth_interface)!= true) {
-            ALOGE(LOGTAG "(%s) Gatt Initialization Failed",__FUNCTION__);
-            return false;
-    } else {
-        le_supported_profiles = config_get_int(config,CONFIG_DEFAULT_SECTION,
-                                                "BtBleSupportedProfiles",0);
-        ALOGD(LOGTAG "(%s) Le_Supported_Profiles (%x)",__FUNCTION__,le_supported_profiles);
-        if (le_supported_profiles & REMOTE_START_PROFILE)
-        {
-            rsp = new Rsp(gatt_interface);
-            if (!rsp) {
-                ALOGE(LOGTAG "(%s) RSP Alloc failed return failure",__FUNCTION__);
-                return false;
-            }
-            for (int i = 0; i < 16; i++) {
-               rsp_uuid.uu[i] = 0x30; //Proprietary UUID.
-            }
-            return true;
-        }
-    }
-}
-bool Gatt::HandleDisableGatt()
-{
-    bool status = true;
-    ALOGD(LOGTAG  "(%s) Closing Gatt Instance",__FUNCTION__);
-    if ((le_supported_profiles & REMOTE_START_PROFILE) && rsp) {
-        status = rsp->StopService();
-    }
-    return status;
-}
-
diff --git a/bt-app/gatt/src/Rsp.cpp b/bt-app/gatt/src/Rsp.cpp
deleted file mode 100755
index c0ee30b..0000000
--- a/bt-app/gatt/src/Rsp.cpp
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
- * Copyright (c) 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "Gatt.hpp"
-#include "Rsp.hpp"
-
-#define LOGTAG "RSP "
-
-Rsp::Rsp(btgatt_interface_t *gatt_itf)
-{
-    gatt_interface = gatt_itf;
-    SetDeviceState(WLAN_INACTIVE);
-}
-
-Rsp::~Rsp()
-{
-    ALOGD(LOGTAG "(%s) RSP DeInitialized",__FUNCTION__);
-    SetDeviceState(WLAN_INACTIVE);
-}
-
-bool Rsp::CopyUUID(bt_uuid_t *uuid)
-{
-    CHECK_PARAM(uuid)
-    for (int i = 0; i < 16; i++) {
-        uuid->uu[i] = 0x30; //Proprietary UUID ( all 0x30s.)
-    }
-    return true;
-}
-
-bool Rsp::CopyParams(bt_uuid_t *uuid_dest, bt_uuid_t *uuid_src)
-{
-    CHECK_PARAM(uuid_dest)
-    CHECK_PARAM(uuid_src)
-
-    for (int i = 0; i < 16; i++) {
-        uuid_dest->uu[i] = uuid_src->uu[i];
-    }
-    return true;
-}
-
-bool Rsp::MatchParams(bt_uuid_t *uuid_dest, bt_uuid_t *uuid_src)
-{
-    CHECK_PARAM(uuid_dest)
-    CHECK_PARAM(uuid_src)
-
-    for (int i = 0; i < 16; i++) {
-        if(uuid_dest->uu[i] != uuid_src->uu[i])
-            return false;
-    }
-    ALOGD(LOGTAG "(%s) UUID Matches",__FUNCTION__);
-    return true;
-}
-
-bool Rsp::EnableRSP()
-{
-    ALOGD(LOGTAG "(%s) Enable RSP Initiated",__FUNCTION__);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM(event)
-
-    event->event_id = RSP_ENABLE_EVENT;
-
-    CopyUUID(&event->rsp_enable_event.characteristics_uuid);
-    CopyUUID(&event->rsp_enable_event.descriptor_uuid);
-    CopyUUID(&event->rsp_enable_event.server_uuid);
-    CopyUUID(&event->rsp_enable_event.service_uuid);
-
-    ALOGD(LOGTAG "(%s) Posting: RSP_ENABLE_EVENT",__FUNCTION__);
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-bool Rsp::DisableRSP(int server_if)
-{
-    ALOGD(LOGTAG "(%s) Disable RSP Initiated",__FUNCTION__);
-
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM(event)
-
-    event->event_id = RSP_DISABLE_EVENT;
-    event->rsp_disable_event.server_if = server_if;
-    PostMessage(THREAD_ID_GATT, event);
-}
-
-bool Rsp::RegisterApp()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    bt_uuid_t server_uuid = GetRSPAttrData()->server_uuid;
-    return GetGattInterface()->server->register_server(&server_uuid) == BT_STATUS_SUCCESS;
-}
-
-bool Rsp::RegisterClient()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    bt_uuid_t client_uuid = GetRSPAttrData()->server_uuid;
-    client_uuid.uu[0] = 0xff;
-    return GetGattInterface()->client->register_client(&client_uuid) == BT_STATUS_SUCCESS;
-}
-
-bool Rsp::UnregisterClient(int client_if)
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    return GetGattInterface()->client->unregister_client(client_if) == BT_STATUS_SUCCESS;
-}
-
-bool Rsp::ClientSetAdvData(char *str)
-{
-    bt_status_t        Ret;
-    bool              SetScanRsp        = false;
-    bool              IncludeName       = true;
-    bool              IncludeTxPower    = false;
-    int               min_conn_interval = RSP_MIN_CI;
-    int               max_conn_interval = RSP_MAX_CI;
-
-    GetGattInterface()->client->set_adv_data(GetRSPClientAppData()->clientIf, SetScanRsp,
-                                                IncludeName, IncludeTxPower, min_conn_interval,
-                                                max_conn_interval, 0,strlen(str), str,
-                                                strlen(str), str, 0,NULL);
-}
-
-void Rsp::CleanUp(int server_if)
-{
-    UnregisterServer(server_if);
-    UnregisterClient(GetRSPClientAppData()->clientIf);
-}
-
-bool Rsp::UnregisterServer(int server_if)
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "Gatt Interface Not present");
-        return false;
-    }
-    return GetGattInterface()->server->unregister_server(server_if) == BT_STATUS_SUCCESS;
-}
-
-bool Rsp::StartAdvertisement()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    ALOGD(LOGTAG  "(%s) Listening on the interface (%d) ",__FUNCTION__,
-            GetRSPAppData()->server_if);
-    SetDeviceState(WLAN_INACTIVE);
-    return GetGattInterface()->client->listen(GetRSPClientAppData()->clientIf, true);
-}
-
-bool Rsp::SendResponse(GattsRequestWriteEvent *event)
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    CHECK_PARAM(event)
-    btgatt_response_t att_resp;
-    int response = -1;
-    memset(att_resp.attr_value.value,0,BTGATT_MAX_ATTR_LEN);
-    memcpy(att_resp.attr_value.value, event->value, event->length);
-    att_resp.attr_value.handle = event->attr_handle;
-    att_resp.attr_value.offset = event->offset;
-    att_resp.attr_value.len = event->length;
-    att_resp.attr_value.auth_req = 0;
-
-    if(!strncasecmp((const char *)(event->value), "on", 2)) {
-        if (GetDeviceState() == WLAN_INACTIVE)
-        {
-            HandleWlanOn();
-            SetDeviceState(WLAN_TRANSACTION_PENDING);
-        }
-        response = 0;
-    } else {
-        response = -1;
-    }
-
-    ALOGD(LOGTAG "(%s) Sending RSP response to write (%d) value (%s) State (%d)",__FUNCTION__,
-            GetRSPAppData()->server_if, event->value,GetDeviceState());
-
-    return GetGattInterface()->server->send_response(event->conn_id, event->trans_id,
-                                                         response, &att_resp);
-}
-
-bool Rsp::HandleWlanOn()
-{
-    BtEvent *event = new BtEvent;
-    CHECK_PARAM(event);
-    event->event_id = SKT_API_IPC_MSG_WRITE;
-    event->bt_ipc_msg_event.ipc_msg.type = BT_IPC_REMOTE_START_WLAN;
-    event->bt_ipc_msg_event.ipc_msg.status = INITIATED;
-    StopAdvertisement();
-    ALOGD(LOGTAG "(%s) Posting wlan start to main thread",__FUNCTION__);
-    PostMessage (THREAD_ID_MAIN, event);
-    return true;
-}
-
-bool Rsp::StopAdvertisement()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    ALOGD(LOGTAG "(%s) Stopping listen on the interface (%d) ",__FUNCTION__,
-            GetRSPAppData()->server_if);
-    return GetGattInterface()->client->listen(GetRSPClientAppData()->clientIf, false);
-}
-
-bool Rsp::AddService()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    btgatt_srvc_id_t srvc_id;
-    srvc_id.id.inst_id = 0;   // 1 instance
-    srvc_id.is_primary = 1;   // Primary addition
-    srvc_id.id.uuid = GetRSPAttrData()->service_uuid;
-    return GetGattInterface()->server->add_service(GetRSPAppData()->server_if, &srvc_id,4)
-                                                        ==BT_STATUS_SUCCESS;
-}
-
-bool Rsp::DisconnectServer()
-{
-    int server_if = GetRSPConnectionData()->server_if;
-    bt_bdaddr_t * bda = GetRSPConnectionData()->bda;
-    int conn_id = GetRSPConnectionData()->conn_id;
-    ALOGD(LOGTAG  "(%s) Disconnecting interface (%d), connid (%d) ",__FUNCTION__,
-            server_if, conn_id);
-    return GetGattInterface()->server->disconnect(server_if, bda, conn_id) == BT_STATUS_SUCCESS;
-}
-
-bool Rsp::DeleteService()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    bool status = false;
-    int srvc_handle = GetRspSrvcData()->srvc_handle;
-    return GetGattInterface()->server->delete_service(GetRSPAppData()->server_if,
-                                                            srvc_handle) == BT_STATUS_SUCCESS;
-}
-
-bool Rsp::AddCharacteristics()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-    bt_uuid_t char_uuid;
-    CopyParams(&char_uuid, &(GetRspSrvcData()->srvc_id->id.uuid));
-    int srvc_handle = GetRspSrvcData()->srvc_handle;
-    int server_if = GetRspSrvcData()->server_if;
-    ALOGD(LOGTAG  "(%s) Adding Characteristics server_if (%d), srvc_handle (%d)",
-            __FUNCTION__, server_if,srvc_handle);
-    return GetGattInterface()->server->add_characteristic(server_if, srvc_handle, &char_uuid,
-                                                            GATT_PROP_WRITE, GATT_PERM_WRITE)
-                                                            ==BT_STATUS_SUCCESS;
-}
-
-bool Rsp::AddDescriptor(void)
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-
-    bt_uuid_t desc_uuid;
-    desc_uuid = GetRSPAttrData()->descriptor_uuid;
-    int srvc_handle = GetRspSrvcData()->srvc_handle;
-    return GetGattInterface()->server->add_descriptor(GetRSPAppData()->server_if,
-                                                        srvc_handle, &desc_uuid,
-                                                        GATT_PERM_READ) == BT_STATUS_SUCCESS;
-}
-
-bool Rsp::StartService()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-
-    int srvc_handle = GetRspSrvcData()->srvc_handle;
-    return GetGattInterface()->server->start_service(GetRSPAppData()->server_if,
-                                                        srvc_handle, GATT_TRANSPORT_LE)
-                                                        == BT_STATUS_SUCCESS;
-}
-
-bool Rsp::StopService()
-{
-    if (GetGattInterface() == NULL)
-    {
-        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
-        return false;
-    }
-
-    int srvc_handle = GetRspSrvcData()->srvc_handle;
-    return GetGattInterface()->server->stop_service(GetRSPAppData()->server_if,
-                                                        srvc_handle) == BT_STATUS_SUCCESS;
-}
-
diff --git a/bt-app/hfp_ag/include/HfpAG.hpp b/bt-app/hfp_ag/include/HfpAG.hpp
new file mode 100644
index 0000000..b55c807
--- /dev/null
+++ b/bt-app/hfp_ag/include/HfpAG.hpp
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef HFP_AG_APP_H
+#define HFP_AG_APP_H
+
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_hf.h>
+#include <pthread.h>
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "ipc.h"
+#include "utils.h"
+#include "hardware/bt_hf_vendor.h"
+
+// for MDM, define, this, TODO: move it to bitbake
+//#define BT_ALSA_AUDIO_INTEGRATION 0
+
+#if defined(BT_MODEM_INTEGRATION)
+#include <dlfcn.h>
+#include "mcm_client.h"
+#include "mcm_voice_v01.h"
+#include "mcm_sim_v01.h"
+#include "mcm_nw_v01.h"
+
+typedef  uint32 (*mcm_client_init_t)
+(
+    mcm_client_handle_type      *client_handle,
+    mcm_client_ind_cb            client_ind_cb,
+    mcm_client_async_cb          client_resp_cb
+);
+
+typedef  uint32 (*mcm_client_release_t)(mcm_client_handle_type handle);
+
+typedef  uint32 (*mcm_client_execute_command_async_t)
+(
+    mcm_client_handle_type        client_handle,
+    int                           msg_id,
+    void                         *req_c_struct,
+    int                           req_c_struct_len,
+    void                         *resp_c_struct,
+    int                           resp_c_struct_len,
+    mcm_client_async_cb           async_resp_cb,
+    void                          *token_id
+);
+
+typedef  uint32 (*mcm_client_execute_command_sync_t)
+(
+    mcm_client_handle_type      client_handle,
+    int                         msg_id,
+    void                       *req_c_struct,
+    int                         req_c_struct_len,
+    void                       *resp_c_struct,
+    int                         resp_c_struct_len
+);
+#endif
+
+// currently only 2 HF indicators are defined by SIG
+#define MAX_HF_INDICATORS 2
+
+
+typedef enum {
+    HFP_AG_STATE_NOT_STARTED = 0,
+    HFP_AG_STATE_DISCONNECTED,
+    HFP_AG_STATE_PENDING,
+    HFP_AG_STATE_CONNECTED,
+    HFP_AG_STATE_AUDIO_ON
+}HfpAgState;
+
+#if defined(BT_MODEM_INTEGRATION)
+
+typedef struct {
+    uint32_t    call_id; // call id to identify this call
+    uint8_t     idx;
+    bthf_call_direction_t     dir; // 0=outgoing, 1=incoming
+    bthf_call_state_t     stat; // 0-6
+    bthf_call_mode_t     mode; // 0=voice, 1=data, 2=fax
+    bthf_call_mpty_type_t     mpty; // 0=no, 1=yes
+    bthf_call_addrtype_t     numType;
+    char        number[MCM_MAX_PHONE_NUMBER_V01 + 1]; // remote's number
+}call_info;
+
+
+    void ril_ind_cb(mcm_client_handle_type hndl, uint32 msg_id,
+                     void *ind_c_struct, uint32 ind_len);
+    void ril_resp_cb(mcm_client_handle_type hndl, uint32 msg_id,
+                     void *resp_c_struct, uint32 resp_len, void *token_id);
+#endif
+
+class Hfp_Ag {
+
+  private:
+#if defined(BT_MODEM_INTEGRATION)
+    bool mDiallingOut;
+    uint8_t mNumActiveCalls;
+    uint8_t mNumHeldCalls;
+    uint8_t mNumRingingCalls;
+    bthf_call_state_t mCallSetupState;
+    int mSignalStrength;
+    char *mRingingAddress;
+
+    char mLastDialledNumber[MCM_MAX_PHONE_NUMBER_V01 + 1];
+    call_info mCalls[MCM_MAX_VOICE_CALLS_V01];
+
+    mcm_client_handle_type          mcm_client_hdl;
+    int                             token_id;
+    mcm_voice_call_operation_t_v01  call_op;
+    uint32_t                        call_id;
+
+    mcm_voice_command_resp_msg_v01                  voice_cmd_resp;
+    mcm_voice_hangup_resp_msg_v01                   hangup_resp;
+    mcm_voice_dial_resp_msg_v01                     dial_resp;
+    mcm_voice_get_calls_resp_msg_v01                get_calls_resp;
+    mcm_voice_event_register_resp_msg_v01           voice_event_register_resp;
+    mcm_voice_set_call_waiting_resp_msg_v01         set_cw_resp;
+    mcm_voice_dtmf_resp_msg_v01                     dtmf_resp;
+    mcm_voice_start_dtmf_resp_msg_v01               start_dtmf_resp;
+    mcm_voice_stop_dtmf_resp_msg_v01                stop_dtmf_resp;
+    mcm_sim_get_device_phone_number_resp_msg_v01    get_phone_num_resp;
+    mcm_nw_get_operator_name_resp_msg_v01           cops_resp;
+
+    // handle to mcm library
+    void *lib_handle;
+    // function pointer to mcm_client_init
+    mcm_client_init_t mcm_client_init_ptr;
+
+    // function pointer to mcm_client_release
+    mcm_client_release_t mcm_client_release_ptr;
+
+    // function pointer to mcm_client_execute_command_async
+    mcm_client_execute_command_async_t mcm_client_execute_command_async_ptr;
+
+    // function pointer to mcm_client_execute_command_sync
+    mcm_client_execute_command_sync_t mcm_client_execute_command_sync_ptr;
+
+#endif
+
+    int mHfIndHfList[MAX_HF_INDICATORS];
+    // index 0 is for 1st assigned number, index 1 for 2nd assigned number etc
+    int mHfIndAgList[MAX_HF_INDICATORS];
+    const bt_interface_t * bluetooth_interface;
+    const bthf_interface_t *sBtHfpAgInterface;
+    HfpAgState mAgState;
+    ControlStatusType mcontrolStatus;
+    bthf_wbs_config_t mWbsState;
+    bthf_nrec_t mNrec;
+    const bthf_vendor_interface_t *sBtHfpAgVendorInterface;
+  public:
+    Hfp_Ag(const bt_interface_t *bt_interface, config_t *config);
+    ~Hfp_Ag();
+    void ProcessEvent(BtEvent* pEvent);
+    void state_disconnected_handler(BtEvent* pEvent);
+    void state_pending_handler(BtEvent* pEvent);
+    void state_connected_handler(BtEvent* pEvent);
+    void state_audio_on_handler(BtEvent* pEvent);
+    void change_state(HfpAgState mState);
+    pthread_mutex_t lock;
+    bt_bdaddr_t mConnectingDevice;
+    bt_bdaddr_t mConnectedDevice;
+    void HandleEnableAg();
+    void HandleDisableAg();
+    void ConfigureAudio(bool enable);
+    void process_at_bind(BtEvent* pEvent);
+    void process_at_biev(BtEvent* pEvent);
+#if defined(BT_MODEM_INTEGRATION)
+    void init_modem();
+    void release_modem();
+    bthf_call_state_t get_call_state(mcm_voice_call_state_t_v01 state);
+    void process_call_list(mcm_voice_call_record_t_v01 *calls, uint32_t num_calls);
+    int get_current_calls();
+    void get_and_send_operator_name(bt_bdaddr_t *bd_addr);
+    void get_and_send_subscriber_number(bt_bdaddr_t *bd_addr);
+    void dial_call(char *number, bt_bdaddr_t *bd_addr);
+    uint32 send_voice_cmd(mcm_voice_call_operation_t_v01 op);
+    uint32 end_call(bthf_call_state_t state);
+    uint32 get_call_id(bthf_call_state_t state);
+    uint32 process_chld(int chld);
+    void process_ril_ind(BtEvent* pEvent);
+    void process_ril_resp(BtEvent* pEvent);
+    void processSlcConnected();
+#endif
+
+#if defined(BT_ALSA_AUDIO_INTEGRATION)
+    void init_audio();
+    void set_audio_params();
+    void setup_sco_path();
+    void teardown_sco_path();
+    void release_audio();
+#endif
+};
+
+#endif
diff --git a/bt-app/hfp_ag/src/HfpAG.cpp b/bt-app/hfp_ag/src/HfpAG.cpp
new file mode 100644
index 0000000..6e52c54
--- /dev/null
+++ b/bt-app/hfp_ag/src/HfpAG.cpp
@@ -0,0 +1,1823 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2012-2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <list>
+#include <map>
+#include <iostream>
+#include <string.h>
+#include <hardware/bluetooth.h>
+#include <hardware/hardware.h>
+#include <hardware/bt_hf.h>
+#include "hardware/bt_hf_vendor.h"
+
+#include "Audio_Manager.hpp"
+#include "HfpAG.hpp"
+
+#define LOGTAG "HFP_AG "
+
+using namespace std;
+using std::list;
+using std::string;
+
+Hfp_Ag *pHfpAG = NULL;
+extern BT_Audio_Manager *pBTAM;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(BT_MODEM_INTEGRATION)
+const char *MCM_LIBRARY_NAME = "/usr/lib/libmcm.so.0";
+#endif
+
+void BtHfpAgMsgHandler(void *msg) {
+    BtEvent* pEvent = NULL;
+    if(!msg) {
+        printf("Msg is NULL, return.\n");
+        return;
+    }
+
+    pEvent = ( BtEvent *) msg;
+
+    ALOGD(LOGTAG " BtHfpAgMsgHandler event = %d", pEvent->event_id);
+    fprintf(stdout, " BtHfpAgMsgHandler event = %d\n", pEvent->event_id);
+    switch(pEvent->event_id) {
+        case PROFILE_API_START:
+            if (pHfpAG) {
+                pHfpAG->HandleEnableAg();
+            }
+            break;
+        case PROFILE_API_STOP:
+            if (pHfpAG) {
+                pHfpAG->HandleDisableAg();
+            }
+            break;
+        default:
+            if(pHfpAG) {
+               pHfpAG->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+    }
+    delete pEvent;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+static void connection_state_callback(bthf_connection_state_t state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG " Connection State CB");
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    switch( state ) {
+        case BTHF_CONNECTION_STATE_DISCONNECTED:
+            pEvent->hfp_ag_event.event_id = HFP_AG_DISCONNECTED_CB;
+        break;
+        case BTHF_CONNECTION_STATE_CONNECTING:
+            pEvent->hfp_ag_event.event_id = HFP_AG_CONNECTING_CB;
+        break;
+        case BTHF_CONNECTION_STATE_CONNECTED:
+            pEvent->hfp_ag_event.event_id = HFP_AG_CONNECTED_CB;
+        break;
+        case BTHF_CONNECTION_STATE_SLC_CONNECTED:
+            pEvent->hfp_ag_event.event_id = HFP_AG_SLC_CONNECTED_CB;
+        break;
+        case BTHF_CONNECTION_STATE_DISCONNECTING:
+            pEvent->hfp_ag_event.event_id = HFP_AG_DISCONNECTING_CB;
+        break;
+        default:
+        break;
+    }
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+static void audio_state_callback(bthf_audio_state_t state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG " Audio State CB");
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    switch( state ) {
+        case BTHF_AUDIO_STATE_DISCONNECTED:
+            pEvent->hfp_ag_event.event_id = HFP_AG_AUDIO_STATE_DISCONNECTED_CB;
+        break;
+        case BTHF_AUDIO_STATE_CONNECTING:
+            pEvent->hfp_ag_event.event_id = HFP_AG_AUDIO_STATE_CONNECTING_CB;
+        break;
+        case BTHF_AUDIO_STATE_CONNECTED:
+            pEvent->hfp_ag_event.event_id = HFP_AG_AUDIO_STATE_CONNECTED_CB;
+        break;
+        case BTHF_AUDIO_STATE_DISCONNECTING:
+            pEvent->hfp_ag_event.event_id = HFP_AG_AUDIO_STATE_DISCONNECTING_CB;
+        break;
+    }
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void voice_recognition_callback(bthf_vr_state_t state, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG "VR state is %s",(state == BTHF_VR_STATE_STOPPED) ? "stopped": "started");
+    fprintf(stdout, "VR state is %s\n",(state == BTHF_VR_STATE_STOPPED) ? "stopped": "started");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.arg1 = state;
+    pEvent->hfp_ag_event.event_id = HFP_AG_VR_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void answer_call_callback(bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " answer_call_callback");
+    fprintf(stdout, " answer_call_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.event_id = HFP_AG_ANSWER_CALL_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void hangup_call_callback(bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " hangup_call_callback");
+    fprintf(stdout, " hangup_call_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.event_id = HFP_AG_HANGUP_CALL_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void volume_control_callback(bthf_volume_type_t type, int volume, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG "%s : %s volume is %d", __func__,
+          (type == BTHF_VOLUME_TYPE_SPK) ? "speaker": "mic", volume);
+
+    fprintf(stdout, "%s : %s volume is %d\n", __func__,
+          (type == BTHF_VOLUME_TYPE_SPK) ? "speaker": "mic", volume);
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.event_id = HFP_AG_VOL_CONTROL_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void dial_call_callback(char *number, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " dial_call_callback");
+    fprintf(stdout, " dial_call_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+
+    // for AT+BLDN, number will be NULL
+    if (number == NULL)
+       pEvent->hfp_ag_event.str[0] = '\0';
+    else
+       strncpy(pEvent->hfp_ag_event.str, number, strlen(number));
+
+    pEvent->hfp_ag_event.event_id = HFP_AG_DIAL_CALL_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void dtmf_cmd_callback(char dtmf, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " dtmf_cmd_callback");
+    fprintf(stdout, " dtmf_cmd_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.arg1 = dtmf;
+    pEvent->hfp_ag_event.event_id = HFP_AG_DTMF_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void noice_reduction_callback(bthf_nrec_t nrec, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " noice_reduction_callback");
+    fprintf(stdout, " noice_reduction_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.arg1 = nrec;
+    pEvent->hfp_ag_event.event_id = HFP_AG_NREC_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void wbs_callback(bthf_wbs_config_t wbs_config, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " wbs_callback");
+    fprintf(stdout, " wbs_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.arg1 = wbs_config;
+    pEvent->hfp_ag_event.event_id = HFP_AG_WBS_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void at_chld_callback(bthf_chld_type_t chld, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " at_chld_callback");
+    fprintf(stdout, " at_chld_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.arg1 = (int)chld;
+    pEvent->hfp_ag_event.event_id = HFP_AG_CHLD_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void at_cnum_callback(bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " at_cnum_callback");
+    fprintf(stdout, " at_cnum_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.event_id = HFP_AG_SUBSCRIBER_INFO_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void at_cind_callback(bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " at_cind_callback");
+    fprintf(stdout, "at_cind_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.event_id = HFP_AG_CIND_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void at_cops_callback(bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " at_cops_callback");
+    fprintf(stdout, "at_cops_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.event_id = HFP_AG_COPS_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void at_clcc_callback(bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " at_clcc_callback");
+    fprintf(stdout, "at_clcc_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.event_id = HFP_AG_CLCC_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void unknown_at_callback(char *at_string, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " unknown_at_callback");
+    fprintf(stdout, "unknown_at_callback\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->hfp_ag_event.event_id = HFP_AG_UNKNOWN_AT_CMD_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void key_pressed_callback(bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG " key_pressed_callback");
+}
+
+void bind_cmd_vendor_cb(char* hf_ind, bthf_vendor_bind_type_t type, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " bind_cmd_vendor_cb");
+    fprintf(stdout, " bind_cmd_vendor_cb\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    strncpy(pEvent->hfp_ag_event.str, hf_ind, strlen(hf_ind));
+    pEvent->hfp_ag_event.arg1 = type;
+    pEvent->hfp_ag_event.event_id = HFP_AG_BIND_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void biev_cmd_vendor_cb(char* hf_ind_val, bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG " biev_cmd_vendor_cb");
+    fprintf(stdout, " biev_cmd_vendor_cb\n");
+
+    memcpy(&pEvent->hfp_ag_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    strncpy(pEvent->hfp_ag_event.str, hf_ind_val, strlen(hf_ind_val));
+    pEvent->hfp_ag_event.event_id = HFP_AG_BIEV_CB;
+    PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+static bthf_callbacks_t sBluetoothHfpAgCallbacks = {
+    sizeof(sBluetoothHfpAgCallbacks),
+    connection_state_callback,
+    audio_state_callback,
+    voice_recognition_callback,
+    answer_call_callback,
+    hangup_call_callback,
+    volume_control_callback,
+    dial_call_callback,
+    dtmf_cmd_callback,
+    noice_reduction_callback,
+    wbs_callback,
+    at_chld_callback,
+    at_cnum_callback,
+    at_cind_callback,
+    at_cops_callback,
+    at_clcc_callback,
+    unknown_at_callback,
+    key_pressed_callback
+};
+
+static bthf_vendor_callbacks_t sBluetoothHfpAgVendorCallbacks = {
+    sizeof(sBluetoothHfpAgVendorCallbacks),
+    bind_cmd_vendor_cb,
+    biev_cmd_vendor_cb,
+};
+
+#if defined(BT_MODEM_INTEGRATION)
+void ril_ind_cb(mcm_client_handle_type hndl, uint32 msg_id,
+                     void *ind_c_struct, uint32 ind_len) {
+   BtEvent *pEvent = new BtEvent;
+   fprintf(stdout, "%s: indications is %u\n",__func__, msg_id);
+   ALOGD(LOGTAG "%s: indications is %u\n", __func__, msg_id);
+
+   if (ind_c_struct == NULL) {
+       ALOGE(LOGTAG "%s: indication data is NULL", __func__);
+       fprintf(stdout, "indication data is NULL\n");
+       return;
+   }
+
+   pEvent->hfp_ag_event.hdl = hndl;
+   pEvent->hfp_ag_event.msg_id = msg_id;
+   pEvent->hfp_ag_event.data_length = ind_len;
+   memcpy(&pEvent->hfp_ag_event.data, ind_c_struct, ind_len);
+   pEvent->hfp_ag_event.event_id = HFP_AG_RIL_IND_CB;
+   PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+
+void ril_resp_cb(mcm_client_handle_type hndl, uint32 msg_id,
+                      void *resp_c_struct, uint32 resp_len, void *token_id){
+   BtEvent *pEvent = new BtEvent;
+   fprintf(stdout, "%s: response msg %u\n", __func__, msg_id);
+   ALOGD(LOGTAG "%s: response msg  is %u\n", __func__, msg_id);
+
+   if (resp_c_struct == NULL) {
+       ALOGE(LOGTAG "%s: response data is NULL", __func__);
+       fprintf(stdout, "response data is NULL\n");
+       return;
+   }
+
+   pEvent->hfp_ag_event.hdl = hndl;
+   pEvent->hfp_ag_event.msg_id = msg_id;
+   pEvent->hfp_ag_event.data_length = resp_len;
+   memcpy(&pEvent->hfp_ag_event.data, resp_c_struct, resp_len);
+   pEvent->hfp_ag_event.event_id = HFP_AG_RIL_RESP_CB;
+   PostMessage(THREAD_ID_HFP_AG, pEvent);
+}
+#endif
+
+void Hfp_Ag::HandleEnableAg(void) {
+    if (bluetooth_interface != NULL)
+    {
+        sBtHfpAgInterface = (bthf_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_HANDSFREE_ID);
+        if (sBtHfpAgInterface == NULL)
+        {
+            // TODO: sent message to indicate failure for profile init
+            ALOGE(LOGTAG "get profile interface failed, returning");
+            return;
+        }
+        sBtHfpAgVendorInterface = (bthf_vendor_interface_t *)bluetooth_interface->
+            get_profile_interface(BT_PROFILE_HANDSFREE_VENDOR_ID);
+        if (sBtHfpAgVendorInterface == NULL)
+        {
+            ALOGE(LOGTAG "get profile vendor interface failed, returning");
+            return;
+        }
+        change_state(HFP_AG_STATE_DISCONNECTED);
+        sBtHfpAgInterface->init(&sBluetoothHfpAgCallbacks, 1);
+        sBtHfpAgVendorInterface->init_vendor(&sBluetoothHfpAgVendorCallbacks);
+
+#if defined(BT_MODEM_INTEGRATION)
+        init_modem();
+#endif
+
+#if defined(BT_ALSA_AUDIO_INTEGRATION)
+        init_audio();
+#endif
+        BtEvent *pEvent = new BtEvent;
+        pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+        pEvent->profile_start_event.profile_id = PROFILE_ID_HFP_AG;
+        pEvent->profile_start_event.status = true;
+        PostMessage(THREAD_ID_GAP, pEvent);
+    }
+}
+
+void Hfp_Ag::HandleDisableAg(void) {
+   change_state(HFP_AG_STATE_NOT_STARTED);
+   if(sBtHfpAgInterface != NULL) {
+       sBtHfpAgInterface->cleanup();
+       sBtHfpAgInterface = NULL;
+   }
+   if(sBtHfpAgVendorInterface != NULL) {
+       sBtHfpAgVendorInterface->cleanup_vendor();
+       sBtHfpAgVendorInterface = NULL;
+   }
+#if defined(BT_MODEM_INTEGRATION)
+   release_modem();
+#endif
+
+#if defined(BT_ALSA_AUDIO_INTEGRATION)
+   release_audio();
+#endif
+
+   BtEvent *pEvent = new BtEvent;
+   pEvent->profile_stop_event.event_id = PROFILE_EVENT_STOP_DONE;
+   pEvent->profile_stop_event.profile_id = PROFILE_ID_HFP_AG;
+   pEvent->profile_stop_event.status = true;
+   PostMessage(THREAD_ID_GAP, pEvent);
+}
+
+void Hfp_Ag::ProcessEvent(BtEvent* pEvent) {
+    ALOGD(LOGTAG " Processing event %d", pEvent->event_id);
+    fprintf(stdout, " AG: Processing event = %d\n", pEvent->event_id);
+    switch(mAgState) {
+        case HFP_AG_STATE_DISCONNECTED:
+            state_disconnected_handler(pEvent);
+            break;
+        case HFP_AG_STATE_PENDING:
+            state_pending_handler(pEvent);
+            break;
+        case HFP_AG_STATE_CONNECTED:
+            state_connected_handler(pEvent);
+            break;
+        case HFP_AG_STATE_AUDIO_ON:
+            state_audio_on_handler(pEvent);
+            break;
+        case HFP_AG_STATE_NOT_STARTED:
+            ALOGE(LOGTAG " STATE UNINITIALIZED, return");
+            break;
+    }
+}
+
+void Hfp_Ag::state_disconnected_handler(BtEvent* pEvent) {
+    char str[18];
+    ALOGD(LOGTAG "state_disconnected_handler Processing event %d", pEvent->event_id);
+    fprintf(stdout, "state_disconnected_handler Processing event %d\n", pEvent->event_id);
+    switch(pEvent->event_id) {
+        case HFP_AG_API_CONNECT_REQ:
+            memcpy(&mConnectingDevice, &pEvent->hfp_ag_event.bd_addr, sizeof(bt_bdaddr_t));
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->connect(&pEvent->hfp_ag_event.bd_addr);
+            }
+            bdaddr_to_string(&mConnectingDevice, str, 18);
+            fprintf(stdout, "connecting with device %s", str);
+            ALOGD(LOGTAG " connecting with device %s", str);
+            change_state(HFP_AG_STATE_PENDING);
+            break;
+        case HFP_AG_CONNECTING_CB:
+            memcpy(&mConnectingDevice, &pEvent->hfp_ag_event.bd_addr, sizeof(bt_bdaddr_t));
+            change_state(HFP_AG_STATE_PENDING);
+            break;
+        case HFP_AG_CONNECTED_CB:
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            memcpy(&mConnectedDevice, &pEvent->hfp_ag_event.bd_addr, sizeof(bt_bdaddr_t));
+
+            bdaddr_to_string(&mConnectedDevice, str, 18);
+            fprintf(stdout, " connected with device %s", str);
+            ALOGD(LOGTAG " connected with device %s", str);
+
+            change_state(HFP_AG_STATE_CONNECTED);
+            break;
+        default:
+            ALOGD(LOGTAG " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+void Hfp_Ag::state_pending_handler(BtEvent* pEvent) {
+    char str[18];
+    ALOGD(LOGTAG "state_pending_handler Processing event %d", pEvent->event_id);
+    fprintf(stdout, "state_pending_handler Processing event %d\n", pEvent->event_id);
+    switch(pEvent->event_id) {
+        case HFP_AG_CONNECTING_CB:
+            break;
+        case HFP_AG_CONNECTED_CB:
+            memcpy(&mConnectedDevice, &pEvent->hfp_ag_event.bd_addr, sizeof(bt_bdaddr_t));
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+
+            bdaddr_to_string(&mConnectedDevice, str, 18);
+            fprintf(stdout, "connected with device %s", str);
+            ALOGD(LOGTAG "connected with device %s", str);
+            change_state(HFP_AG_STATE_CONNECTED);
+            break;
+        case HFP_AG_DISCONNECTED_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Disconnected from or Unable to connect with device %s", str);
+            ALOGD(LOGTAG "Disconnected from or Unable to connect with device %s", str);
+
+            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            change_state(HFP_AG_STATE_DISCONNECTED);
+            break;
+        default:
+            ALOGD(LOGTAG " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+void Hfp_Ag::state_connected_handler(BtEvent* pEvent) {
+    ALOGD(LOGTAG "state_connected_handler Processing event %d", pEvent->event_id);
+    fprintf(stdout, "state_connected_handler Processing event = %d", pEvent->event_id);
+    char str[18];
+    BtEvent *pControlRequest, *pReleaseControlReq;
+    switch(pEvent->event_id) {
+        case HFP_AG_API_CONNECT_REQ: // TODO: handle connections to another device
+            break;
+        case HFP_AG_API_DISCONNECT_REQ:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            if (sBtHfpAgInterface != NULL) {
+                bt_status_t ret_val;
+                ret_val = sBtHfpAgInterface->disconnect(&pEvent->hfp_ag_event.bd_addr);
+                if (ret_val != BT_STATUS_SUCCESS) {
+                    fprintf(stdout, "Failure disconnecting with device %s", str);
+                    ALOGD(LOGTAG "Failure disconnecting with device %s", str);
+                    break;
+                }
+            }
+
+            fprintf(stdout, "Disconnecting with device %s", str);
+            ALOGD(LOGTAG "Disconnecting with device %s", str);
+            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            change_state(HFP_AG_STATE_PENDING);
+            break;
+        case HFP_AG_SLC_CONNECTED_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "SLC connected with device %s", str);
+            ALOGD(LOGTAG " SLC connected with device %s", str);
+#if defined(BT_MODEM_INTEGRATION)
+            processSlcConnected();
+#endif
+            break;
+        case HFP_AG_DISCONNECTED_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Disconnected with device %s", str);
+            ALOGD(LOGTAG "Disconnected with device %s", str);
+
+            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            change_state(HFP_AG_STATE_DISCONNECTED);
+            break;
+        case HFP_AG_DISCONNECTING_CB:
+            break;
+        case HFP_AG_VR_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "VR start/stop req from device %s", str);
+            ALOGD(LOGTAG "VR start/stop req from device %s", str);
+
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+            break;
+        case HFP_AG_WBS_CB:
+            mWbsState = (bthf_wbs_config_t)pEvent->hfp_ag_event.arg1;
+            break;
+        case HFP_AG_NREC_CB:
+            mNrec = (bthf_nrec_t)pEvent->hfp_ag_event.arg1;
+            break;
+        case HFP_AG_ANSWER_CALL_CB:
+            // answer call using RIL APIs.
+            // OK will be sent from stack itself.
+#if defined(BT_MODEM_INTEGRATION)
+            send_voice_cmd(MCM_VOICE_CALL_ANSWER_V01);
+#endif
+            break;
+        case HFP_AG_HANGUP_CALL_CB:
+            // OK will be sent from stack itself.
+#if defined(BT_MODEM_INTEGRATION)
+            end_call(BTHF_CALL_STATE_ACTIVE);
+#endif
+            break;
+        case HFP_AG_VOL_CONTROL_CB:
+            // TODO: change the speaker volume using mm audio shell script
+            // OK will be sent from stack itself.
+            break;
+        case HFP_AG_DIAL_CALL_CB:
+#if defined(BT_MODEM_INTEGRATION)
+            dial_call(pEvent->hfp_ag_event.str, &pEvent->hfp_ag_event.bd_addr);
+#else
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+#endif
+            break;
+        case HFP_AG_CIND_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Sending CIND resp to device %s", str);
+            ALOGD(LOGTAG "Sending CIND resp to device %s", str);
+
+            if (sBtHfpAgInterface != NULL) {
+#if defined(BT_MODEM_INTEGRATION)
+                // we already have active/held/ringing call, call setup info. send it to stack
+                sBtHfpAgInterface->cind_response(1, mNumActiveCalls, mNumHeldCalls,
+                                                mCallSetupState, 5, 0, 5, &pEvent->hfp_ag_event.bd_addr);
+#else
+                sBtHfpAgInterface->cind_response(1, 0, 0, BTHF_CALL_STATE_IDLE, 5, 0, 5, &pEvent->hfp_ag_event.bd_addr);
+#endif
+
+            }
+            break;
+        case HFP_AG_CHLD_CB:
+#if defined(BT_MODEM_INTEGRATION)
+            {
+               uint32 ret_val = 0;
+               ret_val = process_chld(pEvent->hfp_ag_event.arg1);
+               if (ret_val != MCM_SUCCESS_V01) {
+                   ALOGE(LOGTAG, "error processing chld %d", pEvent->hfp_ag_event.arg1);
+                   fprintf(stdout, "error processing chld %d", pEvent->hfp_ag_event.arg1);
+               }
+
+               if (sBtHfpAgInterface != NULL) {
+                   sBtHfpAgInterface->at_response( (ret_val == MCM_SUCCESS_V01)
+                         ? BTHF_AT_RESPONSE_OK : BTHF_AT_RESPONSE_ERROR,
+                         0, &pEvent->hfp_ag_event.bd_addr);
+               }
+            }
+#else
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+#endif
+            break;
+        case HFP_AG_COPS_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Sending COPS resp to device %s", str);
+            ALOGD(LOGTAG "Sending COPS resp to device %s", str);
+
+#if defined(BT_MODEM_INTEGRATION)
+            //  info needs to be fetched from RIL for MDM
+            get_and_send_operator_name(&pEvent->hfp_ag_event.bd_addr);
+#else
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->cops_response("", &pEvent->hfp_ag_event.bd_addr);
+            }
+#endif
+            break;
+        case HFP_AG_SUBSCRIBER_INFO_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Sending CNUM resp to device %s", str);
+            ALOGD(LOGTAG "Sending CNUM resp to device %s", str);
+
+#if defined(BT_MODEM_INTEGRATION)
+            //  info needs to be fetched from RIL for MDM
+            get_and_send_subscriber_number(&pEvent->hfp_ag_event.bd_addr);
+#else
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+#endif
+            break;
+        case HFP_AG_CLCC_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Sending CLCC resp to device %s", str);
+            ALOGD(LOGTAG "Sending CLCC resp to device %s", str);
+
+            // TODO: cross check if we need to call get_current_calls here.
+
+            if (sBtHfpAgInterface != NULL) {
+#if defined(BT_MODEM_INTEGRATION)
+                for (int i = 0; i < MCM_MAX_VOICE_CALLS_V01; i++) {
+                    if (mCalls[i].call_id != 0xFFFFFFFF)
+                        sBtHfpAgInterface->clcc_response(mCalls[i].idx,
+                                                         mCalls[i].dir,
+                                                         mCalls[i].stat,
+                                                         mCalls[i].mode,
+                                                         mCalls[i].mpty,
+                                                         mCalls[i].number,
+                                                         mCalls[i].numType,
+                                                         &pEvent->hfp_ag_event.bd_addr);
+                }
+#endif
+                // just send OK for now
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_OK, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+            break;
+         case HFP_AG_UNKNOWN_AT_CMD_CB:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+         break;
+#if defined(BT_MODEM_INTEGRATION)
+         case HFP_AG_RIL_IND_CB:
+             process_ril_ind(pEvent);
+             break;
+         case HFP_AG_RIL_RESP_CB:
+             process_ril_resp(pEvent);
+             break;
+#endif
+        case HFP_AG_API_CONNECT_AUDIO_REQ:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Connecting SCO/eSCO with device %s", str);
+            ALOGD(LOGTAG "Connecting SCO/eSCO with device %s", str);
+
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->connect_audio(&pEvent->hfp_ag_event.bd_addr);
+            }
+            break;
+        case HFP_AG_AUDIO_STATE_CONNECTED_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "SCO/eSCO connected with device %s, codec %s", str,
+                ((mWbsState == BTHF_WBS_YES)? "WBS": "NBS"));
+            ALOGD(LOGTAG "SCO/eSCO connected with device %s, codec %s", str,
+                ((mWbsState == BTHF_WBS_YES)? "WBS": "NBS"));
+
+#if defined(BT_ALSA_AUDIO_INTEGRATION)
+            setup_sco_path();
+#endif
+            change_state(HFP_AG_STATE_AUDIO_ON);
+            break;
+        case HFP_AG_BIND_CB:
+            process_at_bind(pEvent);
+            break;
+        case HFP_AG_BIEV_CB:
+            process_at_biev(pEvent);
+            break;
+        case HFP_AG_API_ACCEPT_CALL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_RELEASE_HELD_CALL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_REJECT_CALL_REQ:
+            break;
+        case HFP_AG_API_END_CALL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_HOLD_CALL_REQ:
+            break;
+        case HFP_AG_API_SWAP_CALLS_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_DIAL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_REDIAL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_START_VR_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->start_voice_recognition(&mConnectedDevice);
+            }
+            break;
+        case HFP_AG_API_STOP_VR_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->stop_voice_recognition(&mConnectedDevice);
+            }
+            break;
+        case HFP_AG_API_QUERY_CURRENT_CALLS_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_QUERY_OPERATOR_NAME_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_QUERY_SUBSCRIBER_INFO_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_SPK_VOL_CTRL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->volume_control(BTHF_VOLUME_TYPE_SPK,
+                                          pEvent->hfp_ag_event.arg1, &mConnectedDevice);
+            }
+            break;
+        case HFP_AG_API_MIC_VOL_CTRL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->volume_control(BTHF_VOLUME_TYPE_MIC,
+                                          pEvent->hfp_ag_event.arg1, &mConnectedDevice);
+            }
+            break;
+        default:
+            ALOGD(LOGTAG," event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+void Hfp_Ag::state_audio_on_handler(BtEvent* pEvent) {
+    char str[18];
+    BtEvent *pControlRequest, *pReleaseControlReq;
+    ALOGD(LOGTAG "state_audio_on_handler Processing event %d", pEvent->event_id);
+    switch(pEvent->event_id) {
+        case HFP_AG_API_DISCONNECT_REQ:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+
+            // disconnect SCO, clean up SCO
+#if defined(BT_ALSA_AUDIO_INTEGRATION)
+            teardown_sco_path();
+#endif
+            if (sBtHfpAgInterface != NULL) {
+                bt_status_t ret_val;
+                // no need to check if disconnection of SCO is success here.
+                sBtHfpAgInterface->disconnect_audio(&pEvent->hfp_ag_event.bd_addr);
+
+                ret_val = sBtHfpAgInterface->disconnect(&pEvent->hfp_ag_event.bd_addr);
+                if (ret_val != BT_STATUS_SUCCESS) {
+                    fprintf(stdout, "Failure disconnecting with device %s", str);
+                    ALOGD(LOGTAG "Failure disconnecting with device %s", str);
+                    break;
+                }
+            }
+
+            fprintf(stdout, "Disconnecting with device %s", str);
+            ALOGD(LOGTAG "Disconnecting with device %s", str);
+            memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
+            memset(&mConnectingDevice, 0, sizeof(bt_bdaddr_t));
+            change_state(HFP_AG_STATE_PENDING);
+            break;
+        case HFP_AG_API_DISCONNECT_AUDIO_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->disconnect_audio(&pEvent->hfp_ag_event.bd_addr);
+            }
+
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Disconnecting SCO/eSCO with device %s", str);
+            ALOGD(LOGTAG "Disconnecting SCO/eSCO with device %s", str);
+            break;
+        case HFP_AG_AUDIO_STATE_DISCONNECTED_CB:
+
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Disconnected SCO connection with device %s", str);
+            ALOGD(LOGTAG "Disconnected SCO connection with device %s", str);
+
+#if defined(BT_ALSA_AUDIO_INTEGRATION)
+            teardown_sco_path();
+#endif
+            change_state(HFP_AG_STATE_CONNECTED);
+            break;
+        case HFP_AG_VR_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "VR start/stop req from device %s", str);
+            ALOGD(LOGTAG "VR start/stop req from device %s", str);
+
+            // send error for VR start/stop request
+
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+            break;
+        case HFP_AG_WBS_CB:
+            mWbsState = (bthf_wbs_config_t)pEvent->hfp_ag_event.arg1;
+            break;
+        case HFP_AG_NREC_CB:
+            mNrec = (bthf_nrec_t)pEvent->hfp_ag_event.arg1;
+            break;
+        case HFP_AG_ANSWER_CALL_CB:
+            // answer call using RIL APIs.
+            // OK will be sent from stack itself.
+#if defined(BT_MODEM_INTEGRATION)
+            send_voice_cmd(MCM_VOICE_CALL_ANSWER_V01);
+#endif
+            break;
+        case HFP_AG_HANGUP_CALL_CB:
+            // OK will be sent from stack itself.
+#if defined(BT_MODEM_INTEGRATION)
+            end_call(BTHF_CALL_STATE_ACTIVE);
+#endif
+            break;
+        case HFP_AG_VOL_CONTROL_CB:
+            // TODO: change the speaker volume using mm audio shell script
+            // OK will be sent from stack itself.
+            break;
+        case HFP_AG_DIAL_CALL_CB:
+#if defined(BT_MODEM_INTEGRATION)
+            dial_call(pEvent->hfp_ag_event.str, &pEvent->hfp_ag_event.bd_addr);
+#else
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+#endif
+            break;
+        case HFP_AG_CIND_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Sending CIND resp to device %s", str);
+            ALOGD(LOGTAG "Sending CIND resp to device %s", str);
+
+            if (sBtHfpAgInterface != NULL) {
+#if defined(BT_MODEM_INTEGRATION)
+                // we already have active/held/ringing call, call setup info. send it to stack
+                sBtHfpAgInterface->cind_response(1, mNumActiveCalls, mNumHeldCalls,
+                                                mCallSetupState, 5, 0, 5, &pEvent->hfp_ag_event.bd_addr);
+#else
+                sBtHfpAgInterface->cind_response(1, 0, 0, BTHF_CALL_STATE_IDLE, 5, 0, 5, &pEvent->hfp_ag_event.bd_addr);
+#endif
+
+            }
+            break;
+        case HFP_AG_CHLD_CB:
+#if defined(BT_MODEM_INTEGRATION)
+            {
+               uint32 ret_val = 0;
+               ret_val = process_chld(pEvent->hfp_ag_event.arg1);
+               if (ret_val != MCM_SUCCESS_V01) {
+                   ALOGE(LOGTAG, "error processing chld %d", pEvent->hfp_ag_event.arg1);
+                   fprintf(stdout, "error processing chld %d", pEvent->hfp_ag_event.arg1);
+               }
+
+               if (sBtHfpAgInterface != NULL) {
+                   sBtHfpAgInterface->at_response( (ret_val == MCM_SUCCESS_V01)
+                         ? BTHF_AT_RESPONSE_OK : BTHF_AT_RESPONSE_ERROR,
+                         0, &pEvent->hfp_ag_event.bd_addr);
+               }
+            }
+#else
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+#endif
+            break;
+        case HFP_AG_COPS_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Sending COPS resp to device %s", str);
+            ALOGD(LOGTAG "Sending COPS resp to device %s", str);
+
+#if defined(BT_MODEM_INTEGRATION)
+            //  info needs to be fetched from RIL for MDM
+            get_and_send_operator_name(&pEvent->hfp_ag_event.bd_addr);
+#else
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->cops_response("", &pEvent->hfp_ag_event.bd_addr);
+            }
+#endif
+            break;
+        case HFP_AG_SUBSCRIBER_INFO_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Sending CNUM resp to device %s", str);
+            ALOGD(LOGTAG "Sending CNUM resp to device %s", str);
+
+#if defined(BT_MODEM_INTEGRATION)
+            //  info needs to be fetched from RIL for MDM
+            get_and_send_subscriber_number(&pEvent->hfp_ag_event.bd_addr);
+#else
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+#endif
+            break;
+        case HFP_AG_CLCC_CB:
+            bdaddr_to_string(&pEvent->hfp_ag_event.bd_addr, str, 18);
+            fprintf(stdout, "Sending CLCC resp to device %s", str);
+            ALOGD(LOGTAG "Sending CLCC resp to device %s", str);
+
+            // TODO: cross check if we need to call get_current_calls here.
+
+            if (sBtHfpAgInterface != NULL) {
+#if defined(BT_MODEM_INTEGRATION)
+                for (int i = 0; i < MCM_MAX_VOICE_CALLS_V01; i++) {
+                    if (mCalls[i].call_id != 0xFFFFFFFF)
+                        sBtHfpAgInterface->clcc_response(mCalls[i].idx,
+                                                         mCalls[i].dir,
+                                                         mCalls[i].stat,
+                                                         mCalls[i].mode,
+                                                         mCalls[i].mpty,
+                                                         mCalls[i].number,
+                                                         mCalls[i].numType,
+                                                         &pEvent->hfp_ag_event.bd_addr);
+                }
+#endif
+                // just send OK for now
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_OK, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+            break;
+         case HFP_AG_UNKNOWN_AT_CMD_CB:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+            }
+         break;
+#if defined(BT_MODEM_INTEGRATION)
+         case HFP_AG_RIL_IND_CB:
+             process_ril_ind(pEvent);
+             break;
+         case HFP_AG_RIL_RESP_CB:
+             process_ril_resp(pEvent);
+             break;
+#endif
+        case HFP_AG_BIND_CB:
+            process_at_bind(pEvent);
+            break;
+        case HFP_AG_BIEV_CB:
+            process_at_biev(pEvent);
+            break;
+        case HFP_AG_API_ACCEPT_CALL_REQ:
+            break;
+        case HFP_AG_API_RELEASE_HELD_CALL_REQ:
+            break;
+        case HFP_AG_API_REJECT_CALL_REQ:
+            break;
+        case HFP_AG_API_END_CALL_REQ:
+            break;
+        case HFP_AG_API_HOLD_CALL_REQ:
+            break;
+        case HFP_AG_API_SWAP_CALLS_REQ:
+            break;
+        case HFP_AG_API_DIAL_REQ:
+            break;
+        case HFP_AG_API_REDIAL_REQ:
+            break;
+        case HFP_AG_API_START_VR_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->start_voice_recognition(&mConnectedDevice);
+            }
+            break;
+        case HFP_AG_API_STOP_VR_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->stop_voice_recognition(&mConnectedDevice);
+            }
+            break;
+        case HFP_AG_API_QUERY_CURRENT_CALLS_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_QUERY_OPERATOR_NAME_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_QUERY_SUBSCRIBER_INFO_REQ:
+            if (sBtHfpAgInterface != NULL) {
+            }
+            break;
+        case HFP_AG_API_SPK_VOL_CTRL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->volume_control(BTHF_VOLUME_TYPE_SPK,
+                                          pEvent->hfp_ag_event.arg1, &mConnectedDevice);
+            }
+            break;
+        case HFP_AG_API_MIC_VOL_CTRL_REQ:
+            if (sBtHfpAgInterface != NULL) {
+                sBtHfpAgInterface->volume_control(BTHF_VOLUME_TYPE_MIC,
+                                          pEvent->hfp_ag_event.arg1, &mConnectedDevice);
+            }
+            break;
+        default:
+            ALOGD(LOGTAG," event not handled %d ", pEvent->event_id);
+            break;
+    }
+
+}
+
+void Hfp_Ag::ConfigureAudio(bool enable) {
+
+}
+
+#if defined(BT_MODEM_INTEGRATION)
+
+void Hfp_Ag::processSlcConnected() {
+  //  update the calls info to stack once done with SLC
+  // TODO: should we add any delay here?
+   sBtHfpAgInterface->phone_state_change(mNumActiveCalls,
+                               mNumHeldCalls,
+                               mCallSetupState,
+                               mRingingAddress == NULL ? "" : mRingingAddress,
+                               BTHF_CALL_ADDRTYPE_INTERNATIONAL);
+}
+
+void Hfp_Ag::get_and_send_operator_name(bt_bdaddr_t *bd_addr) {
+   uint32 ret_val = 0;
+   mcm_nw_get_operator_name_req_msg_v01 cops_req;
+
+   memset(&cops_req, 0, sizeof(cops_req));
+   memset(&cops_resp, 0, sizeof(cops_resp));
+
+   ret_val = mcm_client_execute_command_sync_ptr(mcm_client_hdl,
+                                 MCM_NW_GET_OPERATOR_NAME_REQ_V01,
+                                 &cops_req,
+                                 sizeof(cops_req),
+                                 &cops_resp,
+                                 sizeof(mcm_nw_get_operator_name_resp_msg_v01));
+   if (ret_val == MCM_SUCCESS_V01 && cops_resp.operator_name_valid) {
+       ALOGD(LOGTAG, "getting operator name successful");
+       if (sBtHfpAgInterface != NULL) {
+           // TODO: cross check of short_eons has the operator name
+           sBtHfpAgInterface->cops_response(cops_resp.operator_name.short_eons, bd_addr);
+       }
+   }
+   else {
+       ALOGE(LOGTAG, "getting operator name list failed");
+       if (sBtHfpAgInterface != NULL) {
+           sBtHfpAgInterface->cops_response("", bd_addr);
+       }
+   }
+}
+
+void Hfp_Ag::get_and_send_subscriber_number(bt_bdaddr_t *bd_addr) {
+   uint32 ret_val = 0;
+   mcm_sim_get_device_phone_number_req_msg_v01 cnum_req;
+
+   memset(&cnum_req, 0, sizeof(cnum_req));
+
+   ret_val = mcm_client_execute_command_sync_ptr(mcm_client_hdl,
+                                 MCM_SIM_GET_DEVICE_PHONE_NUMBER_REQ_V01,
+                                 &cnum_req,
+                                 sizeof(cnum_req),
+                                 &get_phone_num_resp,
+                                 sizeof(mcm_sim_get_device_phone_number_resp_msg_v01));
+   if (ret_val == MCM_SUCCESS_V01 &&
+         get_phone_num_resp.resp.result == MCM_RESULT_SUCCESS_V01 &&
+         get_phone_num_resp.phone_number_valid) {
+       ALOGD(LOGTAG, "getting subscriber info successful");
+       if (sBtHfpAgInterface != NULL) {
+           char phone_num_str[256];
+           strcpy(phone_num_str, "+CNUM: ,\"");
+
+           // dest buffer is 256 bytes length handle buffer overflow if phone number length is > 239
+           if (get_phone_num_resp.phone_number_len > 239)
+               strncat(phone_num_str, get_phone_num_resp.phone_number, 239);
+           else
+               strcat(phone_num_str, get_phone_num_resp.phone_number);
+
+           strcat(phone_num_str, "\",145,,4");
+
+           sBtHfpAgInterface->formatted_at_response(phone_num_str, bd_addr);
+           sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_OK, 0, bd_addr);
+       }
+   }
+   else {
+       ALOGE(LOGTAG, "getting subscriber info failed");
+       if (sBtHfpAgInterface != NULL) {
+           sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, bd_addr);
+       }
+   }
+}
+
+bthf_call_state_t Hfp_Ag::get_call_state(mcm_voice_call_state_t_v01 state){
+    switch (state) {
+       case MCM_VOICE_CALL_STATE_INCOMING_V01:
+          mNumRingingCalls++;
+          mCallSetupState = BTHF_CALL_STATE_INCOMING;
+          return BTHF_CALL_STATE_INCOMING;
+       case MCM_VOICE_CALL_STATE_DIALING_V01:
+          mCallSetupState = BTHF_CALL_STATE_DIALING;
+          return BTHF_CALL_STATE_DIALING;
+       case MCM_VOICE_CALL_STATE_ALERTING_V01:
+          mCallSetupState = BTHF_CALL_STATE_ALERTING;
+          return BTHF_CALL_STATE_ALERTING;
+       case MCM_VOICE_CALL_STATE_ACTIVE_V01:
+          mNumActiveCalls++;
+          return BTHF_CALL_STATE_ACTIVE;
+       case MCM_VOICE_CALL_STATE_HOLDING_V01:
+          mNumHeldCalls++;
+          return BTHF_CALL_STATE_HELD;
+       case MCM_VOICE_CALL_STATE_WAITING_V01:
+          mNumRingingCalls++;
+          mCallSetupState = BTHF_CALL_STATE_INCOMING;
+          return BTHF_CALL_STATE_INCOMING;
+       case MCM_VOICE_CALL_STATE_END_V01:
+          // intenntional fall through
+       default:
+          return BTHF_CALL_STATE_IDLE;
+    }
+}
+
+void Hfp_Ag::process_call_list(mcm_voice_call_record_t_v01 *calls, uint32_t num_calls) {
+    mcm_voice_call_record_t_v01 *call_record;
+    uint32_t i, j;
+
+    mNumActiveCalls = 0;
+    mNumHeldCalls = 0;
+    mNumRingingCalls = 0;
+    mCallSetupState = BTHF_CALL_STATE_IDLE;
+    mRingingAddress = NULL;
+    memset(mCalls, 0, sizeof(mCalls));
+
+    // call_id should be invalidated
+    for (i = 0; i < MCM_MAX_VOICE_CALLS_V01; i++) {
+        mCalls[i].call_id = 0xFFFFFFFF;
+        mCalls[i].idx = 0;
+    }
+
+    for (i = 0, j = 0; j < num_calls; j++) {
+        call_record = &calls[j];
+
+        // if list contains terminated call info, don't update its info in our call list
+        if (call_record->state == MCM_VOICE_CALL_STATE_END_V01)
+           continue;
+
+        mCalls[i].call_id = call_record->call_id;  // call_id is not index
+        mCalls[i].idx = i+1; // in CLCC resp, index starts from 1
+        mCalls[i].dir = (call_record->direction == MCM_VOICE_CALL_MOBILE_ORIGINATED_V01)
+                          ? BTHF_CALL_DIRECTION_OUTGOING : BTHF_CALL_DIRECTION_INCOMING;
+        mCalls[i].stat = get_call_state(call_record->state);
+        mCalls[i].mode = BTHF_CALL_TYPE_VOICE;
+        // TODO: this needs to be revisited since RIL does not provide this info
+        mCalls[i].mpty = BTHF_CALL_MPTY_TYPE_SINGLE;
+        mCalls[i].numType = BTHF_CALL_ADDRTYPE_INTERNATIONAL; // TODO: cross check
+        strncpy(mCalls[i].number, call_record->number, sizeof(call_record->number));
+
+        if (mCalls[i].stat == BTHF_CALL_STATE_INCOMING ||
+             mCalls[i].stat == BTHF_CALL_STATE_WAITING)
+           mRingingAddress = mCalls[i].number;
+        i++;
+    }
+}
+
+int Hfp_Ag::get_current_calls() {
+   int ret_val = 0;
+
+   mcm_voice_get_calls_req_msg_v01         get_calls_req_msg;
+   mcm_voice_get_calls_resp_msg_v01        get_calls_resp_msg;
+
+   memset(&get_calls_req_msg, 0, sizeof(get_calls_req_msg));
+   memset(&get_calls_resp_msg, 0, sizeof(get_calls_resp_msg));
+
+   ret_val = mcm_client_execute_command_sync_ptr(mcm_client_hdl,
+                                              MCM_VOICE_GET_CALLS_REQ_V01,
+                                              &get_calls_req_msg,
+                                              sizeof(get_calls_req_msg),
+                                              &get_calls_resp_msg,
+                                              sizeof(get_calls_resp_msg));
+   if (ret_val == MCM_SUCCESS_V01) {
+       ALOGD(LOGTAG, "getting current call list successful");
+       // store the call information
+       process_call_list(get_calls_resp_msg.calls, get_calls_resp_msg.calls_len);
+   }
+   else
+       ALOGE(LOGTAG, "getting current call list failed");
+
+   return ret_val;
+}
+
+void Hfp_Ag::dial_call(char *number, bt_bdaddr_t *bd_addr) {
+    if (mDiallingOut == true ||
+        (strlen(number) == 0) && (strlen(mLastDialledNumber) == 0) ||
+         number[0] == '>' ||
+         strlen(number) > MCM_MAX_PHONE_NUMBER_V01) {
+        ALOGE(LOGTAG, "MO call in progress, or number not available of redial or memory dialling not supported");
+        fprintf(stdout, "MO call in progress, or number not available of redial or memory dialling not supported\n");
+        // if MO call is already being initiated, send error
+        // if it is redial request and we don't have last dialled number, send error
+        // if memory dialling is requested, send error
+        if (sBtHfpAgInterface != NULL)
+            sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, bd_addr);
+        return;
+    }
+
+    uint32 ret_val = 0;
+    mcm_voice_dial_req_msg_v01   dial_req;
+    memset(&dial_req, 0, sizeof(mcm_voice_dial_req_msg_v01));
+    memset(&dial_resp, 0, sizeof(mcm_voice_dial_resp_msg_v01));
+
+    dial_req.address_valid = true;
+
+    // redial request
+    if (strlen(number) == 0)
+        strncpy(dial_req.address, mLastDialledNumber, strlen(mLastDialledNumber));
+    else {
+        // remove trailing ';' if present
+        if (number[strlen(number) - 1] == ';')
+            strncpy(dial_req.address, number, strlen(number) - 1);
+        else
+            strncpy(dial_req.address, number, strlen(number));
+    }
+
+    ret_val = mcm_client_execute_command_async_ptr(mcm_client_hdl,
+                                                   MCM_VOICE_DIAL_REQ_V01,
+                                                   &dial_req,
+                                                   sizeof(dial_req),
+                                                   &dial_resp,
+                                                   sizeof(dial_resp),
+                                                   ril_resp_cb,
+                                                   &token_id);
+
+    if (ret_val != MCM_SUCCESS_V01) {
+        ALOGE(LOGTAG, "sending dial command failed");
+        fprintf(stdout, LOGTAG "sending dial command failed\n");
+        // send error if dial fails
+        if (sBtHfpAgInterface != NULL)
+            sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, bd_addr);
+        return;
+    }
+
+    mDiallingOut = true;
+    // store the last dialled number
+    if (number[strlen(number) - 1] == ';')
+        strncpy(dial_req.address, number, strlen(number) - 1);
+    else
+        strncpy(dial_req.address, number, strlen(number));
+}
+
+uint32 Hfp_Ag::send_voice_cmd(mcm_voice_call_operation_t_v01 op) {
+
+    uint32 ret_val = 0;
+    mcm_voice_command_req_msg_v01    voice_cmd_req;
+
+    memset(&voice_cmd_req, 0, sizeof(mcm_voice_command_req_msg_v01));
+    memset(&voice_cmd_resp, 0, sizeof(mcm_voice_command_resp_msg_v01));
+
+    voice_cmd_req.call_operation = op;
+    ret_val = mcm_client_execute_command_async_ptr(mcm_client_hdl,
+                                                   MCM_VOICE_COMMAND_REQ_V01,
+                                                   &voice_cmd_req,
+                                                   sizeof(voice_cmd_req),
+                                                   &voice_cmd_resp,
+                                                   sizeof(voice_cmd_resp),
+                                                   ril_resp_cb,
+                                                   &token_id);
+
+   if (ret_val == MCM_SUCCESS_V01) {
+       // save operation to process the response call back
+       call_op = op;
+   }
+   else {
+        ALOGE(LOGTAG, "sending %d command failed", op);
+        fprintf(stdout, "sending %d command failed\n", op);
+   }
+
+   return ret_val;
+}
+
+uint32 Hfp_Ag::get_call_id(bthf_call_state_t state){
+    for (uint8 i = 0; i < MCM_MAX_VOICE_CALLS_V01; i++) {
+        if (mCalls[i].call_id != 0xFFFFFFFF && mCalls[i].stat == state)
+            return mCalls[i].call_id;
+    }
+    return 0xFFFFFFFF;
+}
+
+uint32 Hfp_Ag::end_call(bthf_call_state_t state) {
+
+    uint32 ret_val = 0, call_id = 0;
+    mcm_voice_hangup_req_msg_v01 hangup_req;
+
+    call_id = get_call_id(state);
+    if (call_id == 0xFFFFFFFF) {
+        ALOGE(LOGTAG, "%s: No calls in state %u to hangup, returning", __func__, state);
+        fprintf(stdout, "%s: No calls in state %u to hangup, returning\n", __func__, state);
+        return MCM_ERROR_GENERIC_V01;
+    }
+
+    memset(&hangup_req, 0, sizeof(mcm_voice_hangup_req_msg_v01));
+    memset(&hangup_resp, 0, sizeof(mcm_voice_hangup_resp_msg_v01 ));
+
+    hangup_req.call_id = call_id;
+    ret_val = mcm_client_execute_command_async_ptr(mcm_client_hdl,
+                                                   MCM_VOICE_HANGUP_REQ_V01,
+                                                   &hangup_req,
+                                                   sizeof(hangup_req),
+                                                   &hangup_resp,
+                                                   sizeof(hangup_resp),
+                                                   ril_resp_cb,
+                                                   &token_id);
+
+   if (ret_val != MCM_SUCCESS_V01) {
+        ALOGE(LOGTAG, "sending hangup command failed");
+        fprintf(stdout, LOGTAG "sending hangup command failed\n");
+   }
+
+   return ret_val;
+}
+
+uint32 Hfp_Ag::process_chld(int chld) {
+   uint32 ret_val = MCM_ERROR_GENERIC_V01;
+
+   switch (chld) {
+       case BTHF_CHLD_TYPE_RELEASEHELD:
+          if (mNumRingingCalls > 0) {
+              // state BTHF_CALL_STATE_INCOMING for incoming/waiting calls
+              ret_val = end_call(BTHF_CALL_STATE_INCOMING);
+          }
+          else if(mNumHeldCalls > 0)
+              ret_val = end_call(BTHF_CALL_STATE_HELD);
+       break;
+       case BTHF_CHLD_TYPE_RELEASEACTIVE_ACCEPTHELD:
+          if (mNumActiveCalls == 0 && mNumHeldCalls == 0 && mNumRingingCalls == 0)
+              break;
+
+          if (mNumActiveCalls > 0)
+              ret_val = end_call(BTHF_CALL_STATE_ACTIVE);
+
+          if (mNumRingingCalls > 0)
+              ret_val = send_voice_cmd(MCM_VOICE_CALL_ANSWER_V01);
+          else if (mNumHeldCalls > 0)
+              ret_val = send_voice_cmd(MCM_VOICE_CALL_UNHOLD_V01);
+       break;
+       case BTHF_CHLD_TYPE_HOLDACTIVE_ACCEPTHELD:
+          if (mNumActiveCalls > 0)
+              ret_val = send_voice_cmd(MCM_VOICE_CALL_HOLD_V01);
+
+          if (mNumRingingCalls > 0)
+              ret_val = send_voice_cmd(MCM_VOICE_CALL_ANSWER_V01);
+          else if (mNumHeldCalls > 0)
+              ret_val = send_voice_cmd(MCM_VOICE_CALL_UNHOLD_V01);
+       break;
+       case BTHF_CHLD_TYPE_ADDHELDTOCONF:
+          // TODO: cross check on this. There is no way to know from RIL if a call is in conference
+          if (mNumActiveCalls > 0 && mNumHeldCalls > 0)
+             ret_val = send_voice_cmd(MCM_VOICE_CALL_CONFERENCE_V01);
+       break;
+       default:
+          ALOGE(LOGTAG, "unhandled chld command %d", chld);
+          fprintf(stdout, "unhandled chld command %d\n", chld);
+       break;
+   }
+   return ret_val;
+}
+
+void Hfp_Ag::process_ril_ind(BtEvent* pEvent){
+   if (pEvent->hfp_ag_event.hdl != mcm_client_hdl) {
+       fprintf(stdout, "invalid mcm client handle, returning\n");
+       ALOGE(LOGTAG, "%s: invalid mcm client handle, returning\n");
+       return;
+   }
+
+   switch(pEvent->hfp_ag_event.msg_id){
+      case MCM_VOICE_CALL_IND_V01:
+      {
+          mcm_voice_call_ind_msg_v01 *call_ind =
+                   (mcm_voice_call_ind_msg_v01 *)(pEvent->hfp_ag_event.data);
+          // TODO: save the existing active, held and ringing call info before updating them.
+          // Send the information to stack only when there is a change in the call info
+          if (call_ind != NULL) {
+              process_call_list(call_ind->calls, call_ind->calls_len);
+              // for MO call initiated from BT headset, send OK to headset
+              if (mDiallingOut == true && mCallSetupState == BTHF_CALL_STATE_DIALING) {
+                  mDiallingOut = false;
+                  sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_OK, 0,
+                                                 &pEvent->hfp_ag_event.bd_addr);
+              }
+              //  update the calls info to stack
+              sBtHfpAgInterface->phone_state_change(mNumActiveCalls,
+                     mNumHeldCalls,
+                     mCallSetupState,
+                     mRingingAddress == NULL ? "" : mRingingAddress,
+                     BTHF_CALL_ADDRTYPE_INTERNATIONAL);
+          }
+      }
+          break;
+      case MCM_NW_SIGNAL_STRENGTH_EVENT_IND_V01:
+      {
+          mcm_nw_signal_strength_event_ind_msg_v01 *network_ss_ind_msg =
+                      (mcm_nw_signal_strength_event_ind_msg_v01 *)(pEvent->hfp_ag_event.data);
+      }
+          break;
+      case MCM_VOICE_MUTE_IND_V01:
+      // intentional fall through
+      case MCM_VOICE_DTMF_IND_V01:
+      // intentional fall through
+      default:
+          fprintf(stdout, "unhandled indication\n", pEvent->hfp_ag_event.msg_id);
+          ALOGD(LOGTAG, "unhandled indication %u\n", pEvent->hfp_ag_event.msg_id);
+          break;
+   }
+}
+
+void Hfp_Ag::process_ril_resp(BtEvent* pEvent){
+   if (pEvent->hfp_ag_event.hdl != mcm_client_hdl) {
+       fprintf(stdout, "invalid mcm client handle, returning\n");
+       ALOGE(LOGTAG, "%s: invalid mcm client handle, returning\n");
+       return;
+   }
+
+   switch(pEvent->hfp_ag_event.msg_id){
+      case MCM_VOICE_DIAL_RESP_V01:
+      {
+          mcm_voice_dial_resp_msg_v01 *dial_resp = (mcm_voice_dial_resp_msg_v01*)pEvent->hfp_ag_event.data;
+          mcm_response_t_v01 *resp = &dial_resp->response;
+
+          // if dial request failed, send error to remote
+          if (resp->result != MCM_RESULT_SUCCESS_V01) {
+              ALOGE(LOGTAG, "dialling call failed with error %d", resp->error);
+              fprintf(stdout, "dialling call failed with error %d\n", resp->error);
+              if (sBtHfpAgInterface != NULL)
+                  sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_ERROR, 0, &pEvent->hfp_ag_event.bd_addr);
+          }
+      }
+          break;
+      case MCM_VOICE_COMMAND_RESP_V01:
+      {
+          mcm_voice_command_resp_msg_v01 *cmd_resp = (mcm_voice_command_resp_msg_v01 *)pEvent->hfp_ag_event.data;
+          mcm_response_t_v01 *resp = &cmd_resp->response;
+
+          // if voice command request failed, send error to remote
+          if (resp->result != MCM_RESULT_SUCCESS_V01) {
+              ALOGE(LOGTAG, "voice command %d failed with error %d", call_op, resp->error);
+              fprintf(stdout, "voice command %d failed with error %d\n", call_op, resp->error);
+          }
+      }
+          break;
+      case MCM_VOICE_HANGUP_RESP_V01:
+      {
+          mcm_voice_hangup_resp_msg_v01 *hangup_resp = (mcm_voice_hangup_resp_msg_v01 *)pEvent->hfp_ag_event.data;
+          mcm_response_t_v01 *resp = &hangup_resp->response;
+
+          // if hangup request failed, send error to remote
+          if (resp->result != MCM_RESULT_SUCCESS_V01) {
+              ALOGE(LOGTAG, "ending call failed with error %d", resp->error);
+              fprintf(stdout, "ending call failed with error %d\n", resp->error);
+          }
+      }
+          break;
+      default:
+          ALOGE(LOGTAG, "unhandled response %d", pEvent->hfp_ag_event.msg_id);
+          fprintf(stdout, "unhandled response %d\n", pEvent->hfp_ag_event.msg_id);
+          break;
+   }
+}
+
+void Hfp_Ag::init_modem() {
+   lib_handle = NULL;
+   mcm_client_hdl = 0;
+   mcm_client_init_ptr = NULL;
+   mcm_client_release_ptr = NULL;
+   mcm_client_execute_command_async_ptr = NULL;
+   mcm_client_execute_command_sync_ptr= NULL;
+
+   // reset call related information
+   mDiallingOut = false;
+   mNumActiveCalls = 0;
+   mNumHeldCalls = 0;
+   mNumRingingCalls = 0;
+   mSignalStrength = 0;
+   mCallSetupState = BTHF_CALL_STATE_IDLE;
+   memset(mLastDialledNumber, 0, sizeof(mLastDialledNumber));
+   memset(mCalls, 0, sizeof(mCalls));
+
+   // call_id should be invalidated
+   for (int i = 0; i < MCM_MAX_VOICE_CALLS_V01; i++) {
+       mCalls[i].call_id = 0xFFFFFFFF;
+       mCalls[i].idx = 0;
+   }
+
+   lib_handle = dlopen(MCM_LIBRARY_NAME, RTLD_NOW);
+
+   if (!lib_handle) {
+      ALOGE(LOGTAG, "%s unable to open %s: %s", __func__, MCM_LIBRARY_NAME, dlerror());
+      return;
+   }
+
+   mcm_client_init_ptr = (mcm_client_init_t)dlsym(lib_handle, "mcm_client_init");
+   // TODO: handle error
+   if (mcm_client_init_ptr == NULL) {
+       ALOGE(LOGTAG, "unable to find mcm_client_init symbol");
+   }
+
+   mcm_client_release_ptr = (mcm_client_release_t)dlsym(lib_handle, "mcm_client_release");
+   // TODO: handle error
+   if (mcm_client_release_ptr == NULL) {
+       ALOGE(LOGTAG, "unable to find mcm_client_release symbol");
+   }
+   mcm_client_execute_command_async_ptr =
+         (mcm_client_execute_command_async_t)dlsym(lib_handle,
+                                           "mcm_client_execute_command_async");
+   // TODO: handle error
+   if (mcm_client_execute_command_async_ptr == NULL) {
+       ALOGE(LOGTAG, "unable to find mcm_client_execute_command_async symbol");
+   }
+   mcm_client_execute_command_sync_ptr =
+         (mcm_client_execute_command_sync_t)dlsym(lib_handle,
+                                          "mcm_client_execute_command_sync");
+   // TODO: handle error
+   if (mcm_client_execute_command_sync_ptr == NULL) {
+       ALOGE(LOGTAG, "unable to find mcm_client_execute_command_sync symbol");
+   }
+
+   mcm_client_init_ptr(&mcm_client_hdl, ril_ind_cb, ril_resp_cb);
+
+   mcm_voice_event_register_req_msg_v01   req_msg;
+   mcm_voice_event_register_resp_msg_v01  resp_msg;
+
+   memset(&req_msg, 0, sizeof(req_msg));
+   memset(&resp_msg, 0, sizeof(resp_msg));
+
+   req_msg.register_voice_call_event_valid = TRUE;
+   req_msg.register_voice_call_event       = TRUE;
+
+   int ret_val = MCM_ERROR_GENERIC_V01;
+
+   ret_val = mcm_client_execute_command_sync_ptr(mcm_client_hdl,
+                                             MCM_VOICE_EVENT_REGISTER_REQ_V01,
+                                             &req_msg,
+                                             sizeof(req_msg),
+                                             &resp_msg,
+                                             sizeof(resp_msg));
+
+   if (ret_val == MCM_SUCCESS_V01)
+       ALOGD(LOGTAG, "registration of voice indications successful");
+   else
+       ALOGE(LOGTAG, "registration of voice indications failed");
+
+   // register for signal strength indications
+   mcm_nw_event_register_req_msg_v01 nw_evt_req_msg;
+   mcm_nw_event_register_resp_msg_v01 nw_evt_resp_msg;
+   memset(&nw_evt_req_msg, 0, sizeof(nw_evt_req_msg));
+   memset(&nw_evt_resp_msg, 0, sizeof(nw_evt_resp_msg));
+
+   nw_evt_req_msg.register_voice_registration_event_valid = TRUE;
+   nw_evt_req_msg.register_voice_registration_event = TRUE;
+
+   nw_evt_req_msg.register_signal_strength_event_valid = TRUE;
+   nw_evt_req_msg.register_signal_strength_event = TRUE;
+
+   ret_val = mcm_client_execute_command_sync_ptr(mcm_client_hdl,
+                                              MCM_NW_EVENT_REGISTER_REQ_V01,
+                                              &nw_evt_req_msg,
+                                              sizeof(nw_evt_req_msg),
+                                              &nw_evt_resp_msg,
+                                              sizeof(nw_evt_resp_msg));
+   if (ret_val == MCM_SUCCESS_V01)
+       ALOGD(LOGTAG, "registration of network indications successful");
+   else
+       ALOGE(LOGTAG, "registration of network indications failed");
+
+   // get current call list to update the headset
+   ret_val = get_current_calls();
+
+}
+
+void Hfp_Ag::release_modem() {
+   if (mcm_client_hdl)
+       mcm_client_release_ptr(mcm_client_hdl);
+
+   if (lib_handle)
+       dlclose(lib_handle);
+}
+#endif
+
+#if defined(BT_ALSA_AUDIO_INTEGRATION)
+void Hfp_Ag::init_audio() {
+   char cmd[50];
+   mWbsState = BTHF_WBS_NO;
+   mNrec = BTHF_NREC_STOP;
+
+   // set up voice path using amix commands
+   strcpy(cmd, "amix \'SEC_AUX_PCM_RX_Voice Mixer CSVoice\' 1");
+   system(cmd);
+
+   strcpy(cmd, "amix \'Voice_Tx Mixer SEC_AUX_PCM_TX_Voice\' 1");
+   system(cmd);
+}
+
+void Hfp_Ag::set_audio_params() {
+   char cmd[50];
+
+   ALOGD(LOGTAG, "%s: setting sample rate %s\n", __func__,
+             (mWbsState == BTHF_WBS_YES ? "16000" : "8000"));
+   fprintf(stdout, "%s: setting sample rate %s\n", __func__,
+             (mWbsState == BTHF_WBS_YES ? "16000" : "8000"));
+
+   // set sample rate using amix commands
+   if (mWbsState == BTHF_WBS_YES)
+       strcpy(cmd, "amix \'AUX PCM SampleRate\' \'rate_16000\'");
+   else
+       strcpy(cmd, "amix \'AUX PCM SampleRate\' \'rate_8000\'");
+   system(cmd);
+}
+
+void Hfp_Ag::setup_sco_path() {
+   char cmd[50];
+
+   ALOGD(LOGTAG, "%s: starting arec and aplay\n", __func__);
+   fprintf(stdout, "%s: starting arec and aplay\n", __func__);
+
+   // set sample rate before starting sco
+   set_audio_params();
+
+   // start sco using aplay and arec commands
+   sprintf(cmd, "aplay -D hw:0,2 -P -R%s -C 1 &",
+              (mWbsState == BTHF_WBS_YES ? "16000" : "8000"));
+   system(cmd);
+
+   sprintf(cmd, "arec -D hw:0,2 -P -R%s -C 1 &",
+              (mWbsState == BTHF_WBS_YES ? "16000" : "8000"));
+   system(cmd);
+}
+
+void Hfp_Ag::teardown_sco_path() {
+    char cmd[50];
+
+    ALOGD(LOGTAG, "%s: killing arec and aplay\n", __func__);
+    fprintf(stdout, "%s: killing arec and aplay\n", __func__);
+
+    strcpy(cmd, "killall -9 arec");
+    system(cmd);
+
+    strcpy(cmd, "killall -9 aplay");
+    system(cmd);
+
+}
+
+void Hfp_Ag::release_audio() {
+   char cmd[50];
+
+   // set up voice path using amix commands
+   strcpy(cmd, "amix \'SEC_AUX_PCM_RX_Voice Mixer CSVoice\' 0");
+   system(cmd);
+
+   strcpy(cmd, "amix \'Voice_Tx Mixer SEC_AUX_PCM_TX_Voice\' 0");
+   system(cmd);
+}
+
+#endif
+
+void Hfp_Ag::process_at_bind(BtEvent* pEvent) {
+   char *hf_ind, *str1, *str2;
+   int i = 0, type = pEvent->hfp_ag_event.arg1;
+
+   hf_ind = pEvent->hfp_ag_event.str;
+   ALOGD(LOGTAG " %s: str is %s, type is %d", __func__, hf_ind, type);
+
+   if (type == 0) {
+       str1 = hf_ind;
+       for (i = 0; i < MAX_HF_INDICATORS; i++) {
+          mHfIndHfList[i] = (int)strtol(str1, &str2, 0);
+
+          // move ahead in the string if char is not ',' or a digit
+          while(*str2 != ',' && *str2 != '\0' && !(*str2 >= '0' && *str2 <= '9'))
+              str2++;
+
+          // if headset does not support all indicators, break
+          if (*str2 == '\0')
+              break;
+
+          if (*str2 == ',')
+             str2++;
+
+          str1 = str2;
+      }
+   }
+   else if(type == 1) {
+      if (sBtHfpAgVendorInterface != NULL) {
+          for (i = 0; i < MAX_HF_INDICATORS;i++) {
+              // TODO: send all the indicators as disabled for now
+              sBtHfpAgVendorInterface->
+                  bind_response_vendor(i+1, BTHF_VENDOR_HF_INDICATOR_STATE_DISABLED,
+                  &pEvent->hfp_ag_event.bd_addr);
+          }
+      }
+      if (sBtHfpAgInterface != NULL) {
+          sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_OK, 0,
+                      &pEvent->hfp_ag_event.bd_addr);
+      }
+   }
+   else if(type == 2) {
+       char str[256] = "(", temp_str[5];
+
+       for(int i = 0; i < MAX_HF_INDICATORS; i++) {
+           sprintf(temp_str, "%d,", i+1);
+           strcat(str, temp_str);
+       }
+       str[strlen(str) - 1] = ')';
+
+       if (sBtHfpAgVendorInterface != NULL) {
+          sBtHfpAgVendorInterface->bind_string_response_vendor(str, &pEvent->hfp_ag_event.bd_addr);
+       }
+       if (sBtHfpAgInterface != NULL) {
+          sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_OK, 0,
+                      &pEvent->hfp_ag_event.bd_addr);
+       }
+   }
+}
+
+void Hfp_Ag::process_at_biev(BtEvent* pEvent) {
+    // TODO: just send OK for now
+    if (sBtHfpAgInterface != NULL) {
+        sBtHfpAgInterface->at_response(BTHF_AT_RESPONSE_OK, 0,
+                    &pEvent->hfp_ag_event.bd_addr);
+    }
+}
+
+void Hfp_Ag::change_state(HfpAgState mState) {
+   ALOGD(LOGTAG " current State = %d, new state = %d", mAgState, mState);
+   pthread_mutex_lock(&lock);
+   mAgState = mState;
+   ALOGD(LOGTAG " state changes to %d ", mAgState);
+   pthread_mutex_unlock(&lock);
+
+   // reset variables when we enter into disconnected state
+   if (mState == HFP_AG_STATE_DISCONNECTED) {
+       mWbsState = BTHF_WBS_NO;
+       mNrec = BTHF_NREC_STOP;
+   }
+}
+
+Hfp_Ag :: Hfp_Ag(const bt_interface_t *bt_interface, config_t *config) {
+    this->bluetooth_interface = bt_interface;
+    sBtHfpAgInterface = NULL;
+    mAgState = HFP_AG_STATE_NOT_STARTED;
+    mcontrolStatus = STATUS_LOSS_TRANSIENT;
+    pthread_mutex_init(&this->lock, NULL);
+
+    memset(mHfIndHfList, 0, sizeof(mHfIndHfList));
+    memset(mHfIndAgList, 0, sizeof(mHfIndAgList));
+}
+
+Hfp_Ag :: ~Hfp_Ag() {
+    mcontrolStatus = STATUS_LOSS_TRANSIENT;
+    pthread_mutex_destroy(&lock);
+}
diff --git a/bt-app/hfp_client/include/HfpClient.hpp b/bt-app/hfp_client/include/HfpClient.hpp
index 20c7cb9..a2985de 100644
--- a/bt-app/hfp_client/include/HfpClient.hpp
+++ b/bt-app/hfp_client/include/HfpClient.hpp
@@ -30,12 +30,19 @@
 #ifndef HFP_CLIENT_APP_H
 #define HFP_CLIENT_APP_H
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
 #include <map>
 #include <string>
 #include <hardware/bluetooth.h>
 #include <hardware/bt_hf_client.h>
 #include <pthread.h>
 
+#if defined(USE_GST)
+#include <gst/gst.h>
+#endif
+
 #if defined(BT_AUDIO_HAL_INTEGRATION)
 
 #include <hardware/audio.h>
@@ -48,7 +55,9 @@
 #include "osi/include/allocator.h"
 #include "ipc.h"
 #include "utils.h"
+#include "hardware/bt_hf_client_vendor.h"
 
+#include "Audio_Manager.hpp"
 
 typedef enum {
     HFP_CLIENT_STATE_NOT_STARTED = 0,
@@ -72,14 +81,16 @@ class Hfp_Client {
     unsigned int chld_feat;
 #if defined(BT_AUDIO_HAL_INTEGRATION)
     config_t *config;
-    audio_stream_out_t* out_stream;
-    audio_stream_out_t* out_stream_ring_tone;
+    qahw_stream_handle_t* out_stream;
+    qahw_stream_handle_t* out_stream_ring_tone;
 #endif
     const bt_interface_t * bluetooth_interface;
     const bthf_client_interface_t *sBtHfpClientInterface;
     HfpClientState mClientState;
     HfpClientMode mAudioMode;
     ControlStatusType mcontrolStatus;
+    const bthf_client_vendor_interface_t *sBtHfpClientVendorInterface;
+
   public:
     Hfp_Client(const bt_interface_t *bt_interface, config_t *config);
     ~Hfp_Client();
@@ -97,6 +108,7 @@ class Hfp_Client {
     void HandleDisableClient();
     void ConfigureAudio(bool enable);
     void ConfigureRingTonePlayback();
+    void ConfigureVolume(bthf_client_volume_type_t vol_type, int vol, bool mute_mic);
     void PlayRingTone();
     void StopRingTone();
 };
diff --git a/bt-app/hfp_client/src/HfpClient.cpp b/bt-app/hfp_client/src/HfpClient.cpp
index 9206b82..83842fc 100644
--- a/bt-app/hfp_client/src/HfpClient.cpp
+++ b/bt-app/hfp_client/src/HfpClient.cpp
@@ -23,8 +23,19 @@
 #include <hardware/hardware.h>
 #include <hardware/bt_hf_client.h>
 
-#include "Audio_Manager.hpp"
+//#include "Audio_Manager.hpp"
 #include "HfpClient.hpp"
+#include "hardware/bt_hf_client_vendor.h"
+
+#if (defined USE_GST)
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <gst/gstbthelper.h>
+#ifdef __cplusplus
+}
+#endif
+#endif
 
 #define LOGTAG "HFP_CLIENT"
 
@@ -35,6 +46,11 @@ using std::string;
 Hfp_Client *pHfpClient = NULL;
 extern BT_Audio_Manager *pBTAM;
 
+#if (defined USE_GST)
+
+gstbt gstbtringtoneobj;
+
+#endif
 
 char ring_tone[] =
 {
@@ -329,100 +345,100 @@ static void audio_state_cb(bthf_client_audio_state_t state, bt_bdaddr_t* bd_addr
 
 void vr_cmd_cb(bthf_client_vr_state_t state) {
     ALOGD(LOGTAG "VR state is %s",(state == BTHF_CLIENT_VR_STATE_STOPPED) ? "stopped": "started");
-    cout << LOGTAG "VR state is " << ((state == BTHF_CLIENT_VR_STATE_STOPPED) ? "stopped": "started") << endl;
+    fprintf(stdout, "VR state is %s\n",(state == BTHF_CLIENT_VR_STATE_STOPPED) ? "stopped": "started");
 }
 
 void network_state_cb (bthf_client_network_state_t state) {
     ALOGD(LOGTAG "network state is %s", (state == BTHF_CLIENT_NETWORK_STATE_NOT_AVAILABLE) ? "not available": "available");
-    cout << LOGTAG "network state is " << ((state == BTHF_CLIENT_NETWORK_STATE_NOT_AVAILABLE) ? "not available": "available") << endl;
+    fprintf(stdout, "network state is %s\n", (state == BTHF_CLIENT_NETWORK_STATE_NOT_AVAILABLE) ? "not available": "available");
 }
 
 void network_roaming_cb (bthf_client_service_type_t type) {
     ALOGD(LOGTAG "AG is in %s", (type == BTHF_CLIENT_SERVICE_TYPE_HOME) ? "home network": "roaming");
-    cout << LOGTAG "AG is in " << ((type == BTHF_CLIENT_SERVICE_TYPE_HOME) ? "home network": "roaming") << endl;
+    fprintf(stdout, "AG is in %s\n", (type == BTHF_CLIENT_SERVICE_TYPE_HOME) ? "home network": "roaming");
 }
 
 void network_signal_cb (int signal) {
     ALOGD(LOGTAG "signal level is %d", signal);
-    cout << "signal level is " << signal << endl;
+    fprintf(stdout, "signal level is %d\n", signal);
 }
 
 void battery_level_cb (int level) {
     ALOGD(LOGTAG "battery level is %d", level);
-    cout << LOGTAG "battery level is " << level << endl;
+    fprintf(stdout, "battery level is %d\n", level);
 }
 
 void current_operator_cb (const char *name) {
     ALOGD(LOGTAG "operator name is %s", name);
-    cout << LOGTAG "operator name is " << name << endl;
+    fprintf(stdout, "operator name is %s\n", name);
 }
 
 void call_cb (bthf_client_call_t call) {
     ALOGD(LOGTAG "%s call is in progress", (call == BTHF_CLIENT_CALL_NO_CALLS_IN_PROGRESS) ? "no": "a");
-    cout << LOGTAG << ((call == BTHF_CLIENT_CALL_NO_CALLS_IN_PROGRESS) ? "no": "a") << " call is in progress" << endl;
+    fprintf(stdout, "%s call is in progress\n", (call == BTHF_CLIENT_CALL_NO_CALLS_IN_PROGRESS) ? "no": "a");
 }
 
 void callsetup_cb (bthf_client_callsetup_t callsetup) {
    BtEvent *pEvent = new BtEvent;
    if (callsetup == BTHF_CLIENT_CALLSETUP_NONE) {
-      cout << LOGTAG "no call in setup" << endl;
+      fprintf(stdout, "no call in setup\n");
       ALOGD(LOGTAG "no call is setup");
       // TODO: post this only when MT call ends
       pEvent->hfp_client_event.event_id = HFP_CLIENT_STOP_RINGTONE_REQ;
       PostMessage(THREAD_ID_HFP_CLIENT, pEvent);
    }
    else if(callsetup == BTHF_CLIENT_CALLSETUP_INCOMING) {
-      cout << LOGTAG "Incoming call is in setup" << endl;
+      fprintf(stdout, "Incoming call is in setup\n");
       ALOGD(LOGTAG "Incoming call is in setup");
    }
    else if(callsetup == BTHF_CLIENT_CALLSETUP_OUTGOING) {
-      cout << LOGTAG "Outgoing call is in setup" << endl;
+      fprintf(stdout, "Outgoing call is in setup\n");
       ALOGD(LOGTAG "Outgoing call is in setup");
    }
    else if(callsetup == BTHF_CLIENT_CALLSETUP_ALERTING) {
-      cout << LOGTAG "Outgoing call in alerting state" << endl;
+      fprintf(stdout, "Outgoing call in alerting state\n");
       ALOGD(LOGTAG "Outgoing call in alerting state");
    }
 }
 
 void callheld_cb (bthf_client_callheld_t callheld) {
    if (callheld == BTHF_CLIENT_CALLHELD_NONE) {
-      cout << LOGTAG "no held call" << endl;
+      fprintf(stdout, "no held call\n");
       ALOGD(LOGTAG "no held call");
    }
    else if (callheld == BTHF_CLIENT_CALLHELD_HOLD_AND_ACTIVE) {
-      cout << LOGTAG "a call is placed on hold or calls are swapped" << endl;
+      fprintf(stdout,"a call is placed on hold or calls are swapped\n");
       ALOGD(LOGTAG "a call is placed on hold or calls are swapped");
    }
    else if (callheld == BTHF_CLIENT_CALLHELD_HOLD) {
-      cout << LOGTAG "a call is on hold, no active calls" << endl;
+      fprintf(stdout,"a call is on hold, no active calls\n");
       ALOGD(LOGTAG "a call is on hold, no active calls");
    }
 }
 
 void resp_and_hold_cb (bthf_client_resp_and_hold_t resp_and_hold) {
    if (resp_and_hold == BTHF_CLIENT_RESP_AND_HOLD_HELD) {
-      cout << LOGTAG "incoming call put on held" << endl;
+      fprintf(stdout,"incoming call put on held\n");
       ALOGD(LOGTAG "incoming call put on held");
    }
    else if (resp_and_hold == BTRH_CLIENT_RESP_AND_HOLD_ACCEPT) {
-      cout << LOGTAG "held incoming call accepted" << endl;
+      fprintf(stdout,"held incoming call accepted\n");
       ALOGD(LOGTAG "held incoming call accepted");
    }
    else if (resp_and_hold == BTRH_CLIENT_RESP_AND_HOLD_REJECT) {
-      cout << LOGTAG "held incoming call rejected" << endl;
+      fprintf(stdout,"held incoming call rejected\n");
       ALOGD(LOGTAG "held incoming call rejected");
    }
 }
 
 void clip_cb (const char *number) {
    ALOGD(LOGTAG "CLIP number is %s", number);
-   cout << LOGTAG "CLIP number is " << number << endl;
+   fprintf(stdout, "CLIP number is %s\n", number);
 }
 
 void call_waiting_cb (const char *number) {
    ALOGD(LOGTAG "a call is waiting from number %s", number);
-   cout << LOGTAG "a call is waiting from number " << number << endl;
+   fprintf(stdout, "a call is waiting from number %s\n", number);
 }
 
 void current_calls_cb (int index, bthf_client_call_direction_t dir,
@@ -431,15 +447,24 @@ void current_calls_cb (int index, bthf_client_call_direction_t dir,
                                             const char *number) {
    ALOGD(LOGTAG "%s: index %d, call direction %d, call state %d, multiparty %d, number %s",
         __func__, index, dir, state, mpty, number);
-   cout << __func__ << ": index " << index << " call direction " << dir;
-   cout << " call state " << state << " multiparty " << mpty << " number " << number << endl;
+   fprintf(stdout, "%s: index %d, call direction %d, call state %d, multiparty %d, number %s\n",
+    __func__, index, dir, state, mpty, number);
 }
 
 void volume_change_cb (bthf_client_volume_type_t type, int volume) {
-   ALOGD(LOGTAG "%s : %s volume is %d", __func__,
+   BtEvent *pEvent = new BtEvent;
+   ALOGD(LOGTAG "%s : %s volume is %d\n", __func__,
+          (type == BTHF_CLIENT_VOLUME_TYPE_SPK) ? "speaker": "mic", volume);
+   fprintf(stdout,"%s : %s volume is %d\n", __func__,
           (type == BTHF_CLIENT_VOLUME_TYPE_SPK) ? "speaker": "mic", volume);
-   cout << LOGTAG << " " << __func__ << ": " << ((type == BTHF_CLIENT_VOLUME_TYPE_SPK) ? "speaker": "mic");
-   cout << " volume is " << volume;
+
+   if (type == BTHF_CLIENT_VOLUME_TYPE_SPK)
+       pEvent->hfp_client_event.event_id = HFP_CLIENT_API_SPK_VOL_CTRL_REQ;
+   else if (type == BTHF_CLIENT_VOLUME_TYPE_MIC)
+       pEvent->hfp_client_event.event_id = HFP_CLIENT_API_MIC_VOL_CTRL_REQ;
+
+   pEvent->hfp_client_event.arg1 = volume;
+   PostMessage(THREAD_ID_HFP_CLIENT, pEvent);
 }
 
 void cmd_complete_cb (bthf_client_cmd_complete_t type, int cme) {
@@ -449,26 +474,26 @@ void cmd_complete_cb (bthf_client_cmd_complete_t type, int cme) {
 void subscriber_info_cb (const char *name, bthf_client_subscriber_service_type_t type) {
    if (type == BTHF_CLIENT_SERVICE_UNKNOWN) {
        ALOGD(LOGTAG "subscriber name is %s type is unknown", name);
-       cout << LOGTAG "subscriber name is " << name << " type is unknown" << endl;
+       fprintf(stdout, "subscriber name is %s type is unknown\n", name);
    }
    else if (type == BTHF_CLIENT_SERVICE_VOICE) {
        ALOGD(LOGTAG "subscriber name is %s type is voice", name);
-       cout << LOGTAG "subscriber name is " << name << " type is voice" << endl;
+       fprintf(stdout, "subscriber name is %s type is voice\n", name);
    }
    else if (type == BTHF_CLIENT_SERVICE_FAX) {
        ALOGD(LOGTAG "subscriber name is %s type is fax", name);
-       cout << LOGTAG "subscriber name is " << name << " type is fax" << endl;
+       fprintf(stdout, "subscriber name is %s type is fax\n", name);
    }
 }
 
 void in_band_ring_cb (bthf_client_in_band_ring_state_t in_band) {
    if (in_band == BTHF_CLIENT_IN_BAND_RINGTONE_NOT_PROVIDED) {
        ALOGD(LOGTAG " in-band ringtone not provided");
-       cout << "in-band ringtone not provided" << endl;
+       fprintf(stdout, "in-band ringtone not provided\n");
    }
    else if (in_band == BTHF_CLIENT_IN_BAND_RINGTONE_PROVIDED) {
        ALOGD(LOGTAG " in-band ringtone provided");
-       cout << "in-band ringtone provided" << endl;
+       fprintf(stdout, "in-band ringtone provided\n");
    }
 }
 
@@ -479,17 +504,17 @@ void last_voice_tag_number_cb (const char *number) {
 void ring_indication_cb () {
    BtEvent *pEvent = new BtEvent;
    ALOGD(LOGTAG "ring_indication");
-   cout << "RING indication for incoming call" << endl;
+   fprintf(stdout, "RING indication for incoming call\n");
    pEvent->hfp_client_event.event_id = HFP_CLIENT_PLAY_RINGTONE_REQ;
    PostMessage(THREAD_ID_HFP_CLIENT, pEvent);
 }
 
-void cgmi_cb (const char *str) {
-   ALOGD(LOGTAG "cgmi_cb %s", str);
+void cgmi_vendor_cb (const char *str) {
+   ALOGD(LOGTAG " cgmi_vendor_cb %s", str);
 }
 
-void cgmm_cb (const char *str) {
-   ALOGD(LOGTAG "cgmm_cb %s", str);
+void cgmm_vendor_cb (const char *str) {
+   ALOGD(LOGTAG " cgmm_vendor_cb %s", str);
 }
 
 
@@ -516,8 +541,12 @@ static bthf_client_callbacks_t sBluetoothHfpClientCallbacks = {
     in_band_ring_cb,
     last_voice_tag_number_cb,
     ring_indication_cb,
-    cgmi_cb,
-    cgmm_cb,
+};
+
+static bthf_client_vendor_callbacks_t sBluetoothHfpClientVendorCallbacks = {
+    sizeof(sBluetoothHfpClientVendorCallbacks),
+    cgmi_vendor_cb,
+    cgmm_vendor_cb,
 };
 
 void Hfp_Client::HandleEnableClient(void) {
@@ -531,8 +560,17 @@ void Hfp_Client::HandleEnableClient(void) {
             ALOGE(LOGTAG "get profile interface failed, returning");
             return;
         }
+        sBtHfpClientVendorInterface = (bthf_client_vendor_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_HANDSFREE_CLIENT_VENDOR_ID);
+        if (sBtHfpClientVendorInterface == NULL)
+        {
+            // TODO: sent message to indicate failure for profile init
+            ALOGE(LOGTAG "get profile vendor interface failed, returning");
+            return;
+        }
         change_state(HFP_CLIENT_STATE_DISCONNECTED);
         sBtHfpClientInterface->init(&sBluetoothHfpClientCallbacks);
+        sBtHfpClientVendorInterface->init_vendor(&sBluetoothHfpClientVendorCallbacks);
         BtEvent *pEvent = new BtEvent;
         pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
         pEvent->profile_start_event.profile_id = PROFILE_ID_HFP_CLIENT;
@@ -547,6 +585,10 @@ void Hfp_Client::HandleDisableClient(void) {
        sBtHfpClientInterface->cleanup();
        sBtHfpClientInterface = NULL;
    }
+   if(sBtHfpClientVendorInterface != NULL) {
+       sBtHfpClientVendorInterface->cleanup_vendor();
+       sBtHfpClientVendorInterface = NULL;
+   }
    BtEvent *pEvent = new BtEvent;
    pEvent->profile_stop_event.event_id = PROFILE_EVENT_STOP_DONE;
    pEvent->profile_stop_event.profile_id = PROFILE_ID_HFP_CLIENT;
@@ -556,7 +598,7 @@ void Hfp_Client::HandleDisableClient(void) {
 
 void Hfp_Client::ProcessEvent(BtEvent* pEvent) {
     ALOGD(LOGTAG " Processing event %d in state %d", pEvent->event_id, mClientState);
-    cout << " Processing event " << pEvent->event_id << " in state " << mClientState << endl;
+    fprintf(stdout, " Processing event %d in state %d\n", pEvent->event_id, mClientState);
     switch(mClientState) {
         case HFP_CLIENT_STATE_DISCONNECTED:
             state_disconnected_handler(pEvent);
@@ -586,7 +628,7 @@ void Hfp_Client::state_disconnected_handler(BtEvent* pEvent) {
                 sBtHfpClientInterface->connect(&pEvent->hfp_client_event.bd_addr);
             }
             bdaddr_to_string(&mConnectingDevice, str, 18);
-            cout << "connecting with device " << str << endl;
+            fprintf(stdout, "connecting with device %s\n", str);
             ALOGD(LOGTAG "connecting with device %s", str);
             change_state(HFP_CLIENT_STATE_CONNECTING);
             break;
@@ -604,7 +646,7 @@ void Hfp_Client::state_disconnected_handler(BtEvent* pEvent) {
             mAudioWbs = false;
 
             bdaddr_to_string(&mConnectedDevice, str, 18);
-            cout << "SLC connected with device " << str << endl;
+            fprintf(stdout, "SLC connected with device %s\n", str);
             ALOGD(LOGTAG "SLC connected with device %s", str);
             change_state(HFP_CLIENT_STATE_CONNECTED);
             break;
@@ -629,13 +671,13 @@ void Hfp_Client::state_connecting_handler(BtEvent* pEvent) {
             mAudioWbs = false;
 
             bdaddr_to_string(&mConnectedDevice, str, 18);
-            cout << "SLC connected with device " << str << endl;
+            fprintf(stdout, "SLC connected with device %s\n", str);
             ALOGD(LOGTAG "SLC connected with device %s", str);
             change_state(HFP_CLIENT_STATE_CONNECTED);
             break;
         case HFP_CLIENT_DISCONNECTED_CB:
             bdaddr_to_string(&pEvent->hfp_client_event.bd_addr, str, 18);
-            cout << "Disconneced from or Unable to connect with device " << str << endl;
+            fprintf(stdout, "Disconnected from or Unable to connect with device %s\n", str);
             ALOGD(LOGTAG "Disconnected from or Unable to connect with device %s", str);
 
             memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
@@ -671,7 +713,7 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
             }
 
             bdaddr_to_string(&pEvent->hfp_client_event.bd_addr, str, 18);
-            cout << "Disconnecting with device " << str << endl;
+            fprintf(stdout, "Disconnecting with device %s\n", str);
             ALOGD(LOGTAG "Disconnecting with device %s", str);
             change_state(HFP_CLIENT_STATE_CONNECTING);
             break;
@@ -684,7 +726,7 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
 
             mcontrolStatus = STATUS_LOSS_TRANSIENT;
             bdaddr_to_string(&pEvent->hfp_client_event.bd_addr, str, 18);
-            cout << "Disconnected with device " << str << endl;
+            fprintf(stdout, "Disconnected with device %s\n", str);
             ALOGD(LOGTAG "Disconnected with device %s", str);
 
             memset(&mConnectedDevice, 0, sizeof(bt_bdaddr_t));
@@ -692,6 +734,7 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
             peer_feat = 0;
             chld_feat = 0;
             mAudioWbs = false;
+            change_mode(HFP_CLIENT_MODE_NORMAL);
             change_state(HFP_CLIENT_STATE_DISCONNECTED);
             break;
         case HFP_CLIENT_DISCONNECTING_CB:
@@ -705,7 +748,7 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
             break;
         case HFP_CLIENT_API_CONNECT_AUDIO_REQ:
             bdaddr_to_string(&pEvent->hfp_client_event.bd_addr, str, 18);
-            cout << "Connecting SCO/eSCO with device " << str << endl;
+            fprintf(stdout, "Connecting SCO/eSCO with device %s\n", str);
             ALOGD(LOGTAG "Connecting SCO/eSCO with device %s", str);
 
             if (sBtHfpClientInterface != NULL) {
@@ -717,12 +760,12 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
             // intentional fall through.
         case HFP_CLIENT_AUDIO_STATE_CONNECTED_CB:
             bdaddr_to_string(&pEvent->hfp_client_event.bd_addr, str, 18);
-            cout << "SCO/eSCO connected with device " << str << endl;
+            fprintf(stdout, "SCO/eSCO connected with device %s\n", str);
             ALOGD(LOGTAG " SCO/eSCO connected with device %s", str);
 
             if (mcontrolStatus == STATUS_LOSS || mcontrolStatus == STATUS_LOSS_TRANSIENT)
             {
-                cout << "Connected state: Requesting for focus" << endl;
+                fprintf(stdout, "Connected state: Requesting for focus\n");
                 ALOGD(LOGTAG  " Connected state: Requesting for focus");
                 pControlRequest = new BtEvent;
                 pControlRequest->btamControlReq.event_id = BT_AM_REQUEST_CONTROL;
@@ -733,8 +776,18 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
             else
             {
                 // we already have the focus, configure for SCO connection. TODO: cross check
-                cout << "Connected state: already have focus, configure audio for SCO" << endl;
-                ALOGD(LOGTAG " Connected state: already have focus, configure audio for SCO");
+                fprintf(stdout, "Connected state: already have focus, configure audio for SCO\n");
+                ALOGD(LOGTAG " Connected state: already have focus, configure audio for SCO, current mode %d", mAudioMode);
+
+                // for MT call, stop ring tone if it is playing before connecting sco
+                if (mAudioMode == HFP_CLIENT_MODE_RINGTONE)
+                {
+                    ALOGD("Audio Mode is ring tone, stop the ring tone");
+                    fprintf(stdout, "Audio Mode is ring tone, stop the ring tone\n");
+                    change_mode(HFP_CLIENT_MODE_NORMAL);
+                    StopRingTone();
+                }
+
                 ConfigureAudio(true);
             }
 
@@ -755,7 +808,7 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
             else
             {
                 ALOGD("Audio Mode is ring tone, play the ring tone");
-                cout << "Audio Mode is ring tone, play the ring tone" << endl;
+                fprintf(stdout, "Audio Mode is ring tone, play the ring tone\n");
                 PlayRingTone();
             }
             break;
@@ -763,17 +816,26 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
             if (mAudioMode == HFP_CLIENT_MODE_RINGTONE)
             {
                 ALOGD("Audio Mode is ring tone, stop the ring tone");
-                cout << "Audio Mode is ring tone, stop the ring tone" << endl;
-                // TODO: cleanup ringtone path. Clost audio devices etc.
-                change_mode(HFP_CLIENT_MODE_NORMAL);
+                fprintf(stdout, "Audio Mode is ring tone, stop the ring tone\n");
+
                 StopRingTone();
+                // release control
+                pReleaseControlReq = new BtEvent;
+                pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
+                pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_HFP_CLIENT;
+                PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
+
+                mcontrolStatus = STATUS_LOSS_TRANSIENT;
+
+                change_mode(HFP_CLIENT_MODE_NORMAL);
             }
             break;
         case BT_AM_CONTROL_STATUS:
             ALOGD(LOGTAG "earlier status = %d  new status = %d", mcontrolStatus,
                                    pEvent->btamControlStatus.status_type);
-            cout << "Connected: earlier status " << mcontrolStatus << " new status "
-                            << pEvent->btamControlStatus.status_type << endl;
+            fprintf(stdout, "earlier status = %d  new status = %d\n", mcontrolStatus,
+                                   pEvent->btamControlStatus.status_type);
+
             mcontrolStatus = pEvent->btamControlStatus.status_type;
 
             switch(mcontrolStatus) {
@@ -790,14 +852,14 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
                     if (mAudioMode == HFP_CLIENT_MODE_RINGTONE)
                     {
                         ALOGD(LOGTAG " in Ringtone mode, configure and play ringtone");
-                        cout << "in Ringtone mode, configure and play ringtone" << endl;
+                        fprintf(stdout, "in Ringtone mode, configure and play ringtone\n");
                         ConfigureRingTonePlayback();
                         PlayRingTone();
                     }
                     else
                     {
                         ALOGD(LOGTAG " Configure audio for SCO");
-                        cout << "Configure audio for SCO" << endl;
+                        fprintf(stdout, "Configure audio for SCO\n");
                         ConfigureAudio(true);
                     }
                     break;
@@ -814,7 +876,23 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
             }
             break;
         case HFP_CLIENT_API_REJECT_CALL_REQ:
-                // intentional fall through. TODO: cross check
+            if (mAudioMode == HFP_CLIENT_MODE_RINGTONE)
+            {
+                ALOGD("Audio Mode is ring tone, stop the ring tone");
+                fprintf(stdout, "Audio Mode is ring tone, stop the ring tone\n");
+
+                StopRingTone();
+                // release control
+                pReleaseControlReq = new BtEvent;
+                pReleaseControlReq->btamControlRelease.event_id = BT_AM_RELEASE_CONTROL;
+                pReleaseControlReq->btamControlRelease.profile_id = PROFILE_ID_HFP_CLIENT;
+                PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
+
+                mcontrolStatus = STATUS_LOSS_TRANSIENT;
+
+                change_mode(HFP_CLIENT_MODE_NORMAL);
+            }
+            // intentional fall through. TODO: cross check
         case HFP_CLIENT_API_END_CALL_REQ:
             if (sBtHfpClientInterface != NULL) {
                 sBtHfpClientInterface->handle_call_action(BTHF_CLIENT_CALL_ACTION_CHUP, 0);
@@ -949,7 +1027,7 @@ void Hfp_Client::state_connected_handler(BtEvent* pEvent) {
 void Hfp_Client::state_audio_on_handler(BtEvent* pEvent) {
     char str[18];
     BtEvent *pControlRequest, *pReleaseControlReq;
-    ALOGD(LOGTAG "state_connected_handler Processing event %d", pEvent->event_id);
+    ALOGD(LOGTAG "state_audio_on_handler Processing event %d", pEvent->event_id);
     switch(pEvent->event_id) {
         case HFP_CLIENT_API_DISCONNECT_AUDIO_REQ:
             if (sBtHfpClientInterface != NULL) {
@@ -957,13 +1035,12 @@ void Hfp_Client::state_audio_on_handler(BtEvent* pEvent) {
             }
 
             bdaddr_to_string(&pEvent->hfp_client_event.bd_addr, str, 18);
-            cout << "Disconnecting SCO/eSCO with device " << str << endl;
+            fprintf(stdout, "Disconnecting SCO/eSCO with device %s\n", str);
             ALOGD(LOGTAG "Disconnecting SCO/eSCO with device %s", str);
             break;
         case HFP_CLIENT_AUDIO_STATE_DISCONNECTED_CB:
 
             mAudioWbs = false;
-            ConfigureAudio(false);
 
             // release control
             pReleaseControlReq = new BtEvent;
@@ -976,14 +1053,15 @@ void Hfp_Client::state_audio_on_handler(BtEvent* pEvent) {
             change_state(HFP_CLIENT_STATE_CONNECTED);
 
             bdaddr_to_string(&pEvent->hfp_client_event.bd_addr, str, 18);
-            cout << "Disconnected SCO connection with device " << str << endl;
+            ConfigureAudio(false);
+            fprintf(stdout, "Disconnected SCO connection with device %s\n", str);
             ALOGD(LOGTAG "Disconnected SCO connection with device %s", str);
             break;
         case BT_AM_CONTROL_STATUS:
             ALOGD(LOGTAG "earlier status = %d  new status = %d", mcontrolStatus,
                                    pEvent->btamControlStatus.status_type);
-            cout << "AudioOn: earlier status " << mcontrolStatus << " new status "
-                            << pEvent->btamControlStatus.status_type << endl;
+            fprintf(stdout, "earlier status = %d  new status = %d\n", mcontrolStatus,
+                                   pEvent->btamControlStatus.status_type);
             mcontrolStatus = pEvent->btamControlStatus.status_type;
 
             switch(mcontrolStatus) {
@@ -998,7 +1076,7 @@ void Hfp_Client::state_audio_on_handler(BtEvent* pEvent) {
                     break;
                  case STATUS_GAIN_TRANSIENT:
                     ALOGD(LOGTAG " Configure audio for SCO");
-                    cout << "Configure audio for SCO" << endl;
+                    fprintf(stdout, "Configure audio for SCO\n");
                     ConfigureAudio(true);
                     break;
             }
@@ -1118,12 +1196,18 @@ void Hfp_Client::state_audio_on_handler(BtEvent* pEvent) {
             break;
         case HFP_CLIENT_API_SPK_VOL_CTRL_REQ:
             if (sBtHfpClientInterface != NULL) {
+                ConfigureVolume(BTHF_CLIENT_VOLUME_TYPE_SPK, pEvent->hfp_client_event.arg1, false);
                 sBtHfpClientInterface->volume_control(BTHF_CLIENT_VOLUME_TYPE_SPK,
                                           pEvent->hfp_client_event.arg1);
             }
             break;
         case HFP_CLIENT_API_MIC_VOL_CTRL_REQ:
             if (sBtHfpClientInterface != NULL) {
+                if (pEvent->hfp_client_event.arg1 == 0)
+                    ConfigureVolume(BTHF_CLIENT_VOLUME_TYPE_MIC, pEvent->hfp_client_event.arg1, true);
+                else
+                    ConfigureVolume(BTHF_CLIENT_VOLUME_TYPE_MIC, pEvent->hfp_client_event.arg1, false);
+
                 sBtHfpClientInterface->volume_control(BTHF_CLIENT_VOLUME_TYPE_MIC,
                                           pEvent->hfp_client_event.arg1);
             }
@@ -1140,7 +1224,7 @@ void Hfp_Client::state_audio_on_handler(BtEvent* pEvent) {
                 sBtHfpClientInterface->send_at_cmd(15, 1, 0, NULL);
             }
             break;
-         
+
         default:
             ALOGD(LOGTAG," event not handled %d ", pEvent->event_id);
             break;
@@ -1148,20 +1232,24 @@ void Hfp_Client::state_audio_on_handler(BtEvent* pEvent) {
 
 }
 
-
 void Hfp_Client::ConfigureRingTonePlayback() {
 
 #if defined(BT_AUDIO_HAL_INTEGRATION)
-   audio_hw_device_t* audio_device;
+#if defined(USE_GST)
+   init_gst_pipeline(&gstbtringtoneobj, AUDIO_FORMAT_PCM_16_BIT,
+           8000, 1, AUDIO_OUTPUT_FLAG_DIRECT_PCM, "bt_hfp_client");
+#else
+   qahw_module_handle_t* audio_module;
    audio_config_t config;
    audio_io_handle_t handle = 0x7;
+   int ret = 0;
 
    ALOGD(LOGTAG "ConfigureRingTonePlayback");
-   cout << "ConfigureRingTonePlayback" << endl;
+   fprintf(stdout, "ConfigureRingTonePlayback\n");
 
    if (pBTAM == NULL) {
       ALOGD(LOGTAG "Audio Manager not initialized");
-      cout << "Audio Manager not initialized" << endl;
+      fprintf(stdout, "Audio Manager not initialized\n");
       return;
    }
 
@@ -1173,19 +1261,20 @@ void Hfp_Client::ConfigureRingTonePlayback() {
    config.channel_mask = audio_channel_out_mask_from_count(1);
    config.offload_info.channel_mask = audio_channel_out_mask_from_count(1);
 
-   audio_device = pBTAM->GetAudioDevice();
-   if(audio_device != NULL) {
+   audio_module = pBTAM->GetAudioDevice();
+   if(audio_module != NULL) {
          // select speaker(2) as output device
-         audio_device->open_output_stream(audio_device, handle, 2, AUDIO_OUTPUT_FLAG_DIRECT_PCM,
+         ret = qahw_open_output_stream(audio_module, handle, 2, AUDIO_OUTPUT_FLAG_DIRECT_PCM,
                                         &config, &out_stream_ring_tone, "bt_hfp_client");
    }
    else {
-      cout << "ConfigureRingTonePlayback: audio_device is NULL" << endl;
+      fprintf(stdout, "ConfigureRingTonePlayback: audio_device is NULL\n");
       ALOGD(LOGTAG " ConfigureRingTonePlayback: audio_device is NULL");
    }
+#endif // USE_GST
 #else
    ALOGD("%s: BT_AUDIO_HAL_INTEGRATION needs to be defined", __func__);
-   cout << "BT_AUDIO_HAL_INTEGRATION needs to be defined" << endl;
+   fprintf(stdout, "BT_AUDIO_HAL_INTEGRATION needs to be defined\n");
 #endif
 }
 
@@ -1193,24 +1282,36 @@ void Hfp_Client::ConfigureRingTonePlayback() {
 void Hfp_Client::PlayRingTone() {
    ALOGD("%s:", __func__);
 #if defined(BT_AUDIO_HAL_INTEGRATION)
-  int i, j;
+  int i, j, ret = 0;
+  qahw_out_buffer_t out_buf;
+#if defined(USE_GST)
+  play_gst_ringtone(&gstbtringtoneobj, ring_tone);
+#else
   // 40msec of 8kz 16-bit mono = 40*8*2 = 640 bytes
   uint8_t *buf = (uint8_t*)osi_malloc(640);
 
   if (buf == NULL)
   {
-     cout << "memory allocation for playing ringtone failed" << endl;
+     fprintf(stdout, "memory allocation for playing ringtone failed\n");
      ALOGD("%s: memory allocation for playing ringtone failed", __func__);
      return;
   }
 
+  out_buf.buffer = buf;
+  out_buf.bytes = 640;
+
   for(i = 0; i < 5; i++)
   {
      for(j = 0; j < 5; j++)
      {
         memcpy(buf, (void*)(ring_tone + j * 640), 640);
+
         if ((pBTAM->GetAudioDevice() != NULL) && (out_stream_ring_tone != NULL)) {
-           out_stream_ring_tone->write(out_stream_ring_tone, buf, 640);
+           ret = qahw_out_write(out_stream_ring_tone, &out_buf);
+           if (ret < 0) {
+               ALOGE(LOGTAG " %s: writing data to audio hal failed", __func__);
+               //break;
+           }
         }
      }
   }
@@ -1218,39 +1319,46 @@ void Hfp_Client::PlayRingTone() {
   if (buf)
      osi_free(buf);
 
+#endif // USE_GST
 #else
    ALOGD("%s: BT_AUDIO_HAL_INTEGRATION needs to be defined", __func__);
-   cout << "BT_AUDIO_HAL_INTEGRATION needs to be defined" << endl;
+   fprintf(stdout, "BT_AUDIO_HAL_INTEGRATION needs to be defined\n");
 #endif
 }
 
 void Hfp_Client::StopRingTone() {
 #if (defined BT_AUDIO_HAL_INTEGRATION)
-    audio_hw_device_t* audio_device;
+#if defined(USE_GST)
+    close_gst_pipeline(&gstbtringtoneobj);
+#else
+    int ret = 0;
+    qahw_module_handle_t* audio_module;
     if (pBTAM != NULL) {
-        audio_device = pBTAM->GetAudioDevice();
-        if((audio_device != NULL) && (out_stream_ring_tone != NULL)) {
+        audio_module = pBTAM->GetAudioDevice();
+        if((audio_module != NULL) && (out_stream_ring_tone != NULL)) {
             ALOGD(LOGTAG, " closing output stream for ring tone ");
-            audio_device->close_output_stream(audio_device, out_stream_ring_tone);
+            ret = qahw_close_output_stream(out_stream_ring_tone);
             out_stream_ring_tone = NULL;
         }
     }
-#endif
+#endif // USE_GST
+#endif // BT_AUDIO_HAL_INTEGRATION
 }
 
 void Hfp_Client::ConfigureAudio(bool enable) {
 
 #if defined(BT_AUDIO_HAL_INTEGRATION)
-   audio_hw_device_t* audio_device;
+   qahw_module_handle_t* audio_module;
    audio_config_t config;
    audio_io_handle_t handle = 0x999;
 
    ALOGD(LOGTAG "Configure Audio for enable/disable %d, wbs %d", enable, mAudioWbs);
-   cout << "Configure Audio for enable/disable " <<  enable << " wbs " <<  mAudioWbs << endl;
+   fprintf(stdout, "Configure Audio for enable/disable %d, wbs %d\n", enable, mAudioWbs);
+
 
    if (pBTAM == NULL) {
       ALOGD(LOGTAG "Audio Manager not initialized");
-      cout << "Audio Manager not initialized" << endl;
+      fprintf(stdout, "Audio Manager not initialized\n");
       return;
    }
 
@@ -1258,51 +1366,95 @@ void Hfp_Client::ConfigureAudio(bool enable) {
    config.format = AUDIO_FORMAT_PCM_16_BIT;
    config.sample_rate = 8000;
 
-   audio_device = pBTAM->GetAudioDevice();
-   if(audio_device != NULL) {
+   audio_module = pBTAM->GetAudioDevice();
+   if(audio_module != NULL) {
       if (enable) {
          // select speaker(2) as output device
-         audio_device->open_output_stream(audio_device, handle, 2, AUDIO_OUTPUT_FLAG_NONE,
+         qahw_open_output_stream(audio_module, handle, 2, AUDIO_OUTPUT_FLAG_NONE,
                                         &config, &out_stream, "bt_hfp_client");
          ALOGD(LOGTAG " setting sample rate %s", (mAudioWbs ? "16000" : "8000"));
-         cout << "setting sample rate " << (mAudioWbs ? "16000" : "8000") << endl;
+         fprintf(stdout, " setting sample rate %s\n", (mAudioWbs ? "16000" : "8000"));
          if (mAudioWbs)
-            audio_device->set_parameters(audio_device, "hfp_set_sampling_rate=16000");
+            qahw_set_parameters(audio_module, "hfp_set_sampling_rate=16000");
          else
-            audio_device->set_parameters(audio_device, "hfp_set_sampling_rate=8000");
+            qahw_set_parameters(audio_module, "hfp_set_sampling_rate=8000");
 
-         cout << "setting hfp_enable to true" << endl;
+         fprintf(stdout, "setting hfp_enable to true\n");
          ALOGD(LOGTAG " setting hfp_enable to true");
-         audio_device->set_parameters(audio_device, "hfp_volume=15");
-         audio_device->set_parameters(audio_device, "hfp_enable=true");
+         qahw_set_parameters(audio_module, "hfp_volume=15");
+         qahw_set_parameters(audio_module, "hfp_enable=true");
       }
       else
       {
-         cout << "setting hfp_enable to false" << endl;
+         fprintf(stdout, "setting hfp_enable to false\n");
          ALOGD(LOGTAG " setting hfp_enable to false");
-         audio_device->set_parameters(audio_device, "hfp_enable=false");
+         qahw_set_parameters(audio_module, "hfp_enable=false");
 
          if (out_stream != NULL) {
-            cout << "closing output stream for SCO/eSCO" << endl;
+            fprintf(stdout, "closing output stream for SCO/eSCO\n");
             ALOGD(LOGTAG " Closing output stream for SCO/eSCO");
-            audio_device->close_output_stream(audio_device, out_stream);
+            qahw_close_output_stream(out_stream);
             out_stream = NULL;
          }
       }
    }
    else {
-      cout << "ConfigureAudio: audio_device is NULL" << endl;
+      fprintf(stdout, "ConfigureAudio: audio_device is NULL\n");
       ALOGD(LOGTAG " ConfigureAudio: audio_device is NULL");
    }
+
 #else
    ALOGD("%s: BT_AUDIO_HAL_INTEGRATION needs to be defined", __func__);
-   cout << "BT_AUDIO_HAL_INTEGRATION needs to be defined" << endl;
+   fprintf(stdout, "BT_AUDIO_HAL_INTEGRATION needs to be defined\n");
 #endif
 }
 
+
+void Hfp_Client::ConfigureVolume(bthf_client_volume_type_t vol_type, int vol, bool mute_mic) {
+
+#if defined(BT_AUDIO_HAL_INTEGRATION)
+   qahw_module_handle_t* audio_module;
+
+   ALOGD(LOGTAG "ConfigureVolume for %s vol level %d, mute_mic %d",
+           (vol_type == BTHF_CLIENT_VOLUME_TYPE_SPK)? "speaker" :"mic", vol, mute_mic);
+   fprintf(stdout, "ConfigureVolume for %s vol level %d, mute_mic %d\n",
+           (vol_type == BTHF_CLIENT_VOLUME_TYPE_SPK)? "speaker" :"mic", vol, mute_mic);
+
+   if (pBTAM == NULL) {
+      ALOGD(LOGTAG "Audio Manager not initialized");
+      fprintf(stdout, "Audio Manager not initialized\n");
+      return;
+   }
+
+   audio_module = pBTAM->GetAudioDevice();
+   if(audio_module == NULL || out_stream == NULL) {
+      ALOGD(LOGTAG "Audio is not configured for SCO");
+      fprintf(stdout, "Audio is not configured for SCO\n");
+      return;
+   }
+
+   if (vol_type == BTHF_CLIENT_VOLUME_TYPE_SPK) {
+      char buf[14];
+
+      if (vol <= 0)
+         qahw_set_parameters(audio_module, "hfp_volume=0");
+      else if (vol >=  15)
+         qahw_set_parameters(audio_module, "hfp_volume=15");
+      else {
+         sprintf(buf, "hfp_volume=%d", vol);
+         qahw_set_parameters(audio_module, buf);
+      }
+   }
+   else if (vol_type == BTHF_CLIENT_VOLUME_TYPE_MIC) {
+      //audio_module->set_mic_mute(audio_module, mute_mic);
+   }
+
+#endif // BT_AUDIO_HAL_INTEGRATION
+}
+
 void Hfp_Client::change_state(HfpClientState mState) {
    ALOGD(LOGTAG " current State = %d, new state = %d", mClientState, mState);
-   cout <<  "change_state: current State = " << mClientState << " new state = " <<  mState;
+   fprintf(stdout, " current State = %d, new state = %d\n", mClientState, mState);
    pthread_mutex_lock(&lock);
    mClientState = mState;
    ALOGD(LOGTAG " state changes to %d ", mState);
@@ -1311,7 +1463,7 @@ void Hfp_Client::change_state(HfpClientState mState) {
 
 void Hfp_Client::change_mode(HfpClientMode mode) {
    ALOGD(LOGTAG " current mode = %d, new mode = %d", mAudioMode, mode);
-   cout << "change_mode: current mode " << mAudioMode << " new mode " << mode << endl;
+   fprintf(stdout, " current mode = %d, new mode = %d\n", mAudioMode, mode);
    pthread_mutex_lock(&lock);
    mAudioMode = mode;
    ALOGD(LOGTAG " mode changes to %d ", mAudioMode);
@@ -1328,18 +1480,26 @@ Hfp_Client :: Hfp_Client(const bt_interface_t *bt_interface, config_t *config) {
     peer_feat = 0;
     chld_feat = 0;
 #if defined(BT_AUDIO_HAL_INTEGRATION)
-    this->config = config;
-    out_stream =  NULL;
+#if defined(USE_GST)
+    memset(&gstbtringtoneobj, 0 , sizeof(gstbtringtoneobj));
+#else
     out_stream_ring_tone = NULL;
 #endif
+    this->config = config;
+    out_stream =  NULL;
+#endif // BT_AUDIO_HAL_INTEGRATION
     pthread_mutex_init(&this->lock, NULL);
 }
 
 Hfp_Client :: ~Hfp_Client() {
     mcontrolStatus = STATUS_LOSS_TRANSIENT;
 #if defined(BT_AUDIO_HAL_INTEGRATION)
-    out_stream =  NULL;
+#if defined(USE_GST)
+    close_gst_pipeline(&gstbtringtoneobj);
+#else
     out_stream_ring_tone = NULL;
-#endif
+#endif // USE_GST
+    out_stream =  NULL;
+#endif // BT_AUDIO_HAL_INTEGRATION
     pthread_mutex_destroy(&lock);
 }
diff --git a/bt-app/include/ipc.h b/bt-app/include/ipc.h
index 0772a6f..845fc7d 100644
--- a/bt-app/include/ipc.h
+++ b/bt-app/include/ipc.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *  Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *  Copyright (C) 2014 Google, Inc.
  *
@@ -24,12 +24,18 @@
 #include <hardware/bluetooth.h>
 #include <hardware/bt_gatt.h>
 #include <hardware/bt_gatt_types.h>
+#include <hardware/bt_sdp.h>
 
 extern thread_t *g_gap_thread;
 extern thread_t *g_main_thread;
 extern thread_t *g_socket_thread;
 extern thread_t *g_pan_thread;
 extern thread_t *g_gatt_thread;
+extern thread_t *g_pbapc_thread;
+
+// TODO: move this to bitbake
+//#define BT_MODEM_INTEGRATION 0
+
 /**
  * @file ipc.h
  *
@@ -41,12 +47,21 @@ extern thread_t *g_gatt_thread;
 #define PAN_MSG_BASE            (2000)
 #define GATT_MSG_BASE           (3000)
 #define RSP_MSG_BASE            (4000)
+#define SDP_CLIENT_MSG_BASE     (5000)
+#define PBAP_CLIENT_MSG_BASE    (6000)
+#define OPP_MSG_BASE            (7000)
+
 #define AUDIO_MANAGER_MSG_BASE  (250)
 #define A2DP_SINK_MSG_BASE      (300)
 #define HFP_CLIENT_MSG_BASE     (400)
+#define A2DP_SOURCE_MSG_BASE    (500)
+#define HFP_AG_MSG_BASE         (600)
+#define AVRCP_MSG_BASE          (700)
 #define MAX_BD_STR_LEN          (18)
 #define BT_IPC_MSG_LEN 2
 
+#define CMD_ID_VOL_UP           0x41
+#define CMD_ID_VOL_DOWN         0x42
 #define CMD_ID_PLAY             0x44
 #define CMD_ID_STOP             0x45
 #define CMD_ID_PAUSE            0x46
@@ -55,8 +70,8 @@ extern thread_t *g_gatt_thread;
 #define CMD_ID_FORWARD          0x4B
 #define CMD_ID_BACKWARD         0x4C
 
-#define KEY_PRESSED             0;
-#define KEY_RELEASED            1;
+#define KEY_PRESSED             0
+#define KEY_RELEASED            1
 
 /**
  *   Threads info
@@ -69,6 +84,14 @@ typedef enum {
     THREAD_ID_PAN,
     THREAD_ID_GATT,
     THREAD_ID_BT_AM,
+    THREAD_ID_SDP_CLIENT,
+#ifdef USE_BT_OBEX
+    THREAD_ID_PBAP_CLIENT,
+    THREAD_ID_OPP,
+#endif
+    THREAD_ID_HFP_AG,
+    THREAD_ID_A2DP_SOURCE,
+    THREAD_ID_AVRCP,
     THREAD_ID_MAX,
 } ThreadIdType;
 
@@ -81,6 +104,14 @@ typedef enum {
     PROFILE_ID_BT_AM,
     PROFILE_ID_PAN,
     PROFILE_ID_GATT,
+    PROFILE_ID_SDP_CLIENT,
+#ifdef USE_BT_OBEX
+    PROFILE_ID_PBAP_CLIENT,
+    PROFILE_ID_OPP,
+#endif
+    PROFILE_ID_HFP_AG,
+    PROFILE_ID_A2DP_SOURCE,
+    PROFILE_ID_AVRCP,
     PROFILE_ID_MAX
 } ProfileIdType;
 
@@ -116,6 +147,8 @@ typedef struct {
 typedef enum {
     MAIN_API_INIT = (MAIN_MSG_BASE + 1),
     MAIN_API_DEINIT,
+    MAIN_API_ENABLE,
+    MAIN_API_DISABLE,
     MAIN_EVENT_ACL_CONNECTED,
     MAIN_EVENT_ACL_DISCONNECTED,
     MAIN_EVENT_DEVICE_FOUND,
@@ -125,6 +158,9 @@ typedef enum {
     MAIN_EVENT_DISABLED,
     MAIN_EVENT_SSP_REQUEST,
     MAIN_EVENT_PIN_REQUEST,
+#ifdef USE_BT_OBEX
+    MAIN_EVENT_INCOMING_FILE_REQUEST,
+#endif
 
     MAIN_MSG_DISCOVER_DEVICES,
     MAIN_MSG_BOND_DEVICE,
@@ -145,12 +181,33 @@ typedef enum {
     A2DP_SINK_AUDIO_SUSPENDED,
     A2DP_SINK_AUDIO_STOPPED,
     A2DP_SINK_AUDIO_STARTED,
-    AVRCP_CTRL_CONNECTED_CB,
-    AVRCP_CTRL_DISCONNECTED_CB,
-    AVRCP_CTRL_PASS_THRU_CMD_REQ,
+    A2DP_SINK_CODEC_CONFIG,
     A2DP_SINK_FETCH_PCM_DATA,
+    A2DP_SINK_FILL_COMPRESS_BUFFER,
     A2DP_SINK_CLEANUP_REQ,
     A2DP_SINK_CLEANUP_DONE,
+    A2DP_SINK_STREAMING_FLUSH_AUDIO,
+
+    A2DP_SINK_STREAMING_CLEANUP_REQ,
+    A2DP_SINK_STREAMING_API_START,
+    A2DP_SINK_STREAMING_API_STOP,
+    A2DP_SINK_STREAMING_OPEN_INPUT_STREAM,
+    A2DP_SINK_STREAMING_CLOSE_AUDIO_STREAM,
+    A2DP_SINK_STREAMING_AM_REQUEST_CONTROL,
+    A2DP_SINK_STREAMING_FETCH_PCM_DATA,
+    A2DP_SINK_STREAMING_CONTROL_STATUS,
+    A2DP_SINK_STREAMING_AM_RELEASE_CONTROL,
+    A2DP_SINK_STREAMING_DISCONNECTED,
+    A2DP_SINK_STREAMING_DISABLE_DONE,
+
+    AVRCP_CTRL_CONNECTED_CB = AVRCP_MSG_BASE,
+    AVRCP_CTRL_DISCONNECTED_CB,
+    AVRCP_CTRL_PASS_THRU_CMD_REQ,
+    AVRCP_CLEANUP_REQ,
+    AVRCP_CLEANUP_DONE,
+    AVRCP_CTRL_REG_NOTI_ABS_VOL_CB,
+    AVRCP_CTRL_VOL_CHANGED_NOTI_REQ,
+    AVRCP_CTRL_SET_ABS_VOL_CMD_CB,
 
     HFP_CLIENT_API_ENABLE = HFP_CLIENT_MSG_BASE,
     HFP_CLIENT_API_DISABLE,
@@ -201,6 +258,89 @@ typedef enum {
     HFP_CLIENT_AUDIO_STATE_CONNECTED_CB,
     HFP_CLIENT_AUDIO_STATE_CONNECTED_MSBC_CB,
 
+    HFP_AG_API_ENABLE = HFP_AG_MSG_BASE,
+    HFP_AG_API_DISABLE,
+    HFP_AG_API_ENABLE_DONE,
+    HFP_AG_API_ENABLE_FAILED,
+    HFP_AG_API_DISABLE_DONE,
+    HFP_AG_API_INIT_MODEM,
+    HFP_AG_API_DEINIT_MODEM,
+    HFP_AG_API_CONNECT_REQ,
+    HFP_AG_API_DISCONNECT_REQ,
+    HFP_AG_API_CONNECT_AUDIO_REQ,
+    HFP_AG_API_DISCONNECT_AUDIO_REQ,
+    HFP_AG_API_DIAL_REQ,
+    HFP_AG_API_REDIAL_REQ,
+    HFP_AG_API_ACCEPT_CALL_REQ,
+    HFP_AG_API_REJECT_CALL_REQ,
+    HFP_AG_API_END_CALL_REQ,
+    HFP_AG_API_HOLD_CALL_REQ,
+    HFP_AG_API_SWAP_CALLS_REQ,
+    HFP_AG_API_RELEASE_HELD_CALL_REQ,
+    HFP_AG_API_ADD_HELD_CALL_TO_CONF_REQ,
+    HFP_AG_API_DUMP_CALLS_REQ,
+    HFP_AG_API_QUERY_CURRENT_CALLS_REQ,
+    HFP_AG_API_QUERY_OPERATOR_NAME_REQ,
+    HFP_AG_API_QUERY_SUBSCRIBER_INFO_REQ,
+    HFP_AG_API_START_VR_REQ,
+    HFP_AG_API_STOP_VR_REQ,
+    HFP_AG_API_MIC_VOL_CTRL_REQ,
+    HFP_AG_API_SPK_VOL_CTRL_REQ,
+    HFP_AG_CONNECTING_CB,
+    HFP_AG_CONNECTED_CB,
+    HFP_AG_SLC_CONNECTED_CB,
+    HFP_AG_DISCONNECTING_CB,
+    HFP_AG_DISCONNECTED_CB,
+    HFP_AG_AUDIO_STATE_DISCONNECTING_CB,
+    HFP_AG_AUDIO_STATE_DISCONNECTED_CB,
+    HFP_AG_AUDIO_STATE_CONNECTING_CB,
+    HFP_AG_AUDIO_STATE_CONNECTED_CB,
+    HFP_AG_VR_CB,
+    HFP_AG_ANSWER_CALL_CB,
+    HFP_AG_HANGUP_CALL_CB,
+    HFP_AG_VOL_CONTROL_CB,
+    HFP_AG_DIAL_CALL_CB,
+    HFP_AG_DTMF_CB,
+    HFP_AG_NREC_CB,
+    HFP_AG_WBS_CB,
+    HFP_AG_CHLD_CB,
+    HFP_AG_SUBSCRIBER_INFO_CB,
+    HFP_AG_CIND_CB,
+    HFP_AG_COPS_CB,
+    HFP_AG_CLCC_CB,
+    HFP_AG_UNKNOWN_AT_CMD_CB,
+    HFP_AG_BIND_CB,
+    HFP_AG_BIEV_CB,
+    HFP_AG_RIL_IND_CB,
+    HFP_AG_RIL_RESP_CB,
+
+    A2DP_SOURCE_API_CONNECT_REQ = A2DP_SOURCE_MSG_BASE,
+    A2DP_SOURCE_API_DISCONNECT_REQ,
+    A2DP_SOURCE_AUDIO_CMD_REQ,
+    A2DP_SOURCE_CONNECTION_PRIORITY_REQ,
+    A2DP_SOURCE_DISCONNECTED_CB,
+    A2DP_SOURCE_CONNECTING_CB,
+    A2DP_SOURCE_CONNECTED_CB,
+    A2DP_SOURCE_DISCONNECTING_CB,
+    A2DP_SOURCE_AUDIO_SUSPENDED,
+    A2DP_SOURCE_AUDIO_STOPPED,
+    A2DP_SOURCE_AUDIO_STARTED,
+    AVRCP_TARGET_CONNECTED_CB,
+    AVRCP_TARGET_DISCONNECTED_CB,
+    AVRCP_TARGET_GET_ELE_ATTR,
+    AVRCP_TARGET_GET_PLAY_STATUS,
+    AVRCP_TARGET_REG_NOTI,
+    AVRCP_TARGET_TRACK_CHANGED,
+    AVRCP_TARGET_VOLUME_CHANGED,
+    AVRCP_TARGET_SET_ABS_VOL,
+    AVRCP_TARGET_ABS_VOL_TIMEOUT,
+    AVRCP_TARGET_SEND_VOL_UP_DOWN,
+    AVRCP_TARGET_GET_FOLDER_ITEMS_CB,
+    AVRCP_TARGET_SET_ADDR_PLAYER_CB,
+    AVRCP_TARGET_ADDR_PLAYER_CHANGED,
+    AVRCP_TARGET_AVAIL_PLAYER_CHANGED,
+    AVRCP_TARGET_USE_BIGGER_METADATA,
+
     GAP_API_ENABLE = GAP_MSG_BASE,
     GAP_API_DISABLE,
     GAP_API_START_INQUIRY,
@@ -225,6 +365,7 @@ typedef enum {
     GAP_EVENT_PROFILE_STOP_TIMEOUT,
     GAP_EVENT_ENABLE_TIMEOUT,
     GAP_EVENT_DISABLE_TIMEOUT,
+    GAP_EVENT_SSR_CLEANUP,
     SKT_API_START_LISTENER,
     SKT_API_IPC_MSG_WRITE,
     SKT_API_IPC_MSG_READ,
@@ -237,11 +378,12 @@ typedef enum {
     PAN_EVENT_CONTROL_STATE_CHANGED = PAN_MSG_BASE,
     PAN_EVENT_CONNECTION_STATE_CHANGED,
     PAN_EVENT_SET_TETHERING_REQ,
+    PAN_EVENT_GET_MODE_REQ,
     PAN_EVENT_DEVICE_CONNECT_REQ,
     PAN_EVENT_DEVICE_DISCONNECT_REQ,
     PAN_EVENT_DEVICE_CONNECTED_LIST_REQ,
 
-  //GATTS EVENTS
+    //GATTS EVENTS
     BTGATTS_REGISTER_APP_EVENT = GATT_MSG_BASE,
     BTGATTS_CONNECTION_EVENT,
     BTGATTS_SERVICE_ADDED_EVENT,
@@ -293,9 +435,53 @@ typedef enum {
     BTGATTC_BATCHSCAN_THRESHOLD_EVENT,
     BTGATTC_TRACK_ADV_EVENT_EVENT,
     BTGATTC_SCAN_PARAMETER_SETUP_COMPLETED_EVENT,
+    BTGATTC_GET_GATT_DB_EVENT,
 
     RSP_ENABLE_EVENT = RSP_MSG_BASE,
-    RSP_DISABLE_EVENT
+    RSP_DISABLE_EVENT,
+
+    SDP_CLIENT_SEARCH = SDP_CLIENT_MSG_BASE,
+    SDP_CLIENT_ADD_RECORD,
+    SDP_CLIENT_REMOVE_RECORD,
+    SDP_CLIENT_SEARCH_TIMEOUT,
+
+    PBAP_CLIENT_REGISTER = PBAP_CLIENT_MSG_BASE,
+    PBAP_CLIENT_CONNECT,
+    PBAP_CLIENT_INTERNAL_CONNECT,
+    PBAP_CLIENT_CONNECT_TIMEOUT,
+    PBAP_CLIENT_DISCONNECT,
+    PBAP_CLIENT_ABORT,
+    PBAP_CLIENT_GET_PHONEBOOK_SIZE,
+    PBAP_CLIENT_GET_PHONEBOOK,
+    PBAP_CLIENT_GET_VCARD,
+    PBAP_CLIENT_GET_VCARD_LISTING,
+    PBAP_CLIENT_SET_PATH,
+    PBAP_CLIENT_SET_FILTER,
+    PBAP_CLIENT_SET_ORDER,
+    PBAP_CLIENT_SET_SEARCH_ATTRIBUTE,
+    PBAP_CLIENT_SET_SEARCH_VALUE,
+    PBAP_CLIENT_SET_PHONE_BOOK,
+    PBAP_CLIENT_SET_REPOSITORY,
+    PBAP_CLIENT_SET_VCARD_FORMAT,
+    PBAP_CLIENT_SET_LIST_COUNT,
+    PBAP_CLIENT_SET_START_OFFSET,
+    PBAP_CLIENT_GET_FILTER,
+    PBAP_CLIENT_GET_ORDER,
+    PBAP_CLIENT_GET_SEARCH_ATTRIBUTE,
+    PBAP_CLIENT_GET_PHONE_BOOK,
+    PBAP_CLIENT_GET_REPOSITORY,
+    PBAP_CLIENT_GET_VCARD_FORMAT,
+    PBAP_CLIENT_GET_LIST_COUNT,
+    PBAP_CLIENT_GET_START_OFFSET,
+
+    OPP_SRV_REGISTER = OPP_MSG_BASE,
+    OPP_SEND_DATA,
+    OPP_ABORT_TRANSFER,
+    OPP_INTERNAL_CONNECT,
+    OPP_INTERNAL_SEND,
+    OPP_INTERNAL_DISCONNECTION,
+    OPP_INCOMING_FILE_RESPONSE,
+    OPP_CONNECT_TIMEOUT,
 } BluetoothEventId;
 
 typedef struct {
@@ -521,12 +707,41 @@ typedef struct {
 typedef struct {
     BluetoothEventId   event_id;
     bt_bdaddr_t         bd_addr;
+    uint8_t*           buf_ptr;
+    uint16_t           buf_size;
+    uint16_t           arg1;
+    uint16_t           arg2;
 } A2dpSinkEvent;
 
 typedef struct {
     BluetoothEventId   event_id;
     bt_bdaddr_t         bd_addr;
+    ControlStatusType  status_type;
+} A2dpSinkStreamingEvent;
+
+typedef struct {
+    BluetoothEventId   event_id;
+    bt_bdaddr_t         bd_addr;
+} A2dpSourceEvent;
+
+typedef struct {
+    BluetoothEventId   event_id;
+    uint8_t            key_id;
+    bt_bdaddr_t        bd_addr;
+    uint8_t*           buf_ptr;
+    uint16_t           buf_size;
+    uint16_t           arg1;
+    uint32_t           arg2;
+    uint8_t            arg3;
+    uint8_t            arg4;
+} AvrcpTargetEvent;
+
+typedef struct {
+    BluetoothEventId    event_id;
+    bt_bdaddr_t         bd_addr;
     uint8_t             key_id;
+    uint8_t             arg1;
+    uint8_t             arg2;
 } AvrcpCtrlPassThruCmdReq;
 
 /**
@@ -543,6 +758,21 @@ typedef struct {
 } HfpClientEvent;
 
 /**
+ * Event for notifying hfp ag message
+ */
+typedef struct {
+    BluetoothEventId event_id;
+    bt_bdaddr_t         bd_addr;
+    char                str[513];
+    int                 arg1;
+    int                 arg2;
+    uint32_t            hdl;
+    uint32_t            msg_id;
+    uint32_t            data_length;
+    void                *data;
+} HfpAGEvent;
+
+/**
  * Event for notifying Pan control state
  */
 typedef struct {
@@ -574,6 +804,13 @@ typedef struct {
 } PanSetTetheringEvent;
 
 /**
+ * Event for displaying tethering user choice & pan mode on UI
+ */
+typedef struct {
+    BluetoothEventId event_id;
+} PanGetModeEvent;
+
+/**
  * Event for notifying Pan disconnect
  */
 typedef struct {
@@ -672,8 +909,7 @@ typedef struct{
     int conn_id;
     int registered;
     int status;
-    btgatt_srvc_id_t *srvc_id;
-    btgatt_gatt_id_t *char_id;
+    int handle;
 } GattcRegisterForNotificationEvent;
 
 typedef struct{
@@ -693,7 +929,7 @@ typedef struct{
     BluetoothEventId event_id;
     int conn_id;
     int status;
-    btgatt_write_params_t *p_data;
+    int handle;
 } GattcWriteCharacteristicEvent;
 
 typedef struct{
@@ -713,7 +949,7 @@ typedef struct{
     BluetoothEventId event_id;
     int conn_id;
     int status;
-    btgatt_write_params_t *p_data;
+    uint16_t handle;
 } GattcWriteDescriptorEvent;
 
 typedef struct{
@@ -833,7 +1069,15 @@ typedef struct
     BluetoothEventId event_id;
     int client_if;
     btgattc_error_t status;
-} GattcScanParameterSetupCompleted_Event;
+} GattcScanParameterSetupCompletedEvent;
+
+typedef struct
+{
+    BluetoothEventId event_id;
+    int conn_id;
+    btgatt_db_element_t *db;
+    int count;
+} GattcGetGattDbEvent;
 
 typedef struct{
     BluetoothEventId event_id;
@@ -982,6 +1226,7 @@ typedef struct
 typedef struct {
     BluetoothEventId event_id;
     bt_uuid_t server_uuid;
+    bt_uuid_t client_uuid;
     bt_uuid_t service_uuid;
     bt_uuid_t characteristics_uuid;
     bt_uuid_t descriptor_uuid;
@@ -997,6 +1242,42 @@ typedef struct {
     int server_if;
 } RspAddServiceEvent;
 
+/** Callback for SDP search */
+typedef void (*SdpSearchCb)(bt_status_t status, bt_bdaddr_t *bd_addr, uint8_t* uuid,
+    bluetooth_sdp_record *record, bool more_result);
+
+typedef void (*SdpAddRecordCb)(bt_status_t status, int handle);
+
+typedef void (*SdpRemoveRecordCb)(bt_status_t status);
+
+typedef struct {
+    BluetoothEventId        event_id;
+    bt_bdaddr_t             bd_addr;
+    uint8_t                 *uuid;
+    SdpSearchCb             searchCb;
+    SdpAddRecordCb          addRecordCb;
+    SdpRemoveRecordCb       removeRecordCb;
+    bluetooth_sdp_record    record;
+    int                     rec_handle;
+} SdpClientEvent;
+
+#ifdef USE_BT_OBEX
+typedef struct {
+    BluetoothEventId    event_id;
+    bt_bdaddr_t         bd_addr;
+    char                value[256];
+    uint32_t            max_list_count;
+    uint32_t            list_start_offset;
+} PbapClientEvent;
+
+typedef struct {
+    BluetoothEventId    event_id;
+    bt_bdaddr_t         bd_addr;
+    char                value[256];
+    bool                accept;
+} OppEvent;
+#endif
+
 /**
   * @brief BT IPC message between qcbtdaemon & btapp
   */
@@ -1055,8 +1336,12 @@ typedef union {
     ProfileStartEvent                       profile_start_event;
     ProfileStopEvent                        profile_stop_event;
     A2dpSinkEvent                           a2dpSinkEvent;
+    A2dpSinkStreamingEvent                  a2dpSinkStreamingEvent;
     AvrcpCtrlPassThruCmdReq                 avrcpCtrlEvent;
+    A2dpSourceEvent                         a2dpSourceEvent;
+    AvrcpTargetEvent                        avrcpTargetEvent;
     HfpClientEvent                          hfp_client_event;
+    HfpAGEvent                              hfp_ag_event;
     BTAMControlRequest                      btamControlReq;
     BTAMControlStatus                       btamControlStatus;
     BTAMControlRelease                      btamControlRelease;
@@ -1064,6 +1349,7 @@ typedef union {
     PanControlStateEvent                    pan_control_state_event;
     PanConnectionStateEvent                 pan_connection_state_event;
     PanSetTetheringEvent                    pan_set_tethering_event;
+    PanGetModeEvent                         pan_get_mode_event;
     PanDeviceDisconnectEvent                pan_device_disconnect_event;
     PanDeviceConnectEvent                   pan_device_connect_event;
     PanDeviceConnectedListEvent             pan_device_connected_list_event;
@@ -1117,10 +1403,16 @@ typedef union {
     GattcBatchscanReportsEvent              gattc_batchscan_reports_event;
     GattcBatchscanThresholdEvent            gattc_batchscan_threshold_event;
     GattcTrackAdvEventEvent                 gattc_track_adv_event_event;
-    GattcScanParameterSetupCompleted_Event  gattc_scan_parameter_setup_completed_event;
+    GattcScanParameterSetupCompletedEvent   gattc_scan_parameter_setup_completed_event;
+    GattcGetGattDbEvent                     gattc_get_gatt_db_event;
 
     RspEnableEvent                          rsp_enable_event;
     RspDisableEvent                         rsp_disable_event;
+    SdpClientEvent                          sdp_client_event;
+#ifdef USE_BT_OBEX
+    PbapClientEvent                         pbap_client_event;
+    OppEvent                                opp_event;
+#endif
     BtIpcMsgEvent                           bt_ipc_msg_event;
 } BtEvent;
 
@@ -1137,6 +1429,14 @@ typedef enum{
      */
     BT_IPC_DISABLE_TETHERING,
     /**
+     * ipc message to enable reverse tethering
+     */
+    BT_IPC_ENABLE_REVERSE_TETHERING,
+    /**
+     * ipc message to disable reverse tethering
+     */
+    BT_IPC_DISABLE_REVERSE_TETHERING,
+    /**
      * ipc message to start WLAN
      */
     BT_IPC_REMOTE_START_WLAN,
@@ -1167,7 +1467,15 @@ void BtA2dpSinkMsgHandler(void *msg);
 void BtPanMsgHandler(void *context);
 void BtGattMsgHandler(void *context);
 void BtHfpClientMsgHandler (void *context);
+void BtHfpAgMsgHandler (void *context);
 void BtAudioManagerHandler(void *msg);
+void BtSdpClientMsgHandler(void *context);
+void BtAvrcpMsgHandler(void *msg);
+#ifdef USE_BT_OBEX
+void BtPbapClientMsgHandler(void *context);
+void BtOppMsgHandler(void *context);
+#endif
+void BtA2dpSourceMsgHandler(void *msg);
 #ifdef __cplusplus
 }
 #endif
diff --git a/bt-app/main/Makefile.am b/bt-app/main/Makefile.am
index 8fd5387..7c9c22c 100644
--- a/bt-app/main/Makefile.am
+++ b/bt-app/main/Makefile.am
@@ -1,27 +1,54 @@
 AM_CPPFLAGS = -O2 \
-              -D_GNU_SOURCE
+            -D_GNU_SOURCE
 
 AM_CFLAGS = -Wall \
-        -Wundef \
-        -Wstrict-prototypes \
-        -Wno-trigraphs \
-        -std=c99
+            -Wundef \
+            -Wstrict-prototypes \
+            -Wno-trigraphs \
+            -std=c99
 
+if USE_BT_OBEX
+AM_CFLAGS += -DOI_CPU_TYPE=19
+endif
 ACLOCAL_AMFLAGS = -I m4
 
 AM_CPPFLAGS += -I${WORKSPACE}/qcom-opensource/bt/bt-app \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/utils/include \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/audio_manager/include \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/a2dp_sink/include \
+               -I${WORKSPACE}/qcom-opensource/bt/bt-app/avrcp/include \
+               -I${WORKSPACE}/qcom-opensource/bt/bt-app/a2dp_src/include \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/osi/include \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/gap/include \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/pan/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/gatt/include \
+               -I${WORKSPACE}/qcom-opensource/bt/bt-app/rsp/include \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/main/include \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/hfp_client/include \
+               -I${WORKSPACE}/qcom-opensource/bt/bt-app/hfp_ag/include \
                -I${WORKSPACE}/qcom-opensource/bt/bt-app/include \
+               -I${WORKSPACE}/qcom-opensource/bt/gatt/include \
+               -I${WORKSPACE}/qcom-opensource/bt/bt-app/sdp_client/include \
                -I${WORKSPACE}/system/media/audio/include \
-               -I${WORKSPACE}/hardware/libhardware/include
+               -I${WORKSPACE}/hardware/qcom/audio/qahw_api/inc \
+               -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/hal/include \
+               -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/vhal/include \
+               -I${WORKSPACE}/mcm-api/api
+
+if USE_BT_OBEX
+AM_CPPFLAGS += -DOI_CPU_TYPE=19 \
+               -I${WORKSPACE}/qcom-opensource/bt/bt-app/pbap_client/include \
+               -I${WORKSPACE}/qcom-opensource/bt/bt-app/opp/include \
+               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/include \
+               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/include/profiles \
+               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/profiles/obex \
+               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/include \
+               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/include/profiles \
+               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/oem
+endif
+
+if AUDIO_HAL_SUPPORTED
+AM_CPPFLAGS += -DBT_AUDIO_HAL_INTEGRATION
+endif
 
 c_sources = ../utils/src/utils.c \
             src/Main.cpp \
@@ -31,17 +58,74 @@ c_sources = ../utils/src/utils.c \
             ../gap/src/RemoteDevices.cpp \
             ../audio_manager/src/Audio_Manager.cpp \
             ../a2dp_sink/src/A2dp_Sink.cpp \
+            ../a2dp_sink/src/A2dp_Sink_Streaming.cpp \
+            ../avrcp/src/Avrcp.cpp \
+            ../a2dp_src/src/A2dp_Src.cpp \
             ../hfp_client/src/HfpClient.cpp \
+            ../hfp_ag/src/HfpAG.cpp \
             ../pan/src/Pan.cpp \
-            ../gatt/src/Gatt.cpp \
-            ../gatt/src/Rsp.cpp
+            ../sdp_client/src/SdpClient.cpp\
+            ../rsp/src/Rsp.cpp
+
+if USE_BT_OBEX
+c_sources +=  ../pbap_client/src/PbapClient.cpp \
+              ../opp/src/Opp.cpp
+endif
 
+if USE_GST
+requiredlibs = ../osi/libgstbtapposi.la -lpthread -lm -ldl -lrt -lhardware
+else
 requiredlibs = ../osi/libbtapposi.la -lpthread -lm -ldl -lrt -lhardware
+endif
+
+requiredlibs += $(SYS_LIB)/libgengatt.la
+if AUDIO_HAL_SUPPORTED
+requiredlibs += $(SYS_LIB)/libqahw.la
+endif
+
+if USE_BT_OBEX
+requiredlibs += $(SYS_LIB)/libbtobex.la
+endif
+
+if USE_GLIB
+
+if USE_GST
+ gstbtapp_CFLAGS  = $(AM_CFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
+ gstbtapp_CPPFLAGS  = $(AM_CPPFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
+ gstbtapp_LDFLAGS = $(requiredlibs) @GLIB_LIBS@
+ gstbtapp_CPPFLAGS += $(GSTREAMER_CFLAGS) -DUSE_GST
+else
+ btapp_CFLAGS  = $(AM_CFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
+ btapp_CPPFLAGS  = $(AM_CPPFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
+ btapp_LDFLAGS = $(requiredlibs) @GLIB_LIBS@
+endif
+
+else
+
+if USE_GST
+ gstbtapp_CFLAGS = $(AM_CFLAGS)
+ gstbtapp_LDFLAGS = $(requiredlibs)
+else
+ btapp_CFLAGS = $(AM_CFLAGS)
+ btapp_LDFLAGS = $(requiredlibs)
+endif
+
+endif
+
+if USE_GST
+gstbtapp_CFLAGS += $(GSTREAMER_CFLAGS)
+gstbtapp_LDFLAGS += $(GSTREAMER_LIBS) -lgstaudio-1.0 -lgstapp-1.0 -lgstbthelper
+endif
 
-AM_LDFLAGS := $(LDFLAFGS)
+AM_LDFLAGS = $(LDFLAFGS)
 
+if USE_GST
+bin_PROGRAMS = gstbtapp
+gstbtapp_CC = @CC@
+gstbtapp_SOURCES = $(c_sources)
+else
 bin_PROGRAMS = btapp
 btapp_CC = @CC@
 btapp_SOURCES = $(c_sources)
-btapp_LDADD = $(requiredlibs)
+endif
 pkgconfigdir = $(libdir)/pkgconfig
diff --git a/bt-app/main/include/Main.hpp b/bt-app/main/include/Main.hpp
old mode 100755
new mode 100644
index c19fa12..c333f67
--- a/bt-app/main/include/Main.hpp
+++ b/bt-app/main/include/Main.hpp
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *  Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *  Copyright (C) 2014 Google, Inc.
  *
@@ -30,6 +30,7 @@
 #include <hardware/bluetooth.h>
 #include "include/ipc.h"
 #include "utils.h"
+#include "Rsp.hpp"
 
 #include <cutils/sockets.h>
 #include <sys/un.h>
@@ -43,6 +44,11 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 
+#ifdef USE_GLIB
+#include <glib.h>
+#define strlcpy g_strlcpy
+#endif
+
 /**
  * @file Main.hpp
  * @brief Main header file for the BT application
@@ -78,12 +84,15 @@ const char *BT_SOCKET_ENABLED      = "BtSockInputEnabled";
 const char *BT_ENABLE_DEFAULT      = "BtEnableByDefault";
 const char *BT_USER_INPUT          = "UserInteractionNeeded";
 const char *BT_A2DP_SINK_ENABLED   = "BtA2dpSinkEnable";
+const char *BT_A2DP_SOURCE_ENABLED = "BtA2dpSourceEnable";
 const char *BT_HFP_CLIENT_ENABLED  = "BtHfClientEnable";
+const char *BT_HFP_AG_ENABLED      = "BtHfpAGEnable";
+const char *BT_AVRCP_ENABLED       = "BtAvrcpEnable";
 
 /**
  * The Configuration file path
  */
-const char *CONFIG_FILE_PATH       = "/etc/bluetooth/bt_app.conf";
+const char *CONFIG_FILE_PATH       = "/data/misc/bluetooth/bt_app.conf";
 
 /**
  * To track user command status
@@ -126,6 +135,7 @@ typedef enum {
     GAP_OPTION,
     TEST_ON_OFF,
     A2DP_SINK,
+    A2DP_SOURCE,
     CONNECT,
     DISCONNECT,
     PLAY,
@@ -135,11 +145,53 @@ typedef enum {
     REWIND,
     FORWARD,
     BACKWARD,
+    VOL_UP,
+    VOL_DOWN,
+    TRACK_CHANGE,
+    SET_ABS_VOL,
+    SEND_VOL_UP_DOWN,
+    VOL_CHANGED_NOTI,
+    ADDR_PLAYER_CHANGE,
+    AVAIL_PLAYER_CHANGE,
+    BIGGER_METADATA,
     PAN_OPTION,
     CONNECTED_LIST,
     SET_TETHERING,
+    GET_PAN_MODE,
+    RSP_OPTION,
     RSP_INIT,
     RSP_START,
+#ifdef USE_BT_OBEX
+    PBAP_CLIENT_OPTION,
+    PBAP_REGISTER,
+    PBAP_GET_PHONEBOOK_SIZE,
+    PBAP_GET_PHONEBOOK,
+    PBAP_GET_VCARD,
+    PBAP_GET_VCARD_LISTING,
+    PBAP_SET_PATH,
+    PBAP_ABORT,
+    PBAP_SET_FILTER,
+    PBAP_SET_ORDER,
+    PBAP_SET_SEARCH_ATTRIBUTE,
+    PBAP_SET_SEARCH_VALUE,
+    PBAP_SET_PHONE_BOOK,
+    PBAP_SET_REPOSITORY,
+    PBAP_SET_VCARD_FORMAT,
+    PBAP_SET_LIST_COUNT,
+    PBAP_SET_START_OFFSET,
+    PBAP_GET_FILTER,
+    PBAP_GET_ORDER,
+    PBAP_GET_SEARCH_ATTRIBUTE,
+    PBAP_GET_PHONE_BOOK,
+    PBAP_GET_REPOSITORY,
+    PBAP_GET_VCARD_FORMAT,
+    PBAP_GET_LIST_COUNT,
+    PBAP_GET_START_OFFSET,
+    OPP_OPTION,
+    OPP_REGISTER,
+    OPP_SEND,
+    OPP_ABORT,
+#endif
     HFP_CLIENT,
     CREATE_SCO_CONN,
     DESTROY_SCO_CONN,
@@ -171,6 +223,7 @@ typedef enum {
     SEND_DTMF,
     DISABLE_NREC_ON_AG,
     SEND_AT_CMD,
+    HFP_AG,
     BACK_TO_MAIN,
     END,
 } CommandList;
@@ -190,7 +243,14 @@ typedef enum {
     TEST_MENU,
     A2DP_SINK_MENU,
     HFP_CLIENT_MENU,
-    PAN_MENU
+    PAN_MENU,
+    RSP_MENU,
+#ifdef USE_BT_OBEX
+    PBAP_CLIENT_MENU,
+    OPP_MENU,
+#endif
+    HFP_AG_MENU,
+    A2DP_SOURCE_MENU
 } MenuType;
 
 /**
@@ -236,9 +296,16 @@ UserMenuList GapMenu[] = {
 UserMenuList MainMenu[] = {
     {GAP_OPTION,            "gap_menu",         ZERO_PARAM,   "gap_menu"},
     {PAN_OPTION,            "pan_menu",         ZERO_PARAM,   "pan_menu"},
+    {RSP_OPTION,            "rsp_menu",         ZERO_PARAM,   "rsp_menu"},
     {TEST_MODE,             "test_menu",        ZERO_PARAM,   "test_menu"},
     {A2DP_SINK,             "a2dp_sink_menu",   ZERO_PARAM,   "a2dp_sink_menu"},
     {HFP_CLIENT,            "hfp_client_menu",  ZERO_PARAM,   "hfp_client_menu"},
+#ifdef USE_BT_OBEX
+    {PBAP_CLIENT_OPTION,    "pbap_client_menu", ZERO_PARAM,   "pbap_client_menu"},
+    {OPP_OPTION,            "opp_menu",         ZERO_PARAM,   "opp_menu"},
+#endif
+    {HFP_AG,                "hfp_ag_menu",      ZERO_PARAM,   "hfp_ag_menu"},
+    {A2DP_SOURCE,           "a2dp_source_menu", ZERO_PARAM,   "a2dp_source_menu"},
     {MAIN_EXIT,             "exit",             ZERO_PARAM,   "exit"},
 };
 
@@ -248,6 +315,9 @@ UserMenuList MainMenu[] = {
 UserMenuList PanMenu[] = {
     {SET_TETHERING,  "enable_tethering",         ONE_PARAM, \
     "enable_tethering<space><true or false> eg. enable_tethering true"},
+    {GET_PAN_MODE,   "get_mode",                 ZERO_PARAM, "get_mode"},
+    {CONNECT,        "connect",                  ONE_PARAM, \
+    "connect<space><bt_address> eg. connect 00:11:22:33:44:55"},
     {DISCONNECT,     "disconnect",               ONE_PARAM, \
     "disconnect<space><bt_address> eg. disconnect 00:11:22:33:44:55"},
     {CONNECTED_LIST, "connected_device_list",    ZERO_PARAM, "connected_device_list"},
@@ -259,8 +329,15 @@ UserMenuList PanMenu[] = {
 UserMenuList TestMenu[] = {
     {TEST_ON_OFF,           "on_off",    ONE_PARAM,     "<on_off> <number>   eg: on_off 100"},
     {BACK_TO_MAIN,          "main_menu", ZERO_PARAM,    "main_menu"},
+};
+
+/**
+ * list of supported commands for RSP Menu
+ */
+UserMenuList RspMenu[] = {
     {RSP_INIT,              "rsp_init",  ZERO_PARAM,    "rsp_init (only for Init time)"},
     {RSP_START,             "rsp_start", ZERO_PARAM,    "rsp_start would (re)start adv"},
+    {BACK_TO_MAIN,          "main_menu",  ZERO_PARAM, "main_menu"},
 };
 
 /**
@@ -269,14 +346,38 @@ UserMenuList TestMenu[] = {
 UserMenuList A2dpSinkMenu[] = {
     {CONNECT,               "connect",          ONE_PARAM,    "connect<space><bt_address>"},
     {DISCONNECT,            "disconnect",       ONE_PARAM,    "disconnect<space><bt_address>"},
-    {PLAY,                  "play",             ZERO_PARAM,    "play"},
-    {PAUSE,                 "pause",            ZERO_PARAM,    "pause"},
-    {STOP,                  "stop",             ZERO_PARAM,    "stop<"},
-    {REWIND,                "rewind",           ZERO_PARAM,    "rewind"},
-    {FASTFORWARD,           "fastforward",      ZERO_PARAM,    "fastforward"},
-    {FORWARD,               "forward",          ZERO_PARAM,    "forward"},
-    {BACKWARD,              "backward",         ZERO_PARAM,    "backward"},
-    {BACK_TO_MAIN,          "main_menu",        ZERO_PARAM,    "main_menu"},
+    {PLAY,                  "play",             ONE_PARAM,    "play<space><bt_address>"},
+    {PAUSE,                 "pause",            ONE_PARAM,    "pause<space><bt_address>"},
+    {STOP,                  "stop",             ONE_PARAM,    "stop<space><bt_address>"},
+    {REWIND,                "rewind",           ONE_PARAM,    "rewind<space><bt_address>"},
+    {FASTFORWARD,           "fastforward",      ONE_PARAM,    "fastforward<space><bt_address>"},
+    {FORWARD,               "forward",          ONE_PARAM,    "forward<space><bt_address>"},
+    {BACKWARD,              "backward",         ONE_PARAM,    "backward<space><bt_address>"},
+    {VOL_UP,                "volup",            ONE_PARAM,    "volup<space><bt_address>"},
+    {VOL_DOWN,              "voldown",          ONE_PARAM,    "voldown<space><bt_address>"},
+    {VOL_CHANGED_NOTI,      "volchangednoti",   ONE_PARAM,    "volchangednoti<space><vol level>"},
+    {BACK_TO_MAIN,          "main_menu",        ZERO_PARAM,   "main_menu"},
+};
+
+/**
+ * list of supported commands for A2DP_SOURCE Menu
+ */
+UserMenuList A2dpSourceMenu[] = {
+    {CONNECT,               "connect",          ONE_PARAM,    "connect<space><bt_address>"},
+    {DISCONNECT,            "disconnect",       ONE_PARAM,    "disconnect<space><bt_address>"},
+    {PLAY,                  "start",            ZERO_PARAM,   "start"},
+    {PAUSE,                 "suspend",          ZERO_PARAM,   "suspend"},
+    {STOP,                  "stop",             ZERO_PARAM,   "stop"},
+    {TRACK_CHANGE,          "trackchange",      ZERO_PARAM,   "trackchange"},
+    {SET_ABS_VOL,           "setabsolutevol",   ONE_PARAM,
+            "setabsolutevol<space><volstep>  eg: setabsolutevol 10 (range 0-15)"},
+    {SEND_VOL_UP_DOWN,      "sendvolupdown",    ONE_PARAM,
+            "sendvolupdown<space><1/0>  eg: sendvolupdown 1 (1-up, 0-down)"},
+    {ADDR_PLAYER_CHANGE,    "addrplayerchange", ONE_PARAM,
+            "addrplayerchange<space><1/0>  eg: addrplayerchange 1 "},
+    {AVAIL_PLAYER_CHANGE,   "availplayerchange",ZERO_PARAM,   "availplayerchange"},
+    {BIGGER_METADATA,       "biggermetadata",   ZERO_PARAM,   "biggermetadata"},
+    {BACK_TO_MAIN,          "main_menu",        ZERO_PARAM,   "main_menu"},
 };
 
 /**
@@ -318,6 +419,79 @@ UserMenuList HfpClientMenu[] = {
     {BACK_TO_MAIN,          "main_menu",     ZERO_PARAM,   "main_menu"},
 };
 
+#ifdef USE_BT_OBEX
+/**
+ * list of supported commands for PBAP_CLIENT Menu
+ */
+UserMenuList PbapClientMenu[] = {
+    {PBAP_REGISTER,             "register",             ZERO_PARAM, "register"},
+    {CONNECT,                   "connect",              ONE_PARAM,  "connect<space><bt_address>"},
+    {DISCONNECT,                "disconnect",           ONE_PARAM,  "disconnect<space><bt_address>"},
+    {PBAP_ABORT,                "abort",                ZERO_PARAM, "abort"},
+    {PBAP_GET_PHONEBOOK_SIZE,   "get_phonebook_size",   ZERO_PARAM, "get_phonebook_size"},
+    {PBAP_GET_PHONEBOOK,        "get_phonebook",        ZERO_PARAM, "get_phonebook"},
+    {PBAP_GET_VCARD,            "get_vcard",            ONE_PARAM,  "get_vcard<space><vcard handle>"},
+    {PBAP_GET_VCARD_LISTING,    "get_vcard_listing",    ZERO_PARAM, "get_vcard_listing"},
+    {PBAP_SET_PATH,             "set_path",             ONE_PARAM,  "set_path<space><path>"},
+    {PBAP_SET_PHONE_BOOK,       "set_phone_book",       ONE_PARAM,  "set_phone_book<space><phonebook>"},
+    {PBAP_GET_PHONE_BOOK,       "get_phone_book",       ZERO_PARAM, "get_phone_book"},
+    {PBAP_SET_REPOSITORY,       "set_repository",       ONE_PARAM,  "set_repository<space><repository>"},
+    {PBAP_GET_REPOSITORY,       "get_repository",       ZERO_PARAM, "get_repository"},
+    {PBAP_SET_ORDER,            "set_sort_order",       ONE_PARAM,  "set_sort_order<space><order>"},
+    {PBAP_GET_ORDER,            "get_sort_order",       ZERO_PARAM, "get_sort_order"},
+    {PBAP_SET_SEARCH_ATTRIBUTE, "set_search_attribute", ONE_PARAM,  "set_search_attribute<space><search_attribute>"},
+    {PBAP_GET_SEARCH_ATTRIBUTE, "get_search_attribute", ZERO_PARAM, "get_search_attribute"},
+    {PBAP_SET_SEARCH_VALUE,     "set_search_value",     ONE_PARAM,  "set_search_value<space><value>"},
+    {PBAP_SET_FILTER,           "set_filter",           ONE_PARAM,  "set_filter<space><filter1,filter2,...>"},
+    {PBAP_GET_FILTER,           "get_filter",           ZERO_PARAM, "get_filter"},
+    {PBAP_SET_VCARD_FORMAT,     "set_vcard_format",     ONE_PARAM,  "set_vcard_format<space><format>"},
+    {PBAP_GET_VCARD_FORMAT,     "get_vcard_format",     ZERO_PARAM, "get_vcard_format"},
+    {PBAP_SET_LIST_COUNT,       "set_list_count",       ONE_PARAM,  "set_list_count<space><listcount>"},
+    {PBAP_GET_LIST_COUNT,       "get_list_count",       ZERO_PARAM, "get_list_count"},
+    {PBAP_SET_START_OFFSET,     "set_start_offset",     ONE_PARAM,  "set_start_offset<space><startoffset>"},
+    {PBAP_GET_START_OFFSET,     "get_start_offset",     ZERO_PARAM, "get_start_offset"},
+    {BACK_TO_MAIN,              "main_menu",            ZERO_PARAM, "main_menu"},
+};
+
+/**
+ * list of supported commands for OPP Menu
+ */
+UserMenuList OppMenu[] = {
+    {OPP_REGISTER,              "register",             ZERO_PARAM, "register"},
+    {OPP_SEND,                  "send",                 TWO_PARAM,  "send<space><bt_address><space><file_name>"},
+    {OPP_ABORT,                 "abort",                ZERO_PARAM, "abort"},
+    {BACK_TO_MAIN,              "main_menu",            ZERO_PARAM, "main_menu"},
+};
+#endif
+
+
+/**
+ * list of supported commands for HFP_CLIENT Menu
+ */
+UserMenuList HfpAGMenu[] = {
+    {CONNECT,               "connect",       ONE_PARAM,    "connect<space><bt_address>"},
+    {DISCONNECT,            "disconnect",    ONE_PARAM,    "disconnect<space><bt_address>"},
+    {CREATE_SCO_CONN,       "create_sco",    ONE_PARAM,    "create_sco<space><bt_address>"},
+    {DESTROY_SCO_CONN,      "destroy_sco",   ONE_PARAM,    "destroy_sco<space><bt_address>"},
+#if defined(BT_MODEM_INTEGRATION)
+    {ACCEPT_CALL,           "accept_call",   ZERO_PARAM,   "accept_call"},
+    {REJECT_CALL,           "reject_call",   ZERO_PARAM,   "reject_call"},
+    {END_CALL,              "end_call",      ZERO_PARAM,   "end_call"},
+    {HOLD_CALL,             "hold_call",     ZERO_PARAM,   "hold_call"},
+    {RELEASE_HELD_CALL,     "release_held_call", ZERO_PARAM,   "release_held_call"},
+    {SWAP_CALLS,            "swap_calls", ZERO_PARAM,   "swap_calls"},
+    {ADD_HELD_CALL_TO_CONF, "add_held_call_to_conference", ZERO_PARAM,   "add_held_call_to_conference"},
+    {DIAL,                  "dial",          ONE_PARAM,    "dial<space><phone_number>"},
+    {QUERY_CURRENT_CALLS,   "query_current_calls", ZERO_PARAM,   "query_current_calls"},
+    {QUERY_OPERATOR_NAME,   "query_operator_name", ZERO_PARAM,   "query_operator_name"},
+    {QUERY_SUBSCRIBER_INFO, "query_subscriber_info", ZERO_PARAM, "query_subscriber_info"},
+    {MIC_VOL_CTRL,          "mic_volume_control",   ONE_PARAM,   "mic_volume_control<space><value>"},
+    {SPK_VOL_CTRL,          "speaker_volume_control",   ONE_PARAM,   "speaker_volume_control<space><value>"},
+    {SEND_DTMF,             "send_dtmf",   ONE_PARAM,    "send_dtmf<space><code>"},
+#endif
+    {BACK_TO_MAIN,          "main_menu",     ZERO_PARAM,   "main_menu"},
+};
+
 #ifdef __cplusplus
 extern "C"
 {
@@ -385,6 +559,18 @@ static void HandleMainCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]);
 static void HandleTestCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]);
 
 /**
+ * @brief HandleRspCommand
+ *
+ *  This function will handle all the commands in @ref RspMenu
+ *
+ * @param[in] cmd_id It has command id from @ref CommandList
+ * @param[in] user_cmd It has parsed commands with arguments passed by user
+ * @return none
+ */
+static void HandleRspCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]);
+
+
+/**
  * @brief HandleGapCommand
  *
  *  This function will handle all the commands in @ref GapMenu
@@ -437,9 +623,17 @@ class BluetoothApp {
     bool is_user_input_enabled_;
     bool is_socket_input_enabled_;
     bool is_a2dp_sink_enabled_;
+    bool is_avrcp_enabled_;
+    bool is_a2dp_source_enabled_;
     bool is_hfp_client_enabled_;
+    bool is_hfp_ag_enabled_;
     bool is_pan_enable_default_;
     bool is_gatt_enable_default_;
+#ifdef USE_BT_OBEX
+    bool is_obex_enabled_;
+    bool is_pbap_client_enabled_;
+    bool is_opp_enabled_;
+#endif
     reactor_object_t *cmd_reactor_;
     struct hw_device_t *device_;
     bluetooth_device_t *bt_device_;
@@ -455,6 +649,9 @@ class BluetoothApp {
     int client_socket_;
     bool ssp_notification;
     bool pin_notification;
+#ifdef USE_BT_OBEX
+    bool incoming_file_notification;
+#endif
 
     /**
      * structure object for standard Bluetooth DM interface
@@ -563,6 +760,19 @@ class BluetoothApp {
      */
     bool HandlePinInput(char user_cmd[][COMMAND_ARG_SIZE]);
 
+#ifdef USE_BT_OBEX
+    /**
+     * @brief HandleIncomingFile
+     *
+     * This function will handle the Incoming File acceptance or rejection from user,
+     * it shows a message on console for user input
+     *
+     * @param[in] user_cmd" Can be either "accept" or "reject"
+     * @return bool
+     */
+    bool HandleIncomingFile(char user_cmd[][COMMAND_ARG_SIZE]);
+#endif
+
     /**
      *@brief ProcessEvent
      *
diff --git a/bt-app/main/src/Main.cpp b/bt-app/main/src/Main.cpp
index 64a1e3b..fcd8d10 100644
--- a/bt-app/main/src/Main.cpp
+++ b/bt-app/main/src/Main.cpp
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *  Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *  Copyright (C) 2014 Google, Inc.
  *
@@ -23,7 +23,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <algorithm>
-#include <sys/syslog.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/wait.h>
@@ -35,32 +34,58 @@
 #include <iostream>
 #include <iomanip>
 #include "Main.hpp"
-#include <syslog.h>
 #include "A2dp_Sink.hpp"
 #include "HfpClient.hpp"
-#include "pan/include/Pan.hpp"
-#include "gatt/include/Gatt.hpp"
+#include "Pan.hpp"
+#include "Gatt.hpp"
+#include "HfpAG.hpp"
 #include "Audio_Manager.hpp"
+#include "SdpClient.hpp"
+#include "Rsp.hpp"
+#ifdef USE_BT_OBEX
+#include "PbapClient.hpp"
+#include "Opp.hpp"
+#endif
+#include "osi/include/compat.h"
+#include "A2dp_Src.hpp"
+#include "Avrcp.hpp"
 
 #include "utils.h"
 
 #define LOGTAG  "MAIN "
-#define LOCAL_SOCKET_NAME "/etc/bluetooth/btappsocket"
+#define LOCAL_SOCKET_NAME "/data/misc/bluetooth/btappsocket"
 
 extern Gap *g_gap;
 extern A2dp_Sink *pA2dpSink;
+extern A2dp_Source *pA2dpSource;
 extern Pan *g_pan;
 extern Gatt *g_gatt;
 extern BT_Audio_Manager *pBTAM;
+extern Rsp *rsp;
+
+extern SdpClient *g_sdpClient;
+#ifdef USE_BT_OBEX
+extern PbapClient *g_pbapClient;
+extern Opp *g_opp;
+extern const char *BT_OBEX_ENABLED;
+#endif
 static BluetoothApp *g_bt_app = NULL;
 extern ThreadInfo threadInfo[THREAD_ID_MAX];
 extern Hfp_Client *pHfpClient;
+extern Hfp_Ag *pHfpAG;
+extern Avrcp *pAvrcp;
+#ifdef USE_BT_OBEX
+static alarm_t *opp_incoming_file_accept_timer = NULL;
+#define USER_ACCEPTANCE_TIMEOUT 25000
+#endif
 
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 
+thread_t *test_thread_id = NULL;
+static void SendDisableCmdToGap();
 /**
  * @brief main function
  *
@@ -77,8 +102,9 @@ int main (int argc, char *argv[]) {
     signal(SIGINT, SignalHandler);
 
     ThreadInfo *main_thread = &threadInfo[THREAD_ID_MAIN];
+#ifndef USE_ANDROID_LOGGING
     openlog ("bt-app", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
-
+#endif
     main_thread->thread_id = thread_new (main_thread->thread_name);
     if (main_thread->thread_id) {
         BtEvent *event = new BtEvent;
@@ -90,7 +116,9 @@ int main (int argc, char *argv[]) {
         thread_join (main_thread->thread_id);
         thread_free (main_thread->thread_id);
     }
+#ifndef USE_ANDROID_LOGGING
     closelog ();
+#endif
     return 0;
 }
 
@@ -100,6 +128,7 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
     int index = 0 , found_index = -1, num_cmds;
     char *temp_arg = NULL;
     char delim[] = " ";
+    char *ptr1;
     int param_count = 0;
     bool status = false;
     int max_param = 0;
@@ -127,14 +156,36 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
             menu = &TestMenu[0];
             num_cmds  = NO_OF_COMMANDS(TestMenu);
             break;
+        case RSP_MENU:
+            menu = &RspMenu[0];
+            num_cmds  = NO_OF_COMMANDS(RspMenu);
+            break;
         case A2DP_SINK_MENU:
             menu = &A2dpSinkMenu[0];
             num_cmds  = NO_OF_COMMANDS(A2dpSinkMenu);
             break;
+        case A2DP_SOURCE_MENU:
+            menu = &A2dpSourceMenu[0];
+            num_cmds  = NO_OF_COMMANDS(A2dpSourceMenu);
+            break;
         case HFP_CLIENT_MENU:
             menu = &HfpClientMenu[0];
             num_cmds  = NO_OF_COMMANDS(HfpClientMenu);
             break;
+#ifdef USE_BT_OBEX
+        case PBAP_CLIENT_MENU:
+            menu = &PbapClientMenu[0];
+            num_cmds  = NO_OF_COMMANDS(PbapClientMenu);
+            break;
+        case OPP_MENU:
+            menu = &OppMenu[0];
+            num_cmds  = NO_OF_COMMANDS(OppMenu);
+            break;
+#endif
+        case HFP_AG_MENU:
+            menu = &HfpAGMenu[0];
+            num_cmds  = NO_OF_COMMANDS(HfpAGMenu);
+            break;
         case MAIN_MENU:
         // fallback to default main menu
         default:
@@ -143,13 +194,13 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
             break;
     }
 
-    if ( (temp_arg = strtok(user_input, delim)) != NULL ) {
+    if ( (temp_arg = strtok_r(user_input, delim, &ptr1)) != NULL ) {
         // find out the command name
         for (index = 0; index < num_cmds; index++) {
             if(!strcasecmp (menu[index].cmd_name, temp_arg)) {
                 *cmd_id = menu[index].cmd_id;
                 found_index = index;
-                strncpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE - 1);
+                strlcpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
                 input_args[param_count++][COMMAND_ARG_SIZE - 1] = '\0';
                 break;
             }
@@ -158,9 +209,9 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
         // validate the command parameters
         if (found_index != -1 ) {
             max_param = menu[found_index].max_param;
-            while ((temp_arg = strtok(NULL, delim)) &&
+            while ((temp_arg = strtok_r(NULL, delim, &ptr1)) &&
                     (param_count < max_param + 1)) {
-                strncpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE - 1);
+                strlcpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
                 input_args[param_count++][COMMAND_ARG_SIZE - 1] = '\0';
             }
 
@@ -179,7 +230,7 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
         } else {
             // to handle the paring inputs
             if(temp_arg != NULL) {
-                strncpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE - 1);
+                strlcpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
                 input_args[param_count++][COMMAND_ARG_SIZE - 1] = '\0';
             }
         }
@@ -205,6 +256,10 @@ static void DisplayMenu(MenuType menu_type) {
             menu = &TestMenu[0];
             num_cmds  = NO_OF_COMMANDS(TestMenu);
             break;
+        case RSP_MENU:
+            menu = &RspMenu[0];
+            num_cmds  = NO_OF_COMMANDS(RspMenu);
+            break;
         case MAIN_MENU:
             menu = &MainMenu[0];
             num_cmds  = NO_OF_COMMANDS(MainMenu);
@@ -213,10 +268,28 @@ static void DisplayMenu(MenuType menu_type) {
             menu = &A2dpSinkMenu[0];
             num_cmds  = NO_OF_COMMANDS(A2dpSinkMenu);
             break;
+        case A2DP_SOURCE_MENU:
+            menu = &A2dpSourceMenu[0];
+            num_cmds  = NO_OF_COMMANDS(A2dpSourceMenu);
+            break;
         case HFP_CLIENT_MENU:
             menu = &HfpClientMenu[0];
             num_cmds  = NO_OF_COMMANDS(HfpClientMenu);
             break;
+#ifdef USE_BT_OBEX
+        case PBAP_CLIENT_MENU:
+            menu = &PbapClientMenu[0];
+            num_cmds  = NO_OF_COMMANDS(PbapClientMenu);
+            break;
+        case OPP_MENU:
+            menu = &OppMenu[0];
+            num_cmds  = NO_OF_COMMANDS(OppMenu);
+            break;
+#endif
+        case HFP_AG_MENU:
+            menu = &HfpAGMenu[0];
+            num_cmds  = NO_OF_COMMANDS(HfpAGMenu);
+            break;
     }
     fprintf (stdout, " \n***************** Menu *******************\n");
     for (index = 0; index < num_cmds; index++)
@@ -232,11 +305,11 @@ static void SignalHandler(int sig) {
 static void ExitHandler(void) {
 
     // post the disable message to GAP incase BT is on
-    if (g_bt_app->bt_state == BT_STATE_ON) {
-        BtEvent *event = new BtEvent;
-        event->event_id = GAP_API_DISABLE;
-        PostMessage (THREAD_ID_GAP, event);
-        sleep(1);
+    if ( g_bt_app && g_bt_app->bt_state == BT_STATE_ON) {
+        SendDisableCmdToGap();
+        sleep(3);
+        system("killall -KILL wcnssfilter");
+        usleep(200);
     }
 
     // TODO to wait for complete turn off before proceeding
@@ -255,7 +328,7 @@ static void ExitHandler(void) {
 }
 
 static void HandleA2dpSinkCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
-    ALOGD(LOGTAG, "HandleA2DPSinkCommand cmd_id = %d", cmd_id);
+    ALOGD(LOGTAG "HandleA2DPSinkCommand cmd_id = %d", cmd_id);
     BtEvent *event = NULL;
     switch (cmd_id) {
         case CONNECT:
@@ -274,43 +347,144 @@ static void HandleA2dpSinkCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE])
             event = new BtEvent;
             event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
             event->avrcpCtrlEvent.key_id = CMD_ID_PLAY;
-            PostMessage (THREAD_ID_A2DP_SINK, event);
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
             break;
         case PAUSE:
             event = new BtEvent;
             event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
             event->avrcpCtrlEvent.key_id = CMD_ID_PAUSE;
-            PostMessage (THREAD_ID_A2DP_SINK, event);
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
             break;
         case STOP:
             event = new BtEvent;
             event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
             event->avrcpCtrlEvent.key_id = CMD_ID_STOP;
-            PostMessage (THREAD_ID_A2DP_SINK, event);
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
             break;
         case FASTFORWARD:
             event = new BtEvent;
             event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
             event->avrcpCtrlEvent.key_id = CMD_ID_FF;
-            PostMessage (THREAD_ID_A2DP_SINK, event);
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
             break;
         case REWIND:
             event = new BtEvent;
             event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
             event->avrcpCtrlEvent.key_id = CMD_ID_REWIND;
-            PostMessage (THREAD_ID_A2DP_SINK, event);
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
             break;
         case FORWARD:
             event = new BtEvent;
             event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
             event->avrcpCtrlEvent.key_id = CMD_ID_FORWARD;
-            PostMessage (THREAD_ID_A2DP_SINK, event);
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
             break;
         case BACKWARD:
             event = new BtEvent;
             event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
             event->avrcpCtrlEvent.key_id = CMD_ID_BACKWARD;
-            PostMessage (THREAD_ID_A2DP_SINK, event);
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
+            break;
+        case VOL_UP:
+            event = new BtEvent;
+            event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
+            event->avrcpCtrlEvent.key_id = CMD_ID_VOL_UP;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
+            break;
+        case VOL_DOWN:
+            event = new BtEvent;
+            event->avrcpCtrlEvent.event_id = AVRCP_CTRL_PASS_THRU_CMD_REQ;
+            event->avrcpCtrlEvent.key_id = CMD_ID_VOL_DOWN;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->avrcpCtrlEvent.bd_addr);
+            PostMessage (THREAD_ID_AVRCP, event);
+            break;
+        case VOL_CHANGED_NOTI:
+            event = new BtEvent;
+            event->avrcpCtrlEvent.event_id = AVRCP_CTRL_VOL_CHANGED_NOTI_REQ;
+            event->avrcpCtrlEvent.arg1 = atoi(user_cmd[ONE_PARAM]);
+            PostMessage (THREAD_ID_AVRCP, event);
+            break;
+        case BACK_TO_MAIN:
+            menu_type = MAIN_MENU;
+            DisplayMenu(menu_type);
+            break;
+    }
+}
+
+static void HandleA2dpSourceCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
+    ALOGD(LOGTAG, "HandleA2DPSourceCommand cmd_id = %d", cmd_id);
+    BtEvent *event = NULL;
+    switch (cmd_id) {
+        case CONNECT:
+            event = new BtEvent;
+            event->a2dpSourceEvent.event_id = A2DP_SOURCE_API_CONNECT_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->a2dpSourceEvent.bd_addr);
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case DISCONNECT:
+            event = new BtEvent;
+            event->a2dpSourceEvent.event_id = A2DP_SOURCE_API_DISCONNECT_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->a2dpSourceEvent.bd_addr);
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case PLAY:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = A2DP_SOURCE_AUDIO_CMD_REQ;
+            event->avrcpTargetEvent.key_id = CMD_ID_PLAY;
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case PAUSE:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = A2DP_SOURCE_AUDIO_CMD_REQ;
+            event->avrcpTargetEvent.key_id = CMD_ID_PAUSE;
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case STOP:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = A2DP_SOURCE_AUDIO_CMD_REQ;
+            event->avrcpTargetEvent.key_id = CMD_ID_STOP;
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case TRACK_CHANGE:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = AVRCP_TARGET_TRACK_CHANGED;
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case SET_ABS_VOL:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = AVRCP_TARGET_SET_ABS_VOL;
+            event->avrcpTargetEvent.arg3 = atoi(user_cmd[ONE_PARAM]);
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case SEND_VOL_UP_DOWN:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = AVRCP_TARGET_SEND_VOL_UP_DOWN;
+            event->avrcpTargetEvent.arg3 = atoi(user_cmd[ONE_PARAM]);
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case ADDR_PLAYER_CHANGE:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = AVRCP_TARGET_ADDR_PLAYER_CHANGED;
+            event->avrcpTargetEvent.arg3 = atoi(user_cmd[ONE_PARAM]);
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case AVAIL_PLAYER_CHANGE:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = AVRCP_TARGET_AVAIL_PLAYER_CHANGED;
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
+            break;
+        case BIGGER_METADATA:
+            event = new BtEvent;
+            event->avrcpTargetEvent.event_id = AVRCP_TARGET_USE_BIGGER_METADATA;
+            PostMessage (THREAD_ID_A2DP_SOURCE, event);
             break;
         case BACK_TO_MAIN:
             menu_type = MAIN_MENU;
@@ -417,7 +591,7 @@ static void HandleHfpClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]
         case DIAL:
             event = new BtEvent;
             event->hfp_client_event.event_id = HFP_CLIENT_API_DIAL_REQ;
-            strncpy(event->hfp_client_event.str, user_cmd[ONE_PARAM], 20);
+            strlcpy(event->hfp_client_event.str, user_cmd[ONE_PARAM], 20);
             PostMessage (THREAD_ID_HFP_CLIENT, event);
             break;
         case REDIAL:
@@ -485,7 +659,7 @@ static void HandleHfpClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]
         case SEND_DTMF:
             event = new BtEvent;
             event->hfp_client_event.event_id = HFP_CLIENT_API_SEND_DTMF_REQ;
-            strncpy(event->hfp_client_event.str, user_cmd[ONE_PARAM], 20);
+            strlcpy(event->hfp_client_event.str, user_cmd[ONE_PARAM], 20);
             PostMessage (THREAD_ID_HFP_CLIENT, event);
             break;
         case DISABLE_NREC_ON_AG:
@@ -500,6 +674,105 @@ static void HandleHfpClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]
     }
 }
 
+static void HandleHfpAGCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
+    ALOGD(LOGTAG, "HandleHfpAGCommand cmd_id = %d", cmd_id);
+    fprintf(stdout, "HandleHfpAGCommand cmd_id = %d\n" , cmd_id);
+    BtEvent *event = NULL;
+    switch (cmd_id) {
+        case CONNECT:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_CONNECT_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->hfp_ag_event.bd_addr);
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case DISCONNECT:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_DISCONNECT_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->hfp_ag_event.bd_addr);
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case CREATE_SCO_CONN:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_CONNECT_AUDIO_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->hfp_ag_event.bd_addr);
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case DESTROY_SCO_CONN:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_DISCONNECT_AUDIO_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->hfp_ag_event.bd_addr);
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case ACCEPT_CALL:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_ACCEPT_CALL_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case REJECT_CALL:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_REJECT_CALL_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case END_CALL:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_END_CALL_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case HOLD_CALL:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_HOLD_CALL_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case SWAP_CALLS:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_SWAP_CALLS_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case ADD_HELD_CALL_TO_CONF:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_ADD_HELD_CALL_TO_CONF_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case DIAL:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_DIAL_REQ;
+            strncpy(event->hfp_ag_event.str, user_cmd[ONE_PARAM], 20);
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case START_VR:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_START_VR_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case STOP_VR:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_STOP_VR_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case QUERY_CURRENT_CALLS:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_QUERY_CURRENT_CALLS_REQ;
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case MIC_VOL_CTRL:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_MIC_VOL_CTRL_REQ;
+            event->hfp_ag_event.arg1 = atoi(user_cmd[ONE_PARAM]);
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case SPK_VOL_CTRL:
+            event = new BtEvent;
+            event->hfp_ag_event.event_id = HFP_AG_API_SPK_VOL_CTRL_REQ;
+            event->hfp_ag_event.arg1 = atoi(user_cmd[ONE_PARAM]);
+            PostMessage (THREAD_ID_HFP_AG, event);
+            break;
+        case BACK_TO_MAIN:
+            menu_type = MAIN_MENU;
+            DisplayMenu(menu_type);
+            break;
+    }
+}
+
 static void HandleMainCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
 
     switch (cmd_id) {
@@ -515,16 +788,36 @@ static void HandleMainCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
             menu_type = TEST_MENU;
             DisplayMenu(menu_type);
             break;
+        case RSP_OPTION:
+            menu_type = RSP_MENU;
+            DisplayMenu(menu_type);
+            break;
         case A2DP_SINK:
             menu_type = A2DP_SINK_MENU;
             DisplayMenu(menu_type);
             break;
-
+        case A2DP_SOURCE:
+            menu_type = A2DP_SOURCE_MENU;
+            DisplayMenu(menu_type);
+            break;
         case HFP_CLIENT:
             menu_type = HFP_CLIENT_MENU;
             DisplayMenu(menu_type);
             break;
-
+#ifdef USE_BT_OBEX
+        case PBAP_CLIENT_OPTION:
+            menu_type = PBAP_CLIENT_MENU;
+            DisplayMenu(menu_type);
+            break;
+        case OPP_OPTION:
+            menu_type = OPP_MENU;
+            DisplayMenu(menu_type);
+            break;
+#endif
+        case HFP_AG:
+            menu_type = HFP_AG_MENU;
+            DisplayMenu(menu_type);
+            break;
         case MAIN_EXIT:
             ALOGV (LOGTAG " Self exit of Main thread");
             ExitHandler();
@@ -535,47 +828,102 @@ static void HandleMainCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
     }
 }
 
+
+void HandleOnOffTest (void *context) {
+    char *end;
+    int index = 0;
+    long  num = (long) context;
+    for( index = 0; index < (long)num; index++) {
+
+        BtEvent *event_on = new BtEvent;
+        event_on->event_id = MAIN_API_ENABLE;
+        fprintf( stdout, "Iteration: %d : Posting enable\n", index + 1);
+        PostMessage (THREAD_ID_MAIN, event_on);
+        sleep(5);
+        BtEvent *event_off = new BtEvent;
+        event_off->event_id = MAIN_API_DISABLE;
+        fprintf( stdout, "Iteration: %d : Posting disable\n", index + 1);
+        PostMessage (THREAD_ID_MAIN, event_off);
+        sleep(5);
+    }
+    reactor_stop(thread_get_reactor(test_thread_id));
+    test_thread_id = NULL;
+}
+
 static void HandleTestCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
 
-    long num;
+    long num = 0;
     char *end;
     int index = 0;
     switch (cmd_id) {
         case TEST_ON_OFF:
-            if ( user_cmd[ONE_PARAM][0] != '\0') {
+            if ((user_cmd[ONE_PARAM][0] != '\0')  && (!test_thread_id)) {
                 errno = 0;
                 num = strtol(user_cmd[ONE_PARAM], &end, 0);
                 if (*end != '\0' || errno != 0 || num < INT_MIN || num > INT_MAX){
                     fprintf( stdout, " Enter numeric Value\n");
                     break;
                 }
-                for( index = 0; index < (int)num; index++){
-                    BtEvent *event_on = new BtEvent;
-                    event_on->event_id = GAP_API_ENABLE;
-                    PostMessage (THREAD_ID_GAP, event_on);
-                    sleep(2);
-                    BtEvent *event_off = new BtEvent;
-                    event_off->event_id = GAP_API_DISABLE;
-                    PostMessage (THREAD_ID_GAP, event_off);
-                    sleep(2);
-                }
+
+                test_thread_id = thread_new ("test_thread");
+                if (test_thread_id)
+                    thread_post(test_thread_id, HandleOnOffTest, (void *) num);
+
+            } else if (test_thread_id) {
+                fprintf( stdout, "Test is ongoing, please wait until it finishes\n");
             }
-            fprintf( stdout, "Currently not Handled %ld \n", num);
             break;
 
+        case BACK_TO_MAIN:
+            menu_type = MAIN_MENU;
+            DisplayMenu(menu_type);
+            break;
+        default:
+            ALOGV (LOGTAG " Command not handled");
+            break;
+    }
+}
+
+static void HandleRspCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
+
+    long num;
+    char *end;
+    int index = 0;
+    switch (cmd_id) {
         case RSP_INIT:
             if ((g_bt_app->bt_state == BT_STATE_ON)) {
                 fprintf( stdout, "ENABLE RSP\n");
-                if (g_gatt) g_gatt->rsp->EnableRSP();
-            } else {
+                if (rsp) {
+                   fprintf(stdout,"rsp already initialized \n");
+                   return;
+                } else {
+                  if (g_gatt) {
+                     rsp = new Rsp(g_gatt->GetGattInterface(),g_gatt);
+                     if (rsp) {
+                        rsp->EnableRSP();
+                        fprintf(stdout, " EnableRSP done \n");
+                     }
+                     else {
+                        fprintf(stdout, " RSP Alloc failed return failure \n");
+                     }
+                  } else {
+                     fprintf(stdout," gatt interface us null \n");
+                  }
+                }
+             }
+             else {
                 fprintf( stdout, "BT is in OFF State now \n");
-            }
+             }
             break;
 
         case RSP_START:
             if ((g_bt_app->bt_state == BT_STATE_ON)) {
-                fprintf( stdout, "(Re)start Advertisement \n");
-                if (g_gatt) g_gatt->rsp->StartAdvertisement();
+                if (rsp) {
+                    fprintf( stdout, "(Re)start Advertisement \n");
+                    rsp->StartAdvertisement();
+                } else {
+                    fprintf(stdout , "Do Init first\n");
+                }
             } else {
                 fprintf( stdout, "BT is in OFF State now \n");
             }
@@ -585,12 +933,60 @@ static void HandleTestCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
             menu_type = MAIN_MENU;
             DisplayMenu(menu_type);
             break;
+
         default:
-            ALOGV (LOGTAG " Command not handled");
+            fprintf(stdout, " Command not handled\n");
             break;
     }
 }
 
+static void SendEnableCmdToGap() {
+
+    if ((g_bt_app->status.enable_cmd != COMMAND_INPROGRESS) &&
+        (g_bt_app->status.disable_cmd != COMMAND_INPROGRESS) &&
+        (g_bt_app->bt_state == BT_STATE_OFF)) {
+
+        g_bt_app->status.enable_cmd = COMMAND_INPROGRESS;
+        // Killing previous iteration filter if they still exists
+        system("killall -KILL wcnssfilter");
+        system("killall -KILL btsnoop");
+        system("killall -KILL qcbtdaemon");
+        usleep(200);
+
+        BtEvent *event = new BtEvent;
+        event->event_id = GAP_API_ENABLE;
+        ALOGV (LOGTAG " Posting BT enable to GAP thread");
+        PostMessage (THREAD_ID_GAP, event);
+    } else if ( g_bt_app->status.enable_cmd == COMMAND_INPROGRESS ) {
+        fprintf( stdout, "BT enable is already in process\n");
+    } else if ( g_bt_app->status.disable_cmd == COMMAND_INPROGRESS ) {
+        fprintf( stdout, "Previous BT disable is still in progress\n");
+    } else {
+        fprintf( stdout, "Currently BT is already ON\n");
+    }
+}
+
+static void SendDisableCmdToGap() {
+
+    if ((g_bt_app->status.disable_cmd != COMMAND_INPROGRESS) &&
+        (g_bt_app->status.enable_cmd != COMMAND_INPROGRESS) &&
+        (g_bt_app->bt_state == BT_STATE_ON)) {
+
+        g_bt_app->status.disable_cmd = COMMAND_INPROGRESS;
+
+        BtEvent *event = new BtEvent;
+        event->event_id = GAP_API_DISABLE;
+        ALOGV (LOGTAG " Posting disable to GAP thread");
+        PostMessage (THREAD_ID_GAP, event);
+    } else if (g_bt_app->status.disable_cmd == COMMAND_INPROGRESS) {
+        fprintf( stdout, " disable command is already in process\n");
+    } else if (g_bt_app->status.enable_cmd == COMMAND_INPROGRESS) {
+        fprintf( stdout, " Previous enable command is still in process\n");
+    } else {
+        fprintf( stdout, "Currently BT is already OFF\n");
+    }
+}
+
 static void HandleGapCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
     BtEvent *event = NULL;
 
@@ -601,37 +997,11 @@ static void HandleGapCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
             break;
 
         case BT_ENABLE:
-            if ((g_bt_app->status.enable_cmd != COMMAND_INPROGRESS) &&
-                (g_bt_app->bt_state == BT_STATE_OFF)) {
-
-                g_bt_app->status.enable_cmd = COMMAND_INPROGRESS;
-                BtEvent *event = new BtEvent;
-
-                event->event_id = GAP_API_ENABLE;
-                ALOGV (LOGTAG " Posting BT enable to GAP thread");
-                PostMessage (THREAD_ID_GAP, event);
-            } else if ( g_bt_app->status.enable_cmd == COMMAND_INPROGRESS ) {
-                fprintf( stdout, "BT enable is already in process\n");
-            } else {
-                fprintf( stdout, "Currently BT is already ON\n");
-            }
+            SendEnableCmdToGap();
             break;
 
         case BT_DISABLE:
-
-            if ((g_bt_app->status.disable_cmd != COMMAND_INPROGRESS) &&
-                                (g_bt_app->bt_state == BT_STATE_ON)) {
-
-                g_bt_app->status.disable_cmd = COMMAND_INPROGRESS;
-                event = new BtEvent;
-                event->event_id = GAP_API_DISABLE;
-                ALOGV (LOGTAG " Posting disable to GAP thread");
-                PostMessage (THREAD_ID_GAP, event);
-            } else if (g_bt_app->status.disable_cmd == COMMAND_INPROGRESS) {
-                fprintf( stdout, " disable command is already in process\n");
-            } else {
-                fprintf( stdout, "Currently BT is already OFF\n");
-            }
+            SendDisableCmdToGap();
             break;
 
         case START_ENQUIRY:
@@ -639,6 +1009,7 @@ static void HandleGapCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
             if ((g_bt_app->status.enquiry_cmd != COMMAND_INPROGRESS) &&
                                 (g_bt_app->bt_state == BT_STATE_ON)) {
 
+                g_bt_app->inquiry_list.clear();
                 g_bt_app->status.enquiry_cmd = COMMAND_INPROGRESS;
                 event = new BtEvent;
                 event->event_id = GAP_API_START_INQUIRY;
@@ -744,8 +1115,7 @@ static void HandleGapCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
                 bdstr_t bd_str;
                 bt_bdaddr_t *bd_addr = g_gap->GetBtAddress();
                 bdaddr_to_string(bd_addr, &bd_str[0], sizeof(bd_str));
-                std::string deviceAddress(bd_str);
-                std::cout << " BT Address :" << deviceAddress << std::endl;
+                fprintf(stdout, " BT Address : %s\n", bd_str);
             } else {
                 fprintf( stdout, "No Addr due to BT is OFF\n");
             }
@@ -784,6 +1154,22 @@ static void HandlePanCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
     int index = 0;
 
     switch (cmd_id) {
+        case CONNECT:
+            if ((g_bt_app->bt_state == BT_STATE_ON)) {
+                if (string_is_bdaddr(user_cmd[ONE_PARAM])) {
+                    BtEvent *event = new BtEvent;
+                    event->event_id = PAN_EVENT_DEVICE_CONNECT_REQ;
+                    string_to_bdaddr(user_cmd[ONE_PARAM],
+                            &event->pan_device_connect_event.bd_addr);
+                    PostMessage (THREAD_ID_PAN, event);
+                } else {
+                    fprintf(stdout, " BD address is NULL/Invalid \n");
+                }
+            } else {
+                fprintf(stdout, " Currently BT is in OFF state\n");
+            }
+            break;
+
         case DISCONNECT:
             if ((g_bt_app->bt_state == BT_STATE_ON)) {
                 if (string_is_bdaddr(user_cmd[ONE_PARAM])) {
@@ -793,10 +1179,10 @@ static void HandlePanCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
                             &event->pan_device_disconnect_event.bd_addr);
                     PostMessage (THREAD_ID_PAN, event);
                 } else {
-                    fprintf(stdout, " BD address is NULL/Invalid ");
+                    fprintf(stdout, " BD address is NULL/Invalid\n");
                 }
             } else {
-                fprintf(stdout, " Currently BT is in OFF state");
+                fprintf(stdout, " Currently BT is in OFF state\n");
             }
             break;
 
@@ -806,7 +1192,7 @@ static void HandlePanCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
                 event->event_id = PAN_EVENT_DEVICE_CONNECTED_LIST_REQ;
                 PostMessage (THREAD_ID_PAN, event);
             } else {
-                fprintf(stdout," Currently BT is in OFF state");
+                fprintf(stdout," Currently BT is in OFF state\n");
             }
             break;
 
@@ -829,7 +1215,17 @@ static void HandlePanCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
                 event->pan_set_tethering_event.is_tethering_on = is_tethering_enable;
                 PostMessage (THREAD_ID_PAN, event);
             } else {
-                fprintf(stdout, " Currently BT is in OFF state");
+                fprintf(stdout, " Currently BT is in OFF state\n");
+            }
+            break;
+
+        case GET_PAN_MODE:
+            if ((g_bt_app->bt_state == BT_STATE_ON)) {
+                BtEvent *event = new BtEvent;
+                event->event_id = PAN_EVENT_GET_MODE_REQ;
+                PostMessage (THREAD_ID_PAN, event);
+            } else {
+                fprintf(stdout, " Currently BT is in OFF state\n");
             }
             break;
 
@@ -839,11 +1235,258 @@ static void HandlePanCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
             break;
 
         default:
+            ALOGV (LOGTAG " Command not handled: %d", cmd_id);
+            break;
+    }
+}
+
+#ifdef USE_BT_OBEX
+static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
+
+    long num;
+    char *end;
+    int index = 0;
+    BtEvent *event = NULL;
+
+    if (g_bt_app && g_bt_app->bt_state != BT_STATE_ON) {
+        ALOGE(LOGTAG "BT not switched on, can't handle PBAP Client commands");
+        return;
+    }
+
+    switch (cmd_id) {
+
+        case PBAP_REGISTER:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_REGISTER;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case CONNECT:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_CONNECT;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->pbap_client_event.bd_addr);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case DISCONNECT:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_DISCONNECT;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->pbap_client_event.bd_addr);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_ABORT:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_ABORT;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_PHONEBOOK_SIZE:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_PHONEBOOK_SIZE;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_PHONEBOOK:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_PHONEBOOK;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_VCARD:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_VCARD;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_VCARD_LISTING:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_VCARD_LISTING;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_PATH:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_PATH;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_FILTER:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_FILTER;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_FILTER:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_FILTER;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_ORDER:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_ORDER;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_ORDER:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_ORDER;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_SEARCH_ATTRIBUTE:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_SEARCH_ATTRIBUTE;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_SEARCH_ATTRIBUTE:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_SEARCH_ATTRIBUTE;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_SEARCH_VALUE:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_SEARCH_VALUE;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_PHONE_BOOK:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_PHONE_BOOK;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_PHONE_BOOK:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_PHONE_BOOK;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_REPOSITORY:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_REPOSITORY;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_REPOSITORY:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_REPOSITORY;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_VCARD_FORMAT:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_VCARD_FORMAT;
+            memset( (void *) event->pbap_client_event.value, '\0',
+                sizeof(event->pbap_client_event.value));
+            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+                COMMAND_SIZE);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_VCARD_FORMAT:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_VCARD_FORMAT;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_LIST_COUNT:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_LIST_COUNT;
+            event->pbap_client_event.max_list_count = atoi(user_cmd[ONE_PARAM]);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_LIST_COUNT:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_LIST_COUNT;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_SET_START_OFFSET:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_SET_START_OFFSET;
+            event->pbap_client_event.list_start_offset = atoi(user_cmd[ONE_PARAM]);
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case PBAP_GET_START_OFFSET:
+            event = new BtEvent;
+            event->pbap_client_event.event_id = PBAP_CLIENT_GET_START_OFFSET;
+            PostMessage (THREAD_ID_PBAP_CLIENT, event);
+            break;
+        case BACK_TO_MAIN:
+            menu_type = MAIN_MENU;
+            DisplayMenu(menu_type);
+            break;
+
+        default:
         ALOGV (LOGTAG " Command not handled: %d", cmd_id);
         break;
     }
 }
 
+static void HandleOppCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
+
+    long num;
+    char *end;
+    int index = 0;
+    BtEvent *event = NULL;
+
+    if (g_bt_app && g_bt_app->bt_state != BT_STATE_ON) {
+        ALOGE(LOGTAG "BT not switched on, can't handle OPP commands");
+        return;
+    }
+
+    switch (cmd_id) {
+
+        case OPP_REGISTER:
+            event = new BtEvent;
+            event->opp_event.event_id = OPP_SRV_REGISTER;
+            PostMessage (THREAD_ID_OPP, event);
+            break;
+        case OPP_SEND:
+            event = new BtEvent;
+            event->opp_event.event_id = OPP_SEND_DATA;
+            if(string_to_bdaddr(user_cmd[ONE_PARAM],
+                &event->opp_event.bd_addr)) {
+                memset( (void *) event->opp_event.value, 0,
+                    sizeof(event->opp_event.value));
+                strlcpy(event->opp_event.value, user_cmd[TWO_PARAM],
+                    COMMAND_SIZE);
+                PostMessage (THREAD_ID_OPP, event);
+            } else {
+                ALOGV (LOGTAG " Please enter valid BD Address %s",
+                    user_cmd[ONE_PARAM]);
+            }
+            break;
+        case OPP_ABORT:
+            event = new BtEvent;
+            event->opp_event.event_id = OPP_ABORT_TRANSFER;
+            PostMessage (THREAD_ID_OPP, event);
+            break;
+        case BACK_TO_MAIN:
+            menu_type = MAIN_MENU;
+            DisplayMenu(menu_type);
+            break;
+
+        default:
+        ALOGV (LOGTAG " Command not handled: %d", cmd_id);
+        break;
+    }
+}
+#endif
+
 void BtSocketDataHandler (void *context) {
     char ipc_msg[BT_IPC_MSG_LEN]  = {0};
     int len;
@@ -853,6 +1496,8 @@ void BtSocketDataHandler (void *context) {
         if (len <= 0) {
             ALOGE("Not able to receive msg to remote dev: %s", strerror(errno));
             reactor_unregister (g_bt_app->accept_reactor_);
+            g_bt_app->accept_reactor_ = NULL;
+            close(g_bt_app->client_socket_);
             g_bt_app->client_socket_ = -1;
         } else if(len == BT_IPC_MSG_LEN) {
             BtEvent *event = new BtEvent;
@@ -864,6 +1509,8 @@ void BtSocketDataHandler (void *context) {
                 /*fall through for PAN IPC message*/
                 case BT_IPC_ENABLE_TETHERING:
                 case BT_IPC_DISABLE_TETHERING:
+                case BT_IPC_ENABLE_REVERSE_TETHERING:
+                case BT_IPC_DISABLE_REVERSE_TETHERING:
                     ALOGV (LOGTAG "  Posting IPC_MSG to PAN thread");
                     PostMessage (THREAD_ID_PAN, event);
                     break;
@@ -921,25 +1568,58 @@ static void BtCmdHandler (void *context) {
             case TEST_MENU:
                 HandleTestCommand(cmd_id, user_cmd);
                 break;
+            case RSP_MENU:
+                HandleRspCommand(cmd_id, user_cmd);
+                break;
             case MAIN_MENU:
                 HandleMainCommand(cmd_id,user_cmd );
                 break;
             case A2DP_SINK_MENU:
                 HandleA2dpSinkCommand(cmd_id,user_cmd );
                 break;
+            case A2DP_SOURCE_MENU:
+                HandleA2dpSourceCommand(cmd_id, user_cmd );
+                break;
             case HFP_CLIENT_MENU:
                 HandleHfpClientCommand(cmd_id,user_cmd );
                 break;
+#ifdef USE_BT_OBEX
+            case PBAP_CLIENT_MENU:
+                HandlePbapClientCommand(cmd_id,user_cmd );
+                break;
+            case OPP_MENU:
+                HandleOppCommand(cmd_id,user_cmd );
+                break;
+#endif
+            case HFP_AG_MENU:
+                HandleHfpAGCommand(cmd_id, user_cmd );
+                break;
         }
     } else if (g_bt_app->ssp_notification && user_cmd[0][0] &&
-                        g_bt_app->HandleSspInput(user_cmd)) {
+                        (!strcasecmp (user_cmd[ZERO_PARAM], "yes") ||
+                        !strcasecmp (user_cmd[ZERO_PARAM], "no"))
+                        && g_bt_app->HandleSspInput(user_cmd)) {
         // validate the user input for SSP
         g_bt_app->ssp_notification = false;
     } else if (g_bt_app->pin_notification && user_cmd[0][0] &&
-                        g_bt_app->HandlePinInput(user_cmd)) {
+                        (strcasecmp (user_cmd[ZERO_PARAM], "yes") &&
+                        strcasecmp (user_cmd[ZERO_PARAM], "no") &&
+                        strcasecmp (user_cmd[ZERO_PARAM], "accept") &&
+                        strcasecmp (user_cmd[ZERO_PARAM], "reject"))
+                        && g_bt_app->HandlePinInput(user_cmd)) {
         // validate the user input for PIN
         g_bt_app->pin_notification = false;
-    } else {
+    }
+#ifdef USE_BT_OBEX
+    else if (g_bt_app->incoming_file_notification && user_cmd[0][0] &&
+                        (!strcasecmp (user_cmd[ZERO_PARAM], "accept") ||
+                        !strcasecmp (user_cmd[ZERO_PARAM], "reject"))
+                        && g_bt_app->HandleIncomingFile(user_cmd)) {
+        // validate the user input for OPP Incoming File
+        g_bt_app->incoming_file_notification = false;
+    }
+#endif
+    else {
         fprintf( stdout, " Wrong option selected\n");
         DisplayMenu(menu_type);
         // TODO print the given input string
@@ -964,6 +1644,7 @@ void BtMainMsgHandler (void *context) {
                 if((len = send(g_bt_app->client_socket_, &(event->bt_ipc_msg_event.ipc_msg),
                     BT_IPC_MSG_LEN, 0)) < 0) {
                     reactor_unregister (g_bt_app->accept_reactor_);
+                    close(g_bt_app->client_socket_);
                     g_bt_app->client_socket_ = -1;
                     ALOGE (LOGTAG "Local socket send fail %s", strerror(errno));
                 }
@@ -996,8 +1677,8 @@ bool BluetoothApp :: HandlePinInput(char user_cmd[][COMMAND_ARG_SIZE]) {
             fprintf(stdout, " Minimum 16 digit pin required\n");
             return false;
         }
-    } else if(strlen(user_cmd[ZERO_PARAM]) >16 ) {
-           return false;
+    } else if(strlen(user_cmd[ZERO_PARAM]) > 16 ) {
+        return false;
     }
 
     memset(&pin_reply.pincode, 0, sizeof(bt_pin_code_t));
@@ -1043,6 +1724,37 @@ bool BluetoothApp :: HandleSspInput(char user_cmd[][COMMAND_ARG_SIZE]) {
     return true;
 }
 
+#ifdef USE_BT_OBEX
+bool BluetoothApp :: HandleIncomingFile(char user_cmd[][COMMAND_ARG_SIZE]) {
+    BtEvent *bt_event = new BtEvent;
+    if (!strcasecmp (user_cmd[ZERO_PARAM], "accept")) {
+        bt_event->opp_event.accept = true;
+    } else if (!strcasecmp (user_cmd[ZERO_PARAM], "reject")) {
+        bt_event->opp_event.accept = false;
+    } else {
+        fprintf( stdout, "Wrong option entered\n");
+        return false;
+    }
+    /* Cancel the timer */
+    alarm_cancel(opp_incoming_file_accept_timer);
+    bt_event->event_id = OPP_INCOMING_FILE_RESPONSE;
+    PostMessage (THREAD_ID_OPP, bt_event);
+    return true;
+}
+
+void user_acceptance_timer_expired(void *context) {
+    BtEvent *bt_event = new BtEvent;
+    ALOGD(LOGTAG " user_acceptance_timer_expired, rejecting incoming file");
+    fprintf(stdout,"No user input for %d seconds, rejecting the file\n",
+        USER_ACCEPTANCE_TIMEOUT/1000);
+
+    bt_event->opp_event.accept = false;
+    g_bt_app->incoming_file_notification = false;
+    bt_event->event_id = OPP_INCOMING_FILE_RESPONSE;
+    PostMessage (THREAD_ID_OPP, bt_event);
+}
+#endif
+
 void BluetoothApp :: ProcessEvent (BtEvent * event) {
 
     ALOGD (LOGTAG " Processing event %d", event->event_id);
@@ -1057,6 +1769,14 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
             DeInitHandler();
             break;
 
+        case MAIN_API_ENABLE:
+            SendEnableCmdToGap();
+            break;
+
+        case MAIN_API_DISABLE:
+            SendDisableCmdToGap();
+            break;
+
         case MAIN_EVENT_ENABLED:
             bt_state = event->state_event.status;
             if (event->state_event.status == BT_STATE_OFF) {
@@ -1079,7 +1799,9 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
                 // clearing bond_devices list and inquiry_list
                 bonded_devices.clear();
                 inquiry_list.clear();
-               fprintf(stdout, " BT State is OFF\n");
+                system("killall -KILL wcnssfilter");
+                usleep(200);
+                fprintf(stdout, " BT State is OFF\n");
             }
             status.disable_cmd = COMMAND_COMPLETE;
             break;
@@ -1113,6 +1835,17 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
             break;
 
         case MAIN_EVENT_DEVICE_FOUND:
+           {
+           bdstr_t bd_str;
+            std::map<std::string, std::string>::iterator it;
+            bdaddr_to_string(&event->device_found_event.remoteDevice.address, &bd_str[0], sizeof(bd_str));
+            std::string deviceAddress(bd_str);
+
+            it = bonded_devices.find(deviceAddress);
+            if (it != bonded_devices.end())
+            {
+                break;
+            }
             fprintf(stdout, "Device Found details: \n");
             AddFoundedDevice(event->device_found_event.remoteDevice.name,
                                     event->device_found_event.remoteDevice.address);
@@ -1124,7 +1857,7 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
             fprintf(stdout, "Device class is: %d\n", event->device_found_event.
                                         remoteDevice.bluetooth_class);
             break;
-
+        }
         case MAIN_EVENT_BOND_STATE: {
             std::string bd_name((const char*)event->bond_state_event.bd_name.name);
             HandleBondState(event->bond_state_event.state,
@@ -1165,6 +1898,25 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
             pin_notification = true;
             break;
 
+#ifdef USE_BT_OBEX
+        case MAIN_EVENT_INCOMING_FILE_REQUEST:
+
+            fprintf(stdout, "\n*************************************************");
+            fprintf(stdout, "\n Incoming File Request");
+            fprintf(stdout, "\n*************************************************\n");
+            fprintf(stdout, " ** Please enter \"accept\" / \"reject\" **\n");
+            // instruct the cmd handler to treat the next inputs for OPP
+            incoming_file_notification = true;
+            if (opp_incoming_file_accept_timer) {
+                 // start the user acceptance/rejection rimer
+                alarm_set(opp_incoming_file_accept_timer, USER_ACCEPTANCE_TIMEOUT,
+                                    user_acceptance_timer_expired, NULL);
+            } else {
+                fprintf(stdout, "\n Already pending user acceptance request\n");
+            }
+            break;
+#endif
+
         default:
             ALOGD (LOGTAG " Default Case");
             break;
@@ -1174,15 +1926,21 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
 void BluetoothApp:: HandleBondState(bt_bond_state_t new_state, const bt_bdaddr_t
                                         bd_addr, std::string bd_name ) {
     std::map<std::string, std::string>::iterator it;
+    std::map<std::string, std::string>::iterator it_inquiry;
     bdstr_t bd_str;
     bdaddr_to_string(&bd_addr, &bd_str[0], sizeof(bd_str));
     std::string deviceAddress(bd_str);
     it = bonded_devices.find(deviceAddress);
-
+    it_inquiry= inquiry_list.find(deviceAddress);
     if(new_state == BT_BOND_STATE_BONDED) {
         if (it == bonded_devices.end()) {
             bonded_devices[deviceAddress] = bd_name;
         }
+       if(it_inquiry!=inquiry_list.end())
+        {
+            inquiry_list.erase(it_inquiry);
+        }
+
         fprintf(stdout, "\n*************************************************");
         fprintf(stdout, "\n Pairing state for %s is BONDED", bd_name.c_str());
         fprintf(stdout, "\n*************************************************\n");
@@ -1235,29 +1993,26 @@ bt_state_t BluetoothApp:: GetState() {
 
 void BluetoothApp:: PrintInquiryList() {
 
-    std::cout << "\n**************************** Inquiry List \
-*********************************\n";
+    fprintf(stdout, "\n**************************** Inquiry List \
+*********************************\n");
     std::map<std::string, std::string>::iterator it;
-    for (it = inquiry_list.begin(); it != inquiry_list.end(); ++it) {
-        std::cout << std::left << std::setw(50) << it->second << std::left <<
-        std::setw(50) << it->first << std::endl;
-    }
-    std::cout << "**************************** End of List \
-*********************************\n";
+    for (it = inquiry_list.begin(); it != inquiry_list.end(); ++it)
+        fprintf(stdout, "%-*s %s\n", 50, it->second.data(), it->first.data());
+    fprintf(stdout, "**************************** End of List \
+*********************************\n");
 }
 
 
 void BluetoothApp:: PrintBondedDeviceList() {
 
-    std::cout <<"\n**************************** Bonded Device List \
-**************************** \n";
+    fprintf(stdout, "\n**************************** Bonded Device List \
+**************************** \n");
     std::map<std::string, std::string>::iterator it;
-    for (it = bonded_devices.begin(); it != bonded_devices.end(); ++it) {
-            std::cout << std::left << std::setw(50) << it->second
-             << std::left << std::setw(50) << it->first << std::endl;
-    }
-    std::cout<< "****************************  End of List \
-*********************************\n";
+    for (it = bonded_devices.begin(); it != bonded_devices.end(); ++it)
+        fprintf(stdout, "%-*s %s\n", 50, it->second.data(), it->first.data());
+
+    fprintf(stdout, "****************************  End of List \
+*********************************\n");
 }
 
 bool BluetoothApp :: LoadBtStack (void) {
@@ -1328,6 +2083,25 @@ void BluetoothApp :: InitHandler (void) {
         }
     }
 
+    if(is_avrcp_enabled_) {
+        threadInfo[THREAD_ID_AVRCP].thread_id = thread_new (
+                threadInfo[THREAD_ID_AVRCP].thread_name);
+
+        if (threadInfo[THREAD_ID_AVRCP].thread_id) {
+            pAvrcp = new Avrcp (bt_interface, config);
+        }
+
+    }
+
+    if(is_a2dp_source_enabled_) {
+        threadInfo[THREAD_ID_A2DP_SOURCE].thread_id = thread_new (
+                threadInfo[THREAD_ID_A2DP_SOURCE].thread_name);
+
+        if (threadInfo[THREAD_ID_A2DP_SOURCE].thread_id) {
+            pA2dpSource = new A2dp_Source (bt_interface, config);
+        }
+    }
+
     if(is_hfp_client_enabled_) {
         threadInfo[THREAD_ID_HFP_CLIENT].thread_id = thread_new (
                 threadInfo[THREAD_ID_HFP_CLIENT].thread_name);
@@ -1337,6 +2111,15 @@ void BluetoothApp :: InitHandler (void) {
         }
     }
 
+    if(is_hfp_ag_enabled_) {
+        threadInfo[THREAD_ID_HFP_AG].thread_id = thread_new (
+                threadInfo[THREAD_ID_HFP_AG].thread_name);
+
+        if (threadInfo[THREAD_ID_HFP_AG].thread_id) {
+            pHfpAG = new Hfp_Ag(bt_interface, config);
+        }
+    }
+
     // registers reactors for socket
     if (is_socket_input_enabled_) {
         if(LocalSocketCreate() != -1) {
@@ -1356,6 +2139,12 @@ void BluetoothApp :: InitHandler (void) {
 
     }
 
+    threadInfo[THREAD_ID_SDP_CLIENT].thread_id = thread_new (
+        threadInfo[THREAD_ID_SDP_CLIENT].thread_name);
+
+    if (threadInfo[THREAD_ID_SDP_CLIENT].thread_id)
+        g_sdpClient = new SdpClient(bt_interface, config);
+
     if (is_pan_enable_default_) {
         // Starting PAN Thread
         threadInfo[THREAD_ID_PAN].thread_id = thread_new (
@@ -1374,6 +2163,28 @@ void BluetoothApp :: InitHandler (void) {
             g_gatt = new Gatt(bt_interface, config);
     }
 
+#ifdef USE_BT_OBEX
+    if (is_obex_enabled_ && is_pbap_client_enabled_) {
+        threadInfo[THREAD_ID_PBAP_CLIENT].thread_id = thread_new (
+            threadInfo[THREAD_ID_PBAP_CLIENT].thread_name);
+
+        if (threadInfo[THREAD_ID_PBAP_CLIENT].thread_id)
+            g_pbapClient = new PbapClient(bt_interface, config);
+    }
+    if (is_obex_enabled_ && is_opp_enabled_) {
+        threadInfo[THREAD_ID_OPP].thread_id = thread_new (
+            threadInfo[THREAD_ID_OPP].thread_name);
+
+        if (threadInfo[THREAD_ID_OPP].thread_id)
+            g_opp = new Opp(bt_interface, config);
+    }
+    opp_incoming_file_accept_timer = NULL;
+    if( !(opp_incoming_file_accept_timer = alarm_new())) {
+        ALOGE(LOGTAG " unable to create opp_connect_timer");
+        opp_incoming_file_accept_timer = NULL;
+    }
+#endif
+
     // Enable Command line input
     if (is_user_input_enabled_) {
         cmd_reactor_ = reactor_register (thread_get_reactor
@@ -1386,12 +2197,19 @@ void BluetoothApp :: InitHandler (void) {
 void BluetoothApp :: DeInitHandler (void) {
     UnLoadBtStack ();
 
+    ALOGV (LOGTAG "  %s:",__func__);
      // de-register reactors for socket
     if (is_socket_input_enabled_) {
         if(listen_reactor_)
+        {
             reactor_unregister ( listen_reactor_);
+            listen_reactor_ = NULL;
+        }
         if(accept_reactor_)
+        {
             reactor_unregister ( accept_reactor_);
+            accept_reactor_ = NULL;
+        }
     }
 
     if ((is_hfp_client_enabled_) || (is_a2dp_sink_enabled_)) {
@@ -1411,6 +2229,24 @@ void BluetoothApp :: DeInitHandler (void) {
         }
     }
 
+    if(is_avrcp_enabled_) {
+        //STOP Avrcp thread
+        if (threadInfo[THREAD_ID_AVRCP].thread_id != NULL) {
+            thread_free (threadInfo[THREAD_ID_AVRCP].thread_id);
+            if ( pAvrcp != NULL)
+                delete pAvrcp;
+        }
+    }
+
+    if(is_a2dp_source_enabled_) {
+        //STOP A2dp Source thread
+        if (threadInfo[THREAD_ID_A2DP_SOURCE].thread_id != NULL) {
+            thread_free (threadInfo[THREAD_ID_A2DP_SOURCE].thread_id);
+            if ( pA2dpSource!= NULL)
+                delete pA2dpSource;
+        }
+    }
+
     if(is_hfp_client_enabled_) {
         //STOP HFP client thread
         if (threadInfo[THREAD_ID_HFP_CLIENT].thread_id != NULL) {
@@ -1420,6 +2256,14 @@ void BluetoothApp :: DeInitHandler (void) {
         }
     }
 
+    if(is_hfp_ag_enabled_) {
+        //STOP HFP AG thread
+        if (threadInfo[THREAD_ID_HFP_AG].thread_id != NULL) {
+            thread_free (threadInfo[THREAD_ID_HFP_AG].thread_id);
+            if ( pHfpAG != NULL)
+                delete pHfpAG;
+        }
+    }
 
     // Stop GAP Thread
     if (threadInfo[THREAD_ID_GAP].thread_id != NULL) {
@@ -1428,6 +2272,13 @@ void BluetoothApp :: DeInitHandler (void) {
             delete g_gap;
     }
 
+    // Stop SDP Client Thread
+    if (threadInfo[THREAD_ID_SDP_CLIENT].thread_id != NULL) {
+        thread_free (threadInfo[THREAD_ID_SDP_CLIENT].thread_id);
+        if ( g_sdpClient != NULL)
+            delete g_sdpClient;
+    }
+
     if (is_pan_enable_default_) {
         // Stop PAN Thread
         if (threadInfo[THREAD_ID_PAN].thread_id != NULL) {
@@ -1436,6 +2287,7 @@ void BluetoothApp :: DeInitHandler (void) {
                 delete g_pan;
         }
     }
+
     if (is_gatt_enable_default_) {
         if (threadInfo[THREAD_ID_GATT].thread_id != NULL){
             thread_free(threadInfo[THREAD_ID_GATT].thread_id);
@@ -1444,6 +2296,29 @@ void BluetoothApp :: DeInitHandler (void) {
         }
     }
 
+#ifdef USE_BT_OBEX
+    if (opp_incoming_file_accept_timer) {
+        alarm_free(opp_incoming_file_accept_timer);
+        opp_incoming_file_accept_timer = NULL;
+    }
+    if (is_obex_enabled_ && is_pbap_client_enabled_) {
+        // Stop PBAP Client Thread
+        if (threadInfo[THREAD_ID_PBAP_CLIENT].thread_id != NULL) {
+            thread_free (threadInfo[THREAD_ID_PBAP_CLIENT].thread_id);
+            if (g_pbapClient!= NULL)
+                delete g_pbapClient;
+        }
+    }
+    if (is_obex_enabled_ && is_opp_enabled_) {
+        // Stop Opp Thread
+        if (threadInfo[THREAD_ID_OPP].thread_id != NULL) {
+            thread_free (threadInfo[THREAD_ID_OPP].thread_id);
+            if (g_opp!= NULL)
+                delete g_opp;
+        }
+    }
+#endif
+
     // Stop Command Handler
     if (is_user_input_enabled_) {
         reactor_unregister (cmd_reactor_);
@@ -1473,10 +2348,9 @@ BluetoothApp :: BluetoothApp () {
         ALOGE (LOGTAG " Error in Loading config file");
 }
 
-
 BluetoothApp :: ~BluetoothApp () {
     if (config)
-        config_free(config);
+        config_remove(config);
 
     bonded_devices.clear();
     inquiry_list.clear();
@@ -1494,7 +2368,7 @@ int BluetoothApp:: LocalSocketCreate(void) {
 
   memset(&addr, 0, sizeof(addr));
   addr.sun_family = AF_LOCAL;
-  strncpy(addr.sun_path, LOCAL_SOCKET_NAME, sizeof(addr.sun_path)-1);
+  strlcpy(addr.sun_path, LOCAL_SOCKET_NAME, sizeof(addr.sun_path));
   unlink(LOCAL_SOCKET_NAME);
   if (bind(listen_socket_local_, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
     ALOGE (LOGTAG "Failed to create Local Socket (%s)", strerror(errno));
@@ -1531,9 +2405,30 @@ bool BluetoothApp::LoadConfigParameters (const char *configpath) {
     //checking for a2dp sink
     is_a2dp_sink_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
                                     BT_A2DP_SINK_ENABLED, false);
+    //checking for avrcp
+    is_avrcp_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
+                                    BT_AVRCP_ENABLED, false);
+
+    //checking for a2dp source
+    is_a2dp_source_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
+                                    BT_A2DP_SOURCE_ENABLED, false);
+
     //checking for hfp client
     is_hfp_client_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
                                     BT_HFP_CLIENT_ENABLED, false);
+    //checking for hfp ag
+    is_hfp_ag_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
+                                    BT_HFP_AG_ENABLED, false);
+
+    if (is_hfp_client_enabled_ == true && is_hfp_ag_enabled_ == true) {
+        ALOGE (LOGTAG " Both HFP AG and Client are enabled, disabling AG. Set \
+           BtHfpAGEnable to true, BtHfClientEnable to false in bt_app.conf to \
+           enable only AG");
+        fprintf(stdout, " Both HFP AG and Client are enabled, disabling AG. Set \
+           BtHfpAGEnable to true, BtHfClientEnable to false in bt_app.conf to \
+           enable only AG\n" );
+        is_hfp_ag_enabled_ = false;
+    }
     //checking for Pan handler
     is_pan_enable_default_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
                                     BT_PAN_ENABLED, false);
@@ -1541,5 +2436,19 @@ bool BluetoothApp::LoadConfigParameters (const char *configpath) {
     //checking for Gatt handler
     is_gatt_enable_default_= config_get_bool (config, CONFIG_DEFAULT_SECTION,
                                     BT_GATT_ENABLED, false);
+
+#ifdef USE_BT_OBEX
+    //checking for OBEX handler
+    is_obex_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
+                                    BT_OBEX_ENABLED, false);
+
+    //checking for Pbap Client handler
+    is_pbap_client_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
+                                    BT_PBAP_CLIENT_ENABLED, false);
+
+    //checking for OPP handler
+    is_opp_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
+                                    BT_OPP_ENABLED, false);
+#endif
     return true;
 }
diff --git a/bt-app/main/src/ipc.c b/bt-app/main/src/ipc.c
index 3020cd8..1b71fb0 100644
--- a/bt-app/main/src/ipc.c
+++ b/bt-app/main/src/ipc.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *  Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *  Copyright (C) 2014 Google, Inc.
  *
@@ -23,14 +23,22 @@
 #include "osi/include/log.h"
 
 ThreadInfo threadInfo[THREAD_ID_MAX] = {
-    //thread_id thread type            Thread Message Handler  Thread Name
-    { NULL ,    THREAD_ID_MAIN,        &BtMainMsgHandler,      "Main_Thread" } ,
-    { NULL ,    THREAD_ID_GAP,         &BtGapMsgHandler,       "Gap_Thread" } ,
-    { NULL ,    THREAD_ID_A2DP_SINK,   &BtA2dpSinkMsgHandler,   "A2dp_Sink_Thread" } ,
-    { NULL ,    THREAD_ID_HFP_CLIENT,  &BtHfpClientMsgHandler,  "Hfp_Client_Thread" } ,
-    { NULL ,    THREAD_ID_PAN,         &BtPanMsgHandler,       "Pan_Thread" } ,
-    { NULL ,    THREAD_ID_GATT,        &BtGattMsgHandler,      "Gatt_Thread" } ,
-    { NULL ,    THREAD_ID_BT_AM,       &BtAudioManagerHandler,  "BT_AUDIO_MANAGER_Thread" } ,
+    //thread_id thread type            Thread Message Handler    Thread Name
+    { NULL ,    THREAD_ID_MAIN,        &BtMainMsgHandler,        "Main_Thread" } ,
+    { NULL ,    THREAD_ID_GAP,         &BtGapMsgHandler,         "Gap_Thread" } ,
+    { NULL ,    THREAD_ID_A2DP_SINK,   &BtA2dpSinkMsgHandler,    "A2dp_Sink_Thread" } ,
+    { NULL ,    THREAD_ID_HFP_CLIENT,  &BtHfpClientMsgHandler,   "Hfp_Client_Thread" } ,
+    { NULL ,    THREAD_ID_PAN,         &BtPanMsgHandler,         "Pan_Thread" } ,
+    { NULL ,    THREAD_ID_GATT,        &BtGattMsgHandler,        "Gatt_Thread" } ,
+    { NULL ,    THREAD_ID_BT_AM,       &BtAudioManagerHandler,   "BT_AUDIO_MANAGER_Thread" } ,
+    { NULL ,    THREAD_ID_SDP_CLIENT,  &BtSdpClientMsgHandler,   "Sdp_Client_Thread" } ,
+#ifdef USE_BT_OBEX
+    { NULL ,    THREAD_ID_PBAP_CLIENT, &BtPbapClientMsgHandler,  "Pbap_Client_Thread" } ,
+    { NULL ,    THREAD_ID_OPP,         &BtOppMsgHandler,         "Opp_Thread" } ,
+#endif
+    { NULL ,    THREAD_ID_HFP_AG,      &BtHfpAgMsgHandler,       "Hfp_AG_Thread" } ,
+    { NULL ,    THREAD_ID_A2DP_SOURCE, &BtA2dpSourceMsgHandler,  "A2dp_Source_Thread" } ,
+    { NULL ,    THREAD_ID_AVRCP,       &BtAvrcpMsgHandler,       "Avrcp_Thread" } ,
 };
 
 void PostMessage(ThreadIdType thread_type, void *msg) {
diff --git a/bt-app/opp/include/Opp.hpp b/bt-app/opp/include/Opp.hpp
new file mode 100644
index 0000000..44dec5d
--- /dev/null
+++ b/bt-app/opp/include/Opp.hpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef OPP_APP_H
+#define OPP_APP_H
+
+#pragma once
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_sock.h>
+#include <hardware/bt_sdp.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "osi/include/alarm.h"
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "ipc.h"
+
+#ifdef USE_GLIB
+#include <glib.h>
+#define strlcpy g_strlcpy
+#endif
+
+extern const char *BT_OPP_ENABLED;
+#define OPP_CONNECT_TIMEOUT_DELAY     (30000)
+
+class Opp {
+    private:
+        const bt_interface_t * bluetooth_interface;
+        config_t *config;
+
+        void AddSdpRecord();
+        bool PerformSdp(bt_bdaddr_t *addr);
+        bool SendFile(bt_bdaddr_t *addr, char * fileName);
+        bool Connect();
+        bool SendData();
+        bool HandleConnectTimeout(bt_bdaddr_t *addr);
+        bool Disconnect();
+        bool Abort();
+        bool IncomingFileRsp(bool accept);
+
+    public:
+        Opp(const bt_interface_t *bt_interface, config_t *config);
+        ~Opp();
+        alarm_t *opp_connect_timer;
+        void ProcessEvent(BtEvent* pEvent);
+        void RemoveSdpRecord();
+};
+
+#endif
+
diff --git a/bt-app/opp/src/Opp.cpp b/bt-app/opp/src/Opp.cpp
new file mode 100644
index 0000000..6ae1da1
--- /dev/null
+++ b/bt-app/opp/src/Opp.cpp
@@ -0,0 +1,1449 @@
+/*
+ * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <iostream>
+#include <list>
+#include <map>
+#include "osi/include/log.h"
+#include "osi/include/compat.h"
+#include "Opp.hpp"
+#include "utils.h"
+#include "oi_obex.h"
+#include "oi_obex_lower.h"
+#include "oi_pbap_client.h"
+#include "oi_utils.h"
+#include "oi_assert.h"
+#include <string.h>
+#include "oi_memmgr.h"
+#include "oi_opp_client.h"
+#include "oi_opp_server.h"
+#include "oi_opp_sys.h"
+#include "oi_unicode.h"
+#include "oi_rfcomm_prefs.h"
+#include "oi_l2cap_prefs.h"
+#include "oi_unicode.h"
+#include <unistd.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define LOGTAG "OPP "
+
+using namespace std;
+
+
+static uint8_t  UUID_OBEX_OBJECT_PUSH[] = {0x00, 0x00, 0x11, 0x05, 0x00, 0x00, 0x10, 0x00,
+                                                 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB};
+static  uint32_t profileVersion = 0x0102;
+static char profile_name[] = "OPP Profile";
+static char storageDir[] = "/data/misc/bluetooth/";
+static char noNameFileStoreLocation[] = "/data/misc/bluetooth/NoName";
+static char configFileName[] = "/data/misc/bluetooth/ext_to_mimetype.conf";
+Opp *g_opp = NULL;;
+
+#define UUID_MAX_LENGTH 16
+#define IS_UUID(u1,u2)  !memcmp(u1,u2,UUID_MAX_LENGTH)
+#define MAX_NAME_LEN                        (256)
+#define MAX_STORED_OBJECT_SIZE  1000
+#define MAX_MIME_TYE_LIST_LEN 500
+#define CONFIG_LINE_BUFFER_SIZE 100
+
+/*
+ * TRUE if contrary to the specification the remote peer did not provide a name header
+ */
+static OI_BOOL rejectPush = FALSE;
+OI_OPP_CLIENT_CONNECTION_HANDLE overrideConnection;
+static OI_BOOL  serverAllowPull = FALSE;
+static OI_BOOL  serverAllowPush = TRUE;
+static OI_BOOL  reportProgress = FALSE;
+
+/******************************************************************************
+ * Forward struct typedef
+ */
+typedef struct opp_data_struct OPP_DATA;
+typedef struct file_ext_type FILE_TYPE_DATA;
+
+typedef enum {
+    STATE_INITIAL,        /**< Initial state. */
+    STATE_IDLE,           /**< Idle state. */
+    STATE_CONNECTING,     /**< Connecting state. */
+    STATE_CONNECTED,      /**< Connected state. */
+    STATE_SENDING,        /**< Sending state. */
+    STATE_RECEIVING,      /**< Receiving state. */
+    STATE_DEINITIALIZING, /**< De-initializing state. */
+} OPP_STATE;
+
+struct file_ext_type {
+    OI_CHAR ext[MAX_NAME_LEN];                             /**< Extension of data being transferred */
+    OI_CHAR mimeType[MAX_NAME_LEN];                             /**< Mime Type of data being transferred */
+};
+
+/**
+This structure defines the OPP client data structure.
+*/
+struct opp_data_struct {
+    int rec_handle;                                 /**< Record Handle for OPP SDP */
+    OI_OPP_CLIENT_CONNECTION_HANDLE clientConnectionHandle;     /**< Connection ID to a server */
+    OI_OPP_SERVER_CONNECTION_HANDLE srvConnectionHandle; /**< Connection ID to a client */
+    OI_OPP_SERVER_HANDLE serverHandle; /**< Server handle */
+    OI_OBEX_LOWER_PROTOCOL lowerProtocol;           /**< Lower protocol info of server */
+    OI_BOOL connected;                              /**< Indicates if connected to a server */
+    OPP_STATE state;                               /**< Indicates current state of OPP client */
+    OI_BD_ADDR addr;                                /**< Remote OPP server address */
+    OI_CHAR fileName[MAX_NAME_LEN];                             /**< File Name of data being transferred */
+    OI_BOOL defaultName;                                  /**< TRUE if default name to be used for incoming file */
+    OI_CHAR *fileExt;                             /**< File Extension of data being transferred */
+    OI_CHAR mimeType[MAX_NAME_LEN];                             /**< Mime Type of data being transferred */
+    OI_BOOL abort;                                  /**< TRUE if current op is to be aborted */
+    int numOfEntries;
+    FILE_TYPE_DATA fileTypeData[MAX_MIME_TYE_LIST_LEN];
+};
+
+static OPP_DATA opp;
+
+static const OI_BD_ADDR bogusAddr = { {0,0,0,0,0,0} };
+#define BASE_ENGLISH(id)   ((id) + 0x100)  /* 0x0100 is the default for the primary language. */
+#define BASE_FRANCAIS(id)  ((id) + 0x110)
+#define BASE_DEUTSCH(id)   ((id) + 0x120)
+#define BASE_JAPANESE(id)  ((id) + 0x130)
+#define BASE_KOREAN(id)    ((id) + 0x140)
+#define BASE_CHINESE(id)   ((id) + 0x150)
+#define BASE_SPANISH(id)   ((id) + 0x160)
+#define BASE_ARABIC(id)    ((id) + 0x170)
+#define BASE_HEBREW(id)    ((id) + 0x180)
+#define OBEX_CONN_ID_HEADER_LEN 5
+#define OBEX_SRM_HEADER_LEN 2
+#define OBEX_LEN_HEADER_LEN 5
+#define OBEX_NAME_HEADER_LEN 3
+#define OBEX_TYPE_HEADER_LEN 3
+#define OBEX_BODY_HEADER_LEN 3
+
+static const OI_SDPDB_ATTRIBUTE strAttrs[] = {
+    { BASE_ENGLISH(OI_ATTRID_ServiceName),        OI_ELEMENT_STRING("OBEX Object Push") },
+    { BASE_ENGLISH(OI_ATTRID_ServiceDescription), OI_ELEMENT_STRING("Object Push") }
+};
+
+static const OI_SDP_STRINGS strings = {
+    strAttrs,
+    OI_ARRAYSIZE(strAttrs)
+};
+
+/**
+ * Prefer OBEX/L2CAP if it is supported - otherwise OBEX/RFCOMM
+ */
+static OI_OBEX_LOWER_PROTOCOL_ID preferProtocol = OI_OBEX_LOWER_L2CAP;
+
+static uint8_t OPP_FORMAT_VCARD21     = 0x01;
+static uint8_t OPP_FORMAT_VCARD30     = 0x02;
+static uint8_t OPP_FORMAT_VCAL10      = 0x03;
+static uint8_t OPP_FORMAT_ICAL20      = 0x04;
+static uint8_t OPP_FORMAT_VNOTE       = 0x05;
+static uint8_t OPP_FORMAT_VMESSAGE    = 0x06;
+static uint8_t OPP_FORMAT_ANY_TYPE_OF_OBJ = 0xFF;
+
+static uint8_t OPP_FORMAT_ALL [] = {
+    OPP_FORMAT_VCARD21,
+    OPP_FORMAT_VCARD30,
+    OPP_FORMAT_VCAL10,
+    OPP_FORMAT_ICAL20,
+    OPP_FORMAT_VNOTE,
+    OPP_FORMAT_VMESSAGE,
+    OPP_FORMAT_ANY_TYPE_OF_OBJ
+};
+
+/* ****************************************************************************
+ *
+ *                      virtual object filing system
+ *
+ * These functions implement object open, close, read, and write functions
+ * for both the OPP client and OPP server.
+ *
+ * ****************************************************************************/
+
+void read_config_file(char* config_filename) {
+
+    FILE *fp;
+    char buf[CONFIG_LINE_BUFFER_SIZE];
+    char *token;
+    int count = 0;
+    char *ctx;
+
+    ALOGV(LOGTAG " read_config_file: Opening %s\n", config_filename);
+    if (( fp = fopen(config_filename, "r")) == NULL) {
+        ALOGE(LOGTAG  " Failed to open config file %s", config_filename);
+        return;
+    }
+
+    while (! feof(fp)) {
+        if (fgets(buf, CONFIG_LINE_BUFFER_SIZE, fp) == NULL)
+            break;
+        if (buf[0] == '#' || strlen(buf) == 0) {
+            continue;
+        }
+        /* get the first token */
+        token = strtok_r(buf, ",", &ctx);
+        if (token != NULL) {
+            count ++;
+            strlcpy(opp.fileTypeData[opp.numOfEntries].ext,
+                token, strlen(token) +  1);
+        }
+        /* walk through other tokens */
+        while( token != NULL ) {
+            if (count > 2) {
+                ALOGW(LOGTAG "Invalid format in stored line. continuing...");
+                continue;
+            }
+            token = strtok_r(NULL, ",", &ctx);
+            if (token != NULL) {
+                strlcpy(opp.fileTypeData[opp.numOfEntries].mimeType,
+                token, strlen(token) + 1);
+                count ++;
+            }
+        }
+        count = 0;
+        opp.numOfEntries ++;
+    }
+    ALOGD(LOGTAG "num Of Entries %d\n", opp.numOfEntries);
+    fclose(fp);
+}
+
+/**
+   This structure defines the object.
+ */
+typedef struct {
+    FILE *handle;
+    OI_CHAR16 nameStr[MAX_NAME_LEN];
+    OI_UINT16 nameLen;
+    OI_BYTE *data;
+    OI_UINT32 size;
+    OI_UINT32 bytes_read;
+    OI_BOOL read;
+} OBJECT;
+
+
+static OBJECT object;
+
+static OI_CHAR * obex_err_code_to_str (OI_STATUS status) {
+    switch (status) {
+        case OI_OK                              : return "SUCCESS";
+        case OI_OBEX_COMMAND_ERROR              : return "COMMAND_ERROR";
+        case OI_OBEX_CONNECTION_TIMEOUT         : return "CONNECTION_TIMEOUT";
+        case OI_OBEX_CONNECT_FAILED             : return "CONNECT_FAILED";
+        case OI_OBEX_DISCONNECT_FAILED          : return "DISCONNECT_FAILED";
+        case OI_OBEX_ERROR                      : return "ERROR";
+        case OI_OBEX_INCOMPLETE_PACKET          : return "INCOMPLETE_PACKET";
+        case OI_OBEX_LENGTH_REQUIRED            : return "LENGTH_REQUIRED";
+        case OI_OBEX_NOT_CONNECTED              : return "NOT_CONNECTED";
+        case OI_OBEX_NO_MORE_CONNECTIONS        : return "NO_MORE_CONNECTIONS";
+        case OI_OBEX_OPERATION_IN_PROGRESS      : return "OPERATION_IN_PROGRESS";
+        case OI_OBEX_PUT_RESPONSE_ERROR         : return "PUT_RESPONSE_ERROR";
+        case OI_OBEX_GET_RESPONSE_ERROR         : return "GET_RESPONSE_ERROR";
+        case OI_OBEX_REQUIRED_HEADER_NOT_FOUND  : return "REQUIRED_HEADER_NOT_FOUND";
+        case OI_OBEX_SERVICE_UNAVAILABLE        : return "SERVICE_UNAVAILABLE";
+        case OI_OBEX_TOO_MANY_HEADER_BYTES      : return "TOO_MANY_HEADER_BYTES";
+        case OI_OBEX_UNKNOWN_COMMAND            : return "UNKNOWN_COMMAND";
+        case OI_OBEX_UNSUPPORTED_VERSION        : return "UNSUPPORTED_VERSION";
+        case OI_OBEX_CLIENT_ABORTED_COMMAND     : return "CLIENT_ABORTED_COMMAND";
+        case OI_OBEX_BAD_PACKET                 : return "BAD_PACKET";
+        case OI_OBEX_BAD_REQUEST                : return "BAD_REQUEST";
+        case OI_OBEX_OBJECT_OVERFLOW            : return "OBJECT_OVERFLOW";
+        case OI_OBEX_NOT_FOUND                  : return "NOT_FOUND";
+        case OI_OBEX_ACCESS_DENIED              : return "ACCESS_DENIED";
+        case OI_OBEX_VALUE_NOT_ACCEPTABLE       : return "VALUE_NOT_ACCEPTABLE";
+        case OI_OBEX_PACKET_OVERFLOW            : return "PACKET_OVERFLOW";
+        case OI_OBEX_NO_SUCH_FOLDER             : return "NO_SUCH_FOLDER";
+        case OI_OBEX_NAME_REQUIRED              : return "NAME_REQUIRED";
+        case OI_OBEX_PASSWORD_TOO_LONG          : return "PASSWORD_TOO_LONG";
+        case OI_OBEX_PRECONDITION_FAILED        : return "PRECONDITION_FAILED";
+        case OI_OBEX_UNAUTHORIZED               : return "UNAUTHORIZED";
+        case OI_OBEX_NOT_IMPLEMENTED            : return "NOT_IMPLEMENTED";
+        case OI_OBEX_INVALID_AUTH_DIGEST        : return "INVALID_AUTH_DIGEST";
+        case OI_OBEX_INVALID_OPERATION          : return "INVALID_OPERATION";
+        case OI_OBEX_DATABASE_FULL              : return "DATABASE_FULL";
+        case OI_OBEX_DATABASE_LOCKED            : return "DATABASE_LOCKED";
+        case OI_OBEX_INTERNAL_SERVER_ERROR      : return "INTERNAL_SERVER_ERROR";
+        case OI_OBEX_UNSUPPORTED_MEDIA_TYPE     : return "UNSUPPORTED_TYPE";
+        case OI_OBEX_PARTIAL_CONTENT            : return "PARTIAL_CONTENT";
+        case OI_OBEX_METHOD_NOT_ALLOWED         : return "METHOD_NOT_ALLOWED";
+        case OI_OBEXSRV_INCOMPLETE_GET          : return"OI_OBEXSRV_INCOMPLETE_GET";
+        case OI_OBEX_FOLDER_BROWSING_NOT_ALLOWED : return "FOLDER_BROWSING_NOT_ALLOWED";
+        case OI_OBEX_SERVER_FORCED_DISCONNECT   : return "SERVER_FORCED_DISCONNECT";
+        case OI_OBEX_OFS_ERROR                  : return "OFS_ERROR";
+        case OI_OBEX_FILEOP_ERROR               : return "FILEOP_ERROR";
+        case OI_OBEX_USERID_TOO_LONG            : return "USERID_TOO_LONG";
+        default :
+        ALOGD(LOGTAG "obex_err_code_to_str: status = %d\n", status);
+        return "UNKNOWN_ERROR";
+    }
+}
+
+static OI_CHAR * opp_state_to_str (OPP_STATE state) {
+    switch (state) {
+        case STATE_INITIAL          : return "STATE_INITIAL";
+        case STATE_IDLE             : return "STATE_IDLE";
+        case STATE_CONNECTING       : return "STATE_CONNECTING";
+        case STATE_CONNECTED        : return "STATE_CONNECTED";
+        case STATE_SENDING          : return "STATE_SENDING";
+        case STATE_RECEIVING        : return "STATE_RECEIVING";
+        case STATE_DEINITIALIZING   : return "STATE_DEINITIALIZING";
+        default :
+        ALOGD(LOGTAG "opp_state_to_str: state = %d\n", state);
+        return "UNKNOWN_STATE";
+    }
+}
+
+static OI_STATUS OFS_OpenRead(const OI_OBEX_UNICODE *name,
+                              const OI_CHAR *type,
+                              OI_UINT32 maxRead,
+                              OI_OPP_OPEN_READ_CFM openCfm,
+                              OI_OPP_CONNECTION oppConnection)
+{
+    static OI_CHAR fileName[MAX_NAME_LEN + 1];
+    int read = 0;
+    int remaining;
+    OI_STATUS status;
+
+    /*
+     * Clear object.
+     */
+    memset(&object, 0, sizeof(OBJECT));
+
+    object.read = TRUE;
+    object.nameLen = name->len;
+    if (object.nameLen > (MAX_NAME_LEN - strlen(storageDir) - 1)) {
+        ALOGD(LOGTAG "File name len too large, can't open file for reading\n");
+        return OI_STATUS_DATA_ERROR;
+    }
+    /* Copy Unicode name to saved object */
+    memcpy(object.nameStr, name->str, name->len);
+    /*
+     * Get name as an ascii string. This would not be done by an implementation
+     * that has native support for unicode object names.
+     */
+    strlcpy(fileName, storageDir, strlen(storageDir) + 1);
+    OI_Utf16ToUtf8((const OI_UTF16*)name->str, name->len,
+                            (OI_UTF8*)fileName + strlen(storageDir),
+                            sizeof(fileName));
+    object.handle = fopen((const char *)fileName, "r+b");
+    ALOGD(LOGTAG "Opening object %s to read\n", fileName);
+    if (object.handle != NULL) {
+        fseek(object.handle, 0L, SEEK_END);
+        object.size = ftell(object.handle);
+        rewind(object.handle);
+        object.bytes_read = 0;
+        /* Allocate memory for reading data */
+        object.data = (OI_BYTE *)malloc(maxRead);
+        if (!object.data) {
+            ALOGD(LOGTAG "Unable to allocate %d bytes of memory for reading data", maxRead);
+            fclose(object.handle);
+            object.handle = NULL;
+            return OI_STATUS_OUT_OF_MEMORY;
+        }
+        if (opp.lowerProtocol.protocol == OI_OBEX_LOWER_L2CAP) {
+            maxRead -= (OBEX_CONN_ID_HEADER_LEN + OBEX_LEN_HEADER_LEN +
+                OBEX_SRM_HEADER_LEN + OBEX_NAME_HEADER_LEN + OBEX_TYPE_HEADER_LEN +
+                OBEX_BODY_HEADER_LEN+ (name->len * 2) + (strlen(type) + 1));
+            ALOGD(LOGTAG "maxRead = %d name->len = %d type len = %d\n",
+                maxRead, name->len * 2, strlen(type) + 1 );
+            remaining = maxRead;
+            if (object.bytes_read < object.size) {
+                ALOGD(LOGTAG "Reading  %d bytes\n", remaining);
+                read = fread(object.data + (maxRead - remaining), 1, remaining, object.handle);
+                ALOGD(LOGTAG "Read %d bytes\n", read);
+                remaining -= read;
+                /*
+                 * Pass data from in-memory object to OPP
+                 */
+                if (remaining == 0)
+                    status = OI_OK;
+                else if (remaining < maxRead)
+                    status = OI_STATUS_END_OF_FILE;
+
+                if (remaining < maxRead) {
+                    object.bytes_read += (maxRead - remaining);
+                }
+            }
+        } else {
+            maxRead = remaining = 0;
+            status = OI_OK;
+        }
+        /*
+         * This implementation uses the address of the object as the handle.
+         */
+        openCfm((OI_OPP_HANDLE) &object, name, type, object.size, object.data,
+            (OI_UINT16) (maxRead - remaining), status, oppConnection);
+        return OI_OK;
+    } else {
+        ALOGD(LOGTAG "Unable to Open file %s for reading\n", fileName);
+        OI_Printf("Unable to Open file %s for reading\n", fileName);
+        return OI_STATUS_READ_ERROR;
+    }
+}
+
+static OI_STATUS OFS_OpenWrite(const OI_OBEX_UNICODE *name,
+                               const OI_CHAR *type,
+                               OI_UINT32 objSize,
+                               OI_OPP_OPEN_WRITE_CFM openCfm,
+                               OI_OPP_CONNECTION oppConnection)
+{
+    static OI_CHAR fileName[MAX_NAME_LEN + 1];
+
+    /*
+     * Clear object.
+     */
+    memset(&object, 0, sizeof(OBJECT));
+
+    /*
+     * Initialize received object
+     */
+
+    /* Copy received data to saved object */
+    object.size = objSize;
+    object.read = FALSE;
+    /* Copy Unicode name to saved object */
+    memcpy(object.nameStr, name->str, name->len);
+    object.nameLen = name->len;
+    if (object.nameLen > (MAX_NAME_LEN - strlen(storageDir) - 1)) {
+        ALOGD(LOGTAG "File name len too large, truncating it\n");
+        object.nameLen = MAX_NAME_LEN - strlen(storageDir) - 1;
+    }
+    /*
+     * Get name as an ascii string. This would not be done by an implementation
+     * that has native support for unicode object names.
+     */
+    strlcpy(fileName, storageDir, strlen(storageDir) + 1);
+    OI_Utf16ToUtf8((const OI_UTF16*)name->str, object.nameLen,
+                            (OI_UTF8*)fileName + strlen(storageDir),
+                            sizeof(fileName));
+    memset(opp.fileName, 0, MAX_NAME_LEN);
+    memcpy(opp.fileName, fileName, strlen(fileName));
+    ALOGD(LOGTAG "Opening object %s type %s size %ld to write\n", fileName, type, objSize);
+    object.handle = fopen((const char *)fileName, "w");
+    if (object.handle != NULL) {
+        /*
+         * This implementation uses the address of the object as the handle.
+         */
+        openCfm((OI_OPP_HANDLE) &object, OI_OK, oppConnection);
+        return OI_OK;
+    } else {
+        ALOGD(LOGTAG "Unable to Open file %s for storing data\n", fileName);
+        OI_Printf("Unable to Open file %s for storing data\n", fileName);
+        return OI_STATUS_WRITE_ERROR;
+    }
+}
+
+static void OFS_Close(OI_OPP_HANDLE handle,
+                      OI_STATUS status,
+                      OI_OPP_CONNECTION oppConnection)
+{
+    OBJECT *obj = (OBJECT*) handle;
+
+    if (!OI_SUCCESS(status)) {
+        ALOGE(LOGTAG "Close obj on error %d\n", status);
+        if (OI_OBEX_CLIENT_ABORTED_COMMAND == status) {
+            OI_Printf("Operation aborted\n");
+        }
+    } else {
+        ALOGD(LOGTAG "Close obj size = %ld\n", obj->size);
+        /*
+         * Get name as an ascii string. This would not be done by an implementation
+         * that has native support for unicode object names.
+         */
+        if (!obj->read) {
+            OI_Printf("Received file stored at %s\n", opp.fileName);
+            ALOGD(LOGTAG "Received file %d bytes\n",
+                (OI_UINT) obj->size);
+        } else {
+            ALOGD(LOGTAG "Sent file size %d bytes\n",
+                (OI_UINT) obj->size);
+        }
+    }
+    if (obj->read && obj->data) {
+        /* Free memory for reading data */
+        free(obj->data);
+        obj->data = NULL;
+    }
+    if (obj->handle != NULL) {
+        fclose(obj->handle);
+        obj->handle = NULL;
+    }
+    if (status && !obj->read && opp.fileName != NULL) {
+        ALOGD(LOGTAG "deleting file %s", opp.fileName);
+        remove(opp.fileName);
+    }
+}
+
+
+static OI_STATUS OFS_Read(OI_OPP_HANDLE handle,
+                          OI_UINT32 maxRead,
+                          OI_OPP_READ_CFM readCfm,
+                          OI_OPP_CONNECTION oppConnection)
+{
+    OBJECT *obj = (OBJECT*) handle;
+    int read = 0;
+    int remaining = maxRead;
+    OI_STATUS status;
+
+    if (obj->bytes_read < obj->size) {
+        ALOGD(LOGTAG "Reading  %d bytes\n", remaining);
+        read = fread(obj->data + (maxRead - remaining), 1, remaining, obj->handle);
+        ALOGD(LOGTAG "Read %d bytes\n", read);
+        remaining -= read;
+        /*
+         * Pass data from in-memory object to OPP
+         */
+        if (remaining == 0)
+            status = OI_OK;
+        else if (remaining < maxRead)
+            status = OI_STATUS_END_OF_FILE;
+
+        if (remaining < maxRead) {
+            obj->bytes_read += (maxRead - remaining);
+            readCfm(handle, obj->data, (OI_UINT16) (maxRead - remaining), status, oppConnection);
+        }
+    }
+    return OI_OK;
+}
+
+static OI_STATUS OFS_Write(OI_OPP_HANDLE handle,
+                           const OI_BYTE *buffer,
+                           OI_UINT32 bufLen,
+                           OI_OPP_WRITE_CFM writeCfm,
+                           OI_OPP_CONNECTION oppConnection)
+{
+    OBJECT *obj = (OBJECT*) handle;
+    OI_STATUS status;
+    int wrote = 0;
+    int remaining = bufLen;
+
+    ALOGD(LOGTAG "Write %d bytes\n", bufLen);
+
+    if (bufLen > 0) {
+        while (remaining > 0) {
+            wrote = fwrite(buffer + (bufLen - remaining), sizeof(OI_CHAR),
+                remaining, obj->handle);
+            remaining -= wrote;
+            if (wrote == 0) {
+                ALOGE(LOGTAG "Unable to write to File System\n");
+                writeCfm(handle, OI_STATUS_WRITE_ERROR, oppConnection);
+                return OI_STATUS_WRITE_ERROR;
+            }
+        }
+    }
+    /*
+     * Confirm write
+     */
+    writeCfm(handle, OI_OK, oppConnection);
+    return OI_OK;
+}
+
+static const OI_OPP_OBJSYS_FUNCTIONS objSys = {
+    OFS_OpenRead,
+    OFS_OpenWrite,
+    OFS_Close,
+    OFS_Read,
+    OFS_Write,
+    NULL
+};
+
+/**
+ * used for timing push and pull operations
+ */
+static OI_TIME clientStartTime;
+static OI_TIME serverStartTime;
+
+/******************************************************************************/
+/**
+ * This function performs a simple conversion from ASCII to unicode.
+ * The unicode string is declared as static.
+ */
+static void FilenameToObjname(OI_OBEX_UNICODE *ustr,
+                              const OI_CHAR* astr)
+{
+    static OI_CHAR16 str16[MAX_NAME_LEN];
+    OI_INT i;
+
+    /*
+     * Allow for null termination.
+     */
+    ustr->len = strlen(astr) + 1;
+    if (ustr->len == 1) {
+        ustr->len = 0;
+        return;
+    }
+    ustr->str = str16;
+    for (i = 0; i < ustr->len; ++i) {
+        /*
+         * Don't transcribe cr/lf
+         */
+        if ((astr[i] == '\r') || (astr[i] == '\n')) {
+            ustr->len = i;
+            break;
+        }
+    }
+
+    OI_Utf8ToUtf16((const OI_UTF8*)astr, ustr->len, ustr->str, MAX_NAME_LEN);
+}
+
+/**
+ *  Computes throughput in bits per second given a start time and an end time
+ */
+OI_UINT32 OI_Throughput(OI_UINT32 bytes,
+                        OI_TIME *startTime,
+                        OI_TIME *endTime)
+{
+    OI_INT32 msecs;
+
+    msecs = 1000 * (endTime->seconds - startTime->seconds);
+    msecs += endTime->mseconds - startTime->mseconds;
+
+    if (0 == msecs) {
+        msecs = 1;
+    }
+    if(msecs < 100)
+    {
+        OI_Printf("Time taken to transfer the file is too low (EndTime = %ds%dmsc, StartTime=%ds%dms).\n"
+            "Please calculate the throughput yourself\n", endTime->seconds, endTime->mseconds, startTime->seconds,
+            startTime->mseconds);
+        return 0;
+    }
+
+    return ((OI_UINT32)(bytes / msecs) * 8);
+}
+
+
+/**
+ * Returns a string formatted as seconds and milliseconds
+ */
+const OI_CHAR* OI_ElapsedTimeTxt(OI_TIME *startTime,
+                                 OI_TIME *endTime)
+{
+    static OI_CHAR buffer[16];
+    OI_CHAR zeroes[] = "00";
+    OI_INT32 secs;
+    OI_INT16 msecs;
+
+    secs = endTime->seconds - startTime->seconds;
+    msecs = endTime->mseconds - startTime->mseconds;
+    if (msecs < 0) {
+        msecs += 1000;
+        --secs;
+    }
+    if ((msecs >= 100) || (msecs == 0)) {
+        zeroes[0] = 0;
+    } else if (msecs >= 10) {
+        zeroes[1] = 0;
+    }
+    OI_SNPrintf(buffer, sizeof(buffer)," %d.%s%d", (int)secs, zeroes, (int)msecs);
+    return buffer;
+}
+
+static OPP_STATE getOppState() {
+    ALOGD(LOGTAG "getOppState: state = %s", opp_state_to_str(opp.state));
+    return opp.state;
+}
+
+static void setOppState(OPP_STATE newState) {
+    ALOGD(LOGTAG "%s => %s", opp_state_to_str(opp.state), opp_state_to_str(newState));
+    opp.state = newState;
+}
+
+/* ****************************************************************************
+ *
+ *                      OPP Server Functions
+ *
+ * ****************************************************************************/
+
+
+/*
+ * Changes these values to allow or reject push or pull operations.
+ */
+
+static void ServerConnectInd(OI_BD_ADDR *clientAddr,
+                             OI_OPP_SERVER_CONNECTION_HANDLE connectionId)
+{
+    OI_STATUS status;
+    char bd_str[MAX_BD_STR_LEN];
+
+    bdaddr_to_string((const bt_bdaddr_t*)clientAddr, bd_str, MAX_BD_STR_LEN);
+
+    OI_Printf("OPP connection from %s\n", bd_str);
+    if (getOppState() == STATE_CONNECTING) {
+        bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+        ALOGE(LOGTAG "%s: Already connecting to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Already connecting to %s\n", bd_str);
+        OI_Printf("Rejecting connection\n");
+        status = OI_OPP_AcceptConnect(connectionId, FALSE, FALSE);
+        return;
+    }
+    if (getOppState() >= STATE_CONNECTED) {
+        bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+        ALOGE(LOGTAG "%s: Already connected to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Already connected to %s\n", bd_str);
+        OI_Printf("Rejecting connection\n");
+        status = OI_OPP_AcceptConnect(connectionId, FALSE, FALSE);
+        return;
+    }
+    /*
+     * An OPP server application can selectively allow clients to push or pull
+     * objects. If a client is not allowed to either pull or push the connection
+     * is rejected and the client will receive an ACCESS DENIED response.
+     */
+    status = OI_OPP_AcceptConnect(connectionId, serverAllowPush, serverAllowPull);
+    if (!OI_SUCCESS(status)) {
+        ALOGD(LOGTAG "AcceptConnect returned %d\n", status);
+     } else {
+        if (getOppState() == STATE_IDLE) {
+            opp.srvConnectionHandle = connectionId;
+            memcpy(&opp.addr, clientAddr, sizeof(OI_BD_ADDR));
+            setOppState(STATE_CONNECTED);
+        }
+    }
+}
+
+static void ServerDisconnectInd(OI_OPP_SERVER_CONNECTION_HANDLE connectionId)
+{
+    ALOGD(LOGTAG "ServerDisconnectInd");
+    if (getOppState() == STATE_DEINITIALIZING) {
+        /* BT is being turned off */
+        OI_OPPServer_Deregister(opp.serverHandle);
+        opp.serverHandle = 0;
+        g_opp->RemoveSdpRecord();
+        /*
+        * Its possible that SDP Client thread terminated before receiving above request,
+        * so send stop profile with success.
+        */
+        BtEvent *stop_event = new BtEvent;
+        stop_event->profile_start_event.event_id = PROFILE_EVENT_STOP_DONE;
+        stop_event->profile_start_event.profile_id = PROFILE_ID_OPP;
+        stop_event->profile_start_event.status = true;
+        PostMessage(THREAD_ID_GAP, stop_event);
+    }
+    if (opp.srvConnectionHandle ==  connectionId) {
+        opp.srvConnectionHandle = 0;
+        uint8_t zero[sizeof(bt_bdaddr_t)] = { 0 };
+        memcpy(&opp.addr, zero, sizeof(bt_bdaddr_t));
+        setOppState(STATE_IDLE);
+        opp.lowerProtocol.protocol = OI_OBEX_LOWER_NONE;
+    }
+    if (opp.abort == true) {
+        fprintf(stdout, "Aborted last operation \n");
+        opp.abort = false;
+    }
+}
+
+static void ServerEventInd(OI_OPP_SERVER_CONNECTION_HANDLE connectionId,
+                           OI_OPP_SERVER_EVENT_DATA       *eventPtr)
+{
+    OI_TIME endTime;
+
+    switch(eventPtr->event) {
+        case OI_OPP_SERVER_EVENT_PUSH:
+            if (eventPtr->data.push.localName &&
+                eventPtr->data.push.localName->str &&
+                eventPtr->data.push.localName->len) {
+                OI_Printf("\nIncoming object: %S\n",
+                    eventPtr->data.push.localName->str, eventPtr->data.push.localName->len);
+            } else {
+                OI_Printf("\nIncoming object: Unnamed\n");
+                opp.defaultName = TRUE;
+            }
+            if (eventPtr->data.push.totalSize) {
+                OI_Printf("Incoming size: %d bytes\n", eventPtr->data.push.totalSize);
+            } else {
+                OI_Printf("Incoming size: Unknown\n");
+            }
+            if (eventPtr->data.push.objType) {
+                OI_Printf("Incoming type: %s\n", eventPtr->data.push.objType);
+            } else {
+                OI_Printf("Incoming type: Unknown\n");
+            }
+
+            if (rejectPush || getOppState() != STATE_CONNECTED) {
+                OI_Printf("Rejecting incoming file\n");
+                OI_OPPServer_AcceptPush(connectionId, NULL, FALSE);
+            } else {
+                setOppState(STATE_RECEIVING);
+                memset(opp.fileName, 0, MAX_NAME_LEN);
+                OI_Utf16ToUtf8((const OI_UTF16*)eventPtr->data.push.localName->str,
+                                        eventPtr->data.push.localName->len,
+                                        (OI_UTF8*)opp.fileName,
+                                        sizeof(opp.fileName));
+                // pass the same event to Main thread
+                BtEvent* bt_event = NULL;
+                bt_event = new BtEvent;
+                bt_event->event_id = MAIN_EVENT_INCOMING_FILE_REQUEST;
+                PostMessage(THREAD_ID_MAIN, bt_event);
+            }
+            break;
+
+        case OI_OPP_SERVER_EVENT_PUSH_PROGRESS:
+            if (reportProgress) {
+                OI_Printf("Incoming Progress: %d bytes\n",
+                    eventPtr->data.pushProgress.bytesTransferred);
+            }
+            break;
+
+        case OI_OPP_SERVER_EVENT_PUSH_COMPLETE:
+            if (eventPtr->data.pushComplete.status == OI_OK) {
+                OI_Time_Now(&endTime);
+                ALOGV(LOGTAG "Push completed in %s seconds\n",
+                    OI_ElapsedTimeTxt(&serverStartTime, &endTime));
+                ALOGV(LOGTAG " Incoming Complete: %d bytes status:%d\n",
+                    eventPtr->data.pushComplete.finalSize,
+                    eventPtr->data.pushComplete.status);
+                OI_Printf("Throughput %d Kbps\n",
+                    OI_Throughput(eventPtr->data.pushComplete.finalSize,
+                    &serverStartTime, &endTime));
+                ALOGD(LOGTAG "Throughput %d Kbps\n",
+                    OI_Throughput(eventPtr->data.pushComplete.finalSize,
+                    &serverStartTime, &endTime));
+            }
+            if (getOppState() == STATE_RECEIVING)
+                setOppState(STATE_CONNECTED);
+            break;
+
+        default:
+            break;
+    }
+}
+
+
+static const OI_OPP_SERVER_CALLBACKS callbacks = {
+    ServerConnectInd,
+    ServerDisconnectInd,
+    ServerEventInd
+};
+
+void BtOppMsgHandler(void *msg)
+{
+    BtEvent* event = NULL;
+    bool status = false;
+    OI_STATUS ret;
+    if(!msg) {
+        ALOGE(LOGTAG "%s: Msg is null, return", __FUNCTION__);
+        return;
+    }
+
+    event = ( BtEvent *) msg;
+
+    if (event == NULL) {
+        ALOGE(LOGTAG "%s: event is null", __FUNCTION__);
+        return;
+    }
+
+    ALOGD(LOGTAG "BtOppMsgHandler event = %d", event->event_id);
+    switch(event->event_id) {
+        case PROFILE_API_START:
+            {
+                BtEvent *start_event = new BtEvent;
+                memset(&opp, 0, sizeof(OPP_DATA));
+                start_event->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+                start_event->profile_start_event.profile_id = PROFILE_ID_OPP;
+                start_event->profile_start_event.status = true;
+                PostMessage(THREAD_ID_GAP, start_event);
+            }
+            break;
+
+        case PROFILE_API_STOP:
+            if(g_opp) {
+                if (opp.clientConnectionHandle) {
+                   /* disconnect opp client if connected */
+                   ret = OI_OPPClient_Disconnect(opp.clientConnectionHandle);
+                   ALOGD(LOGTAG " OI_OPPClient_Disconnect returned %d", ret);
+                }
+                if (opp.srvConnectionHandle) {
+                    setOppState(STATE_DEINITIALIZING);
+                    /* disconnect opp server if connected */
+                    ret = OI_OPPServer_ForceDisconnect(opp.srvConnectionHandle);
+                    ALOGD(LOGTAG " OI_OPPServer_ForceDisconnect returned %d", ret);
+                } else {
+                    /* Server is not connected, proceed with de-registration */
+                    ret = OI_OPPServer_Deregister(opp.serverHandle);
+                    ALOGD(LOGTAG " OI_OPPServer_Deregister returned %d", ret);
+                    opp.serverHandle = 0;
+                    g_opp->RemoveSdpRecord();
+                    /*
+                    * Its possible that SDP Client thread terminated before receiving above request,
+                    * so send stop profile with success.
+                    */
+                    BtEvent *stop_event = new BtEvent;
+                    stop_event->profile_start_event.event_id = PROFILE_EVENT_STOP_DONE;
+                    stop_event->profile_start_event.profile_id = PROFILE_ID_OPP;
+                    stop_event->profile_start_event.status = true;
+                    PostMessage(THREAD_ID_GAP, stop_event);
+                }
+            }
+            break;
+
+        default:
+            if(g_opp) {
+               g_opp->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+    }
+    delete event;
+}
+
+Opp :: Opp(const bt_interface_t *bt_interface, config_t *config)
+{
+    this->bluetooth_interface = bt_interface;
+    this->config = config;
+    opp_connect_timer = NULL;
+    if( !(opp_connect_timer = alarm_new())) {
+        ALOGE(LOGTAG " unable to create opp_connect_timer");
+        return;
+    }
+}
+
+void opp_connect_timer_expired(void *context) {
+    ALOGD(LOGTAG, " opp_connect_timer_expired");
+
+    BtEvent *event = new BtEvent;
+    event->event_id = OPP_CONNECT_TIMEOUT;
+    memcpy(&event->opp_event.bd_addr, (bt_bdaddr_t *)context, sizeof(bt_bdaddr_t));
+    PostMessage(THREAD_ID_OPP, event);
+}
+
+Opp :: ~Opp()
+{
+    alarm_free(g_opp->opp_connect_timer);
+    g_opp->opp_connect_timer = NULL;
+}
+
+void ConnectionCfmCb(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                                       OI_STATUS status)
+{
+    char bd_str[MAX_BD_STR_LEN];
+    bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+    ALOGV(LOGTAG "%s: status: %d connectionID = %p", __FUNCTION__,
+        status, connectionId);
+    //stoping opp_connect_timer
+    if(g_opp) {
+        alarm_cancel(g_opp->opp_connect_timer);
+    }
+
+    if (getOppState() != STATE_CONNECTING) {
+        ALOGE(LOGTAG "%s: received connect cfm in invalid state %s",
+            __FUNCTION__, opp_state_to_str(opp.state));
+        /* Most likely connection timed out, so disconnect OBEX link now */
+        OI_OPPClient_Disconnect(connectionId);
+        return;
+    }
+
+    if (status == OI_STATUS_SUCCESS) {
+        opp.clientConnectionHandle = connectionId;
+        setOppState(STATE_CONNECTED);
+        opp.abort = false;
+        fprintf(stdout, "Connected to %s\n", bd_str);
+        /* Send Internal Connect Message to OPP Thread */
+        BtEvent *event = new BtEvent;
+        event->event_id = OPP_INTERNAL_SEND;
+        PostMessage(THREAD_ID_OPP, event);
+    } else {
+        opp.clientConnectionHandle = NULL;
+        setOppState(STATE_IDLE);
+        uint8_t zero[sizeof(bt_bdaddr_t)] = { 0 };
+        memcpy(&opp.addr, zero, sizeof(bt_bdaddr_t));
+        fprintf(stdout, "Failed to Connect to %s\n", bd_str);
+    }
+}
+
+void DisconnectionCfmCb(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId)
+{
+    ALOGV(LOGTAG "%s: connectionID = %p", __FUNCTION__, connectionId);
+    char bd_str[MAX_BD_STR_LEN];
+    if (opp.clientConnectionHandle == connectionId) {
+        bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+        fprintf(stdout, "Disconnected with %s\n", bd_str);
+        opp.clientConnectionHandle = NULL;
+        setOppState(STATE_IDLE);
+        opp.lowerProtocol.protocol = OI_OBEX_LOWER_NONE;
+        opp.abort = false;
+        uint8_t zero[sizeof(bt_bdaddr_t)] = { 0 };
+        memcpy(&opp.addr, zero, sizeof(bt_bdaddr_t));
+    }
+}
+
+void AbortCfmCb(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId)
+{
+    ALOGV(LOGTAG "%s: connectionID = %p", __FUNCTION__, connectionId);
+    fprintf(stdout, "Aborted last operation \n");
+    opp.abort = false;
+}
+
+static void ClientEventInd(OI_OPP_CLIENT_CONNECTION_HANDLE  connectionId,
+                       const OI_OPP_CLIENT_EVENT_DATA  *evtPtr,
+                       OI_STATUS                        status)
+{
+    OI_TIME endTime;
+    static bool pushIndReceived;
+    switch(evtPtr->event) {
+        case OI_OPP_CLIENT_CONNECTED:
+            ConnectionCfmCb(connectionId, status);
+            pushIndReceived = false;
+            break;
+
+        case OI_OPP_CLIENT_PUSH_STARTED:
+            setOppState(STATE_SENDING);
+            break;
+
+        case OI_OPP_CLIENT_PUSH_PROGRESS:
+            if (!pushIndReceived) {
+                OI_Printf("File accepted by remote device\n");
+                OI_Time_Now(&clientStartTime);
+                pushIndReceived = true;
+            }
+            break;
+
+        case OI_OPP_CLIENT_PUSH_COMPLETE:
+            if (status == OI_OK) {
+                OI_Time_Now(&endTime);
+                ALOGV(LOGTAG "Push completed in %s seconds\n",
+                    OI_ElapsedTimeTxt(&clientStartTime, &endTime));
+                ALOGV(LOGTAG "Outgoing Complete: %d bytes status: %s\n", object.size,
+                    obex_err_code_to_str(status));
+                OI_Printf("Throughput %d Kbps\n", OI_Throughput(object.size,
+                    &clientStartTime, &endTime));
+                ALOGD(LOGTAG "Throughput %d Kbps\n", OI_Throughput(object.size,
+                    &clientStartTime, &endTime));
+            } else {
+                OI_Printf("Failed to send file, status = %s\n",
+                    obex_err_code_to_str(status));
+                ALOGD(LOGTAG "Failed to send file, status = %s\n",
+                    obex_err_code_to_str(status));
+            }
+            if (getOppState() == STATE_SENDING)
+                setOppState(STATE_CONNECTED);
+            if (opp.clientConnectionHandle) {
+                /* disconnect opp if connected */
+                OI_OPPClient_Disconnect(opp.clientConnectionHandle);
+            }
+            break;
+
+        case OI_OPP_CLIENT_DISCONNECT:
+            DisconnectionCfmCb(connectionId);
+            break;
+
+        default:
+            ALOGV(LOGTAG "ClientEventInd, unknown event received %d, "
+                "status %d\n", evtPtr->event, status);
+            break;
+    }
+}
+
+static void sdp_add_record_callback(bt_status_t status, int handle)
+{
+    OI_STATUS ret;
+    if (!status) {
+        opp.rec_handle = handle;
+        setOppState(STATE_IDLE);
+        opp.lowerProtocol.protocol = OI_OBEX_LOWER_NONE;
+        opp.numOfEntries = 0;
+        read_config_file(configFileName);
+        if (opp.numOfEntries == 0) {
+            ALOGE(LOGTAG "%s: unable to read mime type entries", __FUNCTION__);
+        }
+        fprintf(stdout, "Successfully Registered OPP Server SDP Record\n");
+        ret = OI_OPPServer_Register(&callbacks, &objSys,
+            OI_OPP_SERVER_OBJ_FORMAT_ANY, &strings, &opp.serverHandle);
+    } else {
+        fprintf(stdout, "Sdp add record failed. Incoming transfer will fail\n");
+        ALOGE(LOGTAG "%s: sdp add record failed, status %d", __FUNCTION__, status);
+    }
+}
+
+static void sdp_remove_record_callback(bt_status_t status)
+{
+    OI_STATUS ret;
+    if (status) {
+        ALOGE(LOGTAG "%s: sdp remove record failed, status %d", __FUNCTION__, status);
+        return;
+    }
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    opp.rec_handle = -1;
+    setOppState(STATE_INITIAL);
+}
+
+static void sdp_search_callback(bt_status_t status, bt_bdaddr_t *bd_addr, uint8_t* uuid,
+            bluetooth_sdp_record *record, bool more_result)
+{
+    char bd_str[MAX_BD_STR_LEN];
+
+    if (status) {
+        ALOGE(LOGTAG "%s: sdp search failed, status %d", __FUNCTION__, status);
+        fprintf(stdout, "Sdp search failed can't proceed with connection\n");
+        return;
+    }
+    ALOGE(LOGTAG "%s", __FUNCTION__);
+    if (IS_UUID(UUID_OBEX_OBJECT_PUSH, uuid)) {
+        bdaddr_to_string(bd_addr, bd_str, MAX_BD_STR_LEN);
+        ALOGE(LOGTAG "%s: status %d, addr %s, L2CAP PSM = %d, "
+            "RFCOMM channel = %d, profile version = 0x%04x, "
+            "supported supported_formats_list_len = %d"
+            "more results = %d", __FUNCTION__, status, bd_str,
+            record->ops.hdr.l2cap_psm,
+            record->ops.hdr.rfcomm_channel_number,
+            record->ops.hdr.profile_version,
+            record->ops.supported_formats_list_len,
+            more_result);
+        if (record->ops.hdr.rfcomm_channel_number > 0 ||
+            record->ops.hdr.l2cap_psm > 0) {
+            if (record->ops.hdr.l2cap_psm > 0 &&
+                record->ops.hdr.profile_version >= profileVersion) {
+                opp.lowerProtocol.protocol = OI_OBEX_LOWER_L2CAP;
+                opp.lowerProtocol.svcId.l2capPSM = record->ops.hdr.l2cap_psm;
+            } else {
+                opp.lowerProtocol.protocol = OI_OBEX_LOWER_RFCOMM;
+                opp.lowerProtocol.svcId.rfcommChannel =
+                    record->ops.hdr.rfcomm_channel_number;
+            }
+            /* Send Internal Connect Message to OPP Thread */
+            BtEvent *event = new BtEvent;
+            event->event_id = OPP_INTERNAL_CONNECT;
+            PostMessage(THREAD_ID_OPP, event);
+        } else {
+            ALOGE(LOGTAG "%s: Could not find remote rfcomm channel or l2cap psm, can't connect",
+                 __FUNCTION__);
+            fprintf(stdout, "Could not find remote rfcomm channel or l2cap psm, can't connect\n");
+        }
+    } else {
+        ALOGE(LOGTAG "%s: Unknown uuid sdp result received, ignoring!!", __FUNCTION__);
+        fprintf(stdout, "Unknown uuid sdp result received, ignoring!!\n");
+    }
+}
+
+bool getMimeTypeFromFileExt(OI_CHAR * fileExt)
+{
+    int i;
+
+    if (fileExt == NULL)
+        return false;
+
+    for (i = 0; i < opp.numOfEntries; i ++) {
+        if (!strncmp (opp.fileTypeData[i].ext, fileExt, strlen(fileExt))) {
+            /* Match Found */
+            strlcpy(opp.mimeType, opp.fileTypeData[i].mimeType,
+                strlen(opp.fileTypeData[i].mimeType));
+            return true;
+        }
+    }
+    return false;
+}
+
+void Opp::ProcessEvent(BtEvent* pEvent)
+{
+    ALOGD(LOGTAG "%s: Processing event %d", __FUNCTION__, pEvent->event_id);
+
+    switch(pEvent->event_id) {
+
+        case OPP_SRV_REGISTER:
+            AddSdpRecord();
+            break;
+
+        case OPP_SEND_DATA:
+            strlcpy((char *)opp.fileName, pEvent->opp_event.value, MAX_NAME_LEN);
+            opp.fileExt = strrchr(opp.fileName, '.');
+            if (opp.fileExt != NULL) {
+                opp.fileExt = opp.fileExt+ 1;
+                ALOGW(LOGTAG "%s: File extension %s", __FUNCTION__, opp.fileExt);
+            } else {
+                ALOGW(LOGTAG "%s: invalid type of file being sent, please send valid file",
+                    __FUNCTION__, opp.fileName);
+                OI_Printf("invalid type of file being sent, please send valid file");
+                break;
+            }
+            memset(opp.mimeType, 0 , MAX_NAME_LEN);
+            if (getMimeTypeFromFileExt(opp.fileExt)) {
+                PerformSdp(&pEvent->opp_event.bd_addr);
+            } else {
+                ALOGE(LOGTAG "%s: Unable to find mime type for extension %s, can't proceed",
+                    __FUNCTION__, opp.fileExt);
+            }
+            break;
+
+        case OPP_INTERNAL_CONNECT:
+            Connect();
+            break;
+
+        case OPP_INTERNAL_SEND:
+            SendData();
+            break;
+
+        case OPP_CONNECT_TIMEOUT:
+            HandleConnectTimeout(&pEvent->opp_event.bd_addr);
+            break;
+
+        case OPP_INTERNAL_DISCONNECTION:
+            Disconnect();
+            break;
+
+        case OPP_ABORT_TRANSFER:
+            Abort();
+            break;
+
+        case OPP_INCOMING_FILE_RESPONSE:
+            IncomingFileRsp(pEvent->opp_event.accept);
+            break;
+
+        default:
+            ALOGW(LOGTAG "%s: unhandled event: %d", __FUNCTION__, pEvent->event_id);
+            break;
+    }
+}
+
+void Opp :: AddSdpRecord()
+{
+    if (getOppState() >= STATE_IDLE) {
+        fprintf(stdout, "Already registered \n");
+        return;
+    }
+    /* Add OPP Server SDP Record */
+    BtEvent *sdp_search_event = new BtEvent;
+    sdp_search_event->sdp_client_event.event_id = SDP_CLIENT_ADD_RECORD;
+    memset(&sdp_search_event->sdp_client_event.record, 0 , sizeof(bluetooth_sdp_record));
+    sdp_search_event->sdp_client_event.record.ops.hdr.type = SDP_TYPE_OPP_SERVER;
+    sdp_search_event->sdp_client_event.record.ops.hdr.profile_version = profileVersion;
+    sdp_search_event->sdp_client_event.record.ops.hdr.service_name = profile_name;
+    sdp_search_event->sdp_client_event.record.ops.hdr.service_name_length = strlen(profile_name);
+    sdp_search_event->sdp_client_event.record.ops.hdr.rfcomm_channel_number = RFCOMM_PREF_OPP_SRV;
+    sdp_search_event->sdp_client_event.record.ops.hdr.l2cap_psm = L2CAP_PREF_OPP_SRV;
+    memset(sdp_search_event->sdp_client_event.record.ops.supported_formats_list,
+        0, sizeof(OPP_FORMAT_ALL));
+    sdp_search_event->sdp_client_event.record.ops.supported_formats_list_len =
+        sizeof(OPP_FORMAT_ALL);
+    sdp_search_event->sdp_client_event.addRecordCb = &sdp_add_record_callback;
+    PostMessage(THREAD_ID_SDP_CLIENT, sdp_search_event);
+}
+
+void Opp :: RemoveSdpRecord()
+{
+    if (getOppState() == STATE_INITIAL) {
+        ALOGE(LOGTAG "Already un-registered ");
+        return;
+    }
+    if (opp.rec_handle != -1) {
+        /* Remove OPP Server SDP Record */
+        BtEvent *sdp_search_event = new BtEvent;
+        sdp_search_event->sdp_client_event.event_id = SDP_CLIENT_REMOVE_RECORD;
+        sdp_search_event->sdp_client_event.removeRecordCb = &sdp_remove_record_callback;
+        sdp_search_event->sdp_client_event.rec_handle = opp.rec_handle;
+        PostMessage(THREAD_ID_SDP_CLIENT, sdp_search_event);
+    }
+}
+
+bool Opp :: PerformSdp(bt_bdaddr_t *addr)
+{
+    bool ret = true;
+    char bd_str[MAX_BD_STR_LEN];
+
+    if (!addr) {
+        ALOGE(LOGTAG "%s: Bluetooth device address null", __FUNCTION__);
+        return false;
+    }
+    bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+    if (getOppState() == STATE_INITIAL) {
+        ALOGE(LOGTAG "%s: Not registered, please register before connecting!!", __FUNCTION__);
+        fprintf(stdout, "Not registered, please register before connecting!!\n");
+        return false;
+    } else if (getOppState() == STATE_CONNECTING) {
+        ALOGE(LOGTAG "%s: Currently connecting to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Currently connecting to %s\n", bd_str);
+        return false;
+    } else if (getOppState() >= STATE_CONNECTED) {
+        ALOGE(LOGTAG "%s: Already connected to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Already connected to %s\n", bd_str);
+        return false;
+    }
+    memcpy(&opp.addr, addr, sizeof(bt_bdaddr_t));
+    bdaddr_to_string(addr, bd_str, MAX_BD_STR_LEN);
+    ALOGV(LOGTAG "%s: %s", __FUNCTION__, bd_str);
+    BtEvent *sdp_search_event = new BtEvent;
+    /* Perform SDP to determine OPP Server Record */
+    sdp_search_event->sdp_client_event.event_id = SDP_CLIENT_SEARCH;
+    memcpy(&sdp_search_event->sdp_client_event.bd_addr, &opp.addr, sizeof(bt_bdaddr_t));
+    sdp_search_event->sdp_client_event.uuid = UUID_OBEX_OBJECT_PUSH;
+    sdp_search_event->sdp_client_event.searchCb = &sdp_search_callback;
+    PostMessage(THREAD_ID_SDP_CLIENT, sdp_search_event);
+
+    return ret;
+}
+
+bool Opp :: Connect()
+{
+    char bd_str[MAX_BD_STR_LEN];
+    if (getOppState() == STATE_CONNECTING) {
+        bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+        ALOGE(LOGTAG "%s: Already connecting to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Already connecting to %s\n", bd_str);
+        return false;
+    }
+    if (getOppState() >= STATE_CONNECTED) {
+        bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+        ALOGE(LOGTAG "%s: Already connected to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Already connecting to %s\n", bd_str);
+        return false;
+    }
+
+    OI_STATUS ret = OI_OPPClient_Connect((OI_BD_ADDR*)&opp.addr,
+        &opp.lowerProtocol, &opp.clientConnectionHandle,
+        &ClientEventInd, &objSys);
+    ALOGV(LOGTAG "%s: OI_OPPClient_Connect returned %d", __FUNCTION__, ret);
+    if (ret) {
+        bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+        ALOGE(LOGTAG "%s: Failed to connect to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Failed to connect to %s\n", bd_str);
+    } else {
+         // start the profile connect timer
+        alarm_set(opp_connect_timer, OPP_CONNECT_TIMEOUT_DELAY,
+                            opp_connect_timer_expired, &opp.addr);
+        setOppState(STATE_CONNECTING);
+    }
+    return ret;
+}
+
+bool Opp :: SendData()
+{
+    OI_OBEX_UNICODE name;
+    name.str = (OI_CHAR16*)malloc(MAX_NAME_LEN);
+    name.len = strlen(opp.fileName) + 1;
+    OI_Utf8ToUtf16((const OI_UTF8*)opp.fileName,
+                    MAX_NAME_LEN, name.str, name.len);
+    OI_STATUS ret = OI_OPPClient_Push(opp.clientConnectionHandle, &name, (const OI_CHAR * )opp.mimeType);
+    free(name.str);
+    ALOGV(LOGTAG "%s: OI_OPPClient_Push returned %d", __FUNCTION__, ret);
+    if (ret) {
+        OI_OPPClient_Disconnect(opp.clientConnectionHandle);
+    }
+    return ret;
+}
+
+bool Opp :: HandleConnectTimeout(bt_bdaddr_t *addr)
+{
+    char bd_str[MAX_BD_STR_LEN];
+    bdaddr_to_string((const bt_bdaddr_t*)addr, bd_str, MAX_BD_STR_LEN);
+    fprintf(stdout, "Failed to Connect to %s due to ConnectionTimeout\n", bd_str);
+    opp.clientConnectionHandle = NULL;
+    setOppState(STATE_IDLE);
+    opp.lowerProtocol.protocol = OI_OBEX_LOWER_NONE;
+    uint8_t zero[sizeof(bt_bdaddr_t)] = { 0 };
+    memcpy(&opp.addr, zero, sizeof(bt_bdaddr_t));
+    return true;
+}
+
+bool Opp :: Disconnect()
+{
+    bool ret = true;
+    char bd_str[MAX_BD_STR_LEN];
+
+    if (getOppState() != STATE_CONNECTED ) {
+        ALOGE(LOGTAG "%s: not connected", __FUNCTION__);
+        fprintf(stdout, "Not connected \n");
+        return false;
+    }
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+
+    OI_STATUS status = OI_OPPClient_Disconnect(opp.clientConnectionHandle);
+    if (status != OI_STATUS_SUCCESS) {
+        ret = false;
+        char bd_str[MAX_BD_STR_LEN];
+        bdaddr_to_string((const bt_bdaddr_t*)&opp.addr, bd_str, MAX_BD_STR_LEN);
+        fprintf(stdout, "Failed to disconnect to %s\n", bd_str);
+        ALOGE(LOGTAG "%s: Failed disconnect %s status: %d", __FUNCTION__, bd_str, status);
+    }
+    return ret;
+}
+
+bool Opp :: Abort()
+{
+    bool ret = true;
+    OI_STATUS status;
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    if (getOppState() != STATE_SENDING && getOppState() != STATE_RECEIVING) {
+        ALOGE(LOGTAG "%s: Data transfer not ongoing, can't abort", __FUNCTION__);
+        fprintf(stdout, "Data transfer not ongoing, can't abort\n");
+        return false;
+    }
+    opp.abort = true;
+    if (opp.clientConnectionHandle && getOppState() == STATE_SENDING)
+        status = OI_OPPClient_Cancel(opp.clientConnectionHandle, &AbortCfmCb);
+    else if (opp.srvConnectionHandle && getOppState() == STATE_RECEIVING)
+        status = OI_OPPServer_ForceDisconnect(opp.srvConnectionHandle);
+    if (status != OI_STATUS_SUCCESS) {
+        ALOGE(LOGTAG "%s: Failed to abort ongoing operation, status: %d", __FUNCTION__, status);
+        opp.abort = false;
+        ret = false;
+    } else {
+        fprintf(stdout, "Abort in progress!!\n");
+    }
+    return ret;
+}
+
+bool Opp :: IncomingFileRsp(bool accept)
+{
+    bool ret = true;
+    OI_STATUS status;
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    if (getOppState() != STATE_RECEIVING) {
+        ALOGE(LOGTAG "%s: File not being received", __FUNCTION__);
+        return false;
+    }
+    if (accept) {
+        OI_Time_Now(&serverStartTime);
+        if (opp.defaultName) {
+            OI_OBEX_UNICODE objName;
+            /*
+             * Rename object.
+             */
+            opp.defaultName = FALSE;
+            FilenameToObjname(&objName, noNameFileStoreLocation);
+            OI_OPPServer_AcceptPush(opp.srvConnectionHandle, &objName, TRUE);
+        } else {
+            OI_OBEX_UNICODE name;
+            name.str = (OI_CHAR16*)malloc(MAX_NAME_LEN);
+            name.len = strlen(opp.fileName) + 1;
+            OI_Utf8ToUtf16((const OI_UTF8*)opp.fileName,
+                            MAX_NAME_LEN, name.str, name.len);
+            ALOGE(LOGTAG "%s: Accepting Incoming File", __FUNCTION__);
+            OI_OPPServer_AcceptPush(opp.srvConnectionHandle, &name, TRUE);
+            free(name.str);
+        }
+    } else {
+        setOppState(STATE_CONNECTED);
+        ALOGE(LOGTAG "%s: Rejecting Incoming File", __FUNCTION__);
+        OI_OPPServer_AcceptPush(opp.srvConnectionHandle, NULL, FALSE);
+    }
+    return ret;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/bt-app/osi/Makefile.am b/bt-app/osi/Makefile.am
old mode 100755
new mode 100644
index bc59568..1a52804
--- a/bt-app/osi/Makefile.am
+++ b/bt-app/osi/Makefile.am
@@ -28,6 +28,15 @@ c_sources = \
 requiredlibs = -lpthread
 library_includedir = $(pkgincludedir)\
 library_include_HEADERS = $(h_sources)
+if USE_GST
+lib_LTLIBRARIES = libgstbtapposi.la
+libgstbtapposi_la_CC = @CC@
+libgstbtapposi_la_SOURCES = $(c_sources)
+libgstbtapposi_la_CPPFLAGS =$(AM_CPPFLAGS)
+libgstbtapposi_la_LIBADD = $(requiredlibs)
+libgstbtapposi_la_CFLAGS = $(AM_CFLAGS) -fPIC -D_GNU_SOURCE -DUSE_GLIB
+libgstbtapposi_la_LDFLAGS = -static
+else
 lib_LTLIBRARIES = libbtapposi.la
 libbtapposi_la_CC = @CC@
 libbtapposi_la_SOURCES = $(c_sources)
@@ -35,3 +44,4 @@ libbtapposi_la_CPPFLAGS =$(AM_CPPFLAGS)
 libbtapposi_la_LIBADD = $(requiredlibs)
 libbtapposi_la_CFLAGS = $(AM_CFLAGS) -fPIC -D_GNU_SOURCE -DUSE_GLIB
 libbtapposi_la_LDFLAGS = -static
+endif
diff --git a/bt-app/osi/include/config.h b/bt-app/osi/include/config.h
index 6a13dae..c879058 100644
--- a/bt-app/osi/include/config.h
+++ b/bt-app/osi/include/config.h
@@ -43,7 +43,7 @@ config_t *config_new(const char *filename);
 // Frees resources associated with the config file. No further operations may
 // be performed on the |config| object after calling this function. |config|
 // may be NULL.
-void config_free(config_t *config);
+void config_remove(config_t *config);
 
 // Returns true if the config file contains a section named |section|. If
 // the section has no key/value pairs in it, this function will return false.
diff --git a/bt-app/osi/include/log.h b/bt-app/osi/include/log.h
index 9d3cb5e..e3ed0e2 100644
--- a/bt-app/osi/include/log.h
+++ b/bt-app/osi/include/log.h
@@ -21,7 +21,6 @@
 #include <limits.h>
 #include <stdio.h>
 #include <unistd.h>
-#include <syslog.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -29,7 +28,13 @@ extern "C" {
 
 #define TAG "bt_app"
 
-
+#ifdef USE_ANDROID_LOGGING
+#include <utils/Log.h>
+#define LOG_TAG "bt_app"
+#define LOG_DEBUG ALOGD
+#define LOG_ERROR ALOGE
+#else
+#include <syslog.h>
 #define ALOGV(fmt, arg...) syslog (LOG_WARNING, fmt, ##arg)
 #define ALOGD(fmt, arg...) syslog (LOG_NOTICE, fmt, ##arg)
 #define ALOGI(fmt, arg...) syslog (LOG_INFO, fmt, ##arg)
@@ -38,6 +43,7 @@ extern "C" {
 
 #define LOG_DEBUG(fmt, arg...) syslog (LOG_NOTICE, fmt, ##arg)
 #define LOG_ERROR(fmt, arg...) syslog (LOG_ERR, fmt, ##arg)
+#endif
 
 #ifdef __cplusplus
 }
diff --git a/bt-app/osi/src/config.c b/bt-app/osi/src/config.c
index ec00ea3..fd520e0 100644
--- a/bt-app/osi/src/config.c
+++ b/bt-app/osi/src/config.c
@@ -75,7 +75,7 @@ config_t *config_new_empty(void) {
   return config;
 
 error:;
-  config_free(config);
+  config_remove(config);
   return NULL;
 }
 
@@ -89,7 +89,7 @@ config_t *config_new(const char *filename) {
   FILE *fp = fopen(filename, "rt");
   if (!fp) {
     LOG_ERROR("%s unable to open file '%s': %s", __func__, filename, strerror(errno));
-    config_free(config);
+    config_remove(config);
     return NULL;
   }
   config_parse(fp, config);
@@ -97,7 +97,7 @@ config_t *config_new(const char *filename) {
   return config;
 }
 
-void config_free(config_t *config) {
+void config_remove(config_t *config) {
   if (!config)
     return;
 
diff --git a/bt-app/pan/include/Pan.hpp b/bt-app/pan/include/Pan.hpp
index e50c26b..e46d8c2 100644
--- a/bt-app/pan/include/Pan.hpp
+++ b/bt-app/pan/include/Pan.hpp
@@ -43,6 +43,11 @@
 #include "osi/include/config.h"
 #include "ipc.h"
 
+#ifdef USE_GLIB
+#include <glib.h>
+#define strlcpy g_strlcpy
+#endif
+
 #define MAX_LENGTH_INTERFACE_NAME 10
 #define MAX_PAN_DEVICES 3
 
@@ -79,7 +84,8 @@ typedef enum
 {
     TETHERED,
     REVERSE_TETHERED,
-    UNTETHERED
+    UNTETHERED,
+    PENDING
 } pan_profile_state_t;
 
 class Pan {
@@ -98,6 +104,7 @@ class Pan {
         void HandlePanControlStateEvent(PanControlStateEvent *event);
         void HandlePanConnectionStateEvent(PanConnectionStateEvent *event);
         void HandlePanSetTetheringEvent(PanSetTetheringEvent *event);
+        void HandlePanGetModeEvent(PanGetModeEvent *event);
         void HandlePanDeviceConnectEvent(PanDeviceConnectEvent *event);
         void HandlePanDeviceDisconnectEvent(PanDeviceDisconnectEvent *event);
         void HandlePanDeviceConnectedListEvent(PanDeviceConnectedListEvent *event);
diff --git a/bt-app/pan/src/Pan.cpp b/bt-app/pan/src/Pan.cpp
index 87846a7..69673b4 100644
--- a/bt-app/pan/src/Pan.cpp
+++ b/bt-app/pan/src/Pan.cpp
@@ -234,6 +234,15 @@ bool Pan :: Connect(bt_bdaddr_t *addr, int src_role, int dest_role)
     bool ret = true;
     char bd_str[MAX_BD_STR_LEN];
 
+    if (src_role == LOCAL_PANU_ROLE && (is_panu_role_supported == false
+        || pan_state != UNTETHERED)) {
+        PAN_APP_UI_PRINT("\nPANU role is not supported OR PAN connection is already active\n");
+        ALOGE(LOGTAG "%s: PANU role is not supported OR PAN connection is already active:"
+                "is_panu_role_supported: %d, pan_State: %d",
+                __FUNCTION__, is_panu_role_supported, pan_state);
+        return false;
+    }
+
     bdaddr_to_string(addr, bd_str, MAX_BD_STR_LEN);
     ALOGV(LOGTAG "%s: %s, src_role: %d, dest_role:%d",
             __FUNCTION__, bd_str, src_role, dest_role);
@@ -283,9 +292,9 @@ bool Pan :: Disconnect(bt_bdaddr_t *addr)
 bool Pan :: HandleEnablePan() {
     ALOGV(LOGTAG "%s", __FUNCTION__);
 
-    is_tethering_on = is_nap_role_supported;
     pan_state = UNTETHERED;
     num_of_pan_device_connected = 0;
+    is_tethering_on = false;
 
     for (int i = 0; i < MAX_PAN_DEVICES; i++) {
         memcpy(&(pan_device[i].bd_addr), &bd_addr_null, sizeof(bt_bdaddr_t));
@@ -335,7 +344,7 @@ void Pan::HandlePanDeviceConnectedListEvent(PanDeviceConnectedListEvent *event)
             PAN_APP_UI_PRINT("%s \n", bd_str);
         }
     }
-    PAN_APP_UI_PRINT("\n*****End Connected Device List*****\n");
+    PAN_APP_UI_PRINT("*****End Connected Device List*****\n");
 }
 
 
@@ -373,7 +382,7 @@ void Pan::HandlePanControlStateEvent(PanControlStateEvent *event)
 {
     ALOGV(LOGTAG "%s", __FUNCTION__);
 
-    strcpy(pan_interface_name, event->ifname);
+    strlcpy(pan_interface_name, event->ifname, sizeof(pan_interface_name));
 }
 
 void Pan::HandlePanConnectionStateEvent(PanConnectionStateEvent *event)
@@ -422,7 +431,8 @@ void Pan::HandlePanConnectionStateEvent(PanConnectionStateEvent *event)
             RemoveDevice(pan_dev);
             num_of_pan_device_connected--;
 
-            if (pan_state == TETHERED && num_of_pan_device_connected == 0) {
+            if ((pan_state == TETHERED || pan_state == PENDING)
+                && num_of_pan_device_connected == 0) {
                 BtEvent *event = new BtEvent;
                 event->event_id = SKT_API_IPC_MSG_WRITE;
                 event->bt_ipc_msg_event.ipc_msg.type = BT_IPC_DISABLE_TETHERING;
@@ -435,7 +445,8 @@ void Pan::HandlePanConnectionStateEvent(PanConnectionStateEvent *event)
             PAN_APP_UI_PRINT("%s IS CONNECTED\n", bd_str);
             num_of_pan_device_connected++;
 
-            if((!is_tethering_on)||(pan_dev->local_role == LOCAL_PANU_ROLE)){
+            if ((!is_tethering_on) || (pan_dev->local_role == LOCAL_PANU_ROLE
+                || pan_state == REVERSE_TETHERED)){
                 ALOGW(LOGTAG "%s: BT tethering is off/Local role is PANU drop the connection",
                         __FUNCTION__);
                 Disconnect(&pan_dev->bd_addr);
@@ -447,12 +458,45 @@ void Pan::HandlePanConnectionStateEvent(PanConnectionStateEvent *event)
                 event->event_id = SKT_API_IPC_MSG_WRITE;
                 event->bt_ipc_msg_event.ipc_msg.type = BT_IPC_ENABLE_TETHERING;
                 event->bt_ipc_msg_event.ipc_msg.status = INITIATED;
+
+                pan_state = PENDING;
                 ALOGV (LOGTAG "%s: Posting msg main thread: enable tethering", __FUNCTION__);
                 PostMessage (THREAD_ID_MAIN, event);
             }
         }
-    } else {
-        ALOGW(LOGTAG "%s: LOCAL_PANU_ROLE:REMOTE_NAP_ROLE not supported", __FUNCTION__);
+    } else if (pan_dev->remote_role == REMOTE_NAP_ROLE) {
+        ALOGW(LOGTAG "%s: LOCAL_PANU_ROLE:REMOTE_NAP_ROLE", __FUNCTION__);
+
+        if (pan_dev->state == BTPAN_STATE_DISCONNECTED) {
+            bdaddr_to_string((&pan_dev->bd_addr), bd_str, MAX_BD_STR_LEN);
+            PAN_APP_UI_PRINT("%s IS DISCONNECTED\n", bd_str);
+            RemoveDevice(pan_dev);
+
+            if (pan_state == REVERSE_TETHERED || pan_state == PENDING) {
+                BtEvent *event = new BtEvent;
+                event->event_id = SKT_API_IPC_MSG_WRITE;
+                event->bt_ipc_msg_event.ipc_msg.type = BT_IPC_DISABLE_REVERSE_TETHERING;
+                event->bt_ipc_msg_event.ipc_msg.status = INITIATED;
+                ALOGV (LOGTAG "%s: Posting msg main thread: disable reverse tethering",
+                        __FUNCTION__);
+                PostMessage (THREAD_ID_MAIN, event);
+            }
+        } else if (pan_dev->state == BTPAN_STATE_CONNECTED) {
+            bdaddr_to_string((&pan_dev->bd_addr), bd_str, MAX_BD_STR_LEN);
+            PAN_APP_UI_PRINT("%s IS CONNECTED\n", bd_str);
+
+            if (pan_state == UNTETHERED) {
+                BtEvent *event = new BtEvent;
+                event->event_id = SKT_API_IPC_MSG_WRITE;
+                event->bt_ipc_msg_event.ipc_msg.type = BT_IPC_ENABLE_REVERSE_TETHERING;
+                event->bt_ipc_msg_event.ipc_msg.status = INITIATED;
+
+                pan_state = PENDING;
+                ALOGV (LOGTAG "%s: Posting msg main thread: enable reverse tethering",
+                        __FUNCTION__);
+                PostMessage (THREAD_ID_MAIN, event);
+            }
+        }
     }
 }
 
@@ -461,9 +505,6 @@ void Pan::HandlePanSetTetheringEvent(PanSetTetheringEvent *event)
     ALOGV(LOGTAG "%s", __FUNCTION__);
 
     if (is_nap_role_supported) {
-        ALOGV(LOGTAG "%s: prev_tether_val: %d, curr_tether_val = %d",
-                 __FUNCTION__, is_tethering_on, event->is_tethering_on);
-
          if (is_tethering_on == event->is_tethering_on) {
              ALOGW(LOGTAG "%s: prev_tether_val is equal to curr_tether_val", __FUNCTION__);
              return;
@@ -479,11 +520,47 @@ void Pan::HandlePanSetTetheringEvent(PanSetTetheringEvent *event)
                 }
             }
         }
+
+        if (pan_interface !=NULL) {
+            ALOGE(LOGTAG "%s: Notifying BT tethering UI status to BNEP layer", __FUNCTION__);
+            pan_interface->set_tethering(is_tethering_on);
+        }
+
+        PAN_APP_UI_PRINT("\n*****TETHER MODE UI OPTION SUCCESSFULLY CHANGED*****\n");
     } else {
         ALOGW(LOGTAG "%s: LOCAL_NAP_ROLE not supported", __FUNCTION__);
+        PAN_APP_UI_PRINT("\n*****LOCAL_NAP_ROLE not supported*****\n");
+    }
+}
+
+void Pan::HandlePanGetModeEvent(PanGetModeEvent *event)
+{
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    PAN_APP_UI_PRINT("\n*****TETHER MODE UI OPTION: %s*****\n",
+        is_tethering_on ? "ENABLED": "DISABLED");
+
+    switch (pan_state) {
+        case UNTETHERED:
+            PAN_APP_UI_PRINT("\n*****PAN IS IN UNTETHERED MODE*****\n");
+            break;
+
+        case TETHERED:
+            PAN_APP_UI_PRINT("\n*****PAN IS IN TETHERED MODE*****\n");
+            break;
+
+        case REVERSE_TETHERED:
+            PAN_APP_UI_PRINT("\n*****PAN IS IN REVERSE TETHERED MODE*****\n");
+            break;
+
+        default:
+            //This should never happen
+            PAN_APP_UI_PRINT("\n*****PAN IS IN UNKNOWN MODE*****\n");
+            break;
+
     }
 }
 
+
 void Pan::HandlePanIpcMsg(BtIpcMsg *ipcMsg)
 {
     ALOGV(LOGTAG "%s: ipcMsg->type: %d, ipcMsg->status = %d",
@@ -495,6 +572,7 @@ void Pan::HandlePanIpcMsg(BtIpcMsg *ipcMsg)
                 case SUCCESS:
                     ALOGV(LOGTAG "%s: BT_IPC_ENABLE_TETHERING: SUCCESS", __FUNCTION__);
                     pan_state  = TETHERED;
+                    PAN_APP_UI_PRINT("\n*****PAN IS IN TETHERED MODE*****\n");
                     break;
 
                 case FAILED:
@@ -507,6 +585,7 @@ void Pan::HandlePanIpcMsg(BtIpcMsg *ipcMsg)
                             Disconnect(&(pan_device[i].bd_addr));
                         }
                     }
+                    PAN_APP_UI_PRINT("\n*****PAN IS IN UNTETHERED MODE*****\n");
                     break;
 
                 default:
@@ -520,11 +599,13 @@ void Pan::HandlePanIpcMsg(BtIpcMsg *ipcMsg)
                 case SUCCESS:
                     ALOGV(LOGTAG "%s: BT_IPC_DISABLE_TETHERING: SUCCESS", __FUNCTION__);
                     pan_state  = UNTETHERED;
+                    PAN_APP_UI_PRINT("\n*****PAN IS IN UNTETHERED MODE*****\n");
                     break;
 
                 case FAILED:
                     ALOGV(LOGTAG "%s: BT_IPC_DISABLE_TETHERING: FAILED", __FUNCTION__);
                     pan_state  = UNTETHERED;
+                    PAN_APP_UI_PRINT("\n*****PAN IS IN UNTETHERED MODE*****\n");
                     break;
 
                 default:
@@ -541,6 +622,63 @@ void Pan::HandlePanIpcMsg(BtIpcMsg *ipcMsg)
             }
             break;
 
+        case BT_IPC_ENABLE_REVERSE_TETHERING:
+            switch(ipcMsg->status){
+                case SUCCESS:
+                    ALOGV(LOGTAG "%s: BT_IPC_ENABLE_REVERSE_TETHERING: SUCCESS", __FUNCTION__);
+                    pan_state  = REVERSE_TETHERED;
+                    PAN_APP_UI_PRINT("\n*****PAN IS IN REVERSE TETHERED MODE*****\n");
+                    break;
+
+                case FAILED:
+                    ALOGV(LOGTAG "%s: BT_IPC_ENABLE_REVERSE_TETHERING: FAILED: drop pan connection",
+                            __FUNCTION__);
+                    pan_state  = UNTETHERED;
+
+                    for (int i = 0; i < MAX_PAN_DEVICES; i++) {
+                        if (pan_device[i].state == BTPAN_STATE_CONNECTED) {
+                            Disconnect(&(pan_device[i].bd_addr));
+                        }
+                    }
+                    PAN_APP_UI_PRINT("\n*****PAN IS IN UNTETHERED MODE*****\n");
+                    break;
+
+                default:
+                    ALOGW(LOGTAG "%s: unhandled status: %d", __FUNCTION__, ipcMsg->status);
+                    break;
+            }
+            break;
+
+        case BT_IPC_DISABLE_REVERSE_TETHERING:
+            switch(ipcMsg->status){
+                case SUCCESS:
+                    ALOGV(LOGTAG "%s: BT_IPC_DISABLE_REVERSE_TETHERING: SUCCESS", __FUNCTION__);
+                    pan_state  = UNTETHERED;
+                    PAN_APP_UI_PRINT("\n*****PAN IS IN UNTETHERED MODE*****\n");
+                    break;
+
+                case FAILED:
+                    ALOGV(LOGTAG "%s: BT_IPC_DISABLE_REVERSE_TETHERING: FAILED", __FUNCTION__);
+                    pan_state  = UNTETHERED;
+                    PAN_APP_UI_PRINT("\n*****PAN IS IN UNTETHERED MODE*****\n");
+                    break;
+
+                default:
+                    ALOGW(LOGTAG "%s: unhandled status: %d", __FUNCTION__, ipcMsg->status);
+                    break;
+            }
+
+            ALOGV (LOGTAG "%s: BT_IPC_DISABLE_REVERSE_TETHERING: drop all pan connection",
+                    __FUNCTION__);
+
+            for (int i = 0; i < MAX_PAN_DEVICES; i++) {
+                if (pan_device[i].state == BTPAN_STATE_CONNECTED) {
+                    Disconnect(&(pan_device[i].bd_addr));
+                }
+            }
+            break;
+
+
         default:
             ALOGW(LOGTAG "%s: unhandled ipc msg: %d", __FUNCTION__, ipcMsg->type);
             break;
@@ -564,6 +702,10 @@ void Pan::ProcessEvent(BtEvent* event)
             HandlePanSetTetheringEvent((PanSetTetheringEvent *)event);
             break;
 
+        case PAN_EVENT_GET_MODE_REQ:
+            HandlePanGetModeEvent((PanGetModeEvent *)event);
+            break;
+
         case PAN_EVENT_DEVICE_CONNECT_REQ:
             HandlePanDeviceConnectEvent((PanDeviceConnectEvent *)event);
             break;
diff --git a/bt-app/pbap_client/include/PbapClient.hpp b/bt-app/pbap_client/include/PbapClient.hpp
new file mode 100644
index 0000000..7fa553d
--- /dev/null
+++ b/bt-app/pbap_client/include/PbapClient.hpp
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef PBAP_CLIENT_APP_H
+#define PBAP_CLIENT_APP_H
+
+#pragma once
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_sock.h>
+#include <hardware/bt_sdp.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "osi/include/alarm.h"
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "ipc.h"
+
+#ifdef USE_GLIB
+#include <glib.h>
+#define strlcpy g_strlcpy
+#endif
+
+extern const char *BT_PBAP_CLIENT_ENABLED;
+#define PBAP_CONNECT_TIMEOUT_DELAY     (30000)
+
+class PbapClient {
+    private:
+        const bt_interface_t * bluetooth_interface;
+        config_t *config;
+
+        void AddSdpRecord();
+        bool PerformSdp(bt_bdaddr_t *addr);
+        bool Connect();
+        bool HandleConnectTimeout(bt_bdaddr_t *addr);
+        bool Disconnect(bt_bdaddr_t *addr);
+        bool GetPhonebookSize();
+        bool GetPhonebook();
+        bool GetVcard(const char *handle);
+        bool GetVcardListing();
+        bool SetPath(const char *str);
+        bool Abort();
+
+    public:
+        PbapClient(const bt_interface_t *bt_interface, config_t *config);
+        ~PbapClient();
+        alarm_t *pbap_connect_timer;
+        void ProcessEvent(BtEvent* pEvent);
+        void RemoveSdpRecord();
+};
+
+#endif
+
diff --git a/bt-app/pbap_client/src/PbapClient.cpp b/bt-app/pbap_client/src/PbapClient.cpp
new file mode 100644
index 0000000..ed2249f
--- /dev/null
+++ b/bt-app/pbap_client/src/PbapClient.cpp
@@ -0,0 +1,1756 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <iostream>
+#include <list>
+#include <map>
+#include "osi/include/log.h"
+#include "osi/include/compat.h"
+#include "PbapClient.hpp"
+#include "utils.h"
+#include "oi_obex.h"
+#include "oi_obex_lower.h"
+#include "oi_pbap_client.h"
+#include "oi_utils.h"
+#include "oi_assert.h"
+#include <string.h>
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define LOGTAG "PBAPClient "
+
+using namespace std;
+
+PbapClient *g_pbapClient = NULL;;
+
+typedef enum {
+    DOWNLOAD                = 0x0001,
+    BROWSING                = 0x0002,
+    DATABASE_IDENTIFIER     = 0x0004,
+    FOLDER_VERSION_COUNTER  = 0x0008,
+    VCARD_SELECTING         = 0x0010,
+    ENHANCE_MISESD_CALLS    = 0x0020,
+    X_BT_UCI_VCARD_PROP     = 0x0040,
+    X_BT_UID_VCARD_PROP     = 0x0080,
+    CONTACT_REFRENCING      = 0x0100,
+    DEFAULT_VCARD_FORMAT    = 0x0200,
+} PBAP_SUPPORTED_FEATURES;
+
+static uint8_t  UUID_PBAP_PSE[] = {0x00, 0x00, 0x11, 0x2F, 0x00, 0x00, 0x10, 0x00,
+                                   0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB};
+static  uint32_t profileVersion = 0x0102;
+static char profile_name[] = "PBAP Client";
+static char storageDir[] = "/data/misc/bluetooth/";
+static char vcardFile[] = "vcard.vcf";
+static char phoneBookFile[] = "pb.txt";
+static char vCardListingFile[] = "vcarListing.txt";
+
+#define UUID_MAX_LENGTH 16
+#define IS_UUID(u1,u2)  !memcmp(u1,u2,UUID_MAX_LENGTH)
+
+/******************************************************************************
+ * Forward struct typedef
+ */
+typedef struct pbap_client_data_struct PBAP_CLIENT_DATA;
+
+/******************************************************************************
+
+/******************************************************************************
+ * Callback prototypes
+ */
+static void sdp_add_record_callback(bt_status_t status, int handle);
+static void sdp_remove_record_callback(bt_status_t status);
+static void sdp_search_callback(bt_status_t status, bt_bdaddr_t *bd_addr, uint8_t* uuid,
+            bluetooth_sdp_record *record, bool more_result);
+
+/******************************************************************************
+
+/******************************************************************************
+ * Function prototypes
+ */
+/* run-time variable access function prototypes */
+static void set_repository(const OI_CHAR *str);
+static void get_repository();
+static void set_phonebook(const OI_CHAR *str);
+static void get_phonebook();
+static void set_format(const OI_CHAR *str);
+static void get_format();
+static void set_filter(const OI_CHAR *str);
+static void get_filter();
+static void set_order(const OI_CHAR *str);
+static void get_order();
+
+/******************************************************************************
+ *
+ * Basic utilities.
+ *
+ */
+
+#ifndef isdelimiter
+#define isdelimiter(c) ((c) == ' ' || (c) == ',' || (c) == '\f' || (c) == '\n' || \
+        (c) == '\r' || (c) == '\t' || (c) == '\v')
+#endif
+
+#ifndef isdigit
+#define isdigit(c) ((c) >= '0' && (c) <= '9')
+#endif
+
+#ifndef ishexdigit
+#define ishexdigit(c) (((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f') || \
+        ((c) >= 'A' && (c) <= 'F'))
+#endif
+
+#ifndef toupper
+#define toupper(c) (((c) >= 'a') && ((c) <= 'z') ? ((c) - 32) : (c))
+#endif
+
+#ifndef tolower
+#define tolower(c) (((c) >= 'A') && ((c) <= 'Z') ? ((c) + 32) : (c))
+#endif
+
+/******************************************************************************
+ * Valid values for each PBAP client variable.
+ */
+static const OI_CHAR *valid_repositories[] = {
+    "local",
+    "sim1",
+    "unset"
+};
+
+static const OI_CHAR *valid_phonebooks[] = {
+    "pb",
+    "ich",
+    "och",
+    "mch",
+    "cch",
+    "unset"
+};
+
+static const OI_CHAR *valid_formats[] = {
+    "v2.1",
+    "v3.0"
+};
+
+static const OI_CHAR *valid_filters[] = {
+    "version",
+    "fn",
+    "n",
+    "photo",
+    "bday",
+    "adr",
+    "label",
+    "tel",
+    "email",
+    "mailer",
+    "tz",
+    "geo",
+    "title",
+    "role",
+    "logo",
+    "agent",
+    "org",
+    "note",
+    "rev",
+    "sound",
+    "url",
+    "uid",
+    "key",
+    "nickname",
+    "categories",
+    "proid",
+    "class",
+    "sort_string",
+    "call_daytime",
+    "all",  /* short cut to enable all fields */
+};
+
+static const OI_CHAR *valid_paths[] = {
+    "/telecom",
+    "/telecom/pb",
+    "/telecom/ich",
+    "/telecom/och",
+    "/telecom/mch",
+    "/telecom/cch",
+    "/SIM1/telecom/",
+    "/SIM1/telecom/pb",
+    "/SIM1/telecom/ich",
+    "/SIM1/telecom/och",
+    "/SIM1/telecom/mch",
+    "/SIM1/telecom/cch",
+};
+
+static const OI_CHAR *valid_orders[] = {
+    "indexed",
+    "alphabetical",
+    "phonetical"
+};
+
+static const OI_CHAR *valid_search_attribs[] = {
+    "name",
+    "number",
+    "sound"
+};
+
+typedef enum {
+    STATE_INITIAL,      /**< Initial state. */
+    STATE_IDLE,         /**< Idle state. */
+    STATE_CONNECTING,   /**< Connecting state. */
+    STATE_CONNECTED,     /**< Connected state. */
+    STATE_DEINITIALIZING, /**< De-initializing state. */
+} PBAP_STATE;
+
+/**
+This structure defines the PBAP client data structure.
+*/
+struct pbap_client_data_struct {
+    int rec_handle;                                 /**< Record Handle for PBAP Client SDP */
+    OI_PBAP_CONNECTION connection;                  /**< Connection ID to a server */
+    OI_OBEX_LOWER_PROTOCOL lowerProtocol;           /**< Lower protocol info of server */
+    OI_BOOL connected;                              /**< Indicates if connected to a server */
+    PBAP_STATE state;                               /**< Indicates current state of pbap client */
+    OI_UINT32 supportedFeatures;                    /**< Indicates supported features of pbap client */
+    OI_UINT16 pb_size;                              /**< Indicates phonebook size */
+    OI_BD_ADDR addr;                                /**< Remote PBAP server address */
+    OI_CHAR *fileName;                             /**< File Name of currently active pbap data being transferred */
+    OI_PBAP_REPOSITORY repository;                  /**< Run-time variable: current repository */
+    OI_PBAP_PHONEBOOK phonebook;                    /**< Run-time varialbe: current phonebook */
+    OI_PBAP_FORMAT_TAG_VALUES format;               /**< Run-time variable: vCard format */
+    OI_UINT64 filter;                               /**< Run-time variable: vCard entry filter */
+    OI_PBAP_ORDER_TAG_VALUES order;                 /**< Run-time variable: sorting order */
+    OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES searchAttribute; /**< Run-time variable: search attribute */
+    OI_UINT32 start_offset;                         /**< Run-time variable: vCard list start offset */
+    OI_UINT32 max_list_count;                       /**< Run-time variable: vCard max list count */
+    OI_BOOL abort;                                  /**< TRUE if current op is to be aborted */
+    OI_BOOL getting_phonebook;                      /**< TRUE if pulling phonebook data */
+    OI_BOOL getting_listing;                        /**< TRUE if pulling phonebook list */
+    OI_BOOL getting_vcard;                          /**< TRUE if pulling vcard */
+    OI_BOOL set_path;                               /**< TRUE if performing set path */
+    OI_BYTE *searchValue;                           /**< Search Value */
+    OI_UINT8 searchValueLen;                        /**< Search Value Length */
+};
+
+static PBAP_CLIENT_DATA pbap_client;
+
+/******************************************************************************
+ * This structure defines the PBAP client variable.
+ */
+typedef struct {
+    const OI_CHAR *name;            /**< Run-time variable name */
+    const OI_CHAR *description;     /**< Run-time variable description */
+    const OI_CHAR **valid_options;  /**< List of valid variable values */
+    OI_INT valid_option_cnt;        /**< Size of valid value list */
+} PBAP_CLIENT_VARIABLE;
+
+/******************************************************************************
+ * List of PBAP client variables.
+ */
+const PBAP_CLIENT_VARIABLE variable_list[] = {
+    { "repository", "Phonebook repository to access",
+        valid_repositories, OI_ARRAYSIZE(valid_repositories) - 1 },
+    { "phonebook", "Phonebook object to access",
+        valid_phonebooks, OI_ARRAYSIZE(valid_phonebooks) - 1 },
+    { "format", "vCard format of phonebook data", valid_formats, OI_ARRAYSIZE(valid_formats) },
+    { "filter", "vCard fields to get (use , separated list for multiple fields)",
+      valid_filters, OI_ARRAYSIZE(valid_filters) },
+    { "order", "vCard listing sort order", valid_orders, OI_ARRAYSIZE(valid_orders) },
+    { "attributes", "vCard listing search attributes", valid_search_attribs, OI_ARRAYSIZE(valid_search_attribs) },
+    { "path", "Virtual Paths to be set on Server", valid_paths, OI_ARRAYSIZE(valid_paths) },
+};
+
+/* PBAP data reception function prototypes */
+static OI_STATUS pb_open(const OI_OBEX_UNICODE *name, OI_PBAP_OPEN_CFM open_cfm,
+    OI_PBAP_CONNECTION connection);
+static void pb_close(OI_PBAP_HANDLE handle, OI_PBAP_CONNECTION pbapConnection, OI_STATUS status);
+static OI_STATUS pb_write(OI_PBAP_HANDLE handle, const OI_BYTE *buffer, OI_UINT16 buf_len,
+    OI_PBAP_WRITE_CFM write_cfm, OI_PBAP_CONNECTION connection);
+static void print_help(const PBAP_CLIENT_VARIABLE *var);
+
+static const OI_PBAP_CLIENT_FILESYS_FUNCTIONS pbap_file_ops = {
+    pb_open,
+    pb_close,
+    pb_write
+};
+
+/**
+ * skip_delimiter()
+ *
+ * This function returns a pointer to the first non-delimiter character.
+ */
+static const OI_CHAR * skip_delimiter(const OI_CHAR *data)
+{
+    OI_ASSERT(data);
+
+    while (*data && isdelimiter(*data)) {
+        data++;
+    }
+    return data;
+}
+
+/**
+ * find_str_in_list()
+ *
+ * Returns the index of an entry in a list of strings that matches the search
+ * string.
+ */
+static int find_str_in_list(const OI_CHAR *str, const OI_CHAR * const *list,
+                                   OI_INT list_size)
+{
+    OI_INT i;
+    OI_INT item = list_size;
+    OI_INT match_cnt = 0;
+    OI_UINT len;
+
+    OI_ASSERT(str);
+    OI_ASSERT(list);
+    OI_ASSERT(list_size > 0);
+
+    for (len = 0; (str[len] != '\0' && !isdelimiter(str[len])); len++);
+
+    for (i = 0; i < list_size; i++) {
+        if (!OI_StrncmpInsensitive(list[i], str, (OI_UINT16)len)) {
+            item = i;
+            match_cnt++;
+            if (len == strlen(list[i])) {
+                break;
+            }
+        }
+    }
+
+    if (match_cnt == 1) {
+        return item;
+    } else {
+        return list_size;
+    }
+}
+
+/******************************************************************************
+ *
+ * PBAP client sample variable manipulation functionality.
+ *
+ */
+
+/**
+ * set_repository()
+ *
+ * This function sets the repository variable used for determining which set
+ * of phonebooks to access.  It also tells BM3 of the newly set repository
+ * which in turn will tell the server.
+ */
+static void set_repository(const OI_CHAR *str)
+{
+    OI_UINT i;
+
+    OI_ASSERT(str);
+
+    if (*str == '\0') {
+        fprintf(stdout, "Repository cannot be set to nothing\n");
+        print_help(&variable_list[0]);
+        return;
+    }
+
+    i = find_str_in_list(str, valid_repositories, OI_ARRAYSIZE(valid_repositories) - 1);
+
+    if (i < OI_ARRAYSIZE(valid_repositories) - 1) {
+        pbap_client.repository = (OI_PBAP_REPOSITORY)i;
+        fprintf(stdout, "Repository set to: %s\n", str);
+    } else {
+        fprintf(stdout, "Invalid repository name: %s\n", str);
+        print_help(&variable_list[0]);
+    }
+}
+
+/**
+ * get_repository()
+ *
+ * This function puts a string representation of the repository's value into a
+ * string buffer.
+ */
+static void get_repository()
+{
+    OI_CHAR str[256];
+    OI_UINT str_len = 256;
+
+    strlcpy(str, valid_repositories[pbap_client.repository], str_len);
+    fprintf(stdout, "Current repository = %s\n", str);
+    ALOGV(LOGTAG "%s: Current repository: %s", __FUNCTION__, str);
+    print_help(&variable_list[0]);
+}
+
+/**
+ * set_phonebook()
+ *
+ * This function sets the phonebook variable used for determining which set of
+ * phonebook entries to access.  It also tells BM3 of the newly set phonebook
+ * which in turn will tell the server.
+ */
+static void set_phonebook(const OI_CHAR *str)
+{
+    OI_UINT i;
+
+    OI_ASSERT(str);
+
+    if (*str == '\0') {
+        OI_Printf("phonebook cannot be set to nothing\n");
+        fprintf(stdout, "Phonebook cannot be set to nothing \n");
+        print_help(&variable_list[1]);
+        return;
+    }
+
+    i = find_str_in_list(str, valid_phonebooks, OI_ARRAYSIZE(valid_phonebooks) - 1);
+
+    if (i < OI_ARRAYSIZE(valid_phonebooks) - 1) {
+        pbap_client.phonebook = (OI_PBAP_PHONEBOOK)i;
+        fprintf(stdout, "Phonebook set to: %s\n", str);
+    } else {
+        fprintf(stdout, "Invalid phonebook name: %s\n", str);
+        print_help(&variable_list[1]);
+    }
+}
+
+/**
+ * get_phonebook()
+ *
+ * This function puts a string representation of the phonebook's value into a
+ * string buffer.
+ */
+static void get_phonebook()
+{
+    OI_CHAR str[256];
+    OI_UINT str_len = 256;
+
+    strlcpy(str, valid_phonebooks[pbap_client.phonebook], str_len);
+    fprintf(stdout, "Current phonebook = %s\n", str);
+    ALOGV(LOGTAG "%s: Current phonebook: %s", __FUNCTION__, str);
+    print_help(&variable_list[1]);
+}
+
+/**
+ * set_format()
+ *
+ * This function sets the format variable used for determining which vCard
+ * format to use.
+ */
+static void set_format(const OI_CHAR *str)
+{
+    OI_UINT i;
+
+    OI_ASSERT(str);
+
+    if (*str == '\0') {
+        OI_Printf("format cannot be set to nothing\n");
+        fprintf(stdout, "Format cannot be set to nothing \n");
+        print_help(&variable_list[2]);
+        return;
+    }
+
+    i = find_str_in_list(str, valid_formats, OI_ARRAYSIZE(valid_formats));
+
+    if (i < OI_ARRAYSIZE(valid_formats)) {
+        pbap_client.format = (OI_PBAP_FORMAT_TAG_VALUES)i;
+        fprintf(stdout, "Format set to: %s\n", str);
+    } else {
+        fprintf(stdout, "Invalid format: %s\n", str);
+        print_help(&variable_list[2]);
+    }
+}
+
+/**
+ * get_format()
+ *
+ * This function puts a string representation of the format's value into a
+ * string buffer.
+ */
+static void get_format()
+{
+    OI_CHAR str[256];
+    OI_UINT str_len = 256;
+
+    strlcpy(str, valid_formats[pbap_client.format], str_len);
+    fprintf(stdout, "Current format = %s\n", str);
+    ALOGV(LOGTAG "%s: Current format: %s", __FUNCTION__, str);
+    print_help(&variable_list[2]);
+}
+
+/**
+ * set_filter()
+ *
+ * This function sets the filter variable used for determining which fields in
+ * the vCard to use.
+ */
+static void set_filter(const OI_CHAR *str)
+{
+    OI_UINT i;
+    OI_UINT32 filter = 0;
+
+    OI_ASSERT(str);
+
+    if (*str == '\0') {
+        OI_Printf("filter cannot be set to nothing\n");
+        fprintf(stdout, "Filter cannot be set to nothing \n");
+        print_help(&variable_list[3]);
+        return;
+    }
+
+    fprintf(stdout, "Setting Filter to: %s\n", str);
+    while (*str != '\0') {
+        i = find_str_in_list(str, valid_filters, OI_ARRAYSIZE(valid_filters));
+
+        /* Check if filter is set to "all" */
+        if (i == OI_ARRAYSIZE(valid_filters) - 1) {
+            filter = 0;
+            break;
+        }
+
+        if (i >= OI_ARRAYSIZE(valid_filters)) {
+            fprintf(stdout, "Invalid filter values: %s\n", str);
+            print_help(&variable_list[3]);
+            return;
+        }
+        filter |= 1 << i;
+        str += strlen(valid_filters[i]);
+        str = skip_delimiter(str);
+    }
+    pbap_client.filter.I2 = filter;
+}
+
+/**
+ * get_filter()
+ *
+ * This function puts a string representation of the filter's value into a
+ * string buffer.
+ */
+static void get_filter()
+{
+    OI_UINT i;
+    OI_INT pos = 0;
+    OI_CHAR string[256];
+    OI_CHAR *str = string;
+    OI_UINT str_len = 256;
+
+    memset(str, 0, sizeof(string));
+    if (OI_PBAP_VCARD_ATTRIBUTE_CHECK_ALL(&pbap_client.filter)) {
+        i = OI_ARRAYSIZE(valid_filters) - 1;
+        strlcpy(str + pos, valid_filters[i], str_len);
+        pos += strlen(valid_filters[i]) + 1;
+    } else {
+        for (i = 0; i < OI_ARRAYSIZE(valid_filters); i++) {
+            if (pbap_client.filter.I2 & (1 << i)) {
+                if (str_len > strlen(valid_filters[i])) {
+                    strlcpy(str + pos, valid_filters[i], str_len);
+                    str_len -= strlen(valid_filters[i]);
+                    pos += strlen(valid_filters[i]);
+                    str[pos] = ' ';
+                    str_len--;
+                    pos++;
+                } else {
+                    pos = 1;
+                    break;
+                }
+            }
+        }
+    }
+    str[pos - 1] = '\0';
+    fprintf(stdout, "Current filter: %s\n", str);
+    ALOGV(LOGTAG "%s: Current filter: %s", __FUNCTION__, str);
+    print_help(&variable_list[3]);
+}
+
+/**
+ * set_order()
+ *
+ * This function sets the order variable used for determining the sorting
+ * order of phonebook entry listings.
+ */
+static void set_order(const OI_CHAR *str)
+{
+    OI_UINT i;
+    OI_INT len;
+
+    OI_ASSERT(str);
+
+    if (*str == '\0') {
+        OI_Printf("order cannot be set to nothing\n");
+        fprintf(stdout, "Order cannot be set to nothing \n");
+        print_help(&variable_list[4]);
+        return;
+    }
+
+    for (i = 0; i < OI_ARRAYSIZE(valid_orders); i++) {
+        len = 0;
+        while (!isdelimiter(str[len]) && str[len] != '\0') {
+            len++;
+        }
+        if (!OI_StrncmpInsensitive(valid_orders[i], str, (OI_UINT16)len)) {
+            break;
+        }
+    }
+
+    if (i < OI_ARRAYSIZE(valid_orders)) {
+        pbap_client.order = (OI_PBAP_ORDER_TAG_VALUES)i;
+        fprintf(stdout, "Order set to: %s\n", str);
+    } else {
+        fprintf(stdout, "Invalid order: %s\n", str);
+        print_help(&variable_list[4]);
+    }
+}
+
+/**
+ * get_order()
+ *
+ * This function puts a string representation of the order's value into a
+ * string buffer.
+ */
+static void get_order()
+{
+    OI_CHAR str[256];
+    OI_UINT str_len = 256;
+
+    strlcpy(str, valid_orders[pbap_client.order], str_len);
+    fprintf(stdout, "Current search order = %s\n", str);
+    ALOGV(LOGTAG "%s: Current search order: %s", __FUNCTION__, str);
+    print_help(&variable_list[4]);
+}
+
+/**
+ * set_search_value()
+ *
+ * This function sets the search variable used for determining the search
+ * criterion of next ponebook fetch.
+ */
+static void set_search_value(const OI_CHAR *str)
+{
+    OI_UINT i;
+    OI_INT len;
+
+    OI_ASSERT(str);
+
+    if (pbap_client.searchValue) {
+        delete pbap_client.searchValue;
+        pbap_client.searchValue = NULL;
+        pbap_client.searchValueLen = 0;
+    }
+    pbap_client.searchValue = new OI_BYTE[strlen(str) + 1];
+    strlcpy((OI_CHAR *)pbap_client.searchValue, str, strlen(str) + 1);
+    pbap_client.searchValueLen = strlen(str);
+}
+
+/**
+ * set_search_attribute()
+ *
+ * This function sets the search attribute for determining the search
+ * criterion of phonebook entry listings.
+ */
+static void set_search_attribute(const OI_CHAR *str)
+{
+    OI_UINT i;
+    OI_INT len;
+
+    OI_ASSERT(str);
+
+    if (*str == '\0') {
+        OI_Printf("search attribute cannot be set to nothing\n");
+        fprintf(stdout, "search attribute cannot be set to nothing \n");
+        print_help(&variable_list[5]);
+        return;
+    }
+
+    for (i = 0; i < OI_ARRAYSIZE(valid_search_attribs); i++) {
+        len = 0;
+        while (!isdelimiter(str[len]) && str[len] != '\0') {
+            len++;
+        }
+        if (!OI_StrncmpInsensitive(valid_search_attribs[i], str, (OI_UINT16)len)) {
+            break;
+        }
+    }
+
+    if (i < OI_ARRAYSIZE(valid_search_attribs)) {
+        pbap_client.searchAttribute = (OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES)i;
+        fprintf(stdout, "search attribute set to: %s\n", str);
+    } else {
+        fprintf(stdout, "Invalid search attribute: %s\n", str);
+        print_help(&variable_list[5]);
+    }
+}
+
+/**
+ * get_search_attribute()
+ *
+ * This function puts a string representation of the search attribute's value into a
+ * string buffer.
+ */
+static void get_search_attribute()
+{
+    OI_CHAR str[256];
+    OI_UINT str_len = 256;
+
+    strlcpy(str, valid_search_attribs[pbap_client.searchAttribute], str_len);
+    fprintf(stdout, "Current search attribute = %s\n", str);
+    ALOGV(LOGTAG "%s: Current search attribute: %s", __FUNCTION__, str);
+    print_help(&variable_list[5]);
+}
+
+/**
+
+/**
+ * help_cmd_handler()
+ *
+ * This command handles the HELP command.  It displays useful help information
+ * to the user.
+ */
+static void print_help(const PBAP_CLIENT_VARIABLE *var)
+{
+    int i;
+    if (var) {
+        printf("\n=====HELP=====\n%s:\t%s\n(valid options:", var->name, var->description);
+        for (i = 0; i < (OI_UINT)var->valid_option_cnt; i++) {
+            printf(" %s", var->valid_options[i]);
+        }
+        printf(")\n");
+    }
+}
+
+void BtPbapClientMsgHandler(void *msg)
+{
+    BtEvent* event = NULL;
+    bool status = false;
+    if(!msg) {
+        ALOGE(LOGTAG "%s: Msg is null, return", __FUNCTION__);
+        return;
+    }
+
+    event = ( BtEvent *) msg;
+
+    if (event == NULL) {
+        ALOGE(LOGTAG "%s: event is null", __FUNCTION__);
+        return;
+    }
+
+    ALOGD(LOGTAG "BtPbapClientMsgHandler event = %d", event->event_id);
+    switch(event->event_id) {
+        case PROFILE_API_START:
+            {
+                BtEvent *start_event = new BtEvent;
+                memset(&pbap_client, 0, sizeof(PBAP_CLIENT_DATA));
+                start_event->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+                start_event->profile_start_event.profile_id = PROFILE_ID_PBAP_CLIENT;
+                start_event->profile_start_event.status = true;
+                PostMessage(THREAD_ID_GAP, start_event);
+            }
+            break;
+
+        case PROFILE_API_STOP:
+            if(g_pbapClient) {
+                if (pbap_client.connection) {
+                    pbap_client.state = STATE_DEINITIALIZING;
+                    /* disconnect connected device */
+                    OI_PBAPClient_Disconnect(pbap_client.connection);
+                } else {
+                    /* PBAP Client is not connected, proceed directly with record removal */
+                    g_pbapClient->RemoveSdpRecord();
+                    /*
+                    * Its possible that SDP Client thread terminated before receiving above request,
+                    * so send stop profile with success.
+                    */
+                    BtEvent *stop_event = new BtEvent;
+                    stop_event->profile_start_event.event_id = PROFILE_EVENT_STOP_DONE;
+                    stop_event->profile_start_event.profile_id = PROFILE_ID_PBAP_CLIENT;
+                    stop_event->profile_start_event.status = true;
+                    PostMessage(THREAD_ID_GAP, stop_event);
+                }
+            }
+            break;
+
+        default:
+            if(g_pbapClient) {
+               g_pbapClient->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+    }
+    delete event;
+}
+
+/******************************************************************************
+*
+* PBAP client bluetooth functionality.
+*
+*/
+
+/**
+* pb_open()
+*
+* This function gets called when the PBAP server is about to send phonebook
+* related data, such as a listing, phonebook entry, or complete phonebook.
+*/
+static OI_STATUS pb_open(const OI_OBEX_UNICODE *name, OI_PBAP_OPEN_CFM open_cfm,
+    OI_PBAP_CONNECTION connection)
+{
+    OI_STATUS status = OI_OK;
+    FILE *stream = NULL;
+    char filename[256];
+
+    if (pbap_client.getting_listing) {
+        snprintf(filename, sizeof(filename), "%s%s", storageDir, vCardListingFile);
+    } else if (pbap_client.getting_phonebook) {
+        snprintf(filename, sizeof(filename), "%s%s", storageDir, phoneBookFile);
+    } else if (pbap_client.getting_vcard) {
+        snprintf(filename, sizeof(filename), "%s%s", storageDir, vcardFile);
+    } else {
+        ALOGE(LOGTAG "unknown operation calling open");
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    pbap_client.fileName = new char[strlen(filename) + 1];
+    if (pbap_client.fileName != NULL) {
+        strlcpy(pbap_client.fileName, filename, strlen(filename) + 1);
+        pbap_client.fileName[strlen(filename)] = '\0';
+        ALOGD(LOGTAG "Opening file: %s\n", pbap_client.fileName);
+        stream = fopen(pbap_client.fileName, "w+b");
+        if (stream == NULL) {
+            status = OI_STATUS_OUT_OF_MEMORY;
+            delete pbap_client.fileName;
+            pbap_client.fileName = NULL;
+        }
+    } else {
+        status = OI_STATUS_OUT_OF_MEMORY;
+    }
+    open_cfm(stream, status, connection);
+    return status;
+}
+
+/**
+* pb_close()
+*
+* This function gets called when there is no more data coming from the PBAP
+* server.
+*/
+static void pb_close(OI_PBAP_HANDLE handle, OI_PBAP_CONNECTION pbapConnection, OI_STATUS status)
+{
+    ALOGD(LOGTAG "Closed file with status: %d\n", status);
+
+    if (handle != NULL)
+        fclose((FILE *)handle);
+    if (status && pbap_client.fileName != NULL)
+        remove(pbap_client.fileName);
+}
+
+/**
+* pb_write()
+*
+* This function is called when phonebook data has just been receieved from
+* the PBAP server.
+*/
+static OI_STATUS pb_write(OI_PBAP_HANDLE handle, const OI_BYTE *buffer, OI_UINT16 buf_len,
+    OI_PBAP_WRITE_CFM write_cfm, OI_PBAP_CONNECTION connection)
+{
+    OI_STATUS status = OI_OK;
+    OI_UINT writeLen;
+
+    if (pbap_client.abort) {
+        ALOGD(LOGTAG "%s: operation aborted, not writing to file\n", __FUNCTION__);
+        status = OI_STATUS_INTERNAL_ERROR;
+        write_cfm(handle, status, connection);
+        return status;
+    }
+    if (handle != NULL)
+    {
+        writeLen = fwrite(buffer, buf_len, 1, (FILE *)handle);
+    }
+    write_cfm(handle, status, connection);
+    return status;
+}
+
+PbapClient :: PbapClient(const bt_interface_t *bt_interface, config_t *config)
+{
+    this->bluetooth_interface = bt_interface;
+    this->config = config;
+    pbap_connect_timer = NULL;
+    if( !(pbap_connect_timer = alarm_new())) {
+        ALOGE(LOGTAG, " unable to create pbap_connect_timer");
+        return;
+    }
+}
+
+void pbap_connect_timer_expired(void *context) {
+    ALOGD(LOGTAG, " pbap_connect_timer_expired");
+
+    BtEvent *event = new BtEvent;
+    event->event_id = PBAP_CLIENT_CONNECT_TIMEOUT;
+    memcpy(&event->pbap_client_event.bd_addr, (bt_bdaddr_t *)context, sizeof(bt_bdaddr_t));
+    PostMessage(THREAD_ID_PBAP_CLIENT, event);
+}
+
+PbapClient :: ~PbapClient()
+{
+    alarm_free(g_pbapClient->pbap_connect_timer);
+    g_pbapClient->pbap_connect_timer = NULL;
+}
+
+void connectionCfm(OI_PBAP_CONNECTION connectionId,
+                                       OI_STATUS status)
+{
+    char bd_str[MAX_BD_STR_LEN];
+    bdaddr_to_string((const bt_bdaddr_t*)&pbap_client.addr, bd_str, MAX_BD_STR_LEN);
+    ALOGV(LOGTAG "%s: status: %d connectionID = %p", __FUNCTION__,
+        status, connectionId);
+    //stoping pbap_connect_timer
+    if(g_pbapClient) {
+        alarm_cancel(g_pbapClient->pbap_connect_timer);
+    }
+
+    if (pbap_client.state != STATE_CONNECTING) {
+        ALOGE(LOGTAG "%s: received connect cfm in invalid state %d",
+            __FUNCTION__, pbap_client.state);
+        /* Most likely connection timed out, so disconnect OBEX link now */
+        OI_PBAPClient_Disconnect(connectionId);
+        return;
+    }
+
+    if (status == OI_STATUS_SUCCESS) {
+        pbap_client.connection = connectionId;
+        pbap_client.state = STATE_CONNECTED;
+        /* Set default parameters */
+        pbap_client.repository = OI_PBAP_LOCAL_REPOSITORY;
+        pbap_client.phonebook = OI_PBAP_MAIN_PHONEBOOK;
+        pbap_client.format = OI_PBAP_FORMAT_VCARD_2_1;
+        pbap_client.order = OI_PBAP_ORDER_INDEXED;
+        pbap_client.searchAttribute = OI_PBAP_SEARCH_ATTRIBUTE_NAME;
+        pbap_client.start_offset = 0;
+        pbap_client.max_list_count = OI_UINT16_MAX;
+        if (pbap_client.searchValue) {
+            delete pbap_client.searchValue;
+            pbap_client.searchValue = NULL;
+            pbap_client.searchValueLen = 0;
+        }
+        if (pbap_client.fileName != NULL) {
+            delete pbap_client.fileName;
+            pbap_client.fileName = NULL;
+        }
+        /* Set Filter to all */
+        pbap_client.filter.I1 = 0;
+        pbap_client.filter.I2 = 0;
+        /* reset all operations to false */
+        pbap_client.getting_vcard = false;
+        pbap_client.getting_phonebook = false;
+        pbap_client.getting_listing = false;
+        pbap_client.set_path = false;
+        pbap_client.abort = false;
+        fprintf(stdout, "Connected to %s\n", bd_str );
+    } else {
+        pbap_client.connection = NULL;
+        pbap_client.state = STATE_IDLE;
+        uint8_t zero[sizeof(bt_bdaddr_t)] = { 0 };
+        memcpy(&pbap_client.addr, zero, sizeof(bt_bdaddr_t));
+        fprintf(stdout, "Failed to Connect to %s\n", bd_str );
+    }
+}
+
+void disconnectInd(OI_PBAP_CONNECTION connectionId)
+{
+    ALOGV(LOGTAG "%s: connectionID = %p", __FUNCTION__, connectionId);
+
+    if (pbap_client.state == STATE_DEINITIALIZING) {
+        /* PBAP Client is not connected, proceed directly with record removal */
+        g_pbapClient->RemoveSdpRecord();
+        /*
+        * Its possible that SDP Client thread terminated before receiving above request,
+        * so send stop profile with success.
+        */
+        BtEvent *stop_event = new BtEvent;
+        stop_event->profile_start_event.event_id = PROFILE_EVENT_STOP_DONE;
+        stop_event->profile_start_event.profile_id = PROFILE_ID_PBAP_CLIENT;
+        stop_event->profile_start_event.status = true;
+        PostMessage(THREAD_ID_GAP, stop_event);
+    }
+
+    char bd_str[MAX_BD_STR_LEN];
+    if (pbap_client.connection == connectionId) {
+        bdaddr_to_string((const bt_bdaddr_t*)&pbap_client.addr, bd_str, MAX_BD_STR_LEN);
+        fprintf(stdout, "Disconnected with %s\n", bd_str );
+        pbap_client.connection = NULL;
+        pbap_client.state = STATE_IDLE;
+        if (pbap_client.searchValue) {
+            delete pbap_client.searchValue;
+            pbap_client.searchValue = NULL;
+            pbap_client.searchValueLen = 0;
+        }
+        if (pbap_client.fileName != NULL) {
+            delete pbap_client.fileName;
+            pbap_client.fileName = NULL;
+        }
+        pbap_client.getting_vcard = false;
+        pbap_client.getting_phonebook = false;
+        pbap_client.getting_listing = false;
+        pbap_client.set_path = false;
+        pbap_client.abort = false;
+        uint8_t zero[sizeof(bt_bdaddr_t)] = { 0 };
+        memcpy(&pbap_client.addr, zero, sizeof(bt_bdaddr_t));
+    }
+}
+
+void authenticationCB(OI_PBAP_CONNECTION connectionId, OI_BOOL userIdRequired)
+{
+    OI_CHAR userid_buf[OI_OBEX_MAX_USERID_LEN + 1] = "userid";
+    OI_CHAR password_buf[OI_OBEX_MAX_PASSWORD_LEN + 1] = "password";
+    OI_UINT8 useridLen = strlen("userid");
+    OI_STATUS status;
+    fprintf(stdout, "Authentication requested by remote device\n");
+    ALOGV(LOGTAG "%s: connectionID = %p, userIdRequired = %d",
+        __FUNCTION__, connectionId, userIdRequired);
+    if (userIdRequired) {
+        OI_Printf("Authenticating with userid=%s and password=%s\n",
+                  userid_buf, password_buf);
+        status = OI_PBAPClient_AuthenticationRsp(connectionId,
+                                               (OI_BYTE*)userid_buf,
+                                               useridLen,
+                                               password_buf);
+    } else {
+        OI_Printf("Authenticating with password=%s\n",
+                  password_buf);
+        status = OI_PBAPClient_AuthenticationRsp(connectionId,
+                                                 NULL,
+                                                 0,
+                                                 password_buf);
+    }
+    if (!OI_SUCCESS(status)) {
+        OI_Printf("Failed to send authentication response: %!\n", status);
+    }
+}
+
+void pullPhonebookSizeCB(OI_PBAP_CONNECTION connectionId,
+                                                     OI_UINT16 phonebookSize,
+                                                     OI_STATUS status)
+{
+    ALOGV(LOGTAG "%s: connectionID = %p, phonebookSize = %d status = %d",
+        __FUNCTION__, connectionId, phonebookSize, status);
+    if (status == OI_STATUS_SUCCESS) {
+        fprintf(stdout, "Phonebook Size is %d\n", phonebookSize);
+    } else {
+        fprintf(stdout, "Get Phonebook Size failed!!\n");
+    }
+    pbap_client.getting_phonebook = false;
+}
+
+void pullPhonebookCB(OI_PBAP_CONNECTION connectionId,
+                                                 OI_UINT8 newMissedCalls,
+                                                 OI_STATUS status)
+{
+    ALOGV(LOGTAG "%s: connectionID = %p, newMissedCalls = %d status = %d",
+        __FUNCTION__, connectionId, newMissedCalls, status);
+    if (status == OI_STATUS_SUCCESS) {
+        ALOGD(LOGTAG "Phonebook downloaded to %s", pbap_client.fileName);
+        fprintf(stdout, "Phonebook downloaded to %s\n", pbap_client.fileName);
+    } else {
+        ALOGD(LOGTAG "Download Phonebook failed, status %d ", status);
+        fprintf(stdout, "Download Phonebook failed!!\n");
+    }
+    pbap_client.getting_phonebook = false;
+    if (pbap_client.fileName != NULL) {
+        delete pbap_client.fileName;
+        pbap_client.fileName = NULL;
+    }
+}
+
+void pullVcardCB(OI_PBAP_CONNECTION connectionId, OI_STATUS status)
+{
+    ALOGV(LOGTAG "%s: connectionID = %p, status = %d",
+        __FUNCTION__, connectionId, status);
+    if (status == OI_STATUS_SUCCESS) {
+        ALOGD(LOGTAG "Vcard downloaded to %s ", pbap_client.fileName);
+        fprintf(stdout, "Vcard downloaded to %s \n", pbap_client.fileName);
+    } else {
+        ALOGD(LOGTAG "Vcard Download failed, status %d ", status);
+        fprintf(stdout, "Vcard Download failed!!\n");
+    }
+    pbap_client.getting_vcard = false;
+    if (pbap_client.fileName != NULL) {
+        delete pbap_client.fileName;
+        pbap_client.fileName = NULL;
+    }
+}
+
+void pullPVcardListingCB(OI_PBAP_CONNECTION connectionId,
+                                                 OI_UINT8 newMissedCalls,
+                                                 OI_STATUS status)
+{
+    ALOGV(LOGTAG "%s: connectionID = %p, newMissedCalls = %d status = %d",
+        __FUNCTION__, connectionId, newMissedCalls, status);
+    if (status == OI_STATUS_SUCCESS) {
+        ALOGD(LOGTAG "Vcard Listing downloaded to %s ", pbap_client.fileName);
+        fprintf(stdout, "Vcard Listing downloaded to %s\n ", pbap_client.fileName);
+    } else {
+        ALOGD(LOGTAG "Vcard Listing failed, status %d ", status);
+        fprintf(stdout, "Vcard Listing failed!!\n");
+    }
+    pbap_client.getting_listing = false;
+    if (pbap_client.fileName != NULL) {
+        delete pbap_client.fileName;
+        pbap_client.fileName = NULL;
+    }
+    if (pbap_client.searchValue) {
+        delete pbap_client.searchValue;
+        pbap_client.searchValue = NULL;
+        pbap_client.searchValueLen = 0;
+    }
+}
+
+void setPathCB (OI_PBAP_CONNECTION connectionId, OI_STATUS status)
+{
+    if (status == OI_STATUS_SUCCESS) {
+        ALOGD(LOGTAG "set path succeeded");
+        fprintf(stdout, "set path succeeded\n");
+    } else {
+        ALOGD(LOGTAG "set path failed, status %d ", status);
+        fprintf(stdout, "set path failed!!\n");
+    }
+    pbap_client.set_path = false;
+}
+
+void abortCfm(OI_PBAP_CONNECTION connectionId)
+{
+    ALOGV(LOGTAG "%s: connectionID = %p", __FUNCTION__, connectionId);
+    fprintf(stdout, "Aborted last operation \n");
+    pbap_client.getting_vcard = false;
+    pbap_client.getting_phonebook = false;
+    pbap_client.getting_listing = false;
+    pbap_client.set_path = false;
+    pbap_client.abort = false;
+}
+
+static void sdp_add_record_callback(bt_status_t status, int handle)
+{
+    if (status) {
+        fprintf(stdout, "Sdp add record failed can't proceed with connection\n");
+        ALOGE(LOGTAG "%s: sdp add record failed, status %d", __FUNCTION__, status);
+    } else {
+        pbap_client.rec_handle = handle;
+        pbap_client.state = STATE_IDLE;
+        fprintf(stdout, "Successfully Registered PBAP Client SDP Record\n");
+    }
+}
+
+static void sdp_remove_record_callback(bt_status_t status)
+{
+    if (status) {
+        ALOGE(LOGTAG "%s: sdp remove record failed, status %d", __FUNCTION__, status);
+        return;
+    }
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    pbap_client.rec_handle = -1;
+    pbap_client.state = STATE_INITIAL;
+}
+
+static void sdp_search_callback(bt_status_t status, bt_bdaddr_t *bd_addr, uint8_t* uuid,
+            bluetooth_sdp_record *record, bool more_result)
+{
+    char bd_str[MAX_BD_STR_LEN];
+
+    if (status) {
+        ALOGE(LOGTAG "%s: sdp search failed, status %d", __FUNCTION__, status);
+        fprintf(stdout, "Sdp search failed can't proceed with connection\n");
+        return;
+    }
+    ALOGE(LOGTAG "%s", __FUNCTION__);
+    if (IS_UUID(UUID_PBAP_PSE, uuid)) {
+        bdaddr_to_string(bd_addr, bd_str, MAX_BD_STR_LEN);
+        ALOGE(LOGTAG "%s: status %d, addr %s, L2CAP PSM = %d, "
+            "RFCOMM channel = %d, profile version = 0x%04x, "
+            "supported features = %d, repositories = %d, "
+            "more results = %d", __FUNCTION__, status, bd_str,
+            record->pse.hdr.l2cap_psm,
+            record->pse.hdr.rfcomm_channel_number,
+            record->pse.hdr.profile_version,
+            record->pse.supported_features,
+            record->pse.supported_repositories,
+            more_result);
+        if (record->pse.hdr.rfcomm_channel_number > 0 ||
+            record->pse.hdr.l2cap_psm > 0) {
+            if (record->pse.hdr.l2cap_psm > 0 &&
+                record->pse.hdr.profile_version >= profileVersion) {
+                pbap_client.lowerProtocol.protocol = OI_OBEX_LOWER_L2CAP;
+                pbap_client.lowerProtocol.svcId.l2capPSM = record->pse.hdr.l2cap_psm;
+            } else {
+                pbap_client.lowerProtocol.protocol = OI_OBEX_LOWER_RFCOMM;
+                pbap_client.lowerProtocol.svcId.rfcommChannel =
+                    record->pse.hdr.rfcomm_channel_number;
+            }
+            pbap_client.supportedFeatures = DOWNLOAD | BROWSING;
+            /* Send Internal Connect Message to PBAP Client Thread */
+            BtEvent *event = new BtEvent;
+            event->event_id = PBAP_CLIENT_INTERNAL_CONNECT;
+            PostMessage(THREAD_ID_PBAP_CLIENT, event);
+        } else {
+            ALOGE(LOGTAG "%s: Could not find remote rfcomm channel or l2cap psm, can't connect",
+                 __FUNCTION__);
+            fprintf(stdout, "Could not find remote rfcomm channel or l2cap psm, can't connect\n");
+        }
+    } else {
+        ALOGE(LOGTAG "%s: Unknown uuid sdp result received, ignoring!!", __FUNCTION__);
+        fprintf(stdout, "Unknown uuid sdp result received, ignoring!!\n");
+    }
+}
+
+void PbapClient::ProcessEvent(BtEvent* pEvent)
+{
+    ALOGD(LOGTAG "%s: Processing event %d", __FUNCTION__, pEvent->event_id);
+
+    switch(pEvent->event_id) {
+
+        case PBAP_CLIENT_REGISTER:
+            AddSdpRecord();
+            break;
+
+        case PBAP_CLIENT_CONNECT:
+            PerformSdp(&pEvent->pbap_client_event.bd_addr);
+            break;
+
+        case PBAP_CLIENT_INTERNAL_CONNECT:
+            Connect();
+            break;
+
+        case PBAP_CLIENT_CONNECT_TIMEOUT:
+            HandleConnectTimeout(&pEvent->pbap_client_event.bd_addr);
+            break;
+
+        case PBAP_CLIENT_DISCONNECT:
+            Disconnect(&pEvent->pbap_client_event.bd_addr);
+            break;
+
+        case PBAP_CLIENT_ABORT:
+            Abort();
+            break;
+
+        case PBAP_CLIENT_GET_PHONEBOOK_SIZE:
+            GetPhonebookSize();
+            break;
+
+        case PBAP_CLIENT_GET_PHONEBOOK:
+            GetPhonebook();
+            break;
+
+        case PBAP_CLIENT_GET_VCARD:
+            GetVcard(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_GET_VCARD_LISTING:
+            GetVcardListing();
+            break;
+
+        case PBAP_CLIENT_SET_PATH:
+            SetPath(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_SET_FILTER:
+            set_filter(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_GET_FILTER:
+            get_filter();
+            break;
+
+        case PBAP_CLIENT_SET_ORDER:
+            set_order(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_GET_ORDER:
+            get_order();
+            break;
+
+        case PBAP_CLIENT_SET_SEARCH_ATTRIBUTE:
+            set_search_attribute(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_GET_SEARCH_ATTRIBUTE:
+            get_search_attribute();
+            break;
+
+        case PBAP_CLIENT_SET_SEARCH_VALUE:
+            set_search_value(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_SET_PHONE_BOOK:
+            set_phonebook(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_GET_PHONE_BOOK:
+            get_phonebook();
+            break;
+
+        case PBAP_CLIENT_SET_REPOSITORY:
+            set_repository(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_GET_REPOSITORY:
+            get_repository();
+            break;
+
+        case PBAP_CLIENT_SET_VCARD_FORMAT:
+            set_format(pEvent->pbap_client_event.value);
+            break;
+
+        case PBAP_CLIENT_GET_VCARD_FORMAT:
+            get_format();
+            break;
+
+        case PBAP_CLIENT_SET_LIST_COUNT:
+            pbap_client.max_list_count = pEvent->pbap_client_event.max_list_count;
+            fprintf(stdout, "Max List set to =: %d\n", pbap_client.max_list_count);
+            break;
+
+        case PBAP_CLIENT_GET_LIST_COUNT:
+            ALOGV(LOGTAG "%s: Max List Count =: %d", __FUNCTION__, pbap_client.max_list_count);
+            fprintf(stdout, " Max List Count =: %d\n", pbap_client.max_list_count);
+            break;
+
+        case PBAP_CLIENT_SET_START_OFFSET:
+            pbap_client.start_offset = pEvent->pbap_client_event.list_start_offset;
+            fprintf(stdout, "List Start set to %d\n", pbap_client.start_offset);
+            break;
+
+        case PBAP_CLIENT_GET_START_OFFSET:
+            ALOGV(LOGTAG "%s: List Start Offset =: %d", __FUNCTION__, pbap_client.start_offset);
+            fprintf(stdout, "List Start Offset =: %d\n", pbap_client.start_offset);
+            break;
+
+        default:
+            ALOGW(LOGTAG "%s: unhandled event: %d", __FUNCTION__, pEvent->event_id);
+            break;
+    }
+}
+
+void PbapClient :: AddSdpRecord()
+{
+    if (pbap_client.state >= STATE_IDLE) {
+        fprintf(stdout, "Already registered \n");
+        return;
+    }
+    /* Add PBAP Client SDP Record */
+    BtEvent *sdp_search_event = new BtEvent;
+    sdp_search_event->sdp_client_event.event_id = SDP_CLIENT_ADD_RECORD;
+    memset(&sdp_search_event->sdp_client_event.record, 0 , sizeof(bluetooth_sdp_record));
+    sdp_search_event->sdp_client_event.record.pce.hdr.type = SDP_TYPE_PBAP_PCE;
+    sdp_search_event->sdp_client_event.record.pce.hdr.profile_version = profileVersion;
+    sdp_search_event->sdp_client_event.record.pce.hdr.service_name = profile_name;
+    sdp_search_event->sdp_client_event.record.pce.hdr.service_name_length = strlen(profile_name);
+    sdp_search_event->sdp_client_event.addRecordCb = &sdp_add_record_callback;
+    PostMessage(THREAD_ID_SDP_CLIENT, sdp_search_event);
+}
+
+void PbapClient :: RemoveSdpRecord()
+{
+    if (pbap_client.state == STATE_INITIAL) {
+        ALOGE(LOGTAG "Already un-registered ");
+        return;
+    }
+    if (pbap_client.searchValue) {
+        delete pbap_client.searchValue;
+        pbap_client.searchValue = NULL;
+        pbap_client.searchValueLen = 0;
+    }
+    if (pbap_client.rec_handle != -1) {
+        /* Remove PBAP Client SDP Record */
+        BtEvent *sdp_search_event = new BtEvent;
+        sdp_search_event->sdp_client_event.event_id = SDP_CLIENT_REMOVE_RECORD;
+        sdp_search_event->sdp_client_event.removeRecordCb = &sdp_remove_record_callback;
+        sdp_search_event->sdp_client_event.rec_handle = pbap_client.rec_handle;
+        PostMessage(THREAD_ID_SDP_CLIENT, sdp_search_event);
+    }
+}
+
+bool PbapClient :: PerformSdp(bt_bdaddr_t *addr)
+{
+    bool ret = true;
+    char bd_str[MAX_BD_STR_LEN];
+
+    if (!addr) {
+        ALOGE(LOGTAG "%s: Bluetooth device address null", __FUNCTION__);
+        return false;
+    }
+    bdaddr_to_string((const bt_bdaddr_t*)&pbap_client.addr, bd_str, MAX_BD_STR_LEN);
+    if (pbap_client.state == STATE_INITIAL) {
+        ALOGE(LOGTAG "%s: Not registered, please register before connecting!!", __FUNCTION__);
+        fprintf(stdout, "Not registered, please register before connecting!!\n");
+        return false;
+    } else if (pbap_client.state == STATE_CONNECTING) {
+        ALOGE(LOGTAG "%s: Currently connecting to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Currently connecting to %s\n", bd_str);
+        return false;
+    } else if (pbap_client.state == STATE_CONNECTED) {
+        ALOGE(LOGTAG "%s: Already connected to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Already connected to %s\n", bd_str);
+        return false;
+    }
+    memcpy(&pbap_client.addr, addr, sizeof(bt_bdaddr_t));
+    bdaddr_to_string(addr, bd_str, MAX_BD_STR_LEN);
+    ALOGV(LOGTAG "%s: %s", __FUNCTION__, bd_str);
+    BtEvent *sdp_search_event = new BtEvent;
+    /* Perform SDP to determine PBAP Server Record */
+    sdp_search_event->sdp_client_event.event_id = SDP_CLIENT_SEARCH;
+    memcpy(&sdp_search_event->sdp_client_event.bd_addr, &pbap_client.addr, sizeof(bt_bdaddr_t));
+    sdp_search_event->sdp_client_event.uuid = UUID_PBAP_PSE;
+    sdp_search_event->sdp_client_event.searchCb = &sdp_search_callback;
+    PostMessage(THREAD_ID_SDP_CLIENT, sdp_search_event);
+
+    return ret;
+}
+
+bool PbapClient :: Connect()
+{
+    OI_STATUS ret = OI_PBAPClient_Connect((OI_BD_ADDR*)&pbap_client.addr,
+        &pbap_client.lowerProtocol, OI_OBEXCLI_AUTH_NONE,
+        &pbap_client.connection, pbap_client.supportedFeatures,
+        &connectionCfm, &disconnectInd, &authenticationCB, &pbap_file_ops);
+    ALOGV(LOGTAG "%s: OI_PBAPClient_Connect returned %d", __FUNCTION__, ret);
+    if (ret) {
+        char bd_str[MAX_BD_STR_LEN];
+        bdaddr_to_string((const bt_bdaddr_t*)&pbap_client.addr, bd_str, MAX_BD_STR_LEN);
+        ALOGE(LOGTAG "%s: Failed to connect to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Failed to connect to %s\n", bd_str);
+    } else {
+         // start the profile connect timer
+        alarm_set(pbap_connect_timer, PBAP_CONNECT_TIMEOUT_DELAY,
+                            pbap_connect_timer_expired, &pbap_client.addr);
+        pbap_client.state = STATE_CONNECTING;
+    }
+    return ret;
+}
+
+bool PbapClient :: HandleConnectTimeout(bt_bdaddr_t *addr)
+{
+    char bd_str[MAX_BD_STR_LEN];
+    bdaddr_to_string((const bt_bdaddr_t*)addr, bd_str, MAX_BD_STR_LEN);
+    fprintf(stdout, "Failed to Connect to %s due to ConnectionTimeout\n", bd_str);
+    pbap_client.connection = NULL;
+    pbap_client.state = STATE_IDLE;
+    uint8_t zero[sizeof(bt_bdaddr_t)] = { 0 };
+    memcpy(&pbap_client.addr, zero, sizeof(bt_bdaddr_t));
+    return true;
+}
+
+bool PbapClient :: Disconnect(bt_bdaddr_t *addr)
+{
+    bool ret = true;
+    char bd_str[MAX_BD_STR_LEN];
+
+    if (!addr) {
+        ALOGE(LOGTAG "%s: Bluetooth device address null", __FUNCTION__);
+        return false;
+    }
+    bdaddr_to_string(addr, bd_str, MAX_BD_STR_LEN);
+    if (pbap_client.state != STATE_CONNECTED || !bdaddr_equals(addr,
+            (const bt_bdaddr_t *)&pbap_client.addr)) {
+        ALOGE(LOGTAG "%s: not connected to %s", __FUNCTION__, bd_str);
+        fprintf(stdout, "Not connected to %s\n", bd_str);
+        return false;
+    }
+    ALOGV(LOGTAG "%s: %s", __FUNCTION__, bd_str);
+
+    OI_STATUS status = OI_PBAPClient_Disconnect(pbap_client.connection);
+    if (status != OI_STATUS_SUCCESS) {
+        ret = false;
+        char bd_str[MAX_BD_STR_LEN];
+        bdaddr_to_string((const bt_bdaddr_t*)&pbap_client.addr, bd_str, MAX_BD_STR_LEN);
+        fprintf(stdout, "Failed to disconnect to %s\n", bd_str);
+        ALOGE(LOGTAG "%s: Failed disconnect %s status: %d", __FUNCTION__, bd_str, status);
+    }
+    return ret;
+}
+
+bool PbapClient :: GetPhonebookSize()
+{
+    bool ret = true;
+
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    if (pbap_client.getting_vcard || pbap_client.getting_phonebook
+            || pbap_client.getting_listing || pbap_client.set_path
+            || pbap_client.abort) {
+        fprintf(stdout, "PBAP Operation in progress, please retry again!!\n");
+        return false;
+    }
+    if (pbap_client.state != STATE_CONNECTED) {
+        ALOGE(LOGTAG "%s: Not connected", __FUNCTION__);
+        fprintf(stdout, "Not connected, can't get phonebook size\n");
+        return false;
+    }
+    OI_STATUS status = OI_PBAPClient_GetPhonebookSize(pbap_client.connection,
+                        pbap_client.repository, pbap_client.phonebook,
+                        &pullPhonebookSizeCB);
+    if (status != OI_STATUS_SUCCESS) {
+        ALOGE(LOGTAG "%s: Failed get phonebook size, status: %d", __FUNCTION__, status);
+        fprintf(stdout, "Failed get phonebook size, err: %d\n", status);
+        ret = false;
+    } else {
+        pbap_client.getting_phonebook = true;
+        fprintf(stdout, "Get Phonebook size in progress!!\n");
+    }
+    return ret;
+}
+
+bool PbapClient :: GetPhonebook()
+{
+    bool ret = true;
+
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    if (pbap_client.getting_vcard || pbap_client.getting_phonebook
+            || pbap_client.getting_listing || pbap_client.set_path
+            || pbap_client.abort) {
+        fprintf(stdout, "PBAP Operation in progress, please retry again!!\n");
+        return false;
+    }
+    if (pbap_client.state != STATE_CONNECTED) {
+        ALOGE(LOGTAG "%s: Not connected", __FUNCTION__);
+        fprintf(stdout, "Not connected, can't download\n");
+        return false;
+    }
+    pbap_client.getting_phonebook = true;
+    OI_STATUS status = OI_PBAPClient_PullPhonebook(pbap_client.connection,
+                        pbap_client.repository, pbap_client.phonebook,
+                        &pbap_client.filter, pbap_client.format,
+                        pbap_client.max_list_count, pbap_client.start_offset,
+                        &pullPhonebookCB);
+    if (status != OI_STATUS_SUCCESS) {
+        ALOGE(LOGTAG "%s: Failed pull phonebook, status: %d", __FUNCTION__, status);
+        fprintf(stdout, "Pull Phonebook failed, err: %d\n", status);
+        pbap_client.getting_phonebook = false;
+        ret = false;
+    } else {
+        fprintf(stdout, "Pull Phonebook in progress!!\n");
+    }
+    return ret;
+}
+
+bool PbapClient :: GetVcard(const OI_CHAR *handle)
+{
+    bool ret = true;
+    OI_UINT32 number = 0;
+    const OI_CHAR *dp = handle;
+
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    if (pbap_client.getting_vcard || pbap_client.getting_phonebook
+            || pbap_client.getting_listing || pbap_client.set_path
+            || pbap_client.abort) {
+        fprintf(stdout, "PBAP Operation in progress, please retry again!!\n");
+        return false;
+    }
+    if (pbap_client.state != STATE_CONNECTED) {
+        ALOGE(LOGTAG "%s: Not connected", __FUNCTION__);
+        fprintf(stdout, "Not connected, can't download\n");
+        return false;
+    }
+    while (*dp != '\0' && ishexdigit(*dp) && (number < OI_UINT32_MAX)) {
+        number *= 16;
+        if((*dp >= 'a') && (*dp <= 'f')) {
+            number += (10 + (*dp - 'a'));
+        } else if ((*dp >= 'A') && (*dp <= 'F')) {
+            number += (10 + (*dp - 'A'));
+        } else {
+            number += (*dp - '0');
+        }
+        dp++;
+    }
+    pbap_client.getting_vcard = true;
+    OI_STATUS status = OI_PBAPClient_PullvCardEntry(pbap_client.connection,
+                        pbap_client.repository, pbap_client.phonebook, number,
+                        &pbap_client.filter, pbap_client.format, &pullVcardCB);
+    if (status != OI_STATUS_SUCCESS) {
+        ALOGE(LOGTAG "%s: Failed pull vcard, status: %d", __FUNCTION__, status);
+        fprintf(stdout, "Pull Vcard failed, err: %d\n", status);
+        pbap_client.getting_vcard = false;
+        ret = false;
+    } else {
+        fprintf(stdout, "Pull Vcard in progress!!\n");
+    }
+    return ret;
+}
+
+bool PbapClient :: GetVcardListing()
+{
+    bool ret = true;
+
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    if (pbap_client.getting_vcard || pbap_client.getting_phonebook
+            || pbap_client.getting_listing || pbap_client.set_path
+            || pbap_client.abort) {
+        fprintf(stdout, "PBAP Operation in progress, please retry again!!\n");
+        return false;
+    }
+    if (pbap_client.state != STATE_CONNECTED) {
+        ALOGE(LOGTAG "%s: Not connected", __FUNCTION__);
+        fprintf(stdout, "Not connected, can't download\n");
+        return false;
+    }
+    pbap_client.getting_listing = true;
+    OI_STATUS status = OI_PBAPClient_PullvCardListing(pbap_client.connection,
+                        pbap_client.repository, pbap_client.phonebook,
+                        pbap_client.order, pbap_client.searchAttribute,
+                        pbap_client.searchValue, pbap_client.searchValueLen,
+                        pbap_client.max_list_count, pbap_client.start_offset,
+                        &pullPVcardListingCB);
+    if (status != OI_STATUS_SUCCESS) {
+        ALOGE(LOGTAG "%s: Failed pull vcard, status: %d", __FUNCTION__, status);
+        fprintf(stdout, "Pull Vcard listing failed, err: %d\n", status);
+        pbap_client.getting_listing = false;
+        ret = false;
+    } else {
+        fprintf(stdout, "Pull Vcard Listing in progress!!\n");
+    }
+    return ret;
+}
+
+bool PbapClient :: SetPath(const OI_CHAR *str)
+{
+    OI_UINT i;
+    OI_PBAP_REPOSITORY rep = OI_PBAP_INVALID_REPOSITORY;
+    OI_PBAP_PHONEBOOK pb = OI_PBAP_INVALID_PHONEBOOK;
+
+    if (pbap_client.getting_vcard || pbap_client.getting_phonebook
+            || pbap_client.getting_listing || pbap_client.set_path
+            || pbap_client.abort) {
+        fprintf(stdout, "PBAP Operation in progress, please retry again!!\n");
+        return false;
+    }
+    if (pbap_client.state != STATE_CONNECTED) {
+        ALOGE(LOGTAG "%s: Not connected", __FUNCTION__);
+        fprintf(stdout, "Not connected, can't perform setpath\n");
+        return false;
+    }
+    OI_ASSERT(str);
+
+    if (*str == '\0') {
+        OI_Printf("path cannot be set to nothing\n");
+        fprintf(stdout, "path cannot be set to nothing \n");
+        print_help(&variable_list[6]);
+        return false;
+    }
+
+    i = find_str_in_list(str, valid_paths, OI_ARRAYSIZE(valid_paths));
+
+    if (i < OI_ARRAYSIZE(valid_paths)) {
+        fprintf(stdout, "path set to: %s\n", str);
+    } else {
+        fprintf(stdout, "Invalid format: %s\n", str);
+        print_help(&variable_list[6]);
+    }
+    switch (i) {
+        case 0:
+            rep = OI_PBAP_LOCAL_REPOSITORY;
+            break;
+        case 1:
+            rep = OI_PBAP_LOCAL_REPOSITORY;
+            pb = OI_PBAP_MAIN_PHONEBOOK;
+            break;
+        case 2:
+            rep = OI_PBAP_LOCAL_REPOSITORY;
+            pb = OI_PBAP_INCOMING_CALLS_HISTORY;
+            break;
+        case 3:
+            rep = OI_PBAP_LOCAL_REPOSITORY;
+            pb = OI_PBAP_OUTGOING_CALLS_HISTORY;
+            break;
+        case 4:
+            rep = OI_PBAP_LOCAL_REPOSITORY;
+            pb = OI_PBAP_MISSED_CALLS_HISTORY;
+            break;
+        case 5:
+            rep = OI_PBAP_LOCAL_REPOSITORY;
+            pb = OI_PBAP_COMBINED_CALLS_HISTORY;
+            break;
+        case 6:
+            rep = OI_PBAP_SIM1_REPOSITORY;
+            break;
+        case 7:
+            rep = OI_PBAP_SIM1_REPOSITORY;
+            pb = OI_PBAP_MAIN_PHONEBOOK;
+            break;
+        case 8:
+            rep = OI_PBAP_SIM1_REPOSITORY;
+            pb = OI_PBAP_INCOMING_CALLS_HISTORY;
+            break;
+        case 9:
+            rep = OI_PBAP_SIM1_REPOSITORY;
+            pb = OI_PBAP_OUTGOING_CALLS_HISTORY;
+            break;
+        case 10:
+            rep = OI_PBAP_SIM1_REPOSITORY;
+            pb = OI_PBAP_MISSED_CALLS_HISTORY;
+            break;
+        case 11:
+            rep = OI_PBAP_SIM1_REPOSITORY;
+            pb = OI_PBAP_COMBINED_CALLS_HISTORY;
+            break;
+        default:
+            break;
+    }
+    pbap_client.set_path = true;
+    OI_STATUS status = OI_PBAPClient_SetPath(pbap_client.connection, rep, pb, &setPathCB);
+    if (status != OI_STATUS_SUCCESS) {
+        ALOGE(LOGTAG "%s: Set path, status: %d", __FUNCTION__, status);
+        fprintf(stdout, "Set path failed, err:  %d\n", status);
+        pbap_client.set_path = false;
+        return false;
+    } else {
+        fprintf(stdout, "Set path in progress!!\n");
+        return true;
+    }
+}
+
+bool PbapClient :: Abort()
+{
+    bool ret = true;
+
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+    if (pbap_client.state != STATE_CONNECTED) {
+        ALOGE(LOGTAG "%s: Not connected", __FUNCTION__);
+        fprintf(stdout, "Not connected, can't perform abort\n");
+        return false;
+    }
+    if (!(pbap_client.getting_vcard || pbap_client.getting_phonebook ||
+        pbap_client.getting_listing)) {
+        ALOGE(LOGTAG "%s: no operation ongoing", __FUNCTION__);
+        fprintf(stdout, "No operation ongoing, can't perform abort\n");
+        return false;
+    }
+    pbap_client.abort = true;
+    OI_STATUS status = OI_PBAPClient_Abort(pbap_client.connection, &abortCfm);
+    if (status != OI_STATUS_SUCCESS) {
+        ALOGE(LOGTAG "%s: Failed to abort ongoing operation, status: %d", __FUNCTION__, status);
+        pbap_client.abort = false;
+        ret = false;
+    } else {
+        fprintf(stdout, "Abort in progress!!\n");
+    }
+    return ret;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+
diff --git a/bt-app/rsp/include/Rsp.hpp b/bt-app/rsp/include/Rsp.hpp
new file mode 100644
index 0000000..e1e8898
--- /dev/null
+++ b/bt-app/rsp/include/Rsp.hpp
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RSP_APP_H
+#define RSP_APP_H
+
+#pragma once
+
+#include <hardware/bluetooth.h>
+#include <stdio.h>
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/allocator.h"
+#include "ipc.h"
+#include "Rsp.hpp"
+#include "Gatt.hpp"
+
+#define RSP_MIN_CI           (100)
+#define RSP_MAX_CI           (1000)
+
+#define GATT_PROP_READ       (0x02)
+#define GATT_PROP_WRITE      (0x08)
+
+#define GATT_PERM_READ       (0x01)
+#define GATT_PERM_WRITE      (0x10)
+
+#define LOGTAG "RSP "
+
+typedef enum
+{
+    WLAN_ACTIVE = 1,
+    WLAN_INACTIVE,
+    WLAN_TRANSACTION_PENDING,
+} rsp_power_state_t;
+class Gatt;
+class Rsp {
+    private:
+        config_t *config;
+        int wlan_state;
+
+        RspEnableEvent attr;
+        GattcRegisterAppEvent app_client_if;
+        GattsRegisterAppEvent app_if;
+        GattsServiceAddedEvent srvc_data;
+        GattsCharacteristicAddedEvent char_data;
+        GattsDescriptorAddedEvent desc_data;
+        GattsConnectionEvent conn_data;
+        btgatt_interface_t *gatt_interface;
+        Gatt *app_gatt;
+
+    public:
+        Rsp(btgatt_interface_t *, Gatt *);
+        ~Rsp();
+
+        bool EnableRSP();
+        bool DisableRSP();
+        inline btgatt_interface_t* GetGattInterface()
+        {
+            return gatt_interface;
+        }
+        inline int GetDeviceState()
+        {
+            fprintf(stdout, "(%s) WLAN Current State (%d) \n",__FUNCTION__, wlan_state);
+            return wlan_state;
+        }
+        inline void SetDeviceState(int currentstate)
+        {
+            fprintf(stdout, "(%s) WLAN Prev State (%d) New State(%d) \n"
+                   ,__FUNCTION__, wlan_state, currentstate);
+            wlan_state = currentstate;
+        }
+        inline void SetRSPClientAppData(GattcRegisterAppEvent *event)
+        {
+            memset(&app_client_if, 0, sizeof(app_client_if));
+            memcpy(&app_client_if, event, sizeof(GattcRegisterAppEvent));
+        }
+        inline GattcRegisterAppEvent* GetRSPClientAppData()
+        {
+            return &app_client_if;
+        }
+        inline void SetRSPAttrData(RspEnableEvent *attrib)
+        {
+            memset (&attr, 0, sizeof(RspEnableEvent));
+            memcpy (&attr, attrib, sizeof(RspEnableEvent));
+        }
+        inline RspEnableEvent* GetRSPAttrData()
+        {
+            return &attr;
+        }
+        inline void SetRSPAppData(GattsRegisterAppEvent *event)
+        {
+            if(app_if.uuid != NULL)
+                osi_free(app_if.uuid);
+            memset(&app_if, 0, sizeof(GattsRegisterAppEvent));
+            memcpy(&app_if, event, sizeof(GattsRegisterAppEvent));
+        }
+        inline GattsRegisterAppEvent* GetRSPAppData()
+        {
+            return &app_if;
+        }
+        inline void SetRSPSrvcData(GattsServiceAddedEvent *event)
+        {
+            memset(&srvc_data, 0, sizeof(GattsServiceAddedEvent));
+            memcpy(&srvc_data, event, sizeof(GattsServiceAddedEvent));
+        }
+        inline GattsServiceAddedEvent* GetRspSrvcData()
+        {
+            return &srvc_data;
+        }
+        inline void SetRSPCharacteristicData(GattsCharacteristicAddedEvent
+                *event)
+        {
+            if(char_data.char_id != NULL)
+                osi_free(char_data.char_id);
+            memset(&char_data, 0, sizeof(GattsCharacteristicAddedEvent));
+            memcpy(&char_data, event, sizeof(GattsCharacteristicAddedEvent));
+        }
+        inline GattsCharacteristicAddedEvent* GetRSPCharacteristicData()
+        {
+            return &char_data;
+        }
+        inline void SetRSPDescriptorData(GattsDescriptorAddedEvent *event)
+        {
+            if(desc_data.descr_id != NULL)
+                osi_free(desc_data.descr_id);
+            memset(&desc_data, 0, sizeof(GattsDescriptorAddedEvent));
+            memcpy(&desc_data, event, sizeof(GattsDescriptorAddedEvent));
+        }
+        inline GattsDescriptorAddedEvent* GetRSPDescriptorData()
+        {
+            return &desc_data;
+        }
+        inline void SetRSPConnectionData(GattsConnectionEvent *event)
+        {
+            memset(&conn_data, 0, sizeof(GattsConnectionEvent));
+            memcpy(&conn_data, event, sizeof(GattsConnectionEvent));
+        }
+        inline GattsConnectionEvent* GetRSPConnectionData()
+        {
+            return &conn_data;
+        }
+        bool SendResponse(GattsRequestWriteEvent *);
+        bool CopyUUID(bt_uuid_t *);
+        bool CopyCharacteristicsUUID(bt_uuid_t *);
+        bool CopyDescriptorUUID(bt_uuid_t *);
+        bool CopyServerUUID(bt_uuid_t *);
+        bool CopyServiceUUID(bt_uuid_t *);
+        bool CopyClientUUID(bt_uuid_t *);
+        bool ClientSetAdvData(char *);
+        bool CopyParams(bt_uuid_t *, bt_uuid_t *);
+        bool MatchParams(bt_uuid_t *, bt_uuid_t *);
+        bool RegisterApp(void);
+        bool DisconnectServer(void);
+        bool UnregisterServer(int);
+        bool RegisterClient(void);
+        bool UnregisterClient(int);
+        bool StartAdvertisement(void);
+        bool StopAdvertisement(void);
+        bool AddService(void);
+        bool AddCharacteristics(void);
+        bool AddDescriptor(void);
+        bool StartService(void);
+        bool StopService(void);
+        bool DeleteService(void);
+        bool HandleWlanOn(void);
+        void CleanUp(int);
+};
+#endif
+
diff --git a/bt-app/rsp/src/Rsp.cpp b/bt-app/rsp/src/Rsp.cpp
new file mode 100644
index 0000000..fd4c14b
--- /dev/null
+++ b/bt-app/rsp/src/Rsp.cpp
@@ -0,0 +1,877 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "Gatt.hpp"
+#include "Rsp.hpp"
+
+#define LOGTAG "RSP "
+#define UNUSED
+
+Rsp *rsp = NULL;
+int serverif, clientif;
+
+class clientCallback : public BluetoothGattClientCallback
+{
+   public:
+   void btgattc_client_register_app_cb(int status,int client_if,bt_uuid_t *uuid) {
+
+        fprintf(stdout,"gattClinetRegisterAppCb\n ");
+
+        GattcRegisterAppEvent event;
+        event.event_id = RSP_ENABLE_EVENT;
+        event.status = status;
+        event.clientIf = client_if;
+        rsp->SetRSPClientAppData(&event);
+
+        rsp->ClientSetAdvData("Remote Start Profile");
+        rsp->StartAdvertisement();
+   }
+
+   void btgattc_scan_result_cb(bt_bdaddr_t* bda, int rssi, uint8_t* adv_data) {
+        UNUSED
+   }
+
+   void btgattc_open_cb(int conn_id, int status, int clientIf, bt_bdaddr_t* bda)
+   {
+        UNUSED
+   }
+
+   void btgattc_close_cb(int conn_id, int status, int clientIf, bt_bdaddr_t* bda)
+   {
+        UNUSED
+   }
+
+   void btgattc_search_complete_cb(int conn_id, int status)
+   {
+        UNUSED
+   }
+
+   void btgattc_search_result_cb(int conn_id, btgatt_srvc_id_t *srvc_id)
+   {
+        UNUSED
+   }
+
+   void btgattc_get_characteristic_cb(int conn_id, int status,
+                                     btgatt_srvc_id_t *srvc_id, btgatt_gatt_id_t *char_id,
+                                     int char_prop)
+   {
+        UNUSED
+   }
+
+   void btgattc_get_descriptor_cb(int conn_id, int status,
+                                 btgatt_srvc_id_t *srvc_id, btgatt_gatt_id_t *char_id,
+                                 btgatt_gatt_id_t *descr_id)
+   {
+        UNUSED
+   }
+
+   void btgattc_get_included_service_cb(int conn_id, int status,
+                                       btgatt_srvc_id_t *srvc_id, btgatt_srvc_id_t *incl_srvc_id)
+   {
+        UNUSED
+   }
+
+   void btgattc_register_for_notification_cb(int conn_id, int registered,
+                                                int status, btgatt_srvc_id_t *srvc_id,
+                                                btgatt_gatt_id_t *char_id)
+   {
+        UNUSED
+   }
+
+   void btgattc_notify_cb(int conn_id, btgatt_notify_params_t *p_data)
+   {
+        UNUSED
+   }
+
+   void btgattc_read_characteristic_cb(int conn_id, int status,
+                                          btgatt_read_params_t *p_data)
+   {
+        UNUSED
+   }
+
+   void btgattc_write_characteristic_cb(int conn_id, int status,
+                                           btgatt_write_params_t *p_data)
+   {
+        UNUSED
+   }
+
+   void btgattc_read_descriptor_cb(int conn_id, int status, btgatt_read_params_t *p_data)
+   {
+        UNUSED
+   }
+
+    void btgattc_write_descriptor_cb(int conn_id, int status, btgatt_write_params_t *p_data)
+    {
+        UNUSED
+    }
+
+   void btgattc_execute_write_cb(int conn_id, int status)
+   {
+        UNUSED
+   }
+
+   void btgattc_remote_rssi_cb(int client_if,bt_bdaddr_t* bda, int rssi, int status)
+   {
+       UNUSED
+   }
+
+   void btgattc_advertise_cb(int status, int client_if)
+   {
+        UNUSED
+
+   }
+
+   void btgattc_configure_mtu_cb(int conn_id, int status, int mtu)
+   {
+        UNUSED
+   }
+
+   void btgattc_scan_filter_cfg_cb(int action, int client_if, int status, int filt_type, int avbl_space)
+   {
+        UNUSED
+   }
+
+   void btgattc_scan_filter_param_cb(int action, int client_if, int status, int avbl_space)
+   {
+        UNUSED
+   }
+
+   void btgattc_scan_filter_status_cb(int action, int client_if, int status)
+   {
+        UNUSED
+   }
+
+   void btgattc_multiadv_enable_cb(int client_if, int status)
+   {
+        UNUSED
+   }
+
+   void btgattc_multiadv_update_cb(int client_if, int status)
+   {
+        UNUSED
+   }
+
+    void btgattc_multiadv_setadv_data_cb(int client_if, int status)
+   {
+        UNUSED
+   }
+
+   void btgattc_multiadv_disable_cb(int client_if, int status)
+   {
+        UNUSED
+   }
+
+   void btgattc_congestion_cb(int conn_id, bool congested)
+   {
+        UNUSED
+   }
+
+   void btgattc_batchscan_cfg_storage_cb(int client_if, int status)
+   {
+        UNUSED
+   }
+
+   void btgattc_batchscan_startstop_cb(int startstop_action, int client_if, int status)
+   {
+        UNUSED
+
+   }
+
+   void btgattc_batchscan_reports_cb(int client_if, int status, int report_format,
+        int num_records, int data_len, uint8_t *p_rep_data)
+   {
+        UNUSED
+   }
+
+   void btgattc_batchscan_threshold_cb(int client_if)
+   {
+        UNUSED
+   }
+
+   void btgattc_track_adv_event_cb(btgatt_track_adv_info_t *p_adv_track_info)
+   {
+        UNUSED
+   }
+
+   void btgattc_scan_parameter_setup_completed_cb(int client_if, btgattc_error_t status)
+   {
+        UNUSED
+   }
+
+};
+
+class serverCallback :public BluetoothGattServerCallback
+{
+
+      public:
+
+      void gattServerRegisterAppCb(int status, int server_if, bt_uuid_t *uuid) {
+
+           fprintf(stdout,"gattServerRegisterAppCb status is %d, serverif is %d \n ",
+                   status, server_if);
+
+           if (status == BT_STATUS_SUCCESS)
+           {
+              GattsRegisterAppEvent rev;
+              rev.event_id = RSP_ENABLE_EVENT;
+              rev.server_if = server_if;
+              rev.uuid = uuid;
+              rev.status = status;
+              fprintf(stdout," set rsp data \n");
+              rsp->SetRSPAppData(&rev);
+              rsp->AddService();
+           } else {
+              fprintf (stdout,"(%s) Failed to registerApp, %d \n",__FUNCTION__, server_if);
+           }
+      }
+
+      void btgatts_connection_cb(int conn_id, int server_if, int connected, bt_bdaddr_t *bda)
+      {
+
+           fprintf(stdout,"btgatts_connection_cb  rsp \n ");
+
+           GattsConnectionEvent event;
+           event.event_id = RSP_ENABLE_EVENT;
+           event.conn_id = conn_id;
+           event.server_if = server_if;
+           event.connected = connected;
+           event.bda = bda;
+
+           if (rsp) {
+               rsp->SetRSPConnectionData(&event);
+               if (connected)
+               {
+                   rsp->StopAdvertisement();
+               }
+           }
+      }
+
+      void btgatts_service_added_cb(int status, int server_if,
+                                    btgatt_srvc_id_t *srvc_id, int srvc_handle)
+      {
+           fprintf(stdout,"btgatts_service_added_cb \n");
+           if (status == BT_STATUS_SUCCESS) {
+              GattsServiceAddedEvent event;
+               event.event_id =RSP_ENABLE_EVENT;
+               event.server_if = server_if;
+               event.srvc_id = srvc_id;
+               event.srvc_handle = srvc_handle;
+               rsp->SetRSPSrvcData(&event);
+               rsp->AddCharacteristics();
+           } else {
+               fprintf(stdout, "(%s) Failed to Add_Service %d ",__FUNCTION__, server_if);
+           }
+      }
+
+      void btgatts_included_service_added_cb(int status, int server_if, int srvc_handle,
+                                                   int incl_srvc_handle)
+      {
+            UNUSED;
+      }
+
+      void btgatts_characteristic_added_cb(int status, int server_if, bt_uuid_t *char_id,
+                                                      int srvc_handle, int char_handle)
+      {
+           fprintf(stdout,"btgatts_characteristic_added_cb \n");
+           if (status == BT_STATUS_SUCCESS) {
+               GattsCharacteristicAddedEvent event;
+               event.event_id =RSP_ENABLE_EVENT;
+               event.server_if = server_if;
+               event.char_id = char_id;
+               event.srvc_handle = srvc_handle;
+               event.char_handle = char_handle;
+               rsp->SetRSPCharacteristicData(&event);
+               rsp->AddDescriptor();
+           } else {
+               fprintf(stdout, "(%s) Failed to Add Characteristics %d ",__FUNCTION__, server_if);
+           }
+      }
+
+      void btgatts_descriptor_added_cb(int status, int server_if, bt_uuid_t *descr_id,
+                                                  int srvc_handle, int descr_handle)
+      {
+           fprintf(stdout,"btgatts_descriptor_added_cb \n");
+           if (status == BT_STATUS_SUCCESS) {
+               GattsDescriptorAddedEvent event;
+               event.event_id =RSP_ENABLE_EVENT;
+               event.server_if = server_if;
+               event.descr_id= descr_id;
+               event.srvc_handle = srvc_handle;
+               event.descr_handle= descr_handle;
+               rsp->SetRSPDescriptorData(&event);
+               rsp->StartService();
+            } else {
+               fprintf(stdout, "(%s) Failed to add descriptor %d \n",__FUNCTION__, server_if);
+            }
+      }
+
+      void btgatts_service_started_cb(int status, int server_if, int srvc_handle)
+      {
+           fprintf(stdout,"btgatts_service_started_cb \n");
+           rsp->RegisterClient();
+      }
+
+      void btgatts_service_stopped_cb(int status, int server_if, int srvc_handle)
+      {
+           fprintf(stdout,"btgatts_service_stopped_cb \n");
+
+          if (rsp) {
+              if (!status)
+                  rsp->DeleteService();
+          }
+          fprintf(stdout,  "RSP Service stopped successfully, deleting the service");
+      }
+
+      void btgatts_service_deleted_cb(int status, int server_if, int srvc_handle)
+      {
+         fprintf(stdout,"btgatts_service_deleted_cb \n");
+
+          if (rsp) {
+              if (!status) {
+                  rsp->CleanUp(server_if);
+                  delete rsp;
+                  rsp = NULL;
+              }
+          }
+          fprintf(stdout,"RSP Service stopped & Unregistered successfully\n");
+      }
+
+      void btgatts_request_read_cb(int conn_id, int trans_id, bt_bdaddr_t *bda, int attr_handle,
+                                              int offset, bool is_long)
+      {
+           UNUSED;
+      }
+
+      void btgatts_request_write_cb(int conn_id, int trans_id, bt_bdaddr_t *bda, int attr_handle,
+                                              int offset, int length, bool need_rsp, bool is_prep,
+                                              uint8_t* value)
+      {
+           fprintf(stdout,"onCharacteristicWriteRequest \n");
+           GattsRequestWriteEvent event;
+           event.event_id = RSP_ENABLE_EVENT;
+           event.conn_id = conn_id;
+           event.trans_id = trans_id;
+           event.bda = bda;
+           event.attr_handle = attr_handle;
+           event.offset = offset;
+           event.length = length;
+           event.need_rsp = need_rsp;
+           event.is_prep = is_prep;
+           event.value = value;
+           rsp->SendResponse(&event);
+      }
+
+      void btgatts_request_exec_write_cb(int conn_id, int trans_id,
+                                                      bt_bdaddr_t *bda, int exec_write)
+      {
+           UNUSED;
+      }
+
+      void btgatts_response_confirmation_cb(int status, int handle)
+      {
+           UNUSED;
+      }
+
+      void btgatts_indication_sent_cb(int conn_id, int status)
+      {
+           UNUSED;
+      }
+
+      void btgatts_congestion_cb(int conn_id, bool congested)
+      {
+           UNUSED;
+      }
+
+      void btgatts_mtu_changed_cb(int conn_id, int mtu)
+      {
+           UNUSED;
+      }
+};
+
+serverCallback *serverCb = NULL;
+clientCallback *clientCb = NULL;
+
+
+
+Rsp::Rsp(btgatt_interface_t *gatt_itf, Gatt* gatt)
+{
+
+    fprintf(stdout,"rsp instantiated ");
+    gatt_interface = gatt_itf;
+    app_gatt = gatt;
+
+    GattsRegisterAppEvent* p_app_if = GetRSPAppData();
+    memset(p_app_if, 0, sizeof(GattsRegisterAppEvent));
+
+    GattsCharacteristicAddedEvent* p_char_data = GetRSPCharacteristicData();
+    memset(p_char_data, 0, sizeof(GattsCharacteristicAddedEvent));
+
+    GattsDescriptorAddedEvent* p_desc_data = GetRSPDescriptorData();
+    memset(p_desc_data, 0, sizeof(GattsDescriptorAddedEvent));
+}
+
+
+Rsp::~Rsp()
+{
+    fprintf(stdout, "(%s) RSP DeInitialized",__FUNCTION__);
+    SetDeviceState(WLAN_INACTIVE);
+
+    GattsRegisterAppEvent* p_app_if = GetRSPAppData();
+    if(p_app_if->uuid != NULL)
+        osi_free(p_app_if->uuid);
+
+    GattsCharacteristicAddedEvent* p_char_data = GetRSPCharacteristicData();
+    if(p_char_data->char_id != NULL)
+        osi_free(p_char_data->char_id);
+
+    GattsDescriptorAddedEvent* p_desc_data = GetRSPDescriptorData();
+    if(p_desc_data->descr_id != NULL)
+        osi_free(p_desc_data->descr_id);
+}
+
+bool Rsp::CopyUUID(bt_uuid_t *uuid)
+{
+    CHECK_PARAM(uuid)
+    for (int i = 0; i < 16; i++) {
+        uuid->uu[i] = 0x30;
+    }
+    return true;
+}
+bool Rsp::CopyCharacteristicsUUID(bt_uuid_t *uuid)
+{
+    CHECK_PARAM(uuid);
+    uuid->uu[0] = 0xfb;
+    uuid->uu[1] = 0x34;
+    uuid->uu[2] = 0x9b;
+    uuid->uu[3] = 0x5f;
+    uuid->uu[4] = 0x80;
+    uuid->uu[5] = 0x00;
+    uuid->uu[6] = 0x00;
+    uuid->uu[7] = 0x80;
+    uuid->uu[8] = 0x00;
+    uuid->uu[9] = 0x10;
+    uuid->uu[10] = 0x00;
+    uuid->uu[11] = 0x00;
+
+    uuid->uu[12] = 0x02;
+    uuid->uu[13] = 0xbb;
+
+    uuid->uu[14] = 0x00;
+    uuid->uu[15] = 0x00;
+
+    return true;
+}
+bool Rsp::CopyDescriptorUUID(bt_uuid_t *uuid)
+{
+    CHECK_PARAM(uuid);
+    uuid->uu[0] = 0xfb;
+    uuid->uu[1] = 0x34;
+    uuid->uu[2] = 0x9b;
+    uuid->uu[3] = 0x5f;
+    uuid->uu[4] = 0x80;
+    uuid->uu[5] = 0x00;
+    uuid->uu[6] = 0x00;
+    uuid->uu[7] = 0x80;
+    uuid->uu[8] = 0x00;
+    uuid->uu[9] = 0x10;
+    uuid->uu[10] = 0x00;
+    uuid->uu[11] = 0x00;
+
+    uuid->uu[12] = 0x03;
+    uuid->uu[13] = 0xcc;
+
+    uuid->uu[14] = 0x00;
+    uuid->uu[15] = 0x00;
+
+    return true;
+}
+bool Rsp::CopyServerUUID(bt_uuid_t *uuid)
+{
+    CHECK_PARAM(uuid);
+    uuid->uu[0] = 0xfb;
+    uuid->uu[1] = 0x34;
+    uuid->uu[2] = 0x9b;
+    uuid->uu[3] = 0x5f;
+    uuid->uu[4] = 0x80;
+    uuid->uu[5] = 0x00;
+    uuid->uu[6] = 0x00;
+    uuid->uu[7] = 0x80;
+    uuid->uu[8] = 0x00;
+    uuid->uu[9] = 0x10;
+    uuid->uu[10] = 0x00;
+    uuid->uu[11] = 0x00;
+
+    uuid->uu[12] = 0x06;
+    uuid->uu[13] = 0x00;
+
+    uuid->uu[14] = 0x00;
+    uuid->uu[15] = 0x00;
+
+    return true;
+}
+bool Rsp::CopyServiceUUID(bt_uuid_t *uuid)
+{
+    CHECK_PARAM(uuid);
+    uuid->uu[0] = 0xfb;
+    uuid->uu[1] = 0x34;
+    uuid->uu[2] = 0x9b;
+    uuid->uu[3] = 0x5f;
+    uuid->uu[4] = 0x80;
+    uuid->uu[5] = 0x00;
+    uuid->uu[6] = 0x00;
+    uuid->uu[7] = 0x80;
+    uuid->uu[8] = 0x00;
+    uuid->uu[9] = 0x10;
+    uuid->uu[10] = 0x00;
+    uuid->uu[11] = 0x00;
+
+    uuid->uu[12] = 0x01;
+    uuid->uu[13] = 0xaa;
+
+    uuid->uu[14] = 0x00;
+    uuid->uu[15] = 0x00;
+    return true;
+}
+bool Rsp::CopyClientUUID(bt_uuid_t *uuid)
+{
+    CHECK_PARAM(uuid)
+    uuid->uu[0] = 0xff;
+    uuid->uu[1] = 0x34;
+    uuid->uu[2] = 0x9b;
+    uuid->uu[3] = 0x5f;
+    uuid->uu[4] = 0x80;
+    uuid->uu[5] = 0x00;
+    uuid->uu[6] = 0x00;
+    uuid->uu[7] = 0x80;
+    uuid->uu[8] = 0x00;
+    uuid->uu[9] = 0x10;
+    uuid->uu[10] = 0x00;
+    uuid->uu[11] = 0x00;
+
+    uuid->uu[12] = 0x05;
+    uuid->uu[13] = 0x00;
+
+    uuid->uu[14] = 0x00;
+    uuid->uu[15] = 0x00;
+    return true;
+}
+
+bool Rsp::CopyParams(bt_uuid_t *uuid_dest, bt_uuid_t *uuid_src)
+{
+    CHECK_PARAM(uuid_dest)
+    CHECK_PARAM(uuid_src)
+
+    for (int i = 0; i < 16; i++) {
+        uuid_dest->uu[i] = uuid_src->uu[i];
+    }
+    return true;
+}
+
+bool Rsp::MatchParams(bt_uuid_t *uuid_dest, bt_uuid_t *uuid_src)
+{
+    CHECK_PARAM(uuid_dest)
+    CHECK_PARAM(uuid_src)
+
+    for (int i = 0; i < 16; i++) {
+        if(uuid_dest->uu[i] != uuid_src->uu[i])
+            return false;
+    }
+    fprintf(stdout, "(%s) UUID Matches",__FUNCTION__);
+    return true;
+}
+
+bool Rsp::EnableRSP()
+{
+    fprintf(stdout, "(%s) Enable RSP Initiated \n",__FUNCTION__);
+
+    RspEnableEvent rev;
+    rev.event_id = RSP_ENABLE_EVENT;// change it later
+    CopyCharacteristicsUUID(&rev.characteristics_uuid);
+    CopyDescriptorUUID(&rev.descriptor_uuid);
+    CopyServerUUID(&rev.server_uuid);
+    CopyClientUUID(&rev.client_uuid);
+    CopyServiceUUID(&rev.service_uuid);
+
+    fprintf(stdout," set rsp data \n");
+    SetRSPAttrData(&rev);
+    RegisterApp();
+}
+
+bool Rsp::DisableRSP()
+{
+    fprintf(stdout, "(%s) Disable RSP Initiated",__FUNCTION__);
+    StopService();
+}
+
+bool Rsp::RegisterApp()
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+    serverCb = new serverCallback;
+    bt_uuid_t server_uuid = GetRSPAttrData()->server_uuid;
+    fprintf(stdout,"reg app addr is %d \n", GetRSPAttrData()->server_uuid);
+    app_gatt->RegisterServerCallback(serverCb,&GetRSPAttrData()->server_uuid);
+    return app_gatt->register_server(&server_uuid) == BT_STATUS_SUCCESS;
+}
+
+bool Rsp::RegisterClient()
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+    clientCb = new clientCallback;
+    bt_uuid_t client_uuid = GetRSPAttrData()->client_uuid;
+    app_gatt->RegisterClientCallback(clientCb,&GetRSPAttrData()->client_uuid);
+    return app_gatt->register_client(&client_uuid) == BT_STATUS_SUCCESS;
+}
+
+bool Rsp::UnregisterClient(int client_if)
+{
+    if (GetGattInterface() == NULL) {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+    if(clientCb != NULL)
+        delete clientCb;
+    app_gatt->UnRegisterClientCallback(client_if);
+    return app_gatt->unregister_client(client_if) == BT_STATUS_SUCCESS;
+}
+
+bool Rsp::ClientSetAdvData(char *str)
+{
+    bt_status_t        Ret;
+    bool              SetScanRsp        = false;
+    bool              IncludeName       = true;
+    bool              IncludeTxPower    = false;
+    int               min_conn_interval = RSP_MIN_CI;
+    int               max_conn_interval = RSP_MAX_CI;
+
+    app_gatt->set_adv_data(GetRSPClientAppData()->clientIf, SetScanRsp,
+                                                IncludeName, IncludeTxPower, min_conn_interval,
+                                                max_conn_interval, 0,strlen(str), str,
+                                                strlen(str), str, 0,NULL);
+}
+
+void Rsp::CleanUp(int server_if)
+{
+    UnregisterServer(server_if);
+    UnregisterClient(GetRSPClientAppData()->clientIf);
+}
+
+bool Rsp::UnregisterServer(int server_if)
+{
+    if (GetGattInterface() == NULL) {
+        ALOGE(LOGTAG  "Gatt Interface Not present");
+        return false;
+    }
+    app_gatt->UnRegisterServerCallback(server_if);
+    if(serverCb != NULL)
+        delete serverCb;
+    return app_gatt->unregister_server(server_if) == BT_STATUS_SUCCESS;
+}
+
+bool Rsp::StartAdvertisement()
+{
+    if (GetGattInterface() == NULL) {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+    fprintf(stdout,  "(%s) Listening on the interface (%d) ",__FUNCTION__,
+            GetRSPAppData()->server_if);
+    SetDeviceState(WLAN_INACTIVE);
+    return app_gatt->listen(GetRSPClientAppData()->clientIf, true);
+}
+
+bool Rsp::SendResponse(GattsRequestWriteEvent *event)
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present \n",__FUNCTION__);
+        return false;
+    }
+    CHECK_PARAM(event)
+    btgatt_response_t att_resp;
+    int response = -1;
+    memset(att_resp.attr_value.value,0,BTGATT_MAX_ATTR_LEN);
+    memcpy(att_resp.attr_value.value, event->value, event->length);
+    att_resp.attr_value.handle = event->attr_handle;
+    att_resp.attr_value.offset = event->offset;
+    att_resp.attr_value.len = event->length;
+    att_resp.attr_value.auth_req = 0;
+
+    if(event->value != NULL && !strncasecmp((const char *)(event->value), "on", 2)) {
+        if (GetDeviceState() == WLAN_INACTIVE)
+        {
+            fprintf(stdout, "(%s) Turn ON WLAN\n", __FUNCTION__);
+            HandleWlanOn();
+            SetDeviceState(WLAN_TRANSACTION_PENDING);
+        }
+        response = 0;
+    } else {
+        response = -1;
+    }
+
+    fprintf(stdout, "(%s) Sending RSP response to write (%d) value (%s) State (%d)",__FUNCTION__,
+            GetRSPAppData()->server_if, event->value,GetDeviceState());
+    if(event->value != NULL)
+        osi_free(event->value);
+
+    rsp->SetDeviceState(WLAN_ACTIVE);;
+    return app_gatt->send_response(event->conn_id, event->trans_id,
+                                                         response, &att_resp);
+}
+
+bool Rsp::HandleWlanOn()
+{
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM(event);
+    event->event_id = SKT_API_IPC_MSG_WRITE;
+    event->bt_ipc_msg_event.ipc_msg.type = BT_IPC_REMOTE_START_WLAN;
+    event->bt_ipc_msg_event.ipc_msg.status = INITIATED;
+    StopAdvertisement();
+    fprintf(stdout, "(%s) Posting wlan start to main thread \n",__FUNCTION__);
+    PostMessage (THREAD_ID_MAIN, event);
+    return true;
+}
+
+bool Rsp::StopAdvertisement()
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+    fprintf(stdout, "(%s) Stopping listen on the interface (%d) \n",__FUNCTION__,
+            GetRSPClientAppData()->clientIf);
+    return app_gatt->listen(GetRSPClientAppData()->clientIf, false);
+}
+
+bool Rsp::AddService()
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+    btgatt_srvc_id_t srvc_id;
+    srvc_id.id.inst_id = 0;   // 1 instance
+    srvc_id.is_primary = 1;   // Primary addition
+    srvc_id.id.uuid = GetRSPAttrData()->service_uuid;
+    return app_gatt->add_service(GetRSPAppData()->server_if, &srvc_id,4)
+                                                        ==BT_STATUS_SUCCESS;
+}
+
+bool Rsp::DisconnectServer()
+{
+    int server_if = GetRSPConnectionData()->server_if;
+    bt_bdaddr_t * bda = GetRSPConnectionData()->bda;
+    int conn_id = GetRSPConnectionData()->conn_id;
+    fprintf(stdout,  "(%s) Disconnecting interface (%d), connid (%d) ",__FUNCTION__,
+            server_if, conn_id);
+    return app_gatt->serverDisconnect(server_if, bda, conn_id) == BT_STATUS_SUCCESS;
+}
+
+bool Rsp::DeleteService()
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+    bool status = false;
+    int srvc_handle = GetRspSrvcData()->srvc_handle;
+    return app_gatt->delete_service(GetRSPAppData()->server_if,
+                                                            srvc_handle) == BT_STATUS_SUCCESS;
+}
+
+bool Rsp::AddCharacteristics()
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+    bt_uuid_t char_uuid;
+    char_uuid=GetRSPAttrData()->characteristics_uuid;
+    int srvc_handle = GetRspSrvcData()->srvc_handle;
+    int server_if = GetRspSrvcData()->server_if;
+    fprintf(stdout,  "(%s) Adding Characteristics server_if (%d), srvc_handle (%d) \n",
+            __FUNCTION__, server_if,srvc_handle);
+    return app_gatt->add_characteristic(server_if, srvc_handle, &char_uuid,
+                                                            GATT_PROP_WRITE, GATT_PERM_WRITE)
+                                                            ==BT_STATUS_SUCCESS;
+}
+
+bool Rsp::AddDescriptor(void)
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+
+    bt_uuid_t desc_uuid;
+    desc_uuid = GetRSPAttrData()->descriptor_uuid;
+    int srvc_handle = GetRspSrvcData()->srvc_handle;
+    return app_gatt->add_descriptor(GetRSPAppData()->server_if,
+                                                        srvc_handle, &desc_uuid,
+                                                        GATT_PERM_READ) == BT_STATUS_SUCCESS;
+}
+
+bool Rsp::StartService()
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+
+    int srvc_handle = GetRspSrvcData()->srvc_handle;
+    return app_gatt->start_service(GetRSPAppData()->server_if,
+                                                        srvc_handle, GATT_TRANSPORT_LE)
+                                                        == BT_STATUS_SUCCESS;
+}
+
+bool Rsp::StopService()
+{
+    if (GetGattInterface() == NULL)
+    {
+        ALOGE(LOGTAG  "(%s) Gatt Interface Not present",__FUNCTION__);
+        return false;
+    }
+
+    int srvc_handle = GetRspSrvcData()->srvc_handle;
+    return app_gatt->stop_service(GetRSPAppData()->server_if,
+                                                        srvc_handle) == BT_STATUS_SUCCESS;
+}
diff --git a/bt-app/sdp_client/include/SdpClient.hpp b/bt-app/sdp_client/include/SdpClient.hpp
new file mode 100644
index 0000000..1ae13c1
--- /dev/null
+++ b/bt-app/sdp_client/include/SdpClient.hpp
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SDP_CLIENT_H
+#define SDP_CLIENT_H
+
+#pragma once
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_sdp.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/alarm.h"
+#include "ipc.h"
+
+#define SDP_SEARCH_TIMEOUT_DELAY     (6000)
+
+class SdpClient {
+    private:
+        const bt_interface_t * bluetooth_interface;
+        const btsdp_interface_t *sdp_client_interface;
+        bt_bdaddr_t mDevice;
+        config_t *config;
+        bool Search(bt_bdaddr_t *addr, uint8_t *uuid, SdpSearchCb cb);
+        void AddRecord(bluetooth_sdp_record *record, SdpAddRecordCb cb);
+        void RemoveRecord(int record_handle, SdpRemoveRecordCb cb);
+
+    public:
+        SdpClient(const bt_interface_t *bt_interface, config_t *config);
+        ~SdpClient();
+        alarm_t *sdp_search_timer;
+        bool HandleEnableSdpClient();
+        bool HandleDisableSdpClient();
+        void ProcessEvent(BtEvent* pEvent);
+};
+
+#endif
+
diff --git a/bt-app/sdp_client/src/SdpClient.cpp b/bt-app/sdp_client/src/SdpClient.cpp
new file mode 100644
index 0000000..490b21c
--- /dev/null
+++ b/bt-app/sdp_client/src/SdpClient.cpp
@@ -0,0 +1,287 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <list>
+#include <map>
+#include "osi/include/log.h"
+#include "SdpClient.hpp"
+#include "utils.h"
+
+#define LOGTAG "Sdp "
+
+using namespace std;
+
+SdpClient *g_sdpClient = NULL;;
+SdpSearchCb mSearchCb;
+bool mSearchOngoing;
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+void BtSdpClientMsgHandler(void *msg)
+{
+    BtEvent* event = NULL;
+    bool status = false;
+    if(!msg) {
+        ALOGE(LOGTAG "%s: Msg is null, return", __FUNCTION__);
+        return;
+    }
+
+    event = ( BtEvent *) msg;
+
+    if (event == NULL)
+    {
+        ALOGE(LOGTAG "%s: event is null", __FUNCTION__);
+        return;
+    }
+
+    ALOGD(LOGTAG "BtSdpClientMsgHandler event = %d", event->event_id);
+    switch(event->event_id) {
+        case PROFILE_API_START:
+            if (g_sdpClient) {
+                status = g_sdpClient->HandleEnableSdpClient();
+
+                BtEvent *start_event = new BtEvent;
+                start_event->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+                start_event->profile_start_event.profile_id = PROFILE_ID_SDP_CLIENT;
+                start_event->profile_start_event.status = status;
+                PostMessage(THREAD_ID_GAP, start_event);
+            }
+            break;
+
+        case PROFILE_API_STOP:
+            if (g_sdpClient) {
+                status = g_sdpClient->HandleDisableSdpClient();
+
+                BtEvent *stop_event = new BtEvent;
+                stop_event->profile_start_event.event_id = PROFILE_EVENT_STOP_DONE;
+                stop_event->profile_start_event.profile_id = PROFILE_ID_SDP_CLIENT;
+                stop_event->profile_start_event.status = status;
+                PostMessage(THREAD_ID_GAP, stop_event);
+            }
+            break;
+
+        default:
+            if(g_sdpClient) {
+               g_sdpClient->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+    }
+    delete event;
+}
+
+void sdp_client_search_callback(bt_status_t status, bt_bdaddr_t *addr, uint8_t* uuid,
+            int num_records, bluetooth_sdp_record *records)
+{
+    int i = 0;
+    bluetooth_sdp_record* record;
+
+    ALOGD(LOGTAG "%s: Status is: %d, Record count: %d", __FUNCTION__, status, num_records);
+
+    //stoping sdp_search_timer
+    if(g_sdpClient) {
+        alarm_cancel(g_sdpClient->sdp_search_timer);
+    }
+    // Ensure we run the loop at least once, to also signal errors if they occur
+    for(i = 0; i < num_records || i==0; i++) {
+        bool more_results = (i < (num_records - 1 ))? true : false;
+        record = &records[i];
+        if (record->hdr.service_name_length > 0) {
+            ALOGD("%s, ServiceName:  %s", __FUNCTION__, record->hdr.service_name);
+        }
+        if (mSearchCb)
+            mSearchCb(status, addr, uuid, record, more_results);
+    }
+    mSearchOngoing = false;
+    mSearchCb = NULL;
+}
+
+static btsdp_callbacks_t sBluetoothSdpClientCallback = {
+    sizeof(sBluetoothSdpClientCallback),
+    sdp_client_search_callback,
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+SdpClient :: SdpClient(const bt_interface_t *bt_interface, config_t *config)
+{
+    this->bluetooth_interface = bt_interface;
+    this->config = config;
+    sdp_search_timer = NULL;
+    if( !(sdp_search_timer = alarm_new())) {
+        ALOGE(LOGTAG, " unable to create sdp_search_timer");
+        return;
+    }
+
+}
+
+SdpClient :: ~SdpClient()
+{
+    alarm_free(g_sdpClient->sdp_search_timer);
+    g_sdpClient->sdp_search_timer = NULL;
+}
+
+void sdp_search_timer_expired(void *context) {
+    ALOGD(LOGTAG, " sdp_search_timer_expired");
+
+    BtEvent *event = new BtEvent;
+    event->event_id = SDP_CLIENT_SEARCH_TIMEOUT;
+    memcpy(&event->sdp_client_event.bd_addr, (bt_bdaddr_t *)context, sizeof(bt_bdaddr_t));
+    PostMessage(THREAD_ID_SDP_CLIENT, event);
+}
+
+void SdpClient::ProcessEvent(BtEvent* pEvent)
+{
+    char str[18];
+    ALOGD(LOGTAG "%s: Processing event %d", __FUNCTION__, pEvent->event_id);
+
+    switch(pEvent->event_id) {
+
+        case SDP_CLIENT_SEARCH:
+            memcpy(&mDevice, &pEvent->sdp_client_event.bd_addr, sizeof(bt_bdaddr_t));
+            bdaddr_to_string(&mDevice, str, 18);
+            ALOGD(LOGTAG "initiating SDP search with device %s", str);
+            Search(&mDevice, pEvent->sdp_client_event.uuid, pEvent->sdp_client_event.searchCb);
+            break;
+
+        case SDP_CLIENT_ADD_RECORD:
+            AddRecord(&pEvent->sdp_client_event.record, pEvent->sdp_client_event.addRecordCb);
+            break;
+
+        case SDP_CLIENT_REMOVE_RECORD:
+            RemoveRecord(pEvent->sdp_client_event.rec_handle,
+                pEvent->sdp_client_event.removeRecordCb);
+            break;
+
+        case SDP_CLIENT_SEARCH_TIMEOUT:
+            if (mSearchCb)
+                mSearchCb(BT_STATUS_FAIL, &pEvent->sdp_client_event.bd_addr,
+                NULL, NULL, false);
+            mSearchOngoing = false;
+            mSearchCb = NULL;
+            break;
+
+        default:
+            ALOGW(LOGTAG "%s: unhandled event: %d", __FUNCTION__, pEvent->event_id);
+            break;
+    }
+}
+
+bool SdpClient :: Search(bt_bdaddr_t *addr, uint8_t *uuid, SdpSearchCb cb)
+{
+    if (mSearchOngoing) {
+        ALOGW(LOGTAG "%s: active sdp search, returning false", __FUNCTION__);
+        if (cb)
+            cb(BT_STATUS_FAIL, addr, uuid, NULL, false);
+        return false;
+    }
+    mSearchOngoing = true;
+    mSearchCb = cb;
+     // start the sdp search timer
+    alarm_set(sdp_search_timer, SDP_SEARCH_TIMEOUT_DELAY,
+                        sdp_search_timer_expired, addr);
+    if (sdp_client_interface)
+        sdp_client_interface->sdp_search(addr, uuid);
+
+    /* sdp_search always returns BT_STATUS_SUCCESS, so return true */
+    return true;
+}
+
+void SdpClient :: AddRecord(bluetooth_sdp_record *record, SdpAddRecordCb cb)
+{
+    bt_status_t status = BT_STATUS_SUCCESS;
+    int record_handle;
+    if (sdp_client_interface) {
+        status = sdp_client_interface->create_sdp_record(record, &record_handle);
+        if (status != BT_STATUS_SUCCESS) {
+            ALOGE(LOGTAG "%s create_sdp_record failed %d", __FUNCTION__, status);
+        } else {
+            ALOGV(LOGTAG "%s create_sdp_record succeded, handle %d",
+                __FUNCTION__, record_handle);
+        }
+        if (cb)
+            cb(status, record_handle);
+    }
+}
+
+void SdpClient :: RemoveRecord(int record_handle, SdpRemoveRecordCb cb)
+{
+    bt_status_t status = BT_STATUS_SUCCESS;
+    if (sdp_client_interface) {
+        status = sdp_client_interface->remove_sdp_record(record_handle);
+        if (status != BT_STATUS_SUCCESS) {
+            ALOGE(LOGTAG "%s remove_sdp_record failed %d", __FUNCTION__, status);
+        }
+        if (cb)
+            cb(status);
+    }
+}
+
+bool SdpClient :: HandleEnableSdpClient() {
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+
+    if ((sdp_client_interface = (btsdp_interface_t *)
+            bluetooth_interface->get_profile_interface(BT_PROFILE_SDP_CLIENT_ID)) == NULL) {
+        ALOGE(LOGTAG "%s: Failed to get Bluetooth Sdp Client Interface", __FUNCTION__);
+        return false;
+    }
+
+    bt_status_t status;
+    if ((status = sdp_client_interface->init(&sBluetoothSdpClientCallback)) != BT_STATUS_SUCCESS) {
+        ALOGE(LOGTAG "%s: Failed to initialize Bluetooth SDP Client, status: %d",
+            __FUNCTION__, status);
+        sdp_client_interface = NULL;
+        return false;
+    }
+    return true;
+}
+
+bool SdpClient :: HandleDisableSdpClient()
+{
+    ALOGV(LOGTAG "%s", __FUNCTION__);
+
+    bt_status_t status;
+    if (sdp_client_interface != NULL) {
+        ALOGE(LOGTAG "%s: Cleaning up Bluetooth Sdp Interface...", __FUNCTION__);
+        if ((status = sdp_client_interface->deinit()) != BT_STATUS_SUCCESS) {
+            ALOGE(LOGTAG "%s: Failed to de-initialize Bluetooth SDP Client, status: %d",
+                __FUNCTION__, status);
+            sdp_client_interface = NULL;
+            return false;
+        }
+        sdp_client_interface = NULL;
+    }
+    return true;
+}
+
+
diff --git a/bt-app/utils/src/utils.c b/bt-app/utils/src/utils.c
index 878db7c..577ecfd 100644
--- a/bt-app/utils/src/utils.c
+++ b/bt-app/utils/src/utils.c
@@ -47,7 +47,7 @@ const char *bdaddr_to_string(const bt_bdaddr_t *addr, char *string, size_t size)
     return NULL;
 
   const uint8_t *ptr = addr->address;
-  sprintf(string, "%02x:%02x:%02x:%02x:%02x:%02x",
+  snprintf(string, size, "%02x:%02x:%02x:%02x:%02x:%02x",
            ptr[0], ptr[1], ptr[2],
            ptr[3], ptr[4], ptr[5]);
   return string;
diff --git a/gatt/Makefile.am b/gatt/Makefile.am
new file mode 100644
index 0000000..4b788bd
--- /dev/null
+++ b/gatt/Makefile.am
@@ -0,0 +1,36 @@
+AM_CPPFLAGS = -O2 \
+              -D_GNU_SOURCE \
+             -I${WORKSPACE}/qcom-opensource/bt/gatt/include \
+             -I${WORKSPACE}/qcom-opensource/bt/bt-app/include \
+             -I${WORKSPACE}/qcom-opensource/bt/bt-app/ \
+             -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/hal/include/ \
+             -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/vhal/include \
+             -I${WORKSPACE}/system/bt \
+             -I${WORKSPACE}/system/core/include
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -DLINUX \
+        -std=c99 \
+        -I${WORKSPACE}/qcom-opensource/bt/gatt/include \
+        -I${WORKSPACE}/qcom-opensource/bt/bt-app/include \
+        -I${WORKSPACE}/qcom-opensource/bt/bt-app/ \
+        -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/hal/include/ \
+        -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/vhal/include \
+        -I${WORKSPACE}/system/core/include
+
+ACLOCAL_AMFLAGS = -I m4
+
+c_sources = src/Gatt.cpp
+
+AM_LDFLAGS := $(LDFLAFGS)
+
+library_includedir = $(pkgincludedir)
+lib_LTLIBRARIES = libgengatt.la
+libgengatt_la_CC = @CC@
+libgengatt_la_SOURCES = $(c_sources)
+libgengatt_la_CPPFLAGS = $(AM_CPPFLAGS)
+libgengatt_la_CFLAGS = $(AM_CFLAGS)
+libgengatt_la_LDFLAGS = $(AM_LDFLAGS) -static -lpthread -lm -ldl -lrt
diff --git a/gatt/configure.ac b/gatt/configure.ac
new file mode 100644
index 0000000..c6ee884
--- /dev/null
+++ b/gatt/configure.ac
@@ -0,0 +1,50 @@
+AC_PREREQ(2.61)
+AC_INIT([gengatt], 1.0.0)
+AM_INIT_AUTOMAKE([-Wall gnu foreign])
+AM_MAINTAINER_MODE
+AC_CONFIG_HEADER([config.h])
+AC_CONFIG_MACRO_DIR([m4])
+
+AC_PROG_CXX
+AM_PROG_AS
+AC_PROG_LIBTOOL
+AC_PROG_AWK
+AC_PROG_CPP
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+PKG_PROG_PKG_CONFIG
+
+# Library configs
+AC_ARG_WITH([common_includes],
+      AC_HELP_STRING([--with-common-includes=@<:@dir@:>@],
+         [Specify the location of the common headers]),
+      [common_incdir=$withval],
+      with_common_includes=no)
+
+if test "x$with_common_includes" != "xno"; then
+   CFLAGS="${CFLAGS} -I${common_incdir}"
+fi
+
+AC_ARG_WITH([glib],
+     AC_HELP_STRING([--with-glib],
+        [enable glib, building HLOS systems which use glib]))
+
+if (test "x${with_glib}" = "xyes"); then
+       PKG_CHECK_MODULES(GTHREAD, gthread-2.0 >= 2.16, dummy=yes,
+                               AC_MSG_ERROR(GThread >= 2.16 is required))
+       PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.16, dummy=yes,
+                               AC_MSG_ERROR(GLib >= 2.16 is required))
+       GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
+       GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
+
+       AC_SUBST(GLIB_CFLAGS)
+       AC_SUBST(GLIB_LIBS)
+fi
+
+AM_CONDITIONAL(USE_GLIB, test "x${with_glib}" = "xyes")
+
+AC_SUBST([CFLAGS])
+AC_SUBST([CC])
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
diff --git a/gatt/include/Gatt.hpp b/gatt/include/Gatt.hpp
new file mode 100644
index 0000000..53674b3
--- /dev/null
+++ b/gatt/include/Gatt.hpp
@@ -0,0 +1,575 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GATT_APP_H
+#define GATT_APP_H
+
+#pragma once
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_gatt.h>
+#include <stdio.h>
+#include <string.h>
+#include <iostream>
+#include <map>
+
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/semaphore.h"
+#include "osi/include/allocator.h"
+#include "ipc.h"
+
+#define MAX_GATT_DEVICES    (1)
+
+#define REMOTE_START_PROFILE            (0x01)
+#define ALERT_NOTIFICATION_PROFILE      (0x02)
+#define CYCLING_SPEED__cADENCE_PROFILE  (0x04)
+#define CYCLING_POWER_PROFILE           (0x08)
+#define RUNNING_SPEED_CADENCE_PROFILE   (0x10)
+#define HUMAN_INTERFACE_DEVICE_PROFILE  (0x20)
+#define HEART_RATE_PROFILE              (0x40)
+
+extern const char *BT_GATT_ENABLED;
+
+#define CHECK_PARAM(x)                                                      \
+   if (!x) {                                                                \
+       ALOGE("'%s' Param is NULL - exiting from function ", __FUNCTION__);  \
+       return false;                                                        \
+   }
+
+#define CHECK_PARAM_VOID(x)                                                      \
+   if (!x) {                                                                     \
+       ALOGE("'%s' Void Param is NULL - exiting from function ", __FUNCTION__);  \
+       return ;                                                                  \
+   }
+
+
+ /**
+   * This virtual class is used to implement {@link BluetoothGatt} callbacks.
+   */
+
+class BluetoothGattClientCallback {
+
+   public:
+
+      virtual void btgattc_client_register_app_cb(int status,int client_if,bt_uuid_t *uuid)
+      {
+      }
+      virtual void btgattc_scan_result_cb(bt_bdaddr_t* bda, int rssi, uint8_t* adv_data)
+      {
+      }
+
+      virtual void btgattc_open_cb(int conn_id, int status, int clientIf, bt_bdaddr_t* bda)
+      {
+      }
+
+      virtual void btgattc_close_cb(int conn_id, int status, int clientIf, bt_bdaddr_t* bda)
+      {
+      }
+
+      virtual void btgattc_search_complete_cb(int conn_id, int status)
+      {
+      }
+
+      virtual void btgattc_register_for_notification_cb(int conn_id, int registered,
+                                                        int status, uint16_t handle)
+      {
+      }
+
+      virtual void btgattc_notify_cb(int conn_id, btgatt_notify_params_t *p_data)
+      {
+      }
+
+      virtual void btgattc_read_characteristic_cb(int conn_id, int status,
+        btgatt_read_params_t *p_data)
+      {
+      }
+
+      virtual void btgattc_write_characteristic_cb(int conn_id, int status,
+        uint16_t handle)
+      {
+      }
+
+      virtual void btgattc_read_descriptor_cb(int conn_id, int status, btgatt_read_params_t *p_data)
+      {
+      }
+
+      virtual void btgattc_write_descriptor_cb(int conn_id, int status, uint16_t handle)
+      {
+      }
+
+      virtual void btgattc_execute_write_cb(int conn_id, int status)
+      {
+      }
+
+      virtual void btgattc_remote_rssi_cb(int client_if,bt_bdaddr_t* bda, int rssi, int status)
+      {
+      }
+
+      virtual void btgattc_advertise_cb(int status, int client_if)
+      {
+      }
+
+      virtual void btgattc_configure_mtu_cb(int conn_id, int status, int mtu)
+      {
+      }
+
+      virtual void btgattc_scan_filter_cfg_cb(int action, int client_if, int status, int filt_type, int avbl_space)
+      {
+      }
+
+      virtual void btgattc_scan_filter_param_cb(int action, int client_if, int status, int avbl_space)
+      {
+      }
+
+      virtual void btgattc_scan_filter_status_cb(int action, int client_if, int status)
+      {
+      }
+
+      virtual void btgattc_multiadv_enable_cb(int client_if, int status)
+      {
+      }
+
+      virtual void btgattc_multiadv_update_cb(int client_if, int status)
+      {
+      }
+
+      virtual void btgattc_multiadv_setadv_data_cb(int client_if, int status)
+      {
+      }
+
+      virtual void btgattc_multiadv_disable_cb(int client_if, int status)
+      {
+      }
+
+      virtual void btgattc_congestion_cb(int conn_id, bool congested)
+      {
+      }
+
+      virtual void btgattc_batchscan_cfg_storage_cb(int client_if, int status)
+      {
+      }
+
+      virtual void btgattc_batchscan_startstop_cb(int startstop_action, int client_if, int status)
+      {
+      }
+
+      virtual void btgattc_batchscan_reports_cb(int client_if, int status, int report_format,
+                                                int num_records, int data_len, uint8_t *p_rep_data)
+      {
+      }
+      virtual void btgattc_batchscan_threshold_cb(int client_if)
+      {
+      }
+
+      virtual void btgattc_track_adv_event_cb(btgatt_track_adv_info_t *p_adv_track_info)
+      {
+      }
+
+      virtual void btgattc_scan_parameter_setup_completed_cb(int client_if, btgattc_error_t status)
+      {
+      }
+      virtual void btgattc_get_gatt_db_cb(int conn_id, btgatt_db_element_t *db, int count)
+      {
+      }
+};
+
+ /**
+   * This virtual class is used to implement {@link BluetoothGattServer} callbacks.
+   */
+class BluetoothGattServerCallback {
+
+   public:
+
+     virtual void gattServerRegisterAppCb(int status, int server_if, bt_uuid_t *uuid)
+     {
+     }
+
+     virtual void btgatts_connection_cb(int conn_id, int server_if, int connected, bt_bdaddr_t *bda)
+     {
+     }
+
+     virtual void btgatts_service_added_cb(int status, int server_if,
+                                 btgatt_srvc_id_t *srvc_id, int srvc_handle)
+     {
+     }
+
+     virtual void btgatts_included_service_added_cb(int status, int server_if, int srvc_handle,
+           int incl_srvc_handle)
+     {
+     }
+
+     virtual void btgatts_characteristic_added_cb(int status, int server_if, bt_uuid_t *char_id,
+                                                   int srvc_handle, int char_handle)
+     {
+     }
+
+     virtual void btgatts_descriptor_added_cb(int status, int server_if, bt_uuid_t *descr_id,
+                                               int srvc_handle, int descr_handle)
+     {
+     }
+
+     virtual void btgatts_service_started_cb(int status, int server_if, int srvc_handle)
+     {
+     }
+
+     virtual void btgatts_service_stopped_cb(int status, int server_if, int srvc_handle)
+     {
+     }
+
+     virtual void btgatts_service_deleted_cb(int status, int server_if, int srvc_handle)
+     {
+     }
+
+     virtual void btgatts_request_read_cb(int conn_id, int trans_id, bt_bdaddr_t *bda, int attr_handle,
+                                           int offset, bool is_long)
+     {
+     }
+
+     virtual void btgatts_request_write_cb(int conn_id, int trans_id, bt_bdaddr_t *bda, int attr_handle,
+                                           int offset, int length, bool need_rsp, bool is_prep,
+                                           uint8_t* value)
+     {
+     }
+
+     virtual void btgatts_request_exec_write_cb(int conn_id, int trans_id,
+                                                   bt_bdaddr_t *bda, int exec_write)
+     {
+     }
+
+     virtual void btgatts_response_confirmation_cb(int status, int handle)
+     {
+     }
+
+     virtual void btgatts_indication_sent_cb(int conn_id, int status)
+     {
+     }
+
+     virtual void btgatts_congestion_cb(int conn_id, bool congested)
+     {
+     }
+
+     virtual void btgatts_mtu_changed_cb(int conn_id, int mtu)
+     {
+     }
+};
+
+class Gatt {
+    private:
+        config_t *config;
+        const bt_interface_t * bluetooth_interface;
+        btgatt_interface_t *gatt_interface;
+
+    public:
+
+        bt_uuid_t rsp_uuid;
+        int le_supported_profiles;
+        std::map<uint8_t *,BluetoothGattServerCallback *> serverCbUuidMap;
+        std::map<int ,BluetoothGattServerCallback *> serverCbSifMap;
+        std::map<uint8_t *,BluetoothGattClientCallback *> clientCbUuidMap;
+        std::map<int ,BluetoothGattClientCallback *> clientCbCifMap;
+        std::map<int,int> ConnidClientifMap;
+        std::map<int ,int> ConnidServerifMap;
+        std::map<int,int> clientIfScanStatusMap;
+
+        Gatt(const bt_interface_t *bt_interface, config_t *config);
+        ~Gatt();
+        void ProcessEvent(BtEvent* );
+        bool Scan( bool ,int);
+        void RegisterServerCallback(BluetoothGattServerCallback * ,bt_uuid_t*);
+        void UnRegisterServerCallback(int);
+        void RegisterClientCallback(BluetoothGattClientCallback * ,bt_uuid_t*);
+        void UnRegisterClientCallback(int);
+        bool GattInterfaceInit(const bt_interface_t *);
+        btgatt_interface_t * GetGattInterface();
+        void GattInterfaceCleanup(void);
+        void HandleGattIpcMsg(BtIpcMsg *);
+        void HandleGattsRegisterAppEvent(GattsRegisterAppEvent *);
+        void HandleGattsConnectionEvent(GattsConnectionEvent *);
+        void HandleGattsServiceAddedEvent(GattsServiceAddedEvent *);
+        void HandleGattsCharacteristicAddedEvent(GattsCharacteristicAddedEvent *);
+        void HandleGattsDescriptorAddedEvent(GattsDescriptorAddedEvent *);
+        void HandleGattsServiceStartedEvent(GattsServiceStartedEvent *);
+        void HandleGattsServiceStoppedEvent(GattsServiceStoppedEvent *);
+        void HandleGattsServiceDeletedEvent(GattsServiceDeletedEvent *);
+        void HandleGattsRequestWriteEvent(GattsRequestWriteEvent *);
+        void HandleGattsRequestReadEvent(GattsRequestReadEvent *);
+        void HandleGattsIncludeServiceAddedEvent(GattsIncludedServiceAddedEvent *);
+        void HandleGattsRequestExecWriteEvent(GattsRequestExecWriteEvent *);
+        void HandleGattsResponseConfirmationEvent(GattsResponseConfirmationEvent*);
+        void HandleGattsIndicationSentEvent(GattsIndicationSentEvent*);
+        void HandleGattsCongetionEvent(GattsCongestionEvent*);
+        void HandleGattsMtuChangedEvent(GattsMTUchangedEvent*);
+        void HandleGattcRegisterAppEvent(GattcRegisterAppEvent *);
+        void HandleGattcScanResultEvent (GattcScanResultEvent *);
+        void HandleGattcOpenEvent(GattcOpenEvent*) ;
+        void HandleGattcCloseEvent(GattcCloseEvent*) ;
+        void HandleGattcSearchCompleteEvent(GattcSearchCompleteEvent*) ;
+        void HandleGattcRegisterForNotificationEvent(GattcRegisterForNotificationEvent*) ;
+        void HandleGattcNotifyEvent(GattcNotifyEvent*) ;
+        void HandleGattcReadCharacteristicEvent(GattcReadCharacteristicEvent*) ;
+        void HandleGattcWriteCharacteristicEvent(GattcWriteCharacteristicEvent*) ;
+        void HandleGattcReadDescriptorEvent(GattcReadDescriptorEvent*) ;
+        void HandleGattcWriteDescriptorEvent(GattcWriteDescriptorEvent *) ;
+        void HandleGattcExecuteWriteEvent(GattcExecuteWriteEvent*) ;
+        void HandleGattcRemoteRssiEvent(GattcRemoteRssiEvent*) ;
+        void HandleGattcAdvertiseEvent(GattcAdvertiseEvent*) ;
+        void HandleGattcConfigureMtuEvent(GattcConfigureMtuEvent*) ;
+        void HandleGattcScanFilterCfgEvent(GattcScanFilterCfgEvent*) ;
+        void HandleGattcScanFilterParamEvent(GattcScanFilterParamEvent*) ;
+        void HandleGattcScanFilterStatusEvent(GattcScanFilterStatusEvent*) ;
+        void HandleGattcMultiadvEnableEvent(GattcMultiadvEnableEvent*) ;
+        void HandleGattcMultiadvUpdateEvent(GattcMultiadvUpdateEvent*) ;
+        void HandleGattcMultiadvSetadvDataEvent(GattcMultiadvSetadvDataEvent*) ;
+        void HandleGattcMultiadvDisableEvent(GattcMultiadvDisableEvent*) ;
+        void HandleGattcCongestionEvent(GattcCongestionEvent*) ;
+        void HandleGattcBatchscanCfgStorageEvent(GattcBatchscanCfgStorageEvent*) ;
+        void HandleGattcBatchscanStartstopEvent(GattcBatchscanStartstopEvent*) ;
+        void HandleGattcBatchscanReportsEvent(GattcBatchscanReportsEvent*) ;
+        void HandleGattcBatchscanThresholdEvent(GattcBatchscanThresholdEvent*) ;
+        void HandleGattcTrackAdvEventEvent(GattcTrackAdvEventEvent*) ;
+        void HandleGattcScanParameterSetupCompletedEvent(GattcScanParameterSetupCompletedEvent*) ;
+        void HandleGattcGetGattDbEvent(GattcGetGattDbEvent *event);
+        void HandleRspEnableEvent(RspEnableEvent *);
+        void HandleRspDisableEvent(RspDisableEvent *);
+        bool HandleEnableGatt(void);
+        bool HandleDisableGatt(void);
+        /** Register a client application from the stack */
+        bt_status_t register_client( bt_uuid_t *uuid );
+
+        /** Unregister a client application from the stack */
+        bt_status_t unregister_client(int client_if );
+
+        /** Start or stop LE device scanning */
+        bt_status_t scan( bool start, int client_if );
+
+        /** Create a connection to a remote LE or dual-mode device */
+        bt_status_t clientConnect( int client_if, const bt_bdaddr_t *bd_addr,
+                             bool is_direct, int transport );
+
+        /** Disconnect a remote device or cancel a pending connection */
+        bt_status_t clientDisconnect( int client_if, const bt_bdaddr_t *bd_addr,
+                        int conn_id);
+
+        /** Start or stop advertisements to listen for incoming connections */
+        bt_status_t listen(int client_if, bool start);
+
+        /** Clear the attribute cache for a given device */
+        bt_status_t refresh( int client_if, const bt_bdaddr_t *bd_addr );
+
+        /**
+               * Enumerate all GATT services on a connected device.
+               * Optionally, the results can be filtered for a given UUID.
+               */
+        bt_status_t search_service(int conn_id, bt_uuid_t *filter_uuid );
+
+        /**
+                * Enumerate included services for a given service.
+                * Set start_incl_srvc_id to NULL to get the first included service.
+                */
+        bt_status_t get_included_service( int conn_id, btgatt_srvc_id_t *srvc_id,
+                                             btgatt_srvc_id_t *start_incl_srvc_id);
+
+        /**
+                * Enumerate characteristics for a given service.
+                * Set start_char_id to NULL to get the first characteristic.
+                */
+        bt_status_t get_characteristic( int conn_id,
+                        btgatt_srvc_id_t *srvc_id, btgatt_gatt_id_t *start_char_id);
+
+        /**
+                * Enumerate descriptors for a given characteristic.
+                * Set start_descr_id to NULL to get the first descriptor.
+                */
+        bt_status_t get_descriptor( int conn_id,
+                        btgatt_srvc_id_t *srvc_id, btgatt_gatt_id_t *char_id,
+                        btgatt_gatt_id_t *start_descr_id);
+
+        /** Read a characteristic on a remote device */
+        bt_status_t read_characteristic( int conn_id,
+                        uint16_t handle, int auth_req );
+
+        /** Write a remote characteristic */
+        bt_status_t write_characteristic(int conn_id,
+                        uint16_t handle, int write_type, int len, int auth_req,
+                        char* p_value);
+
+        /** Read the descriptor for a given characteristic */
+        bt_status_t read_descriptor(int conn_id,
+                        uint16_t handle, int auth_req);
+
+        /** Write a remote descriptor for a given characteristic */
+        bt_status_t write_descriptor( int conn_id,
+                        uint16_t handle, int write_type, int len,
+                        int auth_req, char* p_value);
+
+        /** Execute a prepared write operation */
+        bt_status_t execute_write(int conn_id, int execute);
+
+        /**
+                * Register to receive notifications or indications for a given
+                * characteristic
+                */
+        bt_status_t register_for_notification( int client_if,
+                        const bt_bdaddr_t *bd_addr, uint16_t handle);
+
+        /** Deregister a previous request for notifications/indications */
+        bt_status_t deregister_for_notification( int client_if,
+                        const bt_bdaddr_t *bd_addr, uint16_t handle);
+
+        /** Request RSSI for a given remote device */
+        bt_status_t read_remote_rssi( int client_if, const bt_bdaddr_t *bd_addr);
+
+        /** Setup scan filter params */
+        bt_status_t scan_filter_param_setup(btgatt_filt_param_setup_t filt_param);
+
+
+        /** Configure a scan filter condition  */
+        bt_status_t scan_filter_add_remove(int client_if, int action, int filt_type,
+                                       int filt_index, int company_id,
+                                       int company_id_mask, const bt_uuid_t *p_uuid,
+                                       const bt_uuid_t *p_uuid_mask, const bt_bdaddr_t *bd_addr,
+                                       char addr_type, int data_len, char* p_data, int mask_len,
+                                       char* p_mask);
+
+        /** Clear all scan filter conditions for specific filter index*/
+        bt_status_t scan_filter_clear(int client_if, int filt_index);
+
+        /** Enable / disable scan filter feature*/
+        bt_status_t scan_filter_enable(int client_if, bool enable);
+
+        /** Determine the type of the remote device (LE, BR/EDR, Dual-mode) */
+        int get_device_type( const bt_bdaddr_t *bd_addr );
+
+        /** Set the advertising data or scan response data */
+        bt_status_t set_adv_data(int client_if, bool set_scan_rsp, bool include_name,
+                        bool include_txpower, int min_interval, int max_interval, int appearance,
+                        uint16_t manufacturer_len, char* manufacturer_data,
+                        uint16_t service_data_len, char* service_data,
+                        uint16_t service_uuid_len, char* service_uuid);
+
+        /** Configure the MTU for a given connection */
+        bt_status_t configure_mtu(int conn_id, int mtu);
+
+        /** Request a connection parameter update */
+        bt_status_t conn_parameter_update(const bt_bdaddr_t *bd_addr, int min_interval,
+                        int max_interval, int latency, int timeout);
+
+        /** Sets the LE scan interval and window in units of N*0.625 msec */
+        bt_status_t set_scan_parameters(int client_if, int scan_interval, int scan_window);
+
+        /* Setup the parameters as per spec, user manual specified values and enable multi ADV */
+        bt_status_t multi_adv_enable(int client_if, int min_interval,int max_interval,int adv_type,
+                     int chnl_map, int tx_power, int timeout_s);
+
+        /* Update the parameters as per spec, user manual specified values and restart multi ADV */
+        bt_status_t multi_adv_update(int client_if, int min_interval,int max_interval,int adv_type,
+                     int chnl_map, int tx_power, int timeout_s);
+
+        /* Setup the data for the specified instance */
+        bt_status_t multi_adv_set_inst_data(int client_if, bool set_scan_rsp, bool include_name,
+                        bool incl_txpower, int appearance, int manufacturer_len,
+                        char* manufacturer_data, int service_data_len,
+                        char* service_data, int service_uuid_len, char* service_uuid);
+
+        /* Disable the multi adv instance */
+        bt_status_t multi_adv_disable(int client_if);
+
+        /* Configure the batchscan storage */
+        bt_status_t batchscan_cfg_storage(int client_if, int batch_scan_full_max,
+            int batch_scan_trunc_max, int batch_scan_notify_threshold);
+
+        /* Enable batchscan */
+        bt_status_t batchscan_enb_batch_scan(int client_if, int scan_mode,
+            int scan_interval, int scan_window, int addr_type, int discard_rule);
+
+        /* Disable batchscan */
+        bt_status_t batchscan_dis_batch_scan(int client_if);
+
+        /* Read out batchscan reports */
+        bt_status_t batchscan_read_reports(int client_if, int scan_mode);
+
+        /** Test mode interface */
+        bt_status_t test_command( int command, btgatt_test_params_t* params);
+
+        /** get gatt database */
+        bt_status_t get_gatt_db(int conn_id);
+
+        /** Registers a GATT server application with the stack */
+        bt_status_t register_server( bt_uuid_t *uuid );
+
+        /** Unregister a server application from the stack */
+        bt_status_t unregister_server(int server_if );
+
+        /** Create a connection to a remote peripheral */
+        bt_status_t serverConnect(int server_if, const bt_bdaddr_t *bd_addr,
+                                bool is_direct, int transport);
+
+        /** Disconnect an established connection or cancel a pending one */
+        bt_status_t serverDisconnect(int server_if, const bt_bdaddr_t *bd_addr,
+                        int conn_id );
+
+        /** Create a new service */
+        bt_status_t add_service( int server_if, btgatt_srvc_id_t *srvc_id, int num_handles);
+
+        /** Assign an included service to it's parent service */
+        bt_status_t add_included_service( int server_if, int service_handle, int included_handle);
+
+        /** Add a characteristic to a service */
+        bt_status_t add_characteristic( int server_if,
+                        int service_handle, bt_uuid_t *uuid,
+                        int properties, int permissions);
+
+        /** Add a descriptor to a given service */
+        bt_status_t add_descriptor(int server_if, int service_handle,
+                                      bt_uuid_t *uuid, int permissions);
+
+        /** Starts a local service */
+        bt_status_t start_service(int server_if, int service_handle,
+                                     int transport);
+
+        /** Stops a local service */
+        bt_status_t stop_service(int server_if, int service_handle);
+
+        /** Delete a local service */
+        bt_status_t delete_service(int server_if, int service_handle);
+
+        /** Send value indication to a remote device */
+        bt_status_t send_indication(int server_if, int attribute_handle,
+                                       int conn_id, int len, int confirm,
+                                       char* p_value);
+
+        /** Send a response to a read/write operation */
+        bt_status_t send_response(int conn_id, int trans_id,
+                                     int status, btgatt_response_t *response);
+};
+#endif
diff --git a/gatt/src/Gatt.cpp b/gatt/src/Gatt.cpp
new file mode 100644
index 0000000..34f7045
--- /dev/null
+++ b/gatt/src/Gatt.cpp
@@ -0,0 +1,2409 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <list>
+#include <map>
+#include "osi/include/log.h"
+#include "Gatt.hpp"
+#include <iostream>
+#include <hash_map>
+
+
+#define LOGTAG "GATT "
+#define UNUSED
+#define MAX_NUM_HANDLES     (1)
+
+using namespace std;
+using std::list;
+using std::string;
+Gatt *g_gatt = NULL;
+
+static const bt_bdaddr_t bd_addr_null={0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+
+void btgattc_register_app_cb(int status, int clientIf, bt_uuid_t *app_uuid)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, clientIf);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_REGISTER_APP_EVENT;
+    event->gattc_register_app_event.status = status;
+    event->gattc_register_app_event.clientIf = clientIf;
+    event->gattc_register_app_event.app_uuid = (bt_uuid_t *) osi_malloc (sizeof(bt_uuid_t));;
+    memcpy(event->gattc_register_app_event.app_uuid, app_uuid, sizeof(bt_uuid_t));
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgattc_scan_result_cb(bt_bdaddr_t* bda, int rssi, uint8_t* adv_data)
+{
+    char c_address[32];
+    snprintf(c_address,sizeof(c_address), "%02X:%02X:%02X:%02X:%02X:%02X",
+            bda->address[0], bda->address[1], bda->address[2],
+            bda->address[3], bda->address[4], bda->address[5]);
+
+    ALOGD(LOGTAG "(%s) rssi (%d) bda (%s)\n",__FUNCTION__, rssi,c_address);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_SCAN_RESULT_EVENT;
+    event->gattc_scan_result_event.bda = bda;
+    event->gattc_scan_result_event.rssi= rssi;
+    event->gattc_scan_result_event.adv_data= adv_data;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_open_cb(int conn_id, int status, int clientIf, bt_bdaddr_t* bda)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, clientIf);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_OPEN_EVENT;
+    event->gattc_open_event.status= status;
+    event->gattc_open_event.clientIf= clientIf;
+    event->gattc_open_event.conn_id= conn_id;
+    event->gattc_open_event.bda = bda;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_close_cb(int conn_id, int status, int clientIf, bt_bdaddr_t* bda)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, clientIf);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_CLOSE_EVENT;
+    event->gattc_close_event.status= status;
+    event->gattc_close_event.clientIf= clientIf;
+    event->gattc_close_event.conn_id= conn_id;
+    event->gattc_close_event.bda= bda;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_search_complete_cb(int conn_id, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) conn_id (%d)",__FUNCTION__,status, conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_SEARCH_COMPLETE_EVENT;
+    event->gattc_search_complete_event.status= status;
+    event->gattc_search_complete_event.conn_id= conn_id;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_register_for_notification_cb(int conn_id, int registered,
+                                                    int status, uint16_t handle)
+{
+    ALOGD(LOGTAG "(%s) status (%d) conn_id (%d)",__FUNCTION__,status, conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_REGISTER_FOR_NOTIFICATION_EVENT;
+    event->gattc_register_for_notification_event.status= status;
+    event->gattc_register_for_notification_event.conn_id= conn_id;
+    event->gattc_register_for_notification_event.registered= registered;
+    event->gattc_register_for_notification_event.handle= handle;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_notify_cb(int conn_id, btgatt_notify_params_t *p_data)
+{
+    ALOGD(LOGTAG "(%s) conn_id (%d)",__FUNCTION__,conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_NOTIFY_EVENT;
+    event->gattc_notify_event.conn_id= conn_id;
+    event->gattc_notify_event.p_data= p_data;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_read_characteristic_cb(int conn_id, int status,
+    btgatt_read_params_t *p_data)
+{
+    ALOGD(LOGTAG "(%s) status (%d) conn_id (%d)",__FUNCTION__,status, conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_READ_CHARACTERISTIC_EVENT;
+    event->gattc_read_characteristic_event.status= status;
+    event->gattc_read_characteristic_event.conn_id= conn_id;
+    event->gattc_read_characteristic_event.p_data= p_data;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_write_characteristic_cb(int conn_id, int status,
+    uint16_t handle)
+{
+    ALOGD(LOGTAG "(%s) status (%d) conn_id (%d)",__FUNCTION__,status, conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_WRITE_CHARACTERISTIC_EVENT;
+    event->gattc_write_characteristic_event.status= status;
+    event->gattc_write_characteristic_event.conn_id= conn_id;
+    event->gattc_write_characteristic_event.handle= handle;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_execute_write_cb(int conn_id, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) conn_id (%d)",__FUNCTION__,status, conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_EXECUTE_WRITE_EVENT;
+    event->gattc_execute_write_event.status= status;
+    event->gattc_execute_write_event.conn_id= conn_id;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_read_descriptor_cb(int conn_id, int status, btgatt_read_params_t *p_data)
+{
+    ALOGD(LOGTAG "(%s) status (%d) conn_id (%d)",__FUNCTION__,status, conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_READ_DESCRIPTOR_EVENT;
+    event->gattc_read_descriptor_event.status= status;
+    event->gattc_read_descriptor_event.conn_id= conn_id;
+    event->gattc_read_descriptor_event.p_data= p_data;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_write_descriptor_cb(int conn_id, int status, uint16_t handle)
+{
+    ALOGD(LOGTAG "(%s) status (%d) conn_id (%d)",__FUNCTION__,status, conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_WRITE_DESCRIPTOR_EVENT;
+    event->gattc_write_descriptor_event.status= status;
+    event->gattc_write_descriptor_event.conn_id= conn_id;
+    event->gattc_write_descriptor_event.handle= handle;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_remote_rssi_cb(int client_if,bt_bdaddr_t* bda, int rssi, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_REMOTE_RSSI_EVENT;
+    event->gattc_remote_rssi_event.status = status;
+    event->gattc_remote_rssi_event.client_if= client_if;
+        event->gattc_remote_rssi_event.rssi= rssi;
+        event->gattc_remote_rssi_event.bda= bda;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_advertise_cb(int status, int client_if)
+{
+    ALOGD(LOGTAG "(%s): status (%d) client_if (%d)\n",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_ADVERTISE_EVENT;
+    event->gattc_advertise_event.status= status;
+    event->gattc_advertise_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_configure_mtu_cb(int conn_id, int status, int mtu)
+{
+    ALOGD(LOGTAG "(%s) status (%d) conn_id (%d)",__FUNCTION__,status, conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_CONFIGURE_MTU_EVENT;
+    event->gattc_configure_mtu_event.status= status;
+    event->gattc_configure_mtu_event.conn_id= conn_id;
+    event->gattc_configure_mtu_event.mtu= mtu;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_scan_filter_cfg_cb(int action, int client_if, int status, int filt_type, int avbl_space)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_SCAN_FILTER_CFG_EVENT;
+    event->gattc_scan_filter_cfg_event.status= status;
+    event->gattc_scan_filter_cfg_event.action= action;
+    event->gattc_scan_filter_cfg_event.client_if= client_if;
+    event->gattc_scan_filter_cfg_event.filt_type=filt_type;
+    event->gattc_scan_filter_cfg_event.avbl_space=avbl_space;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_scan_filter_param_cb(int action, int client_if, int status, int avbl_space)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_SCAN_FILTER_PARAM_EVENT;
+    event->gattc_scan_filter_param_event.status= status;
+    event->gattc_scan_filter_param_event.action= action;
+    event->gattc_scan_filter_param_event.client_if= client_if;
+    event->gattc_scan_filter_param_event.avbl_space=avbl_space;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_scan_filter_status_cb(int action, int client_if, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_SCAN_FILTER_STATUS_EVENT;
+    event->gattc_scan_filter_status_event.status= status;
+    event->gattc_scan_filter_status_event.action= action;
+    event->gattc_scan_filter_status_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_multiadv_enable_cb(int client_if, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_MULTIADV_ENABLE_EVENT;
+    event->gattc_multiadv_enable_event.status= status;
+    event->gattc_multiadv_enable_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_multiadv_update_cb(int client_if, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_MULTIADV_UPDATE_EVENT;
+    event->gattc_multiadv_update_event.status= status;
+    event->gattc_multiadv_update_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_multiadv_setadv_data_cb(int client_if, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_MULTIADV_SETADV_DATA_EVENT;
+    event->gattc_multiadv_setadv_data_event.status= status;
+    event->gattc_multiadv_setadv_data_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_multiadv_disable_cb(int client_if, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_MULTIADV_DISABLE_EVENT;
+    event->gattc_multiadv_disable_event.status= status;
+    event->gattc_multiadv_disable_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_congestion_cb(int conn_id, bool congested)
+{
+
+ ALOGD(LOGTAG "(%s) conn_id (%d) congested (%d)",__FUNCTION__,conn_id, congested);
+
+ BtEvent *event = new BtEvent;
+ CHECK_PARAM_VOID(event)
+
+ event->event_id = BTGATTC_CONGESTION_EVENT;
+ event->gattc_congestion_event.conn_id= conn_id;
+ event->gattc_congestion_event.congested= congested;
+
+ PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_batchscan_cfg_storage_cb(int client_if, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_BATCHSCAN_CFG_STORAGE_EVENT;
+    event->gattc_batchscan_cfg_storage_event.status= status;
+    event->gattc_batchscan_cfg_storage_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+void btgattc_batchscan_startstop_cb(int startstop_action, int client_if, int status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_BATCHSCAN_STARTSTOP_EVENT;
+    event->gattc_batchscan_startstop_event.status= status;
+    event->gattc_batchscan_startstop_event.startstop_action= startstop_action;
+    event->gattc_batchscan_startstop_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+
+}
+
+void btgattc_batchscan_reports_cb(int client_if, int status, int report_format,
+                                            int num_records, int data_len, uint8_t *p_rep_data)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_BATCHSCAN_REPORTS_EVENT;
+    event->gattc_batchscan_reports_event.status= status;
+    event->gattc_batchscan_reports_event.client_if= client_if;
+    event->gattc_batchscan_reports_event.report_format = report_format;
+    event->gattc_batchscan_reports_event.num_records= num_records;
+    event->gattc_batchscan_reports_event.data_len= data_len;
+    event->gattc_batchscan_reports_event.p_rep_data= p_rep_data;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_batchscan_threshold_cb(int client_if)
+{
+    ALOGD(LOGTAG "(%s) client_if (%d)",__FUNCTION__,client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_BATCHSCAN_THRESHOLD_EVENT;
+    event->gattc_batchscan_threshold_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_track_adv_event_cb(btgatt_track_adv_info_t *p_adv_track_info)
+{
+    ALOGD(LOGTAG "(%s) ",__FUNCTION__);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_TRACK_ADV_EVENT_EVENT;
+    event->gattc_track_adv_event_event.p_adv_track_info= p_adv_track_info;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_scan_parameter_setup_completed_cb(int client_if, btgattc_error_t status)
+{
+    ALOGD(LOGTAG "(%s) status (%d) client_if (%d)",__FUNCTION__,status, client_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_SCAN_PARAMETER_SETUP_COMPLETED_EVENT;
+    event->gattc_scan_parameter_setup_completed_event.status= status;
+    event->gattc_scan_parameter_setup_completed_event.client_if= client_if;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgattc_get_gatt_db_cb(int conn_id, btgatt_db_element_t *db, int count)
+{
+    ALOGD(LOGTAG "(%s) conn_id (%d)",__FUNCTION__,conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTC_GET_GATT_DB_EVENT;
+    event->gattc_get_gatt_db_event.conn_id = conn_id;
+    event->gattc_get_gatt_db_event.db = db;
+    event->gattc_get_gatt_db_event.count = count;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+static const btgatt_client_callbacks_t sGattClientCallbacks = {
+    btgattc_register_app_cb,
+    btgattc_scan_result_cb,
+    btgattc_open_cb,
+    btgattc_close_cb,
+    btgattc_search_complete_cb,
+    btgattc_register_for_notification_cb,
+    btgattc_notify_cb,
+    btgattc_read_characteristic_cb,
+    btgattc_write_characteristic_cb,
+    btgattc_read_descriptor_cb,
+    btgattc_write_descriptor_cb,
+    btgattc_execute_write_cb,
+    btgattc_remote_rssi_cb,
+    btgattc_advertise_cb,
+    btgattc_configure_mtu_cb,
+    btgattc_scan_filter_cfg_cb,
+    btgattc_scan_filter_param_cb,
+    btgattc_scan_filter_status_cb,
+    btgattc_multiadv_enable_cb,
+    btgattc_multiadv_update_cb,
+    btgattc_multiadv_setadv_data_cb,
+    btgattc_multiadv_disable_cb,
+    btgattc_congestion_cb,
+    btgattc_batchscan_cfg_storage_cb,
+    btgattc_batchscan_startstop_cb,
+    btgattc_batchscan_reports_cb,
+    btgattc_batchscan_threshold_cb,
+    btgattc_track_adv_event_cb,
+    btgattc_scan_parameter_setup_completed_cb,
+    btgattc_get_gatt_db_cb,
+    NULL, /* services_removed_cb */
+    NULL /* services_added_cb */
+};
+
+/**
+ * GATT Server Callback Implementation
+ */
+void btgatts_register_app_cb(int status, int server_if, bt_uuid_t *uuid)
+{
+    ALOGD(LOGTAG "\n (%s) status (%d) server_if (%d) \n",__FUNCTION__, status, server_if);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+    event->event_id = BTGATTS_REGISTER_APP_EVENT;
+    event->gatts_register_app_event.status = status;
+    event->gatts_register_app_event.server_if = server_if;
+    event->gatts_register_app_event.uuid = (bt_uuid_t *) osi_malloc (sizeof(bt_uuid_t));
+    memcpy(event->gatts_register_app_event.uuid, uuid, sizeof(bt_uuid_t));
+    
+    PostMessage(THREAD_ID_GATT, event);
+    ALOGD(LOGTAG "exiting btgatts_register_app_cb \n");
+}
+
+void btgatts_connection_cb(int conn_id, int server_if, int connected, bt_bdaddr_t *bda)
+{
+
+    char c_address[32];
+    snprintf(c_address,sizeof(c_address), "%02X:%02X:%02X:%02X:%02X:%02X",
+            bda->address[0], bda->address[1], bda->address[2],
+            bda->address[3], bda->address[4], bda->address[5]);
+
+    ALOGD(LOGTAG "(%s) connid (%d) server_if (%d) status (%d) bda (%s)\n",__FUNCTION__, conn_id,
+            server_if, connected, c_address);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_CONNECTION_EVENT;
+    event->gatts_connection_event.conn_id = conn_id;
+    event->gatts_connection_event.server_if = server_if;
+    event->gatts_connection_event.connected = connected;
+    event->gatts_connection_event.bda = bda;
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgatts_service_added_cb(int status, int server_if,
+                              btgatt_srvc_id_t *srvc_id, int srvc_handle)
+{
+    ALOGD(LOGTAG "(%s) status (%d) server_if (%d), srvc_handle(%d)) \n",__FUNCTION__,
+                status, server_if, srvc_handle);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_SERVICE_ADDED_EVENT;
+    event->gatts_service_added_event.status = status;
+    event->gatts_service_added_event.server_if = server_if;
+    event->gatts_service_added_event.srvc_id = srvc_id ;
+    event->gatts_service_added_event.srvc_handle = srvc_handle ;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgatts_included_service_added_cb(int status, int server_if, int srvc_handle,
+        int incl_srvc_handle)
+{
+    ALOGD(LOGTAG "(%s) Status:(%d) \n",__FUNCTION__, status);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_INCLUDED_SERVICE_ADDED_EVENT;
+    event->gatts_included_service_added_event.status = status;
+    event->gatts_included_service_added_event.server_if = server_if;
+    event->gatts_included_service_added_event.srvc_handle = srvc_handle ;
+    event->gatts_included_service_added_event.incl_srvc_handle = incl_srvc_handle ;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_characteristic_added_cb(int status, int server_if, bt_uuid_t *char_id,
+                                                int srvc_handle, int char_handle)
+{
+    ALOGD(LOGTAG "(%s) Status:(%d) \n",__FUNCTION__, status);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_CHARACTERISTIC_ADDED_EVENT;
+    event->gatts_characteristic_added_event.status = status;
+    event->gatts_characteristic_added_event.server_if = server_if;
+    event->gatts_characteristic_added_event.char_id = (bt_uuid_t *) osi_malloc (sizeof(bt_uuid_t));;
+    memcpy(event->gatts_characteristic_added_event.char_id, char_id, sizeof(bt_uuid_t));
+    event->gatts_characteristic_added_event.srvc_handle = srvc_handle ;
+    event->gatts_characteristic_added_event.char_handle = char_handle ;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_descriptor_added_cb(int status, int server_if, bt_uuid_t *descr_id,
+                                            int srvc_handle, int descr_handle)
+{
+    ALOGD(LOGTAG "(%s) Status:(%d) \n",__FUNCTION__, status);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_DESCRIPTOR_ADDED_EVENT;
+    event->gatts_descriptor_added_event.status = status;
+    event->gatts_descriptor_added_event.server_if = server_if;
+    event->gatts_descriptor_added_event.descr_id = (bt_uuid_t *) osi_malloc (sizeof(bt_uuid_t));;
+    memcpy(event->gatts_descriptor_added_event.descr_id, descr_id, sizeof(bt_uuid_t));
+    event->gatts_descriptor_added_event.srvc_handle = srvc_handle ;
+    event->gatts_descriptor_added_event.descr_handle = descr_handle ;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_service_started_cb(int status, int server_if, int srvc_handle)
+{
+    ALOGD(LOGTAG "(%s) Status:(%d) \n",__FUNCTION__, status);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_SERVICE_STARTED_EVENT;
+    event->gatts_service_started_event.status = status;
+    event->gatts_service_started_event.server_if = server_if;
+    event->gatts_service_started_event.srvc_handle = srvc_handle ;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_service_stopped_cb(int status, int server_if, int srvc_handle)
+{
+    ALOGD(LOGTAG "(%s) Status:(%d)",__FUNCTION__, status);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_SERVICE_STOPPED_EVENT;
+    event->gatts_service_stopped_event.status = status;
+    event->gatts_service_stopped_event.server_if = server_if;
+    event->gatts_service_stopped_event.srvc_handle = srvc_handle ;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_service_deleted_cb(int status, int server_if, int srvc_handle)
+{
+    ALOGD(LOGTAG "(%s) Status:(%d)",__FUNCTION__, status);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_SERVICE_DELETED_EVENT;
+    event->gatts_service_deleted_event.status = status;
+    event->gatts_service_deleted_event.server_if = server_if;
+    event->gatts_service_deleted_event.srvc_handle = srvc_handle ;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_request_read_cb(int conn_id, int trans_id, bt_bdaddr_t *bda, int attr_handle,
+                                        int offset, bool is_long)
+{
+    char c_address[32];
+    snprintf(c_address,sizeof(c_address), "%02X:%02X:%02X:%02X:%02X:%02X",
+            bda->address[0], bda->address[1], bda->address[2],
+            bda->address[3], bda->address[4], bda->address[5]);
+
+    ALOGD(LOGTAG "(%s) connid:(%d) bda (%s)",__FUNCTION__, conn_id, c_address);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_REQUEST_READ_EVENT;
+    event->gatts_request_read_event.conn_id = conn_id;
+    event->gatts_request_read_event.trans_id = trans_id;
+    event->gatts_request_read_event.bda = bda;
+    event->gatts_request_read_event.attr_handle = attr_handle;
+    event->gatts_request_read_event.offset = offset;
+    event->gatts_request_read_event.is_long = is_long ;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgatts_request_write_cb(int conn_id, int trans_id, bt_bdaddr_t *bda, int attr_handle,
+                                        int offset, int length, bool need_rsp, bool is_prep,
+                                        uint8_t* value)
+{
+    char c_address[32];
+    uint8_t *mem = NULL;
+    snprintf(c_address,sizeof(c_address), "%02X:%02X:%02X:%02X:%02X:%02X",
+            bda->address[0], bda->address[1], bda->address[2],
+           bda->address[3], bda->address[4], bda->address[5]);
+
+    ALOGD(LOGTAG "(%s) connid:(%d) bdaddr:(%s) value (%s) need_rsp (%d)\n",__FUNCTION__, conn_id,
+            c_address, value, need_rsp);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_REQUEST_WRITE_EVENT;
+    event->gatts_request_write_event.conn_id = conn_id;
+    event->gatts_request_write_event.trans_id = trans_id;
+    event->gatts_request_write_event.bda = bda;
+    event->gatts_request_write_event.attr_handle = attr_handle;
+    event->gatts_request_write_event.offset = offset;
+    event->gatts_request_write_event.length = length;
+    event->gatts_request_write_event.need_rsp = need_rsp;
+    event->gatts_request_write_event.is_prep = is_prep;
+    if(length > 0 && value != NULL)
+    {
+        mem = (uint8_t *)osi_malloc(length);
+        if(mem != NULL)
+            memcpy(mem,value,length);
+    }
+    event->gatts_request_write_event.value = mem;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_request_exec_write_cb(int conn_id, int trans_id,
+                                                bt_bdaddr_t *bda, int exec_write)
+{
+
+    char c_address[32];
+    snprintf(c_address,sizeof(c_address), "%02X:%02X:%02X:%02X:%02X:%02X",
+            bda->address[0], bda->address[1], bda->address[2],
+           bda->address[3], bda->address[4], bda->address[5]);
+
+    ALOGD(LOGTAG "(%s) connid:(%d) bda:(%s)",__FUNCTION__, conn_id, c_address);
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_REQUEST_EXEC_WRITE_EVENT;
+    event->gatts_request_exec_write_event.conn_id = conn_id;
+    event->gatts_request_exec_write_event.trans_id = trans_id;
+    event->gatts_request_exec_write_event.bda = bda;
+    event->gatts_request_exec_write_event.exec_write = exec_write;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_response_confirmation_cb(int status, int handle)
+{
+    ALOGD(LOGTAG "(%s) status:(%d) handle:(%d)",__FUNCTION__, status, handle);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_RESPONSE_CONFIRMATION_EVENT;
+    event->gatts_response_confirmation_event.status = status;
+    event->gatts_response_confirmation_event.handle = handle ;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+void btgatts_indication_sent_cb(int conn_id, int status)
+{
+    ALOGD(LOGTAG "(%s) conn_id (%d) status:(%d)",__FUNCTION__, conn_id, status);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_INDICATION_SENT_EVENT;
+    event->gatts_indication_sent_event.status = status;
+    event->gatts_indication_sent_event.conn_id = conn_id ;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_congestion_cb(int conn_id, bool congested)
+{
+    ALOGD(LOGTAG "(%s) contested (%d) conn_id:(%d)",__FUNCTION__, congested,conn_id);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_CONGESTION_EVENT;
+    event->gatts_congestion_event.congested = congested;
+    event->gatts_congestion_event.conn_id = conn_id ;
+
+    PostMessage(THREAD_ID_GATT, event);
+}
+
+void btgatts_mtu_changed_cb(int conn_id, int mtu)
+{
+    ALOGD(LOGTAG "(%s) conn_id:(%d) Mtu (%d)",__FUNCTION__, conn_id, mtu);
+
+    BtEvent *event = new BtEvent;
+    CHECK_PARAM_VOID(event)
+
+    event->event_id = BTGATTS_MTU_CHANGED_EVENT;
+    event->gatts_mtu_changed_event.conn_id = conn_id;
+    event->gatts_mtu_changed_event.mtu = mtu ;
+
+    PostMessage(THREAD_ID_GATT, event);
+
+}
+
+static const btgatt_server_callbacks_t sGattServerCallbacks = {
+    btgatts_register_app_cb,
+    btgatts_connection_cb,
+    btgatts_service_added_cb,
+    btgatts_included_service_added_cb,
+    btgatts_characteristic_added_cb,
+    btgatts_descriptor_added_cb,
+    btgatts_service_started_cb,
+    btgatts_service_stopped_cb,
+    btgatts_service_deleted_cb,
+    btgatts_request_read_cb,
+    btgatts_request_write_cb,
+    btgatts_request_exec_write_cb,
+    btgatts_response_confirmation_cb,
+    btgatts_indication_sent_cb,
+    btgatts_congestion_cb,
+    btgatts_mtu_changed_cb
+};
+/**
+ * GATT callbacks
+ */
+static btgatt_callbacks_t sGattCallbacks = {
+    sizeof(btgatt_callbacks_t),
+    &sGattClientCallbacks,
+    &sGattServerCallbacks
+};
+
+void BtGattMsgHandler(void *msg) {
+    BtEvent* event = NULL;
+    bool status = false;
+    if(!msg)
+    {
+        ALOGD(LOGTAG "(%s) Msg is null, return.\n",__FUNCTION__);
+        return;
+    }
+    event = ( BtEvent *) msg;
+    ALOGD(LOGTAG "(%s) event id (%d) \n",__FUNCTION__, (int) event->event_id);
+    switch(event->event_id) {
+        case PROFILE_API_START:
+            if (g_gatt) {
+                status = g_gatt->HandleEnableGatt(); /*g_gatt->HandleEnableGatt();*/
+                BtEvent *start_event = new BtEvent;
+                CHECK_PARAM_VOID (start_event)
+
+                ALOGD(LOGTAG "(%s) posting profile start done\n",__FUNCTION__);
+
+                start_event->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+                start_event->profile_start_event.profile_id = PROFILE_ID_GATT;
+                start_event->profile_start_event.status = status;
+                PostMessage(THREAD_ID_GAP, start_event);
+            }
+            break;
+        case PROFILE_API_STOP:
+            if (g_gatt) {
+                status = g_gatt->HandleDisableGatt();
+                BtEvent *stop_event = new BtEvent;
+                CHECK_PARAM_VOID (stop_event)
+
+                stop_event->profile_start_event.event_id = PROFILE_EVENT_STOP_DONE;
+                stop_event->profile_start_event.profile_id = PROFILE_ID_GATT;
+                stop_event->profile_start_event.status = status;
+                PostMessage(THREAD_ID_GAP, stop_event);
+            }
+            break;
+        default:
+
+            if(g_gatt) {
+                ALOGD(LOGTAG "(%s) Received Message %d",__FUNCTION__, (int) event->event_id);
+                g_gatt->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+    }
+    delete event;
+}
+#ifdef __cplusplus
+}
+#endif
+
+void Gatt::HandleGattIpcMsg(BtIpcMsg *ipc_msg)
+{
+
+    CHECK_PARAM_VOID(ipc_msg)
+}
+
+void Gatt::HandleGattsRegisterAppEvent(GattsRegisterAppEvent *event)
+{
+    ALOGD(LOGTAG  "(%s) server_if =%d status =%d uuid =%x \n ",__FUNCTION__, event->server_if,
+            event->status, event->uuid->uu);
+
+    int itr;
+    std::map<uint8_t *,BluetoothGattServerCallback *> ::iterator it;
+
+    for (it = serverCbUuidMap.begin(); it != serverCbUuidMap.end(); ++it) {
+        if (it->first &&  event->uuid->uu) {
+           ALOGD(LOGTAG "checking \n");
+           itr = 0;
+           for (itr = 0; itr < 16; itr++) {
+               ALOGD(LOGTAG " it->first is %d, uuid is %d \n",it->first[itr], event->uuid->uu[itr]);
+               if ( it->first[itr] == event->uuid->uu[itr]) {
+                  continue;
+               } else {
+                 break;
+               }
+           }
+           if ( itr == 16) {
+              fprintf (stdout,"App found with this UUID \n");
+              serverCbSifMap.insert(std::make_pair(event->server_if, it->second));
+              break;
+           } else {
+              fprintf (stdout,"No app found with this UUUD\n");
+           }
+        }
+     }
+
+     if (it->second) {
+        it->second->gattServerRegisterAppCb(event->status,event->server_if,event->uuid);
+     } else {
+        ALOGD(LOGTAG "Callback is null \n");
+     }
+}
+
+void Gatt::HandleGattsConnectionEvent(GattsConnectionEvent *event)
+{
+    ALOGD(LOGTAG "(%s) conn_id (%d) server_if (%d) connected (%d)\n",__FUNCTION__, event->conn_id,
+            event->server_if, event->connected);
+
+    ConnidServerifMap.insert(std::make_pair(event->conn_id, event->server_if));
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(event->server_if);
+    if (it != serverCbSifMap.end()) {
+       it->second->btgatts_connection_cb(event->conn_id,event->server_if,event->connected, event->bda);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattsServiceAddedEvent(GattsServiceAddedEvent *event)
+{
+    ALOGD(LOGTAG  "(%s) event_id =%d status =%d server_if =%d,service_handle =%d \n",__FUNCTION__,
+           event->event_id, event->status, event->server_if,event->srvc_handle);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(event->server_if);
+    if (it != serverCbSifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgatts_service_added_cb(event->status,event->server_if,event->srvc_id, event->srvc_handle);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattsCharacteristicAddedEvent(GattsCharacteristicAddedEvent *event)
+{
+    ALOGD(LOGTAG  "(%s) char_handle =%d char_id =%d status =%d server_if =%d,service_handle =%d \n",
+            __FUNCTION__, event->char_handle, event->char_id, event->status,
+            event->server_if, event->srvc_handle);
+
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(event->server_if);
+    if(it != serverCbSifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgatts_characteristic_added_cb(event->status,event->server_if,event->char_id, event->srvc_handle,event->char_handle);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattsDescriptorAddedEvent(GattsDescriptorAddedEvent *event)
+{
+    ALOGD(LOGTAG  "(%s) desc_handle =%d desc_id =%d status =%d server_if =%d, srvc_handle=%x,"
+            "service_handle =%d \n ",__FUNCTION__, event->descr_handle, event->descr_id,
+            event->status, event->server_if,event->srvc_handle);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(event->server_if);
+    if(it != serverCbSifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgatts_descriptor_added_cb(event->status,event->server_if,event->descr_id, event->srvc_handle, event->descr_handle);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+void Gatt::HandleGattsServiceStartedEvent(GattsServiceStartedEvent *event)
+{
+    ALOGD(LOGTAG "(%s) status =%d server_if =%d,service_handle =%d\n",__FUNCTION__,
+            event->status, event->server_if, event->srvc_handle);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(event->server_if);
+    if (it != serverCbSifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgatts_service_started_cb(event->status,event->server_if,event->srvc_handle);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattsServiceStoppedEvent(GattsServiceStoppedEvent *event)
+{
+    ALOGD(LOGTAG  "Handler :(%s) status(%d) server_if(%d) srvc_handle(%d)",__FUNCTION__,
+            event->status, event->server_if, event->srvc_handle);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+    it = serverCbSifMap.find(event->server_if);
+    if (it != serverCbSifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgatts_service_stopped_cb(event->status,event->server_if,event->srvc_handle);
+    }  else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattsServiceDeletedEvent(GattsServiceDeletedEvent *event)
+{
+    ALOGD(LOGTAG  "Handler :(%s) status(%d) server_if(%d) srvc_handle(%d)",__FUNCTION__,
+            event->status, event->server_if, event->srvc_handle);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(event->server_if);
+    if (it != serverCbSifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgatts_service_deleted_cb(event->status,event->server_if,event->srvc_handle);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+// here we have to take decision based on connection id
+void Gatt::HandleGattsRequestWriteEvent(GattsRequestWriteEvent *event)
+{
+    char c_address[32];
+    snprintf(c_address,sizeof(c_address), "%02X:%02X:%02X:%02X:%02X:%02X",
+                event->bda->address[0], event->bda->address[1], event->bda->address[2],
+                event->bda->address[3], event->bda->address[4], event->bda->address[5]);
+
+    ALOGD(LOGTAG "server if is %d \n", ConnidServerifMap[event->conn_id]);
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(ConnidServerifMap[event->conn_id]);
+    if (it != serverCbSifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgatts_request_write_cb(event->conn_id,event->trans_id, event->bda, event->attr_handle,
+                                    event->offset, event->length, event->need_rsp, event->is_prep,
+                                    event->value);
+    } else {
+        ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+
+void Gatt::HandleGattsRequestReadEvent(GattsRequestReadEvent *event)
+{
+
+    ALOGD(LOGTAG  "Handler :(%s) conn_id(%d) event_id(%d) attr_handle(%d)",__FUNCTION__,
+            event->conn_id, event->event_id, event->attr_handle);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(ConnidServerifMap[event->conn_id]);
+    if (it != serverCbSifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgatts_request_read_cb(event->conn_id, event->trans_id, event->bda, event->attr_handle,
+                                       event->offset, event->is_long);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattsIncludeServiceAddedEvent(GattsIncludedServiceAddedEvent *event)
+{
+
+    ALOGD(LOGTAG  "(%s) event_id =%d server_if =%d,service_handle =%d \n",__FUNCTION__,
+            event->event_id, event->server_if,event->srvc_handle);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(event->server_if);
+    if (it != serverCbSifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgatts_included_service_added_cb(event->status,event->server_if,event->srvc_handle, event->incl_srvc_handle);
+    } else {
+        ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+
+void Gatt::HandleGattsRequestExecWriteEvent(GattsRequestExecWriteEvent *event)
+{
+
+    ALOGD(LOGTAG  "Handler :(%s) conn_id(%d) event_id(%d) exec_write(%d)",__FUNCTION__,
+            event->conn_id, event->event_id, event->exec_write);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(ConnidServerifMap[event->conn_id]);
+    if (it != serverCbSifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgatts_request_exec_write_cb(event->conn_id, event->trans_id,
+                                               event->bda, event->exec_write);
+    } else {
+        ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+
+void Gatt::HandleGattsResponseConfirmationEvent(GattsResponseConfirmationEvent *event)
+{
+    UNUSED
+}
+
+void Gatt::HandleGattsIndicationSentEvent(GattsIndicationSentEvent *event)
+{
+
+    ALOGD(LOGTAG  "Handler :(%s) conn_id(%d) event_id(%d) status(%d)",__FUNCTION__,
+                event->conn_id, event->event_id, event->status);
+
+    std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+    it = serverCbSifMap.find(ConnidServerifMap[event->conn_id]);
+    if (it != serverCbSifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgatts_indication_sent_cb(event->conn_id, event->status);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+
+void Gatt::HandleGattsCongetionEvent(GattsCongestionEvent *event)
+{
+        ALOGD(LOGTAG  "Handler :(%s) conn_id(%d) event_id(%d) congested(%d)",__FUNCTION__,
+                        event->conn_id, event->event_id, event->congested);
+
+        std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+        it = serverCbSifMap.find(ConnidServerifMap[event->conn_id]);
+        if(it != serverCbSifMap.end()) {
+         ALOGD(LOGTAG "found \n");
+         it->second->btgatts_congestion_cb(event->conn_id, event->congested);
+        }  else {
+         ALOGD(LOGTAG "Not found \n");
+        }
+}
+
+void Gatt::HandleGattsMtuChangedEvent(GattsMTUchangedEvent *event)
+{
+        ALOGD(LOGTAG  "Handler :(%s) conn_id(%d) event_id(%d) mtu(%d)",__FUNCTION__,
+                        event->conn_id, event->event_id, event->mtu);
+
+        std::map<int,BluetoothGattServerCallback *> ::iterator it;
+
+        it = serverCbSifMap.find(ConnidServerifMap[event->conn_id]);
+        if(it != serverCbSifMap.end()) {
+         ALOGD(LOGTAG "found \n");
+         it->second->btgatts_mtu_changed_cb(event->conn_id, event->mtu);
+        } else {
+         ALOGD(LOGTAG "Not found \n");
+        }
+
+}
+
+void Gatt::HandleGattcRegisterAppEvent(GattcRegisterAppEvent *event)
+{
+    int itr;
+    std::map<uint8_t *,BluetoothGattClientCallback *> ::iterator it;
+
+    for (it = clientCbUuidMap.begin(); it != clientCbUuidMap.end(); ++it) {
+
+         if (it->first &&  event->app_uuid->uu) {
+            ALOGD(LOGTAG "checking \n");
+            itr = 0;
+            for (itr = 0; itr < 16; itr++) {
+                ALOGD(LOGTAG " it->first is %d, uuid is %d \n",it->first[itr], event->app_uuid->uu[itr]);
+                if ( it->first[itr] == event->app_uuid->uu[itr]) {
+                   continue;
+                } else {
+                    break;
+                }
+            }
+            if ( itr == 16) {
+               fprintf (stdout,"found \n");
+               clientCbCifMap.insert(std::make_pair(event->clientIf, it->second));
+               break;
+            } else {
+               fprintf (stdout,"not found \n");
+            }
+        }
+    }
+
+    if (it->second) {
+       it->second->btgattc_client_register_app_cb(event->status,event->clientIf,event->app_uuid);
+    } else {
+       ALOGD(LOGTAG "Callback is null \n");
+    }
+
+}
+
+
+void Gatt::HandleGattcScanResultEvent (GattcScanResultEvent *event)
+{
+         std::map<int,int> ::iterator it;
+        for ( it = clientIfScanStatusMap.begin(); it != clientIfScanStatusMap.end();it++) {
+            if ( it->second == true) {
+                 std::map<int,BluetoothGattClientCallback *> ::iterator it2;
+                 it2 = clientCbCifMap.find(it->first);
+                 if(it2 != clientCbCifMap.end()) {
+                   ALOGD(LOGTAG "found \n");
+                    if ( it2->second) {
+                        it2->second->btgattc_scan_result_cb(event->bda,event->rssi,event->adv_data);
+                    } else {
+                        ALOGD(LOGTAG "Not found \n");
+                    }
+                 }
+             }
+
+        }
+}
+
+void Gatt::HandleGattcOpenEvent(GattcOpenEvent *event) {
+
+    ALOGD(LOGTAG "(%s) conn_id (%d) clientif (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+            event->clientIf, event->status);
+
+    ConnidClientifMap.insert(std::make_pair(event->conn_id, event->clientIf));
+
+    std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+    it = clientCbCifMap.find(event->clientIf);
+    if(it != clientCbCifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgattc_open_cb(event->conn_id, event->status, event->clientIf, event->bda);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattcCloseEvent(GattcCloseEvent *event)  {
+
+    ALOGD(LOGTAG "(%s) conn_id (%d) clientif (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+            event->clientIf, event->status);
+
+    std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+    it = clientCbCifMap.find(event->clientIf);
+    if(it != clientCbCifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgattc_close_cb(event->conn_id, event->status, event->clientIf, event->bda);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattcSearchCompleteEvent(GattcSearchCompleteEvent *event)  {
+
+    ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+            event->event_id, event->status);
+
+
+    std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+    it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+    if(it != clientCbCifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgattc_search_complete_cb(event->conn_id, event->status);
+    } else {
+       ALOGD(LOGTAG "Not found \n");
+    }
+}
+
+void Gatt::HandleGattcRegisterForNotificationEvent(GattcRegisterForNotificationEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+                    event->event_id, event->status);
+
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+      it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+       if(it != clientCbCifMap.end()) {
+          ALOGD(LOGTAG "found \n");
+           it->second->btgattc_register_for_notification_cb(event->conn_id, event->registered,
+                                      event->status, event->handle);
+        } else {
+           ALOGD(LOGTAG "Not found \n");
+        }
+}
+
+void Gatt::HandleGattcNotifyEvent(GattcNotifyEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d)\n",__FUNCTION__, event->conn_id,
+                                event->event_id);
+
+      std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+      it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+      if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_notify_cb(event->conn_id, event->p_data);
+      }  else {
+        ALOGD(LOGTAG "Not found \n");
+      }
+}
+
+void Gatt::HandleGattcReadCharacteristicEvent(GattcReadCharacteristicEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+                                event->event_id, event->status);
+
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_read_characteristic_cb(event->conn_id, event->status,
+                                                    event->p_data);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcWriteCharacteristicEvent(GattcWriteCharacteristicEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+                 event->event_id, event->status);
+
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_write_characteristic_cb(event->conn_id, event->status,
+                     event->handle);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+
+}
+
+void Gatt::HandleGattcReadDescriptorEvent(GattcReadDescriptorEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+                    event->event_id, event->status);
+
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_read_descriptor_cb(event->conn_id, event->status, event->p_data);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcWriteDescriptorEvent(GattcWriteDescriptorEvent  *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+                     event->event_id, event->status);
+
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_write_descriptor_cb(event->conn_id, event->status, event->handle);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcExecuteWriteEvent(GattcExecuteWriteEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+                                event->event_id, event->status);
+
+      std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+      it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+      if(it != clientCbCifMap.end()) {
+         ALOGD(LOGTAG "found \n");
+         it->second->btgattc_execute_write_cb(event->conn_id, event->status);
+      } else {
+         ALOGD(LOGTAG "Not found \n");
+      }
+}
+
+void Gatt::HandleGattcRemoteRssiEvent(GattcRemoteRssiEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) rssi (%d)\n",__FUNCTION__, event->client_if,
+                     event->event_id, event->rssi);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_remote_rssi_cb(event->client_if,event->bda, event->rssi, event->status);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcAdvertiseEvent(GattcAdvertiseEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                     event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgattc_advertise_cb(event->status, event->client_if);
+     } else {
+       ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcConfigureMtuEvent(GattcConfigureMtuEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->conn_id,
+                     event->event_id, event->status);
+
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+     if(it != clientCbCifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgattc_configure_mtu_cb(event->conn_id, event->status, event->mtu);
+     } else {
+       ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcScanFilterCfgEvent(GattcScanFilterCfgEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                     event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_scan_filter_cfg_cb(event->action, event->client_if, event->status,
+                    event->filt_type, event->avbl_space);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcScanFilterParamEvent(GattcScanFilterParamEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                    event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_scan_filter_param_cb(event->action, event->client_if, event->status, event->avbl_space);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcScanFilterStatusEvent(GattcScanFilterStatusEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                    event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_scan_filter_status_cb(event->action, event->client_if, event->status);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcMultiadvEnableEvent(GattcMultiadvEnableEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                     event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgattc_multiadv_enable_cb(event->client_if, event->status);
+     } else {
+       ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcMultiadvUpdateEvent(GattcMultiadvUpdateEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                    event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_multiadv_update_cb(event->client_if, event->status);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcMultiadvSetadvDataEvent(GattcMultiadvSetadvDataEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                     event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+      it = clientCbCifMap.find(event->client_if);
+      if(it != clientCbCifMap.end()) {
+         ALOGD(LOGTAG "found \n");
+         it->second->btgattc_multiadv_setadv_data_cb(event->client_if, event->status);
+      } else {
+         ALOGD(LOGTAG "Not found \n");
+      }
+}
+
+void Gatt::HandleGattcMultiadvDisableEvent(GattcMultiadvDisableEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                     event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_multiadv_disable_cb(event->client_if, event->status);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcCongestionEvent(GattcCongestionEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) congested (%d)\n",__FUNCTION__, event->conn_id,
+                                event->event_id, event->congested);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_congestion_cb(event->conn_id, event->congested);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcBatchscanCfgStorageEvent(GattcBatchscanCfgStorageEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                     event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgattc_batchscan_cfg_storage_cb(event->client_if, event->status);
+     } else {
+       ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcBatchscanStartstopEvent(GattcBatchscanStartstopEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                      event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_batchscan_startstop_cb(event->startstop_action, event->client_if, event->status);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcBatchscanReportsEvent(GattcBatchscanReportsEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                                event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if(it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_batchscan_reports_cb(event->client_if, event->status, event->report_format,
+                               event->num_records, event->data_len, event->p_rep_data);
+        } else {
+        ALOGD(LOGTAG "Not found \n");
+        }
+}
+
+void Gatt::HandleGattcBatchscanThresholdEvent(GattcBatchscanThresholdEvent *event)  {
+
+      ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) \n",__FUNCTION__, event->client_if,
+                      event->event_id);
+      std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+      it = clientCbCifMap.find(event->client_if);
+      if(it != clientCbCifMap.end()) {
+         ALOGD(LOGTAG "found \n");
+         it->second->btgattc_batchscan_threshold_cb(event->client_if);
+        } else {
+         ALOGD(LOGTAG "Not found \n");
+        }
+}
+
+void Gatt::HandleGattcTrackAdvEventEvent(GattcTrackAdvEventEvent *event)  {
+     UNUSED
+}
+
+void Gatt::HandleGattcScanParameterSetupCompletedEvent(GattcScanParameterSetupCompletedEvent *event)  {
+     ALOGD(LOGTAG "(%s) client_if (%d) event_id (%d) status (%d)\n",__FUNCTION__, event->client_if,
+                    event->event_id, event->status);
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(event->client_if);
+     if (it != clientCbCifMap.end()) {
+        ALOGD(LOGTAG "found \n");
+        it->second->btgattc_scan_parameter_setup_completed_cb(event->client_if, event->status);
+     } else {
+        ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::HandleGattcGetGattDbEvent(GattcGetGattDbEvent *event)  {
+     ALOGD(LOGTAG "(%s) conn_id (%d) event_id (%d) count (%d)\n",__FUNCTION__, event->conn_id,
+                    event->event_id, event->count);
+
+     std::map<int,BluetoothGattClientCallback *> ::iterator it;
+
+     it = clientCbCifMap.find(ConnidClientifMap[event->conn_id]);
+     if(it != clientCbCifMap.end()) {
+       ALOGD(LOGTAG "found \n");
+       it->second->btgattc_get_gatt_db_cb(event->conn_id, event->db, event->count);
+     } else {
+       ALOGD(LOGTAG "Not found \n");
+     }
+}
+
+void Gatt::ProcessEvent(BtEvent* event)
+{
+    CHECK_PARAM_VOID(event)
+    ALOGD(LOGTAG "(%s) Processing event %d \n ",__FUNCTION__, event->event_id);
+
+    switch(event->event_id) {
+        case BTGATTS_REGISTER_APP_EVENT:
+            HandleGattsRegisterAppEvent((GattsRegisterAppEvent *)event);
+            break;
+        case BTGATTS_CONNECTION_EVENT:
+            HandleGattsConnectionEvent((GattsConnectionEvent *)event);
+            break;
+        case BTGATTS_SERVICE_ADDED_EVENT:
+            HandleGattsServiceAddedEvent((GattsServiceAddedEvent *)event);
+            break;
+        case BTGATTS_CHARACTERISTIC_ADDED_EVENT:
+            HandleGattsCharacteristicAddedEvent((GattsCharacteristicAddedEvent *)event);
+            break;
+        case BTGATTS_DESCRIPTOR_ADDED_EVENT:
+            HandleGattsDescriptorAddedEvent((GattsDescriptorAddedEvent *)event);
+            break;
+        case BTGATTS_SERVICE_STARTED_EVENT:
+            HandleGattsServiceStartedEvent((GattsServiceStartedEvent *)event);
+            break;
+        case BTGATTS_SERVICE_STOPPED_EVENT:
+            HandleGattsServiceStoppedEvent((GattsServiceStoppedEvent *)event);
+            break;
+        case BTGATTS_SERVICE_DELETED_EVENT:
+            HandleGattsServiceDeletedEvent((GattsServiceDeletedEvent *)event);
+            break;
+        case BTGATTS_REQUEST_WRITE_EVENT:
+            HandleGattsRequestWriteEvent((GattsRequestWriteEvent *)event);
+            break;
+        case BTGATTS_REQUEST_READ_EVENT:
+            HandleGattsRequestReadEvent((GattsRequestReadEvent *) event);
+            break;
+        case BTGATTS_INCLUDED_SERVICE_ADDED_EVENT:
+            HandleGattsIncludeServiceAddedEvent((GattsIncludedServiceAddedEvent *) event);
+            break;
+        case BTGATTS_REQUEST_EXEC_WRITE_EVENT:
+            HandleGattsRequestExecWriteEvent((GattsRequestExecWriteEvent *) event);
+            break;
+        case BTGATTS_RESPONSE_CONFIRMATION_EVENT:
+             HandleGattsResponseConfirmationEvent((GattsResponseConfirmationEvent*)event);
+             break;
+        case BTGATTS_INDICATION_SENT_EVENT:
+             HandleGattsIndicationSentEvent((GattsIndicationSentEvent*)event);
+             break;
+        case BTGATTS_CONGESTION_EVENT:
+             HandleGattsCongetionEvent((GattsCongestionEvent*)event);
+             break;
+        case BTGATTS_MTU_CHANGED_EVENT:
+             HandleGattsMtuChangedEvent((GattsMTUchangedEvent*)event);
+             break;
+        case BTGATTC_REGISTER_APP_EVENT:
+             HandleGattcRegisterAppEvent((GattcRegisterAppEvent *) event);
+             break;
+        case BTGATTC_SCAN_RESULT_EVENT:
+             HandleGattcScanResultEvent((GattcScanResultEvent *) event);
+             break;
+        case BTGATTC_OPEN_EVENT:
+             HandleGattcOpenEvent((GattcOpenEvent*) event);
+             break;
+        case BTGATTC_CLOSE_EVENT:
+             HandleGattcCloseEvent((GattcCloseEvent*) event);
+             break;
+        case BTGATTC_SEARCH_COMPLETE_EVENT:
+             HandleGattcSearchCompleteEvent((GattcSearchCompleteEvent*) event);
+             break;
+        case BTGATTC_REGISTER_FOR_NOTIFICATION_EVENT:
+             HandleGattcRegisterForNotificationEvent((GattcRegisterForNotificationEvent*) event);
+             break;
+        case BTGATTC_NOTIFY_EVENT:
+             HandleGattcNotifyEvent((GattcNotifyEvent*) event);
+             break;
+        case BTGATTC_READ_CHARACTERISTIC_EVENT:
+             HandleGattcReadCharacteristicEvent((GattcReadCharacteristicEvent*) event);
+             break;
+        case BTGATTC_WRITE_CHARACTERISTIC_EVENT:
+             HandleGattcWriteCharacteristicEvent((GattcWriteCharacteristicEvent*) event);
+             break;
+        case BTGATTC_READ_DESCRIPTOR_EVENT:
+             HandleGattcReadDescriptorEvent((GattcReadDescriptorEvent*) event);
+             break;
+        case BTGATTC_WRITE_DESCRIPTOR_EVENT:
+             HandleGattcWriteDescriptorEvent((GattcWriteDescriptorEvent *) event);
+             break;
+        case BTGATTC_EXECUTE_WRITE_EVENT:
+             HandleGattcExecuteWriteEvent((GattcExecuteWriteEvent*) event);
+             break;
+        case BTGATTC_REMOTE_RSSI_EVENT:
+             HandleGattcRemoteRssiEvent((GattcRemoteRssiEvent*) event);
+             break;
+        case BTGATTC_ADVERTISE_EVENT:
+             HandleGattcAdvertiseEvent((GattcAdvertiseEvent*) event);
+             break;
+        case BTGATTC_CONFIGURE_MTU_EVENT:
+             HandleGattcConfigureMtuEvent((GattcConfigureMtuEvent*) event);
+             break;
+        case BTGATTC_SCAN_FILTER_CFG_EVENT:
+             HandleGattcScanFilterCfgEvent((GattcScanFilterCfgEvent*) event);
+             break;
+        case BTGATTC_SCAN_FILTER_PARAM_EVENT:
+             HandleGattcScanFilterParamEvent((GattcScanFilterParamEvent*) event);
+             break;
+        case BTGATTC_SCAN_FILTER_STATUS_EVENT:
+             HandleGattcScanFilterStatusEvent((GattcScanFilterStatusEvent*) event);
+             break;
+        case BTGATTC_MULTIADV_ENABLE_EVENT:
+             HandleGattcMultiadvEnableEvent((GattcMultiadvEnableEvent*) event);
+             break;
+        case BTGATTC_MULTIADV_UPDATE_EVENT:
+             HandleGattcMultiadvUpdateEvent((GattcMultiadvUpdateEvent*) event);
+             break;
+        case BTGATTC_MULTIADV_SETADV_DATA_EVENT:
+             HandleGattcMultiadvSetadvDataEvent((GattcMultiadvSetadvDataEvent*) event);
+             break;
+        case BTGATTC_MULTIADV_DISABLE_EVENT:
+             HandleGattcMultiadvDisableEvent((GattcMultiadvDisableEvent*) event);
+             break;
+        case BTGATTC_CONGESTION_EVENT:
+             HandleGattcCongestionEvent((GattcCongestionEvent*) event);
+             break;
+        case BTGATTC_BATCHSCAN_CFG_STORAGE_EVENT:
+             HandleGattcBatchscanCfgStorageEvent((GattcBatchscanCfgStorageEvent*) event);
+             break;
+        case BTGATTC_BATCHSCAN_STARTSTOP_EVENT:
+             HandleGattcBatchscanStartstopEvent((GattcBatchscanStartstopEvent*) event);
+             break;
+        case BTGATTC_BATCHSCAN_REPORTS_EVENT:
+             HandleGattcBatchscanReportsEvent((GattcBatchscanReportsEvent*) event);
+             break;
+        case BTGATTC_BATCHSCAN_THRESHOLD_EVENT:
+             HandleGattcBatchscanThresholdEvent((GattcBatchscanThresholdEvent*) event);
+             break;
+        case BTGATTC_TRACK_ADV_EVENT_EVENT:
+             HandleGattcTrackAdvEventEvent((GattcTrackAdvEventEvent*) event);
+             break;
+        case BTGATTC_SCAN_PARAMETER_SETUP_COMPLETED_EVENT:
+             HandleGattcScanParameterSetupCompletedEvent((GattcScanParameterSetupCompletedEvent*) event);
+             break;
+        case BTGATTC_GET_GATT_DB_EVENT:
+             HandleGattcGetGattDbEvent((GattcGetGattDbEvent*) event);
+             break;
+        default: //All fall-through, enable as needed
+            ALOGD(LOGTAG  "(%s) Unhandled Event(%d)",__FUNCTION__, event->event_id);
+            break;
+    }
+}
+
+bool Gatt::GattInterfaceInit(const bt_interface_t *bt_interface)
+{
+    gatt_interface = (btgatt_interface_t*) bt_interface->get_profile_interface(BT_PROFILE_GATT_ID);
+    if (gatt_interface == NULL)
+    {
+        ALOGD(LOGTAG "(%s) Failed to init gatt profile \n",__FUNCTION__);
+        return false;
+    }
+    bt_status_t status = gatt_interface->init(&sGattCallbacks);
+    return (status != BT_STATUS_SUCCESS ? false : true);
+}
+
+bt_status_t Gatt::scan( bool start, int client_if )
+{
+    clientIfScanStatusMap[client_if] = start;
+    if (gatt_interface) {
+       return gatt_interface->client->scan( start );
+    }
+}
+
+btgatt_interface_t * Gatt::GetGattInterface()
+{
+    if (gatt_interface)
+       return gatt_interface;
+    else
+       ALOGD(LOGTAG "(%s) gatt interface is null",__FUNCTION__);
+}
+
+
+void Gatt::RegisterServerCallback(BluetoothGattServerCallback * rspServerCb,bt_uuid_t *server_uuid)
+{
+     ALOGD(LOGTAG " RegisterCallback entry \n");
+     std::map<uint8_t *,BluetoothGattServerCallback *> ::iterator it;
+
+     serverCbUuidMap.insert(std::make_pair(server_uuid->uu, rspServerCb));
+     ALOGD(LOGTAG " RegisterCallback exit \n");
+}
+void Gatt::UnRegisterServerCallback( int serverif)
+{
+     ALOGD(LOGTAG "UnRegisterServerCallback \n");
+     std::map<uint8_t *,BluetoothGattServerCallback *> ::iterator it;
+     std::map<int ,BluetoothGattServerCallback *> ::iterator it2;
+     std::map<int ,int> ::iterator it3;
+
+     for (it = serverCbUuidMap.begin(); it != serverCbUuidMap.end(); ++it) {
+
+         if (it->second == serverCbSifMap[serverif]) {
+            serverCbUuidMap.erase (it);
+            break;
+         }
+     }
+     it2 = serverCbSifMap.find(serverif);
+     if (it2 != serverCbSifMap.end())
+     serverCbSifMap.erase (it2);
+     it3 = ConnidServerifMap.find(serverif);
+     if (it3 != ConnidServerifMap.end())
+     ConnidServerifMap.erase(it3);
+}
+
+void Gatt::RegisterClientCallback(BluetoothGattClientCallback * clientCb,bt_uuid_t *client_uuid)
+{
+     ALOGD(LOGTAG " RegisterCallback entry\n");
+     clientCbUuidMap.insert(std::make_pair(client_uuid->uu, clientCb));
+     ALOGD(LOGTAG " RegisterclientCallback exit \n");
+}
+void Gatt::UnRegisterClientCallback( int clientif)
+{
+     std::map<uint8_t *,BluetoothGattClientCallback *> ::iterator it;
+     std::map<int ,BluetoothGattClientCallback *> ::iterator it2;
+     std::map<int ,int> ::iterator it3;
+     for (it = clientCbUuidMap.begin(); it != clientCbUuidMap.end(); ++it) {
+          if (it->second == clientCbCifMap[clientif]) {
+             clientCbUuidMap.erase (it);
+             break;
+          }
+     }
+     it2 = clientCbCifMap.find(clientif);
+     if (it2 != clientCbCifMap.end())
+     clientCbCifMap.erase (it2);
+     it3 = ConnidClientifMap.find(clientif);
+     if (it3 != ConnidClientifMap.end())
+     ConnidClientifMap.erase(it3);
+}
+
+void Gatt::GattInterfaceCleanup()
+{
+    if (gatt_interface) {
+        gatt_interface->cleanup();
+        gatt_interface = NULL;
+    }
+}
+
+Gatt::Gatt(const bt_interface_t *bt_interface, config_t *config)
+{
+    ALOGD(LOGTAG "(%s) Starting Up Gatt Instance",__FUNCTION__);
+    this->gatt_interface = NULL;
+    this->bluetooth_interface = bt_interface;
+    this->config = config;
+}
+Gatt::~Gatt()
+{
+    ALOGD(LOGTAG  "(%s) Cleaning up GATT Interface",__FUNCTION__);
+    GattInterfaceCleanup();
+}
+
+bool Gatt::HandleEnableGatt()
+{
+     ALOGD(LOGTAG "(%s) HandleEnableGatt \n",__FUNCTION__);
+
+     if (GattInterfaceInit(bluetooth_interface)!= true) {
+             ALOGD(LOGTAG "(%s) Gatt Initialization Failed \n ",__FUNCTION__);
+             return false;
+     } else {
+             return true;
+     }
+}
+bool Gatt::HandleDisableGatt()
+{
+    bool status = true;
+    ALOGD(LOGTAG  "(%s) Closing Gatt Instance",__FUNCTION__);
+    GattInterfaceCleanup();
+    return status;
+}
+
+
+bt_status_t Gatt::register_client( bt_uuid_t *client_uuid ) {
+
+            if (gatt_interface) {
+                return gatt_interface->client->register_client(client_uuid);
+            }
+}
+
+
+bt_status_t Gatt::unregister_client(int client_if ) {
+            if (gatt_interface) {
+                return gatt_interface->client->unregister_client(client_if);
+            }
+}
+
+
+bt_status_t Gatt::clientConnect( int client_if, const bt_bdaddr_t *bd_addr,
+                                         bool is_direct, int transport ) {
+
+            if (gatt_interface) {
+               return gatt_interface->client->connect( client_if, bd_addr, is_direct,
+                                      transport );
+            }
+}
+
+
+bt_status_t Gatt::clientDisconnect( int client_if, const bt_bdaddr_t *bd_addr,
+                                int conn_id) {
+            if (gatt_interface) {
+                return gatt_interface->client->disconnect( client_if, bd_addr, conn_id);
+            }
+}
+
+
+bt_status_t Gatt::listen(int client_if, bool start) {
+            if (gatt_interface) {
+                return gatt_interface->client->listen(client_if, start);
+            }
+}
+
+
+bt_status_t Gatt::refresh( int client_if, const bt_bdaddr_t *bd_addr ) {
+            if (gatt_interface) {
+                return gatt_interface->client->refresh( client_if, bd_addr );
+            }
+}
+
+
+bt_status_t Gatt::search_service(int conn_id, bt_uuid_t *filter_uuid ) {
+            if (gatt_interface) {
+                return gatt_interface->client->search_service(conn_id, filter_uuid );
+            }
+}
+
+bt_status_t Gatt::read_characteristic( int conn_id, uint16_t handle,
+                                int auth_req ) {
+        if (gatt_interface) {
+            return gatt_interface->client->read_characteristic(conn_id,
+                                   handle, auth_req );
+        }
+
+}
+
+bt_status_t Gatt::write_characteristic(int conn_id, uint16_t handle,
+                                int write_type, int len, int auth_req,
+                                char* p_value) {
+        if (gatt_interface) {
+            return gatt_interface->client->write_characteristic(conn_id,
+                 handle, write_type, len, auth_req, p_value);
+        }
+
+}
+
+
+bt_status_t Gatt::read_descriptor(int conn_id, uint16_t handle,
+                                int auth_req) {
+        if (gatt_interface) {
+            return gatt_interface->client->read_descriptor(conn_id,
+                handle, auth_req);
+        }
+
+}
+
+
+bt_status_t Gatt::write_descriptor(int conn_id, uint16_t handle,
+                                   int write_type, int len,
+                                   int auth_req, char* p_value) {
+        if (gatt_interface) {
+            return gatt_interface->client->write_descriptor( conn_id, handle,
+                   write_type, len, auth_req,p_value);
+        }
+
+}
+
+
+bt_status_t Gatt::execute_write(int conn_id, int execute) {
+        if (gatt_interface) {
+            return gatt_interface->client->execute_write(conn_id, execute);
+        }
+
+}
+
+
+bt_status_t Gatt::register_for_notification( int client_if,
+                                const bt_bdaddr_t *bd_addr, uint16_t handle) {
+        if (gatt_interface) {
+            return gatt_interface->client->register_for_notification(client_if,
+                                bd_addr, handle);
+        }
+
+}
+
+
+bt_status_t Gatt::deregister_for_notification( int client_if,
+                                const bt_bdaddr_t *bd_addr, uint16_t handle) {
+        if (gatt_interface) {
+            return gatt_interface->client->deregister_for_notification(client_if,
+                                bd_addr, handle);
+        }
+
+}
+
+
+bt_status_t Gatt::read_remote_rssi( int client_if, const bt_bdaddr_t *bd_addr) {
+        if (gatt_interface) {
+            return gatt_interface->client->read_remote_rssi( client_if, bd_addr);
+        }
+
+}
+
+
+bt_status_t Gatt::scan_filter_param_setup(btgatt_filt_param_setup_t filt_param) {
+        if (gatt_interface) {
+            return gatt_interface->client->scan_filter_param_setup(filt_param);
+        }
+
+}
+
+
+
+bt_status_t Gatt::scan_filter_add_remove(int client_if, int action, int filt_type,
+                                         int filt_index, int company_id,
+                                         int company_id_mask, const bt_uuid_t *p_uuid,
+                                         const bt_uuid_t *p_uuid_mask, const bt_bdaddr_t *bd_addr,
+                                         char addr_type, int data_len, char* p_data, int mask_len,
+                                         char* p_mask) {
+        if (gatt_interface) {
+            return gatt_interface->client->scan_filter_add_remove(client_if, action, filt_type,
+                   filt_index, company_id,company_id_mask, p_uuid,p_uuid_mask, bd_addr,
+                    addr_type, data_len, p_data, mask_len, p_mask);
+        }
+
+}
+
+
+bt_status_t Gatt::scan_filter_clear(int client_if, int filt_index) {
+        if (gatt_interface) {
+            return gatt_interface->client->scan_filter_clear(client_if, filt_index);
+        }
+
+}
+
+
+bt_status_t Gatt::scan_filter_enable(int client_if, bool enable) {
+        if (gatt_interface) {
+            return gatt_interface->client->scan_filter_enable(client_if, enable);
+        }
+
+}
+
+
+int Gatt::get_device_type( const bt_bdaddr_t *bd_addr ) {
+        if (gatt_interface) {
+            return gatt_interface->client->get_device_type( bd_addr );
+        }
+
+}
+
+
+bt_status_t Gatt::set_adv_data(int client_if, bool set_scan_rsp, bool include_name,
+                                bool include_txpower, int min_interval, int max_interval, int appearance,
+                                uint16_t manufacturer_len, char* manufacturer_data,
+                                uint16_t service_data_len, char* service_data,
+                                uint16_t service_uuid_len, char* service_uuid) {
+        if (gatt_interface) {
+            return gatt_interface->client->set_adv_data(client_if, set_scan_rsp,
+                                   include_name, include_txpower, min_interval,
+                                   max_interval, appearance,manufacturer_len, manufacturer_data,
+                                   service_data_len, service_data, service_uuid_len,service_uuid);
+        }
+
+}
+
+
+bt_status_t Gatt::configure_mtu(int conn_id, int mtu) {
+        if (gatt_interface) {
+            return gatt_interface->client->configure_mtu(conn_id, mtu);
+        }
+
+}
+
+
+bt_status_t Gatt::conn_parameter_update(const bt_bdaddr_t *bd_addr, int min_interval,
+                                int max_interval, int latency, int timeout) {
+        if (gatt_interface) {
+            return gatt_interface->client->conn_parameter_update(bd_addr, min_interval,
+                                max_interval, latency, timeout) ;
+        }
+
+}
+
+
+bt_status_t Gatt::set_scan_parameters(int client_if, int scan_interval, int scan_window) {
+        if (gatt_interface) {
+            return gatt_interface->client->set_scan_parameters(client_if, scan_interval, scan_window);
+        }
+
+}
+
+
+bt_status_t Gatt::multi_adv_enable(int client_if, int min_interval,int max_interval,int adv_type,
+                         int chnl_map, int tx_power, int timeout_s) {
+        if (gatt_interface) {
+            return gatt_interface->client->multi_adv_enable(client_if, min_interval,max_interval,adv_type,
+                         chnl_map, tx_power, timeout_s);
+        }
+
+}
+
+
+bt_status_t Gatt::multi_adv_update(int client_if, int min_interval,int max_interval,int adv_type,
+                         int chnl_map, int tx_power, int timeout_s) {
+        if (gatt_interface) {
+            return gatt_interface->client->multi_adv_update(client_if, min_interval,max_interval,adv_type,
+                            chnl_map, tx_power, timeout_s);
+        }
+
+}
+
+
+bt_status_t Gatt::multi_adv_set_inst_data(int client_if, bool set_scan_rsp, bool include_name,
+                                bool incl_txpower, int appearance, int manufacturer_len,
+                                char* manufacturer_data, int service_data_len,
+                                char* service_data, int service_uuid_len, char* service_uuid) {
+        if (gatt_interface) {
+            return gatt_interface->client->multi_adv_set_inst_data(client_if, set_scan_rsp, include_name,
+                                incl_txpower, appearance, manufacturer_len, manufacturer_data, service_data_len,
+                                service_data, service_uuid_len, service_uuid);
+        }
+
+}
+
+
+bt_status_t Gatt::multi_adv_disable(int client_if) {
+        if (gatt_interface) {
+            return gatt_interface->client->multi_adv_disable(client_if);
+        }
+
+}
+
+
+bt_status_t Gatt::batchscan_cfg_storage(int client_if, int batch_scan_full_max,
+        int batch_scan_trunc_max, int batch_scan_notify_threshold) {
+        if (gatt_interface) {
+            return gatt_interface->client->batchscan_cfg_storage(client_if, batch_scan_full_max,
+                                   batch_scan_trunc_max, batch_scan_notify_threshold);
+        }
+
+}
+
+
+bt_status_t Gatt::batchscan_enb_batch_scan(int client_if, int scan_mode,
+        int scan_interval, int scan_window, int addr_type, int discard_rule) {
+        if (gatt_interface) {
+            return gatt_interface->client->batchscan_enb_batch_scan(client_if, scan_mode,
+                                   scan_interval, scan_window, addr_type, discard_rule);
+        }
+
+}
+
+
+bt_status_t Gatt::batchscan_dis_batch_scan(int client_if) {
+        if (gatt_interface) {
+            return gatt_interface->client->batchscan_dis_batch_scan(client_if);
+        }
+
+}
+
+
+
+bt_status_t Gatt::batchscan_read_reports(int client_if, int scan_mode) {
+        if (gatt_interface) {
+            return gatt_interface->client->batchscan_read_reports(client_if, scan_mode);
+        }
+
+}
+
+
+bt_status_t Gatt::test_command( int command, btgatt_test_params_t* params) {
+        if (gatt_interface) {
+            return gatt_interface->client->test_command( command, params);
+        }
+
+}
+
+bt_status_t Gatt::get_gatt_db(int conn_id) {
+        if (gatt_interface) {
+            return gatt_interface->client->get_gatt_db(conn_id);
+        }
+
+}
+
+bt_status_t Gatt:: register_server( bt_uuid_t *uuid ) {
+   if (gatt_interface) {
+       return gatt_interface->server->register_server(uuid);
+   }
+}
+
+bt_status_t Gatt:: unregister_server(int server_if ) {
+        if (gatt_interface) {
+            return gatt_interface->server->unregister_server(server_if);
+        }
+
+}
+
+
+bt_status_t Gatt:: serverConnect(int server_if, const bt_bdaddr_t *bd_addr,
+                                                bool is_direct, int transport) {
+        if (gatt_interface) {
+            return gatt_interface->server->connect(server_if, bd_addr,
+                                                is_direct, transport);
+        }
+
+}
+
+
+bt_status_t Gatt:: serverDisconnect(int server_if, const bt_bdaddr_t *bd_addr,
+                                int conn_id ) {
+        if (gatt_interface) {
+            return gatt_interface->server->disconnect(server_if, bd_addr, conn_id);
+        }
+
+}
+
+
+bt_status_t Gatt:: add_service( int server_if, btgatt_srvc_id_t *srvc_id, int num_handles) {
+        if (gatt_interface) {
+            return gatt_interface->server->add_service(server_if, srvc_id, num_handles);
+        }
+
+}
+
+
+bt_status_t Gatt:: add_included_service( int server_if, int service_handle, int included_handle) {
+        if (gatt_interface) {
+            return gatt_interface->server->add_included_service( server_if,service_handle, included_handle);
+        }
+
+}
+
+bt_status_t Gatt:: add_characteristic( int server_if,
+                                int service_handle, bt_uuid_t *uuid,
+                                int properties, int permissions) {
+        if (gatt_interface) {
+            return gatt_interface->server->add_characteristic(server_if, service_handle, uuid,
+                                                            properties, permissions);
+        }
+
+}
+
+
+bt_status_t Gatt:: add_descriptor(int server_if, int service_handle,
+                                                          bt_uuid_t *uuid, int permissions) {
+        if (gatt_interface) {
+            return gatt_interface->server->add_descriptor(server_if,
+                                                        service_handle, uuid,
+                                                        permissions);
+        }
+
+}
+
+
+bt_status_t Gatt:: start_service(int server_if, int service_handle,
+                                                         int transport) {
+        if (gatt_interface) {
+            return gatt_interface->server->start_service(server_if,
+                                                        service_handle, transport);
+        }
+
+}
+
+
+bt_status_t Gatt:: stop_service(int server_if, int service_handle) {
+        if (gatt_interface) {
+            return gatt_interface->server->stop_service(server_if,
+                                                        service_handle);
+        }
+
+}
+
+
+bt_status_t Gatt:: delete_service(int server_if, int service_handle) {
+        if (gatt_interface) {
+            return gatt_interface->server->delete_service(server_if,service_handle);
+        }
+}
+
+
+bt_status_t Gatt:: send_indication(int server_if, int attribute_handle,
+                                                           int conn_id, int len, int confirm,
+                                                           char* p_value) {
+        if (gatt_interface) {
+            return gatt_interface->server->send_indication(server_if, attribute_handle,
+                                           conn_id, len, confirm, p_value);
+        }
+
+}
+
+
+bt_status_t Gatt:: send_response(int conn_id, int trans_id,
+                                                         int status, btgatt_response_t *response) {
+        if (gatt_interface) {
+            return gatt_interface->server->send_response(conn_id, trans_id,
+                                                         status, response);
+        }
+
+}
+
diff --git a/obex_profiles/Makefile.am b/obex_profiles/Makefile.am
new file mode 100644
index 0000000..f3d2272
--- /dev/null
+++ b/obex_profiles/Makefile.am
@@ -0,0 +1,78 @@
+AM_CPPFLAGS = -O2 \
+              -D_GNU_SOURCE
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -DLINUX \
+        -DOI_CPU_TYPE=19 \
+        -DOI_DEBUG \
+        -DOI_USE_NATIVE_MALLOC \
+        -DOI_USE_NATIVE_MEMCPY \
+        -DOI_OBEX_OVER_L2CAP \
+        -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/hal/include/ \
+        -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/vhal/include \
+        -I${WORKSPACE}/system/core/include/ \
+        -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/include \
+        -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/include/profiles \
+        -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/include \
+        -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/include/profiles \
+        -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/oem \
+        -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/platform/linux/include
+
+ACLOCAL_AMFLAGS = -I m4
+
+c_sources = profiles/obex/obexauth.c \
+            profiles/obex/obexcommon.c \
+            profiles/obex/obexcli.c \
+            profiles/obex/obexsrv.c \
+            profiles/obex/obex_lower.c \
+            profiles/obex/obex_lower_socket.c \
+            profiles/obex/obextest.c \
+            profiles/pbap/pbap_client.c \
+            profiles/pbap/pbap_server.c \
+            profiles/pbap/pbap_private.c \
+            profiles/opp/opp_client.c \
+            profiles/opp/opp_server.c \
+            profiles/opp/opp_common.c \
+            stack/support/md5_hash.c \
+            stack/support/memprof.c \
+            stack/support/oi_handle.c \
+            stack/support/oi_mbuf.c \
+            stack/support/oi_time.c \
+            stack/support/oi_list.c \
+            stack/support/oi_init_flags.c \
+            stack/support/oi_config_table.c \
+            stack/support/oi_obextext.c \
+            stack/support/oi_statustext.c \
+            stack/support/oi_unicode.c \
+            stack/support/oi_memmgr.c \
+            stack/support/oi_debug.c \
+            stack/support/oi_dispatch.c \
+            stack/support/oi_fcs.c \
+            stack/support/oi_varstring.c \
+            stack/support/oi_utils.c \
+            stack/support/oi_simplemap.c \
+            stack/support/bt_assigned_nos.c \
+            stack/dataelem/dataelem.c \
+            stack/dataelem/dataelem_text.c \
+            platform/linux/src/oi_osinterface.c \
+            platform/linux/src/oi_assert.c \
+            platform/linux/src/oi_wrapper.c \
+            platform/linux/src/oi_thread.c \
+            platform/linux/src/sockets/oi_eventloop.c \
+            sdk/oem/oi_bt_stack_init_default.c \
+            sdk/oem/oi_bt_profile_config_default.c \
+            sdk/oem/oi_bt_stack_config_default.c \
+            unicode/ConvertUTF.c
+
+AM_LDFLAGS := $(LDFLAFGS)
+
+library_includedir = $(pkgincludedir)
+lib_LTLIBRARIES = libbtobex.la
+libbtobex_la_CC = @CC@
+libbtobex_la_SOURCES = $(c_sources)
+libbtobex_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbtobex_la_CFLAGS = $(AM_CFLAGS)
+libbtobex_la_LDFLAGS = $(AM_LDFLAGS) -static -lpthread -lm -ldl -lrt
diff --git a/obex_profiles/configure.ac b/obex_profiles/configure.ac
new file mode 100644
index 0000000..58f81e1
--- /dev/null
+++ b/obex_profiles/configure.ac
@@ -0,0 +1,50 @@
+AC_PREREQ(2.61)
+AC_INIT([btobex], 1.0.0)
+AM_INIT_AUTOMAKE([-Wall gnu foreign])
+AM_MAINTAINER_MODE
+AC_CONFIG_HEADER([config.h])
+AC_CONFIG_MACRO_DIR([m4])
+
+AC_PROG_CXX
+AM_PROG_AS
+AC_PROG_LIBTOOL
+AC_PROG_AWK
+AC_PROG_CPP
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+PKG_PROG_PKG_CONFIG
+
+# Library configs
+AC_ARG_WITH([common_includes],
+      AC_HELP_STRING([--with-common-includes=@<:@dir@:>@],
+         [Specify the location of the common headers]),
+      [common_incdir=$withval],
+      with_common_includes=no)
+
+if test "x$with_common_includes" != "xno"; then
+   CFLAGS="${CFLAGS} -I${common_incdir}"
+fi
+
+AC_ARG_WITH([glib],
+     AC_HELP_STRING([--with-glib],
+        [enable glib, building HLOS systems which use glib]))
+
+if (test "x${with_glib}" = "xyes"); then
+       PKG_CHECK_MODULES(GTHREAD, gthread-2.0 >= 2.16, dummy=yes,
+                               AC_MSG_ERROR(GThread >= 2.16 is required))
+       PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.16, dummy=yes,
+                               AC_MSG_ERROR(GLib >= 2.16 is required))
+       GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
+       GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
+
+       AC_SUBST(GLIB_CFLAGS)
+       AC_SUBST(GLIB_LIBS)
+fi
+
+AM_CONDITIONAL(USE_GLIB, test "x${with_glib}" = "xyes")
+
+AC_SUBST([CFLAGS])
+AC_SUBST([CC])
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
diff --git a/obex_profiles/include/md5_hash.h b/obex_profiles/include/md5_hash.h
new file mode 100644
index 0000000..22587aa
--- /dev/null
+++ b/obex_profiles/include/md5_hash.h
@@ -0,0 +1,52 @@
+#ifndef _MD5_HASH_H
+#define _MD5_HASH_H
+/** @file
+ * @internal
+ * This code implements the MD5 message-digest algorithm. The algorithm is due
+ * to Ron Rivest and is described in RFC 1321.
+ *
+ * This code was written by Colin Plumb in 1993; no copyright is claimed.
+ *
+ * To compute the message digest of a chunk of bytes, declare an MD5_Context
+ * structure, pass it to OI_MD5_Init, call OI_MD5_Update as needed on buffers full of
+ * bytes, and then call OI_MD5_Final, which will fill a supplied 16-byte array with
+ * the digest.
+ */
+
+#include "oi_stddefs.h"
+
+/** \addtogroup Misc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct {
+    OI_UINT32 buf[4];
+    OI_UINT32 bytes[2];
+    OI_UINT32 in[16];
+} MD5_CONTEXT;
+
+
+void OI_MD5_Init(MD5_CONTEXT *ctx);
+
+
+void OI_MD5_Update(MD5_CONTEXT *ctx,
+                OI_BYTE *buf,
+                OI_UINT16 len);
+
+
+void OI_MD5_Final(OI_BYTE *digest,
+               MD5_CONTEXT *ctx);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _MD5_HASH_H */
+
diff --git a/obex_profiles/include/oi_bytestream.h b/obex_profiles/include/oi_bytestream.h
new file mode 100644
index 0000000..4df440a
--- /dev/null
+++ b/obex_profiles/include/oi_bytestream.h
@@ -0,0 +1,1116 @@
+#ifndef _OI_BYTESTREAM_H
+#define _OI_BYTESTREAM_H
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * This file provides byte stream read and write macros.
+ *
+ *   Provides macros for reading and writing data to a
+ *   byte buffer. A byte stream can be opened for either reading or writing.
+ *
+ *   The size and the position for reading and writing to the byte
+ *   stream are maintained in an OI_BYTE_STREAM struct. This structure holds a
+ *   pointer to a byte buffer and the field mazSize is the allocated size of this
+ *   byte array.  The size field keeps track of how much data is currently in the
+ *   byte array. The pos field is used the by the Put and Get functions to keep
+ *   track of the where to read or write the next value.
+ *
+ * @code
+ *
+ *    -----------------------------------------------------------------------
+ *    |                                                 XXXXXXXXXXXXXXXXXXX |
+ *    -----------------------------------------------------------------------
+ *                 +                                   +                    +
+ *                 |                                   |                    |
+ *                POS                                 SIZE                MAXSIZE
+ *
+ *         current read/write position            data size            buffer size
+ *
+ *
+ * @endcode
+ *
+ *   Position is adjusted as data is read or written from the byte stream and can be
+ *   explicitly set using ByteStream_SetPos.
+ *
+ *   Size is set when the byte stream is initialized and can be explicitly set using
+ *   ByteStream_SetSize to truncate the data (for reading) or set a limit on the number
+ *   of bytes that can be written.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_memmgr.h"
+#include "oi_cpu_dep.h"
+#include "oi_endian.h"
+#include "oi_assert.h"
+
+/** \addtogroup Misc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** Data types to be used with ByteStream_Print and ByteStream_Parse. */
+enum {
+    TYPE_INT8,
+    TYPE_UINT8,
+    TYPE_INT16,
+    TYPE_UINT16,
+    TYPE_INT24,
+    TYPE_UINT24,
+    TYPE_INT32,
+    TYPE_UINT32,
+    TYPE_INT64,
+    TYPE_UINT64,
+    TYPE_DATA,
+    TYPE_BD_ADDR,
+    TYPE_UUID16,
+    TYPE_UUID32,
+    TYPE_UUID128,
+    TYPE_OBEX_UNICODE,
+    TYPE_IPV6_ADDR
+};
+
+/**
+ * When writing integer data to a byte stream you must specify if the data is to
+ * be written in little-endian (least significant bytes first) or big-endian (most significant bytes first)
+ * byte order. The Bluetooth specification indicates which order is required for
+ * each profile or protocol.
+ *
+ * The following constants are defined in cpu_def.h:
+ * @code
+ * OI_BIG_ENDIAN_BYTE_ORDER
+ * OI_LITTLE_ENDIAN_BYTE_ORDER
+ * OI_CPU_BYTE_ORDER
+ * @endcode
+ */
+
+#define NETWORK_BYTE_ORDER  OI_BIG_ENDIAN_BYTE_ORDER
+
+/** Indicates the byte stream being opened is to be read from. */
+#define BYTESTREAM_READ          1
+
+/** Indicates the byte stream being opened is to be written to. */
+#define BYTESTREAM_WRITE         2
+
+/** Indicates the byte stream being opened is locked. */
+#define BYTESTREAM_LOCKED        15
+
+/**
+ * This is the structure definition for a byte stream. The actual byte array must be
+ * allocated separately from the byte stream struct.
+ *
+ * The members of the bytestream are *PRIVATE* to this file, and must not be
+ * used, except as accessed through the Macros in this header file.
+ */
+typedef struct {
+    OI_BYTE *   __bsdata;      // Pointer to an array of bytes of size trueSize
+    OI_UINT16   __trueSize;  // Allocated size of data
+    OI_UINT16   __size;      // Current size of the data
+    OI_UINT16   __pos;       // Current read/write pointer
+    OI_UINT8    __RWFlag;    // Are we reading or writing to the byte stream
+    OI_UINT8    __error;     // Error reading or writing to byte stream
+} OI_BYTE_STREAM;
+
+
+/**
+ * Allocates a bytestream and the data buffer inside.
+ *
+ * @param size  the size in bytes of the data buffer to allocate
+ */
+OI_BYTE_STREAM *ByteStream_Alloc(OI_UINT16 size);
+
+
+/**
+ * Frees an allocated bytestream including the internal buffer.
+ *
+ * @param bs  The bytestream to free.
+ */
+void ByteStream_Free(OI_BYTE_STREAM *bs);
+
+
+#ifdef OI_DEBUG /* Only used by internal test programs */
+/**
+ * Prints to a bytestream using the specified format.
+ *
+ * @param bs         the byte stream to print
+ * @param byteorder  the byte order to use when printing
+ * @param format     string indicating the format for the byte stream
+ * @param formatLen  length of the byte stream format string
+ * @param ...        the arguments matching format
+ */
+OI_STATUS ByteStream_Print(OI_BYTE_STREAM * bs,
+                           OI_INT           byteorder,
+                           const OI_CHAR    format[],
+                           OI_UINT          formatLen,
+                           ...);
+#endif
+
+/**
+ * Parses a bytestream using the specified format.
+ *
+ * @param bs         the byte stream to parse
+ * @param byteorder  the byte order to use when parsing
+ * @param format     string indicating the format for the byte stream
+ * @param formatLen  length of the byte stream format string
+ * @param ...        the arguments matching format
+ */
+OI_STATUS ByteStream_Parse(OI_BYTE_STREAM * bs,
+                           OI_INT           byteorder,
+                           const OI_CHAR    format[],
+                           OI_UINT          formatLen,
+                           ...);
+
+/**
+ * Initializes a byte stream.
+ * Must be called before opening the stream.
+ *
+ * @param bs The byte stream to initialize
+ * @param buf The data buffer to use with the stream
+ * @param size The size of the data buffer
+ *
+ * void ByteStream_Init(OI_BYTE_STREAM  bs,
+ *                      OI_BYTE *       buf,
+ *                      OI_UINT16       size);
+ *
+ */
+
+#define ByteStream_Init(bs, buf, size) \
+do { \
+    OI_ASSERT((size) > 0); \
+    (bs).__error = 0; \
+    (bs).__bsdata = (buf); \
+    (bs).__trueSize = (size); \
+    (bs).__size = (size); \
+} while(0)
+
+
+
+/**
+ * Initializes a byte stream for reading or writing.
+ *
+ * Clears the byte stream if initializing for writing and sets size to trueSize.
+ * Size will be set to the correct size when the stream is closed.
+ *
+ * @param bs The byte stream to initialize
+ * @param rw Whether to read from or write to the byte stream.
+ *
+ * void ByteStream_Open(OI_BYTE_STREAM  bs,
+ *                      OI_UINT8        rw);
+ */
+
+#define ByteStream_Open(bs, rw) \
+do { \
+    OI_ASSERT(((bs).__bsdata != NULL) && ((bs).__trueSize > 0)); \
+    (bs).__pos = 0; \
+    (bs).__RWFlag = (rw); \
+    (bs).__size = (bs).__trueSize; \
+} while(0)
+
+/**
+ * Closes a byte stream.
+ *
+ * @param bs The byte stream to close.
+ *
+ * void ByteStream_Close(OI_BYTE_STREAM  bs);
+ */
+
+#define ByteStream_Close(bs) \
+do { \
+    if ((bs).__RWFlag == BYTESTREAM_WRITE)  { (bs).__size = (bs).__pos; } \
+    (bs).__RWFlag = BYTESTREAM_LOCKED; \
+} while(0)
+
+
+/**
+ * Skips the next n bytes in the byte stream.
+ *
+ * @param bs The byte stream in which to skip bytes
+ * @param count The number of bytes to skip
+ *
+ * void ByteStream_Skip(OI_BYTE_STREAM  bs,
+ *                      OI_UINT16       count);
+ */
+
+#define ByteStream_Skip(bs, count) \
+do { \
+    OI_ASSERT(((bs).__pos  + (count)) <= (bs).__size); \
+    (bs).__pos += (count); \
+} while(0)
+
+
+
+/**
+ * Skips the next n bytes in the byte stream, checking for validity
+ * of the operation.
+ *
+ * @param bs The byte stream in which to skip bytes
+ * @param count The number of bytes to skip
+ *
+ * void ByteStream_Skip_Checked(OI_BYTE_STREAM  bs,
+ *                              OI_UINT16       count);
+ */
+#define ByteStream_Skip_Checked(bs, count) \
+do { \
+    if (((bs).__pos  + (count)) <= (bs).__size) { \
+        (bs).__pos += (count); \
+     } else { \
+         (bs).__error = 1; \
+     } \
+} while(0)
+
+
+
+/**
+ * Advances to the next byte in the buffer.
+ *
+ * @param bs Buffer in which to advance
+ *
+ * void ByteStream_Next(OI_BYTE_STREAM  bs);
+ */
+#define ByteStream_Next(bs) \
+do { \
+    OI_ASSERT(((bs).__pos  + 1) <= (bs).__size); \
+    ++(bs).__pos; \
+} while(0)
+
+/**
+ * Sets the position in the byte stream.
+ *      (We want to make sure p isn't out of range. If p is 0, the compiler
+ *       warns that 0 <= {unsigned} is always true. Using a temporary fails
+ *       when release mode defines OI_ASSERT to nothing; the compiler warns of
+ *       an unused variable. Adding one to both sizes avoids both these traps.)
+ *
+ * @param bs The bytestream in which to set the position
+ * @param p The position to set
+ *
+ * void ByteStream_SetPos(OI_BYTE_STREAM    bs,
+ *                        OI_UINT16         pos);
+ */
+
+#define ByteStream_SetPos(bs, p) \
+do { \
+    OI_ASSERT((OI_INT)((p) + 1) <= (OI_INT)((bs).__size + 1)); \
+    (bs).__pos = (p); \
+} while(0)
+
+/**
+ * Gets the position in the byte stream.
+ *
+ * @param bs The bytestream in which to get the position
+ * @return The position
+ *
+ * OI_UINT16 ByteStream_GetPos(OI_BYTE_STREAM    bs);
+ */
+
+#define ByteStream_GetPos(bs) ((bs).__pos)
+
+/**
+ * Sets the size of the byte stream. The size must be less than or equal to the
+ * maximum size of the byte stream buffer and greater than or equal to the
+ * current read or write position.
+ *
+ * @param bs The byte stream whose size to set
+ * @param sz The size to which to set the byte stream
+ *
+ * void ByteStream_SetSize(OI_BYTE_STREAM   bs,
+ *                         OI_UINT16        sz);
+ */
+
+#define ByteStream_SetSize(bs, sz) \
+do { \
+    OI_ASSERT(((sz) <= (bs).__trueSize) && ((sz) >= (bs).__pos)); \
+    (bs).__size = (sz);                                           \
+} while(0)
+
+/**
+ * Gets the current size of the byte stream.
+ *
+ * @param bs The byte stream whose size to get
+ * @return The size of the byte stream
+ *
+ * OI_UINT16 ByteStream_GetSize(OI_BYTE_STREAM    bs);
+ */
+
+#define ByteStream_GetSize(bs) ((bs).__size)
+
+/**
+ * Gets the maximum size (buffer size) of the byte stream.
+ *
+ * @param bs The byte stream whose maximum size to get
+ * @return The maximum size of the byte stream
+ *
+ * OI_UINT16 ByteStream_GetMaxSize(OI_BYTE_STREAM   bs);
+ */
+#define ByteStream_GetMaxSize(bs) ((bs).__trueSize)
+
+
+
+/**
+ * Gets byte pointer to current position.
+ *
+ * @param bs The byte stream in which to get the byte pointer
+ * @return The pointer to current position
+ *
+ * OI_BYTE * ByteStream_GetCurrentBytePointer(OI_BYTE_STREAM   bs);
+ */
+#define ByteStream_GetCurrentBytePointer(bs) (OI_BYTE*)(&((bs).__bsdata[(bs).__pos]))
+
+
+/**
+ * Gets ByteStream data pointer
+ *
+ * @param bs The byte stream in which to get the byte pointer
+ * @return The pointer to start of stream data
+ *
+ * OI_BYTE * ByteStream_GetDataPointer(OI_BYTE_STREAM   bs);
+ */
+#define ByteStream_GetDataPointer(bs) (OI_BYTE*)((bs).__bsdata)
+
+
+/**
+ * Tests for a byte stream error.
+ *
+ * @param bs The byte stream to test for errors
+ * @return FALSE(0) if there were no errors
+ *
+ * OI_BOOL ByteStream_Error(OI_BYTE_STREAM   bs);
+ */
+#define ByteStream_Error(bs) ((bs).__error != 0)
+
+
+/**
+ * Forces a byte stream error.
+ *
+ * @param bs The byte stream for which to force an error
+ *
+ * void ByteStream_SetError(OI_BYTE_STREAM   bs);
+ */
+#define ByteStream_SetError(bs) {((bs).__error) = 1;}
+
+
+/**
+ * Clears a byte stream error.
+ *
+ * @param bs The byte stream for which to clear an error
+ *
+ * void ByteStream_ClearError(OI_BYTE_STREAM   bs);
+ */
+#define ByteStream_ClearError(bs) {((bs).__error) = 0;}
+
+
+/*******************************************************************
+ * Byte stream read functions
+ ******************************************************************/
+
+/**
+ * Finds how many bytes are still available for reading.
+ *
+ * @code
+ * Example:
+ *   var = ByteStream_NumReadBytesAvail(bs);
+ * @endcode
+ *
+ * @param bs The byte stream to check
+ * @return The number of bytes still available for reading
+ *
+ * OI_UINT16 ByteStream_NumReadBytesAvail(OI_BYTE_STREAM   bs);
+ */
+#define ByteStream_NumReadBytesAvail(bs) ((bs).__size - (bs).__pos)
+
+
+/**
+ * Extracts N bits from current byte stream starting at bit B.
+ *
+ * @param bs The byte stream from which to extract bits
+ * @param i [out] The bits extracted
+ * @param B The bit at which to start extraction
+ * @param N The number of bits to extract
+ *
+ * void ByteStream_Extract(OI_BYTE_STREAM   bs,
+ *                         OI_BYTE          i,
+ *                         OI_BYTE          B,
+ *                         OI_BYTE          N);
+ */
+
+#define ByteStream_Extract(bs, i, B, N) \
+do { \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT(((B) + (N)) <= 8); \
+    (i) = (OI_BYTE) (((bs).__bsdata[(bs).__pos] >> (B)) & (0xFF >> (8 - (N)))); \
+} while(0)
+
+
+/**
+ * Gets N bytes from a byte stream.
+ *
+ * @param bs The byte stream from which to get the bytes
+ * @param bytes [out] The bytes obtained
+ * @param N Number of bytes to obtain
+ *
+ * void ByteStream_GetBytes(OI_BYTE_STREAM  bs,
+ *                          void *          bytes,
+ *                          OI_UINT16       N);
+ */
+#define ByteStream_GetBytes(bs, bytes, N) \
+do { \
+    OI_BYTE *__p = (OI_BYTE*) (bytes);                      \
+    OI_BYTE *__q = (OI_BYTE*) ((bs).__bsdata + (bs).__pos); \
+    OI_BYTE * const __e = __p + (N); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT(((bs).__pos + (N)) <= (bs).__size); \
+    while (__p < __e) { *__p++ = *__q++; } \
+    (bs).__pos += N; \
+} while(0)
+
+
+/**
+ * Gets N bytes from a byte stream, checking them for validity.
+ *
+ * @param bs The byte stream from which to get the bytes
+ * @param bytes [out] The bytes obtained
+ * @param N Number of bytes to obtain
+ *
+ * void ByteStream_GetBytes_Checked(OI_BYTE_STREAM  bs,
+ *                                  void *          bytes,
+ *                                  OI_UINT16       N);
+ */
+#define ByteStream_GetBytes_Checked(bs, bytes, N) \
+do { \
+    OI_BYTE *__p = (OI_BYTE*) (bytes);                      \
+    OI_BYTE *__q = (OI_BYTE*) ((bs).__bsdata + (bs).__pos); \
+    OI_BYTE * const __e = __p + (N); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    if (((bs).__pos + (N)) <= (bs).__size) { \
+        while (__p < __e) { *__p++ = *__q++; } \
+        (bs).__pos += N; \
+    } else { \
+        (bs).__error = 1; \
+    } \
+} while(0)
+
+
+/**
+ * Gets an object from a byte stream.
+ *
+ * @param bs The byte stream from which to get the object
+ * @param val [out] The object obtained
+ */
+#define ByteStream_GetObject(bs, val) \
+   ByteStream_GetBytes((bs), ((OI_BYTE*) &(val)), sizeof(val))
+
+/**
+ * Gets an object from a byte stream, checking it for validity.
+ *
+ * @param bs The byte stream from which to get the object
+ * @param val [out] The object obtained
+ */
+#define ByteStream_GetObject_Checked(bs, val) \
+   ByteStream_GetBytes_Checked((bs), ((OI_BYTE*) &(val)), sizeof(val))
+
+
+
+#define ByteStream_GetINT8 ByteStream_GetUINT8
+#define ByteStream_GetBYTE ByteStream_GetUINT8
+
+/**
+ * Reads 8 bits from a byte stream.
+ *
+ * @param bs The byte stream from which to read the UINT8
+ * @param i [out] The integer obtained
+ * @param t The type of the value
+ *
+ * @code
+ * void ByteStream_GetTyped8(OI_BYTE_STREAM   bs,
+ *                           OI_BYTE          i,
+ *                           <type>           t);
+ * @endcode
+ */
+
+#define ByteStream_GetTyped8(bs, i, t) \
+do { \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT(((bs).__pos + 1) <= (bs).__size); \
+    (i) = (t) (bs).__bsdata[(bs).__pos++]; \
+} while(0)
+
+/**
+ * Reads an unsigned 8-bit integer from a byte stream.
+ *
+ * @param bs The byte stream from which to read the UINT8
+ * @param i [out] The integer obtained
+ *
+ * void ByteStream_GetUINT8(OI_BYTE_STREAM   bs,
+ *                          OI_BYTE          i);
+ */
+
+#define ByteStream_GetUINT8(bs, i) ByteStream_GetTyped8(bs, i, OI_UINT8)
+
+
+
+#define ByteStream_GetINT8_Checked ByteStream_GetUINT8_Checked
+#define ByteStream_GetBYTE_Checked ByteStream_GetUINT8_Checked
+
+/**
+ * Reads 8 bits from a byte stream, checking it for validity.
+ *
+ * @param bs The byte stream from which to read the integer
+ * @param i [out] The integer obtained
+ * @param t The type of the value
+ *
+ * @code
+ * void ByteStream_GetTyped8_Checked(OI_BYTE_STREAM   bs,
+ *                                   OI_BYTE          i,
+ *                                   <type>           t);
+ * @endcode
+ */
+#define ByteStream_GetTyped8_Checked(bs, i, t) \
+do { \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    if (((bs).__pos + 1) <= (bs).__size) { \
+        (i) = (t) (bs).__bsdata[(bs).__pos++]; \
+    } else { \
+        (bs).__error = 1; \
+    } \
+} while(0)
+
+/**
+ * Reads an unsigned 8-bit integer from a byte stream, checking it for validity.
+ *
+ * @param bs The byte stream from which to read the integer
+ * @param i [out] The integer obtained
+ *
+ * void ByteStream_GetUINT8_Checked(OI_BYTE_STREAM   bs,
+ *                                  OI_BYTE          i);
+ */
+#define ByteStream_GetUINT8_Checked(bs, i)  ByteStream_GetTyped8_Checked(bs, i, OI_UINT8)
+
+
+
+#define ByteStream_GetINT16 ByteStream_GetUINT16
+
+/*
+ * Reads a 16-bit integer from a byte stream, specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream
+ * @param i [out] The integer obtained
+ * @param bo Byte order (endianness) of the stream
+ *
+ * void ByteStream_GetUINT16(OI_BYTE_STREAM   bs,
+ *                           OI_UINT16        i,
+ *                           OI_UINT8         bo);
+ */
+#define ByteStream_GetUINT16(bs, i, bo) \
+do { \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(((bs).__pos + 2) <= (bs).__size); \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+        (i) = GetUINT16_BigEndian((bs).__bsdata + (bs).__pos); \
+    } else { \
+        (i) = GetUINT16_LittleEndian((bs).__bsdata + (bs).__pos); \
+    } \
+    (bs).__pos += 2; \
+} while(0)
+
+
+#define ByteStream_GetINT16_Checked ByteStream_GetUINT16_Checked
+
+
+/*
+ * Reads an 16-bit integer from a byte stream, checking it for validity and
+ * specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream from which to get the integer
+ * @param i [out] The integer obtained
+ * @param bo Byte order (endianness) of the stream
+ *
+ * void ByteStream_GetUINT16_Checked(OI_BYTE_STREAM   bs,
+ *                                   OI_UINT16        i,
+ *                                   OI_UINT8         bo);
+ */
+#define ByteStream_GetUINT16_Checked(bs, i, bo) \
+do { \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    if (((bs).__pos + 2) <= (bs).__size) { \
+        if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+            (i) = GetUINT16_BigEndian((bs).__bsdata + (bs).__pos); \
+        } else { \
+            (i) = GetUINT16_LittleEndian((bs).__bsdata + (bs).__pos); \
+        } \
+        (bs).__pos += 2; \
+    } else { \
+        (bs).__error = 1; \
+    } \
+} while(0)
+
+
+
+
+#define ByteStream_GetINT24 ByteStream_GetUINT24
+
+/**
+ * Reads a 24-bit integer from a byte stream, specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream from which to get the integer
+ * @param i [out] The integer obtained
+ * @param bo Byte order (endianness) of the stream
+ *
+ * void ByteStream_GetUINT24(OI_BYTE_STREAM   bs,
+ *                           OI_UINT32        i,
+ *                           OI_UINT8         bo);
+ */
+#define ByteStream_GetUINT24(bs, i, bo) \
+do { \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(((bs).__pos + 3) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT(sizeof(i) >= 3); \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+        (i) = GetUINT24_BigEndian((bs).__bsdata + (bs).__pos); \
+    } else { \
+        (i) = GetUINT24_LittleEndian((bs).__bsdata + (bs).__pos); \
+    } \
+    (bs).__pos += 3; \
+} while(0)
+
+
+
+#define ByteStream_GetINT24_Checked ByteStream_GetUINT24
+
+/**
+ * Reads a 24-bit integer from a byte stream, checking it for validity, and
+ * specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream from which to get the integer
+ * @param i [out] The integer obtained
+ * @param bo Byte order (endianness) of the stream
+ *
+ * void ByteStream_GetUINT24_Checked(OI_BYTE_STREAM   bs,
+ *                                   OI_UINT32        i,
+ *                                   OI_UINT8         bo);
+ */
+#define ByteStream_GetUINT24_Checked(bs, i, bo) \
+do { \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(sizeof(i) >= 3); \
+    if (((bs).__pos + 3) <= (bs).__size) { \
+        if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+            (i) = GetUINT24_BigEndian((bs).__bsdata + (bs).__pos); \
+        } else { \
+            (i) = GetUINT24_LittleEndian((bs).__bsdata + (bs).__pos); \
+        } \
+        (bs).__pos += 3; \
+    } else { \
+        (bs).__error = 1; \
+    } \
+} while(0)
+
+
+
+#define ByteStream_GetINT32 ByteStream_GetUINT32
+
+/**
+ * Reads a 32-bit integer from a byte stream, specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream from which to get the integer
+ * @param i [out] The integer obtained
+ * @param bo Byte order (endianness) of the stream
+ *
+ * void ByteStream_GetUINT32(OI_BYTE_STREAM   bs,
+ *                           OI_UINT32        i,
+ *                           OI_UINT8         bo);
+ */
+#define ByteStream_GetUINT32(bs, i, bo) \
+do { \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(((bs).__pos + 4) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+        (i) = GetUINT32_BigEndian((bs).__bsdata + (bs).__pos); \
+    } else { \
+        (i) = GetUINT32_LittleEndian((bs).__bsdata + (bs).__pos); \
+    } \
+    (bs).__pos += 4; \
+} while(0)
+
+
+#define ByteStream_GetINT32_Checked ByteStream_GetUINT32
+
+/**
+ * Reads a 32-bit integer from a byte stream, checking it for validity, and
+ * specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream from which to get the integer
+ * @param i [out] The integer obtained
+ * @param bo Byte order (endianness) of the stream
+ *
+ * void ByteStream_GetUINT32_Checked(OI_BYTE_STREAM   bs,
+ *                                   OI_UINT32        i,
+ *                                   OI_UINT8         bo);
+ */
+#define ByteStream_GetUINT32_Checked(bs, i, bo) \
+do { \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    if (((bs).__pos + 4) <= (bs).__size) { \
+        if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+            (i) = GetUINT32_BigEndian((bs).__bsdata + (bs).__pos); \
+        } else { \
+            (i) = GetUINT32_LittleEndian((bs).__bsdata + (bs).__pos); \
+        } \
+        (bs).__pos += 4; \
+    } else { \
+        (bs).__error = 1; \
+    } \
+} while(0)
+
+
+
+/**
+ * Reads a Bluetooth address from a byte stream,
+ * specifying whether the byte order in the stream is big- or little-endian.
+
+@code
+        ByteStream_GetBDADDR(
+            OI_BYTE_STREAM  bs,
+            OI_BD_ADDR      ba,
+            BYTE_ORDER);
+@endcode
+
+ * @param bs The byte stream from which to read the Bluetooth address
+ * @param ba [out] The Bluetooth address
+ * @param bo Byte order (endianness) of the stream
+ */
+#define ByteStream_GetBDADDR(bs, ba, bo) \
+do { \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(((bs).__pos + OI_BD_ADDR_BYTE_SIZE) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+        GetBDADDR_BigEndian((ba).addr, &((bs).__bsdata[(bs).__pos]));\
+    } else { \
+        GetBDADDR_LittleEndian((ba).addr, &((bs).__bsdata[(bs).__pos]));\
+    } \
+    (bs).__pos += OI_BD_ADDR_BYTE_SIZE; \
+} while(0)
+
+/**
+ * Reads a Bluetooth address from a byte stream, checking it for validity,
+ * and specifying whether the byte order in the stream is big- or little-endian.
+
+@code
+        ByteStream_GetBDADDR_Checked(
+            OI_BYTE_STREAM  bs,
+            OI_BD_ADDR      ba,
+            BYTE_ORDER);
+@endcode
+
+ * @param bs The byte stream from which to read the Bluetooth address
+ * @param ba [out] The Bluetooth address
+ * @param bo Byte order (endianness) of the stream
+ */
+#define ByteStream_GetBDADDR_Checked(bs, ba, bo) \
+do { \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ); \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    if (((bs).__pos + OI_BD_ADDR_BYTE_SIZE) <= (bs).__size) { \
+        if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+            GetBDADDR_BigEndian((ba).addr, &((bs).__bsdata[(bs).__pos]));\
+        } else { \
+            GetBDADDR_LittleEndian((ba).addr, &((bs).__bsdata[(bs).__pos]));\
+        } \
+        (bs).__pos += OI_BD_ADDR_BYTE_SIZE; \
+    } else { \
+        (bs).__error = 1; \
+    } \
+} while(0)
+
+
+/**********************************************************************
+ * Byte stream write functions
+ **********************************************************************/
+
+/**
+ * Finds how many bytes can still be written.
+ *
+@code
+ * Example:
+ *   var = ByteStream_NumWriteBytesAllowed(bs);
+@endcode
+ *
+ * @param bs The byte stream to write to
+ * @return The number of bytes that can still be written
+ *
+ * OI_UINT16 ByteStream_NumWriteBytesAllowed(OI_BYTE_STREAM   bs);
+ */
+#define ByteStream_NumWriteBytesAllowed(bs) ((bs).__size - (bs).__pos)
+
+
+/**
+ * Inserts N bits into current byte stream starting at bit B.
+ *
+ * @param bs The byte stream into which the bits should be inserted
+ * @param i The bits to insert
+ * @param B The position of the bit in the byte stream starting at which the bits should be inserted
+ * @param N The number of bits to insert
+ *
+ * void ByteStream_Insert(OI_BYTE_STREAM   bs,
+ *                        OI_BYTE          i
+ *                        OI_UINT8         B
+ *                        OI_UINT8         N);
+ */
+#define ByteStream_Insert(bs, i, B, N) \
+do { \
+    OI_ASSERT(((B) + (N)) <= 8); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_WRITE); \
+    (bs).__bsdata[(bs).__pos] |= ((i) & (0xFF >> (8 - (N)))) << (B); \
+} while(0)
+
+
+
+/**
+ * Appends N bytes to a byte stream.
+ *
+ * @param bs The byte stream to which the bytes should be appended
+ * @param bytes The bytes to insert into the byte stream
+ * @param N The number of bytes to insert
+ *
+ * void ByteStream_PutBytes(OI_BYTE_STREAM   bs,
+ *                          OI_BYTE *        bytes
+ *                          OI_UINT16        N);
+ */
+#define ByteStream_PutBytes(bs, bytes, N) \
+do { \
+    OI_BYTE *__p = (OI_BYTE*) ((bs).__bsdata + (bs).__pos); \
+    OI_BYTE *__q = (OI_BYTE*) (bytes); \
+    OI_BYTE * const __e = __p + (N); \
+    OI_ASSERT(((bs).__pos + (N) ) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_WRITE); \
+    while (__p < __e) { *__p++ = *__q++; }        \
+    (bs).__pos += N; \
+} while(0)
+
+/**
+ * Copies N bytes from one byte stream to another.
+ *
+ * @param dst_bs The destination byte stream
+ * @param src_bs The source byte stream
+ * @param N The number of bytes to copy
+ *
+ * void ByteStream_Copy(OI_BYTE_STREAM   dst_bs,
+ *                      OI_BYTE_STREAM   src_bs,
+ *                      OI_UINT16        N);
+ */
+#define ByteStream_Copy(dst_bs, src_bs, N) \
+do { \
+    OI_BYTE *__d = (OI_BYTE*) ((dst_bs).__bsdata + (dst_bs).__pos); \
+    OI_BYTE *__s = (OI_BYTE*) ((src_bs).__bsdata + (src_bs).__pos); \
+    OI_BYTE * const __e = __s + (N); \
+    OI_ASSERT(ByteStream_NumReadBytesAvail(src_bs) >= (N)); \
+    OI_ASSERT(ByteStream_NumWriteBytesAllowed(dst_bs) >= (N)); \
+    OI_ASSERT((dst_bs).__RWFlag == BYTESTREAM_WRITE); \
+    OI_ASSERT((src_bs).__RWFlag == BYTESTREAM_READ); \
+    while (__s < __e) { *__d++ = *__s++; } \
+    (src_bs).__pos += N; \
+    (dst_bs).__pos += N; \
+} while(0)
+
+
+
+/**
+ * Appends an object to a byte stream.
+ *
+ * @param bs The byte stream to which to append the object
+ * @param val The object to append
+ */
+#define ByteStream_PutObject(bs, val) \
+   ByteStream_PutBytes((bs), ((OI_BYTE*) &(val)), sizeof(val))
+
+
+
+
+#define ByteStream_PutINT8 ByteStream_PutUINT8
+#define ByteStream_PutBYTE ByteStream_PutUINT8
+
+/**
+ * Writes an unsigned 8-bit integer to a byte stream.
+ *
+ * @param bs The byte stream to which to write the integer
+ * @param i The integer to write to the byte stream
+ *
+ * void ByteStream_PutUINT8(OI_BYTE_STREAM   bs,
+ *                          OI_UINT8         i);
+ */
+#define ByteStream_PutUINT8(bs, i) \
+{ \
+    OI_ASSERT(((bs).__pos + 1) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_WRITE); \
+    (bs).__bsdata[(bs).__pos++] = (OI_BYTE) (i); \
+}
+
+
+
+#define ByteStream_PutINT16 ByteStream_PutUINT16
+
+/**
+ * Writes a 16-bit integer to a byte stream, specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream to which to write the integer
+ * @param i The integer to write to the byte stream
+ * @param bo The byte order (endianness) of the stream
+ *
+ * void ByteStream_PutUINT16(OI_BYTE_STREAM   bs,
+ *                           OI_UINT16        i,
+ *                           OI_UINT8         bo);
+ */
+#define ByteStream_PutUINT16(bs, i, bo) \
+{ \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(((bs).__pos + 2) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_WRITE); \
+    OI_ASSERT(sizeof(i) >= 2); \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+        SetUINT16_BigEndian((bs).__bsdata + (bs).__pos, (i)); \
+    } else { \
+        SetUINT16_LittleEndian((bs).__bsdata + (bs).__pos, (i)); \
+    } \
+    (bs).__pos += sizeof(OI_UINT16); \
+}
+
+
+#define ByteStream_PutINT24 ByteStream_PutUINT24
+
+/**
+ * Writes a 24-bit integer to a byte stream, specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream to which to write the integer
+ * @param i The integer to write to the byte stream
+ * @param bo The byte order (endianness) of the stream
+ *
+ * void ByteStream_PutUINT24(OI_BYTE_STREAM   bs,
+ *                           OI_UINT32        i,
+ *                           OI_UINT8         bo);
+ */
+#define ByteStream_PutUINT24(bs, i, bo) \
+{ \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(((bs).__pos + 3) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_WRITE); \
+    OI_ASSERT(sizeof(i) >= 3); \
+    OI_ASSERT(0 == ((i) & 0xFF000000)); \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+        SetUINT24_BigEndian((bs).__bsdata + (bs).__pos, (i)); \
+    } else { \
+        SetUINT24_LittleEndian((bs).__bsdata + (bs).__pos, (i)); \
+    } \
+    (bs).__pos += 3; \
+}
+
+
+#define ByteStream_PutINT32 ByteStream_PutUINT32
+
+/**
+ * Writes a 32-bit integer to a byte stream, specifying whether the byte
+ * order in the stream is big- or little-endian.
+ *
+ * @param bs The byte stream to which to write the integer
+ * @param i The integer to write to the byte stream
+ * @param bo The byte order (endianness) of the stream
+ *
+ * void ByteStream_PutUINT32(OI_BYTE_STREAM   bs,
+ *                           OI_UINT32        i,
+ *                           OI_UINT8         bo);
+ */
+#define ByteStream_PutUINT32(bs, i, bo) \
+{ \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(((bs).__pos + 4) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_WRITE); \
+    OI_ASSERT(sizeof(i) >= 4); \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+        SetUINT32_BigEndian((bs).__bsdata + (bs).__pos, (i)); \
+    } else { \
+        SetUINT32_LittleEndian((bs).__bsdata + (bs).__pos, (i)); \
+    } \
+    (bs).__pos += sizeof(OI_UINT32); \
+}
+
+/**
+ * Writes a Bluetooth address to a byte stream, specifying whether the byte
+ * order in the stream is big- or little-endian.
+
+@code
+        ByteStream_PutBDADDR(OI_BYTE_STREAM  bs,
+                             OI_BD_ADDR      ba,
+                             OI_UINT8        bo);
+@endcode
+
+ *
+ * @param bs The byte stream to which to write the Bluetooth address
+ * @param ba The Bluetooth address to write to the byte stream
+ * @param bo The byte order (endianness) of the stream
+ */
+#define ByteStream_PutBDADDR(bs, ba, bo) \
+{ \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) ); \
+    OI_ASSERT(((bs).__pos + OI_BD_ADDR_BYTE_SIZE) <= (bs).__size); \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_WRITE); \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) { \
+        SetBDADDR_BigEndian(&((bs).__bsdata[(bs).__pos]), (ba).addr);\
+    } else { \
+        SetBDADDR_LittleEndian(&((bs).__bsdata[(bs).__pos]), (ba).addr);\
+    } \
+    (bs).__pos += OI_BD_ADDR_BYTE_SIZE; \
+}
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_BYTESTREAM_H */
+
diff --git a/obex_profiles/include/oi_core_common.h b/obex_profiles/include/oi_core_common.h
new file mode 100644
index 0000000..17c22b7
--- /dev/null
+++ b/obex_profiles/include/oi_core_common.h
@@ -0,0 +1,53 @@
+#ifndef _CORE_COMMON_H
+#define _CORE_COMMON_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * Ths header file is provided as a convenience for grouping together many common header
+ * files used by profiles and applications.
+*/
+
+//support
+#include "oi_stddefs.h"
+#include "oi_memmgr.h"
+#include "oi_debug.h"
+#include "oi_assert.h"
+#include "oi_endian.h"
+#include "oi_osinterface.h"
+#include "oi_time.h"
+#include "oi_text.h"
+
+//utils
+#include "oi_std_utils.h"
+
+#include "oi_bt_assigned_nos.h"
+
+#endif /* _CORE_COMMON_H */
diff --git a/obex_profiles/include/oi_dataelem_text.h b/obex_profiles/include/oi_dataelem_text.h
new file mode 100644
index 0000000..9b1cd8b
--- /dev/null
+++ b/obex_profiles/include/oi_dataelem_text.h
@@ -0,0 +1,70 @@
+#ifndef _OI_DATAELEM_TEXT_H
+#define _OI_DATAELEM_TEXT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * This file includes functions for fatal error handling, printing, and getting
+ * a time value. This file is targeted to the Linux operating system.
+ *
+ * These functions are defined in oi_osinterface.h.
+ *
+ * This header file provides the OI_DataElement_Print() function.
+ */
+
+#include "oi_dataelem.h"
+#include "oi_varstring.h"
+
+/** \addtogroup Marshaller_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+void OI_DataElement_XML(OI_VARSTRING *VStr,
+                        OI_DATAELEM const *Element,
+                        OI_UINT8 Indent);
+
+
+
+void OI_DataElement_Print(OI_DATAELEM *Element);
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_DATAELEM_TEXT_H */
+
diff --git a/obex_profiles/include/oi_dispatch.h b/obex_profiles/include/oi_dispatch.h
new file mode 100644
index 0000000..283aeaa
--- /dev/null
+++ b/obex_profiles/include/oi_dispatch.h
@@ -0,0 +1,299 @@
+#ifndef _DISPATCH_H
+#define _DISPATCH_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * This header file provides the interface with the CThru Dispatcher, the
+ * scheduler for callback functions.
+ *
+ * The aynschronous CThru  architecture of the core BLUEmagic 3.0 stack
+ * ensures that no API call into the core stack will ever block. All calls into
+ * the stack take the form of a request for some action to be performed and pass
+ * in a callback function that is called when the action completes. The
+ * CThru Dispatcher's job is to invoke the callback functions at the appropriate time.
+ *
+ * Depending on the host platform the Dispatcher may be called periodically from
+ * a worker thread or, in a single-threaded environment, the Dispatcher may be called
+ * explicitly by an application.
+ *
+ * Callback functions may be registered with the Dispatcher to be called
+ * immediately or to be called at some future time. The Dispatcher deregisters
+ * callback functions immediately after calling them. Callback functions that
+ * re-register themselves will not be called again until the Dispatcher is
+ * called again.
+ *
+ * The Dispatcher returns a callback handle, a 32-bit value that uniquely
+ * identifies the callback registration. This handle can be used later to cancel
+ * the callback or to inquire if the callback has been called.
+ *
+ * For more information see @ref dispatch_docpage.
+ */
+
+#include "oi_common.h"
+#include "oi_time.h"
+
+/** \addtogroup Dispatcher_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * struct for describing an argument block used when registering a callback
+ * function with the Dispatcher and later when the callback function is called
+ * by the Dispatcher
+ */
+
+typedef struct {
+    OI_INT16 size;     /**< Size of the argument block */
+    const void *data;  /**< Pointer to the argument block */
+} DISPATCH_ARG;
+
+
+/* Two of the dispatcher functions have had their prototypes moved to the SDK header
+    file oi_bt_stack_init.h because they need to be visible to applications.  We don't want this
+    file visible because we don't applications calling any other dispatcher functions.
+
+*/
+
+/**
+ * convenience macro to set a value in a DISPATCH_ARG struct.
+ *
+ * @param arg is a DISPATCH_ARG argument block
+ *
+ * @param val is the value to set in the argument block
+ */
+
+#define Dispatch_SetArg(arg, val) { (arg).data = &(val); (arg).size = sizeof(val); }
+
+
+/**
+ * convenience macro to get a value from a pointer to an arg struct given a
+ * type
+ *
+ * @param argp is a pointer to a DISPATCH_ARG argument block.
+ *
+ * @param type is the target type into which to cast the data block
+ */
+
+#define Dispatch_GetArg(argp, type) *((type*) (argp)->data)
+
+/**
+ * convenience macro to get a pointer value from a pointer to an arg struct given a
+ * type
+ *
+ * @param argp is a pointer to a DISPATCH_ARG argument block.
+ *
+ * @param type is the target type into which to cast the data block
+ */
+
+#define Dispatch_GetPointerFromArg(argp, type) ((type*) (argp)->data)
+
+/**
+ * This is a unique identifier returned by OI_Dispatch_RegisterFunc() and
+ * OI_Dispatch_RegisterTimedFunc() that can be used to cancel a callback, test if a
+ * callback function has been called, or change the timeout interval on a timed callback.
+ */
+
+typedef OI_UINT32 DISPATCH_CB_HANDLE;
+
+
+/**
+ * typedef for function profiles for callback functions registered and called
+ * by the Dispatcher
+ */
+
+typedef void (*DISPATCH_CB_FUNC)(DISPATCH_ARG *arg);
+
+
+/**
+ * This function registers a callback function with the Dispatcher. The Dispatcher makes a
+ * copy of the argument data, so the caller can free memory allocated for the
+ * arguments after registering the callback.
+ *
+ * @param CBFunction is the callback function that will be called the next time
+ * OI_Dispatch_Run() is called by the application.
+ *
+ * @param args is a pointer to the arguments structure that will be passed to
+ * the callback function when it is called.
+ *
+ * @param CBHandle (OUT) If this input parameter is not NULL, the value  pointed to by the pointer
+ * CBHandle will be assigned a unique 32-bit identifier handle that the caller can later use to
+ * cancel the registration; if the input value of CBHandle is NULL, no callback handle is assigned.
+ *
+ * @return an error status if the Dispatcher has insufficient resources to
+ * register the new callback function.
+ */
+
+OI_STATUS OI_Dispatch_RegisterFunc(DISPATCH_CB_FUNC    CBFunction,
+                                   DISPATCH_ARG        *args,
+                                   DISPATCH_CB_HANDLE  *CBHandle);
+
+
+/**
+ * This function registers a timed callback function with the Dispatcher. The
+ * Dispatcher will make a copy of the argument data, so the caller is expected
+ * to free any memory allocated for the arguments after registering the callback.
+ *
+ * The Dispatcher checks the timeout value of each timed callback function
+ * whenever OI_Dispatch_Run() is called. Timer callbacks with expired timeouts are
+ * called in the same way as those registered by calling OI_Dispatch_RegisterFunc().
+ *
+ * @param CBFunction is the callback function that will be called the next time
+ * OI_Dispatch_Run() is called by the application after the timeout interval has expired.
+ *
+ * @param args is a pointer to the arguments structure that will be passed to
+ * the callback function when it is called.
+ *
+ * @param timeout is a timeout interval specified in tenths of a second. A timeout value
+ * of zero means zero time - the effect is the same as calling OI_Dispatch_RegisterFunc().
+ * Timeouts may be in the range 0 - OI_MAX_INTERVAL intervals (max timeout 54 min 36.7 sec).
+ *
+ * @param CBHandle (OUT) If this input parameter is not NULL, the value  pointed to by the pointer
+ * CBHandle  will be assigned a unique 32-bit identifier handle that the caller can
+ * later use to cancel the registration or to change to timeout value by calling
+ * OI_Dispatch_SetFuncTimeout(); if the input value of CBHandle is NULL, no callback handle is assigned.
+ *
+ * @return an error status if the Dispatcher has insufficient resources to
+ * register the new callback function.
+ */
+
+OI_STATUS OI_Dispatch_RegisterTimedFunc(DISPATCH_CB_FUNC    CBFunction,
+                                        DISPATCH_ARG        *args,
+                                        OI_INTERVAL         timeout,
+                                        DISPATCH_CB_HANDLE  *CBHandle);
+
+/**
+ * Checks that the callback handle is valid and, if so, updates the timeout value
+ * on the callback function. The new timeout value replaces the previous timeout
+ * value.
+ *
+ * @param CBHandle is a handle to a previously registered callback function.
+ *
+ * @param timeout is a timeout interval specified in tenths of a second.
+ * Setting the timeout interval to zero results in the function being called the
+ * next time the Dispatcher runs.
+ *
+ * @note A timeout can be set on any registered callback whether the callback was
+ * originally registered as a timed function or not.
+ *
+ * @return an error status if CBHandle is invalid.
+ */
+
+OI_STATUS OI_Dispatch_SetFuncTimeout(DISPATCH_CB_HANDLE CBHandle,
+                                     OI_INTERVAL        timeout);
+
+
+/**
+ * This function suspends a callback function by marking it as not callable. A callback is
+ * un-suspened by calling OI_Dispatch_SetFuncTimeout() or OI_Dispatch_CancelFunc() or
+ * OI_Dispatch_CallFunc().
+ *
+ * @param CBHandle This callback handle parameter identifies which callback
+ *                 function is to be suspended.
+ *
+ * @return The OI_OK status code is returned if the callback function was
+ *         successsfully suspended.  An error status code is returned if the
+ *         callback handle does not identify a currently registered callback
+ *         function.
+ */
+
+OI_STATUS OI_Dispatch_SuspendFunc(DISPATCH_CB_HANDLE CBHandle);
+
+
+/**
+ * This function de-registers a callback function and deletes any memory
+ * allocated for the callback function's arguments.
+ *
+ * @param CBHandle This callback handle parameter identifies which callback
+ *                 function is to be deregistered.
+ *
+ * @return The OI_OK status code is returned if the callback function was
+ *         successsfully canceled.  An error status code is returned if the
+ *         callback handle does not identify a currently registered callback
+ *         function.
+ */
+
+OI_STATUS OI_Dispatch_CancelFunc(DISPATCH_CB_HANDLE CBHandle);
+
+
+/**
+ * This function removes a callback function from the dispatcher and calls it
+ * immediately on the caller's thread. After this call the handle will no
+ * longer be valid.
+ *
+ * @param CBHandle This callback handle parameter identifies which callback
+ *                 function is to be called.
+ *
+ * @return The OI_OK status code is returned if the callback function was
+ *         successsfully called.  An error status code is returned if the
+ *         callback handle does not identify a currently registered callback
+ *         function.
+ */
+
+OI_STATUS OI_Dispatch_CallFunc(DISPATCH_CB_HANDLE CBHandle);
+
+/**
+ * This function checks whether a callback handle is valid. A callback handle is only valid
+ * if it corresponds to a registered callback function that has not been called.
+ *
+ * @param CBHandle is a handle to a previously registered callback function.
+ *
+ * @return a boolean value that indicates whether the callback associated with a
+ * callback handle is currently registered with the Dispatcher.
+ */
+
+OI_BOOL OI_Dispatch_IsValidHandle(DISPATCH_CB_HANDLE CBHandle);
+
+/*
+ * OI_Dispatch_Immediate_Run
+ *
+ * Calls and clears all callback functions that were dispatched with a timeout
+ * of Zero. This allows the HCI layer to verify that all processing associated
+ * with an incoming HCI packet has been handled prior to handling any new
+ * Baseband or Application level events.
+ */
+
+void OI_Dispatch_Immediate_Run(void);
+
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _DISPATCH_H */
+
diff --git a/obex_profiles/include/oi_fcs.h b/obex_profiles/include/oi_fcs.h
new file mode 100644
index 0000000..0ca8667
--- /dev/null
+++ b/obex_profiles/include/oi_fcs.h
@@ -0,0 +1,56 @@
+#ifndef _OI_FCS_H
+#define _OI_FCS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * Compute CRC-16
+ */
+
+#include "oi_common.h"
+
+/**
+ * Compute the Frame Check Sequence over the data in a buffer. The FCS operation is commonally know
+ * as CRC-16 and is used principally for L2CAP enhanced modes.
+ *
+ * @param buffer      Pointer to the buffer
+ *
+ * @param bufLen      Length of the buffer
+ *
+ * @patam runningFCS  Pointer to variable holding the running FCS. Initialize to zero to start
+ *                    computing the FCS.
+ *
+ */
+void OI_FCS_Compute(const OI_BYTE *buffer,
+                    OI_UINT16 bufLen,
+                    OI_UINT16 *runningFCS);
+
+
+#endif /* _OI_FCS_H */
diff --git a/obex_profiles/include/oi_fifobufq.h b/obex_profiles/include/oi_fifobufq.h
new file mode 100644
index 0000000..741a45a
--- /dev/null
+++ b/obex_profiles/include/oi_fifobufq.h
@@ -0,0 +1,201 @@
+#ifndef _OI_FIFO_BUF_Q_H
+#define _OI_FIFO_BUF_Q_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *FIFO buffer utility
+ *
+ * This utility provides a FIFO queue for arbitrary-length data buffers.
+ *        - OI_Fifobuf_create()
+ *        - OI_Fifobuf_enqueue()
+ *        - OI_FifoBufQ_getEnqueueBuf()
+ *        - OI_Fifobuf_dequeue()
+ *        - OI_Fifobuf_dequeue_release()
+ *
+ *    Each element in the queue is a buffer that has been enqueued. The dequeue process returns
+ *    buffers in the same order as that in which they were enqueued.
+ *
+ *   The queue is a block of data that is allocated by the queue user but is managed by this
+ *    queue utility.
+ */
+
+#include "oi_common.h"
+
+/** \addtogroup Misc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Queue size and element length are each limited to 64kb.
+  Also, a queue element cannot be larger than 1/2 the queue size. */
+
+/** queue size, limited to 64kilobytes */
+typedef OI_UINT16   OI_QSIZE ;
+
+/** queue element length, limited to 1/2 the queue size  */
+typedef OI_UINT16   OI_Q_ELEMENT_SIZE ;
+
+
+
+/**
+ * This function creates a FIFO buffer queue.
+ *
+ * @param pFifoQueue    This is a pointer to a block of memory that will managed by
+ *                      this queue process. Total size of the queue should be large
+ *                      enough to hold the maximum amount of data that may be queued
+ *                      at any one time plus some.  The "plus some" should consider the
+ *                      following:
+ *                        - Each queued buffer requires a few bytes of overhead.
+ *                        - At times, some buffer space may be wasted in order to keep a
+ *                          queued item's data contiguous when the queue wraps.
+ *
+ *                    @note: The memory block must be 32-bit aligned.
+ *
+ * @param fifoQueueSize   total size of the queue
+ */
+OI_STATUS   OI_FifoBufQ_Create(
+                    OI_BYTE             *pFifoQueue,
+                    OI_QSIZE            fifoQueueSize) ;
+
+/**
+ * This function closes a FIFO buffer queue.
+ *
+ * This function marks the queue so that subsequent enqueue/dequeue requests will fail.
+ *
+ * @param pFifoQueue    Pointer to the queue.
+ *
+ */
+OI_STATUS   OI_FifoBufQ_Close(
+                    OI_BYTE             *pFifoQueue) ;
+
+/**
+ * This function enqueues an external data buffer.
+ *
+ * This function adds a copy of the caller's data buffer to the end of the FIFO queue.
+ * In this context, external means that the caller's data buffer is owned by the caller (i.e.,
+ * buffer was not obtained via OI_FifoBufQ_GetEnqueueBuf()).
+ *        @note: Since a copy of the data is enqueued, the original data buffer is owned by the
+ *               caller and there are no constraints on its used after enqueue().
+ *
+ * @param pFifoQueue pointer to the FIFO queue
+ *
+ * @param dataLen   length of the buffer to be enqueued
+ *
+ * @param pData     pointer to the data buffer to be enqueued
+ */
+OI_STATUS   OI_FifoBufQ_Enqueue_ExtBuf(
+                    OI_BYTE             *pFifoQueue,
+                    OI_Q_ELEMENT_SIZE   dataLen,
+                    OI_BYTE             *pData) ;
+
+/**
+ * This function enqueues a data buffer that was previously obtained via OI_FifoBufQ_getEnqueueBuf().
+ * Since the data is already in the queue buffer, no copying of data is needed.
+ *
+ *      @note: The caller must not access the data buffer after it has been enqueued;
+ *             the buffer is owned by the queue process, not by the caller.
+ *
+ * There is no length parameter because the length was captured in the call to OI_FifoBufQ_GetEnqueueBuf().
+ *
+ * @param pFifoQueue pointer to the FIFO queue
+ *
+ * @param pData      pointer to the data buffer to be enqueued, previously obtained via OI_FifoBufQ_getEnqueueBuf()
+ */
+OI_STATUS   OI_FifoBufQ_Enqueue_QBuf(
+                    OI_BYTE             *pFifoQueue,
+                    OI_BYTE             *pData) ;
+
+/**
+ * This function gets a queue data buffer in preparation for enqueue operation.
+ *
+ * This function returns a pointer to the buffer that is the next buffer to be used to
+ * enqueue data. Caller must subsequently call OI_FifoBufQ_enqueue() with this same pointer.
+ *
+ * @param pFifoQueue pointer to the FIFO queue
+ *
+ * @param dataLen    length of the buffer to be enqueud
+ *      
+ * @return           pointer to a data buffer, NULL if there is no buffer available
+ */
+OI_BYTE *OI_FifoBufQ_GetEnqueueBuf(
+                    OI_BYTE             *pFifoQueue,
+                    OI_Q_ELEMENT_SIZE   dataLen) ;
+
+/**
+ * This function dequeues a data buffer.
+ *
+ * This function returns the next queued buffer. For performance reasons, the dequeued buffer
+ * is returned by reference; i.e., the dequeue process does not make a copy of the data. This
+ * leads to some requirements that the caller must adhere to:
+ *
+ *      - Caller must call OI_Fifobuf_dequeue_release() after consuming the dequeued data.
+ *      - Caller may not block between OI_Fifobuf_dequeue() and OI_Fifobuf_dequeue_release().
+ *      - Caller may not have more than one dequeued packet outstanding at any one time.
+ *
+ * Failure to follow these conventions will result in a corrupt queue.
+ *
+ * @param pFifoQueue pointer to the FIFO queue
+ *
+ * @param pDataLen  This pointer points to the caller's variable where the length of the dequeued
+ *                  buffer will be stored. If there is no buffer to dequeue, *pDataLen is set to zero.
+ *
+ * @return          pointer to the dequeued buffer, NULL if there is no buffer to dequeue
+ */
+OI_BYTE *OI_FifoBufQ_Dequeue(
+                    OI_BYTE             *pFifoQueue,
+                    OI_Q_ELEMENT_SIZE   *pDataLen) ;
+
+/**
+ * This function releases a dequeued data buffer.
+ *
+ * This function releases the buffer that was previously dequeued.
+ *
+ * @param pFifoQueue pointer to the FIFO queue
+ *
+ * @param pData     pointer to buffer previously dequeued
+ *
+ */
+void    OI_FifoBufQ_Dequeue_Release(
+                    OI_BYTE             *pFifoQueue,
+                    OI_BYTE             *pData) ;
+
+/**************************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_FIFO_BUF_Q_H */
+
diff --git a/obex_profiles/include/oi_init_flags.h b/obex_profiles/include/oi_init_flags.h
new file mode 100644
index 0000000..b7ff244
--- /dev/null
+++ b/obex_profiles/include/oi_init_flags.h
@@ -0,0 +1,161 @@
+#ifndef _OI_INIT_FLAGS_H
+#define _OI_INIT_FLAGS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * Initialization flags and access routines
+ *
+ * This file contains initialization flags for each 'module' in the BM3 stack.  Modules are enumerated
+ * in a separate file (oi_modules.h).
+ *
+ * This file also contains access routines and macros for the initialization flags.
+ *
+ * When compiled for debug, init flags are accessed by an accessor function which verifies
+ * consistency of the initialization table.
+ *
+ * When compiled for release, init flags are accessed directly.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_modules.h"
+#include "oi_debug.h"
+#include "oi_assert.h"
+
+/** \addtogroup Misc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*************************************************************
+
+    What is an initialization flag?
+    An init flag is a 32-bit value.
+    Zero = not initialized
+    Non-zero = initialized.  Any further meaning is up to the particular module to whom
+        the init flag belongs.  It might be a pointer, a reference counter or simply a boolean.
+*************************************************************/
+
+typedef OI_UINT32   OI_INIT_FLAG;
+
+#define OI_INIT_FLAG_UNINITIALIZED_VALUE     (0)
+
+/*************************************************************
+
+    void OI_InitFlags_ResetAllFlags(void) ;
+    Reset all initialization flags
+    Know what you're doing if you call this function.
+    It should only be called as part of a global, reset/restart process.
+    This function is defined in oi_bt_statck_init.h in order to be available to applications
+*************************************************************/
+/*************************************************************
+
+    Initialization flag access
+    OI_INIT_FLAG_VALUE (module)
+        Returns the initialization flag for the specified module.  If the flag is non-zero,
+        the actual type is known only to the caller.
+        @param module   Specify module name without the OI_MODULE_ prefix.
+                        Example:
+                             OI_INIT_FLAG_VALUE (DEVMGR)
+                        not:
+                             OI_INIT_FLAG_VALUE (OI_MODULE_DEVMGR)
+
+        @return         Value of the module's initialization flag
+
+    OI_INIT_FLAG_PUT_FLAG (flagValue, module)
+        Macro saves the caller's flag in the initialization table.
+        @param flagValue    new initialization flag value.  Zero means that the module is
+                            uninitialized, any non-zero value means module has been initialized
+        @param module   Specify module name without the OI_MODULE_ prefix.
+                        Example:
+                             OI_INIT_FLAG_PUT_FLAG (TRUE, DEVMGR)
+                        not:
+                             OI_INIT_FLAG_PUT_FLAG (TRUE, OI_MODULE_DEVMGR)
+*************************************************************/
+
+/* Accessor functions */
+extern OI_INIT_FLAG OI_InitFlags_GetFlag(OI_MODULE module) ;
+extern void         OI_InitFlags_PutFlag(OI_INIT_FLAG flagValue, OI_MODULE module, OI_MODULE callingModule) ;
+extern void         OI_InitFlags_Increment(OI_MODULE module) ;
+extern void         OI_InitFlags_Decrement(OI_MODULE module) ;
+extern OI_BOOL      OI_InitFlags_AllUninitialized(void) ;
+
+
+#ifdef OI_DEBUG
+    /* In debug mode, configuration table access is via an accessor function to allow for additional
+        error checking. */
+#define OI_INIT_FLAG_VALUE(module)               (OI_InitFlags_GetFlag(OI_MODULE_##module))
+#define OI_INIT_FLAG_PUT_FLAG(flagValue, module) (OI_InitFlags_PutFlag(flagValue, OI_MODULE_##module, __OI_MODULE__))
+#define OI_INIT_FLAG_INCREMENT(module)           (OI_InitFlags_Increment(OI_MODULE_##module))
+#define OI_INIT_FLAG_DECREMENT(module)           (OI_InitFlags_Decrement(OI_MODULE_##module))
+
+#else
+    /* In release mode, configuration table is accessed directly.
+        Init flags are in a global array, module # is index into the array */
+
+extern OI_INIT_FLAG OI_GV_InitializationFlags[] ;
+
+#define OI_INIT_FLAG_VALUE(module)               (OI_GV_InitializationFlags[OI_MODULE_##module])
+#define OI_INIT_FLAG_PUT_FLAG(flagValue, module) OI_GV_InitializationFlags[OI_MODULE_##module] = (OI_INIT_FLAG)flagValue
+#define OI_INIT_FLAG_INCREMENT(module)           (++OI_GV_InitializationFlags[OI_MODULE_##module])
+#define OI_INIT_FLAG_DECREMENT(module)           (--OI_GV_InitializationFlags[OI_MODULE_##module])
+
+#endif
+
+
+/** Preamble for external APIs that do not initialize the module.
+    Return an error if not initialized.
+ */
+#define OI_CHECK_INIT(x) if (!OI_INIT_FLAG_VALUE(x)) return OI_STATUS_INVALID_STATE;
+
+/** Preamble for external APIs that initialize the module.
+    Initialize the module if not initialized. */
+#define OI_ENSURE_INIT(x) \
+{ \
+    OI_STATUS result; \
+    if (!OI_INIT_FLAG_VALUE(x)) { \
+       result = internalInit(); \
+       if (!OI_SUCCESS(result)) { \
+           return result; \
+       } \
+    } \
+}
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_INIT_FLAGS_H */
+
diff --git a/obex_profiles/include/oi_marshaller.h b/obex_profiles/include/oi_marshaller.h
new file mode 100644
index 0000000..4b308bf
--- /dev/null
+++ b/obex_profiles/include/oi_marshaller.h
@@ -0,0 +1,166 @@
+#ifndef _MARSHALLER_H
+#define _MARSHALLER_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * This file provides functions for marshalling and unmarshalling data elements into bytestreams.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_bt_spec.h"
+#include "oi_dataelem.h"
+#include "oi_bytestream.h"
+
+/** \addtogroup Marshaller_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This function serializes and writes a data element to a byte stream. The
+ * caller should ensure that there is enough space in the byte stream to
+ * accomodate the complete data element list.  To determine how much space will
+ * be required, call OI_DataElement_MarshalledSize. If there is insufficient
+ * room to write the data an error status will be reported on the byte stream.
+ *
+ * @param ByteStream  the byte stream that the data element will be written to.
+ *
+ * @param Element     a pointer to the data element that will be written.
+ *
+ * @return            TRUE if the data element was succesfully marshalled, FALSE
+ *                    if there was not enough room in the byte stream.
+ */
+
+OI_BOOL OI_DataElement_Marshal(OI_BYTE_STREAM *ByteStream,
+                               const OI_DATAELEM *Element);
+
+
+/**
+ * This function serializes and writes a segment of a data element to a byte
+ * stream.
+ *
+ * @param ByteStream     the byte stream that the data element will be written to.
+ *
+ * @param segmentOffset  number of data element bytes to be ignored.
+ *
+ * @param Element        a pointer to the data element that will be written.
+ *
+ * @return               TRUE if the data element was completely marshalled, FALSE
+ *                       if there was not enough room in the byte stream.
+ */
+
+OI_BOOL OI_DataElement_MarshalSegment(OI_BYTE_STREAM *ByteStream,
+                                      OI_UINT16 *segmentOffset,
+                                      const OI_DATAELEM *Element);
+
+/**
+ * Looks at the first data element in the bytestream and returns the element
+ * type, size, and the start of the next element. Thes size returned is the size
+ * in bytes of the element value. The position in the bytestream remains
+ * unchanged.
+ */
+
+OI_STATUS OI_DataElement_Peek(OI_BYTE_STREAM *ByteStream,
+                              OI_UINT8 *elemType,
+                              OI_UINT16 *size);
+
+/**
+ * Unmarshalls a data element sequence returning the size of the data element
+ * list header and number of bytes in the list itself.
+ */
+OI_STATUS OI_DataElement_UnmarshallListHeader(OI_BYTE_STREAM *ByteStream,
+                                              OI_UINT16 *headerBytes,
+                                              OI_UINT16 *listBytes);
+
+/**
+ * This function returns the byte count required to store the passed data
+ * element, or 0 if insufficient memory to calculate count.
+ */
+
+OI_UINT16 OI_DataElement_MarshalledSize(const OI_DATAELEM *Element);
+
+
+/**
+ * This function converts a data element from the marshalled (network)
+ * representation to a more convenient in-memory representation.
+ *
+ * The function allocates dynamic memory for the unmarshalled data element. The
+ * caller must call OI_DataElement_Free to deallocate this memory.
+ *
+ * This function will return an error status if dynamic memory can not be
+ * allocated to unmarshal the data element or if the data element is not
+ * correclty formed.
+ *
+ * If the data element contains list elements (DATAELEM_ELEMENT_SEQUENCE or
+ * DATAELEM_ELEMENT_ALTERNATIVE) the list elements will be allocated as a
+ * contiguous array of SDP_DATA_ELEMENTs.
+ */
+
+OI_STATUS OI_DataElement_Unmarshal(OI_BYTE_STREAM *ByteStream,
+                                   OI_DATAELEM *Element);
+
+/**
+ * This function recursively copies a data element tree.
+ */
+
+OI_STATUS OI_DataElement_Clone(OI_DATAELEM *toElem,
+                               const OI_DATAELEM *fromElem);
+
+
+/**
+ * Transfer a data value from one data element to another. The fromElem is set
+ * to a null data element.
+ */
+void OI_DataElement_Transfer(OI_DATAELEM *toElem,
+                             OI_DATAELEM *fromElem);
+
+/**
+ * This function recursively frees all memory allocated to unmarshal a data
+ * element.
+ */
+
+void OI_DataElement_Free(OI_DATAELEM *Element);
+
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _MARSHALLER_H */
+
diff --git a/obex_profiles/include/oi_mbparse.h b/obex_profiles/include/oi_mbparse.h
new file mode 100644
index 0000000..3965870
--- /dev/null
+++ b/obex_profiles/include/oi_mbparse.h
@@ -0,0 +1,89 @@
+#ifndef _OI_MBPARSE_H
+#define _OI_MBPARSE_H
+
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "oi_common.h"
+#include "oi_mbuf.h"
+
+#include "oi_mbuf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern OI_UINT8  OI_MBPARSE_UINT8_value;
+extern OI_UINT16 OI_MBPARSE_UINT16_value;
+extern OI_UINT32 OI_MBPARSE_UINT32_value;
+
+/**
+ * Pull a UINT8 from an mbuf.
+ *
+ * @param  mbuf     MBUF source
+ * @return   UINT8 value from mbuf
+ *
+ * OI_UINT8 OI_MBParse_GetUINT8(OI_MBUF *mbuf);
+ */
+#define OI_MBParse_GetUINT8(mbuf)  (OI_MBUF_PullBytes((OI_BYTE *)&OI_MBPARSE_UINT8_value, mbuf, sizeof(OI_UINT8)), OI_MBPARSE_UINT8_value)
+
+/**
+ * Pull a UINT16 from an mbuf.
+ *
+ * @param  mbuf     MBUF source
+ * @param  endian   OI_LITTLE_ENDIAN_BYTE_ORDER or OI_BIG_ENDIAN_BYTE_ORDER
+ * @return  OI_UINT16 value from mbuf
+ *
+ * OI_UINT16 OI_MBParse_GetUINT16(OI_MBUF *mbuf, OI_BYTE endian);
+ */
+#define OI_MBParse_GetUINT16(mbuf, endian) \
+    (OI_MBUF_PullBytes((OI_BYTE *)&OI_MBPARSE_UINT16_value, (mbuf), sizeof(OI_UINT16)), \
+    (endian == OI_LITTLE_ENDIAN_BYTE_ORDER) ? GetUINT16_LittleEndian(&OI_MBPARSE_UINT16_value) : GetUINT16_BigEndian(&OI_MBPARSE_UINT16_value))
+
+/**
+ * Pull a UINT32 from an mbuf.
+ *
+ * @param  mbuf     MBUF source
+ * @param  endian   OI_LITTLE_ENDIAN_BYTE_ORDER or OI_BIG_ENDIAN_BYTE_ORDER
+ * @return  OI_UINT32 value from mbuf
+ *
+ * OI_UINT32 OI_MBParse_GetUINT32(OI_MBUF *mbuf, OI_BYTE endian);
+ */
+#define OI_MBParse_GetUINT32(mbuf, endian) \
+    (OI_MBUF_PullBytes((OI_BYTE *)&OI_MBPARSE_UINT32_value, (mbuf), sizeof(OI_UINT32)), \
+    (endian == OI_LITTLE_ENDIAN_BYTE_ORDER) ? GetUINT32_LittleEndian(&OI_MBPARSE_UINT32_value) : GetUINT32_BigEndian(&OI_MBPARSE_UINT32_value))
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif      /* _OI_MBPARSE_H */
diff --git a/obex_profiles/include/oi_memmgr.h b/obex_profiles/include/oi_memmgr.h
new file mode 100644
index 0000000..c555e90
--- /dev/null
+++ b/obex_profiles/include/oi_memmgr.h
@@ -0,0 +1,278 @@
+#ifndef _MEMMGR_H
+#define _MEMMGR_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *  This header file provides memory management functions.
+ *  The memory allocator assumes that all dynamic memory is allocated from a fixed
+ *  size pool. For a desktop environment this pool can be large, but for embedded
+ *  applications this pool may be quite small. A block-based allocation scheme is used to
+ *  prevent memory fragmentation. The size and number of blocks of each allocation
+ *  size will be tuned to the needs of the specific embedded application.
+ *
+ *  See @ref memMgr_docpage for more information on the basic function of the Memory Manager.
+*/
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_debug.h"
+#include "oi_string.h"
+#include "oi_cpu_dep.h"
+
+#ifdef OI_USE_NATIVE_MALLOC
+#include <stdlib.h>
+#endif
+
+/** \addtogroup MemMgr_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * IF OI_DEBUG is defined then MEMMGR is compiled for debugging and memory
+ * profiling. If OI_DEBUG is not defined memmgr debugging and profiling can be
+ * turned on indepdentently by defining MEMMGR_DEBUG and MEMMGR_PROFILE
+ */
+
+#ifdef OI_DEBUG
+    #define MEMMGR_DEBUG
+    #ifndef SMALL_MEMORY
+        #define MEMMGR_PROFILE
+    #endif
+#endif
+
+/*
+ * Cannot use memory manager debugging or profiling is using native malloc
+ * and using native malloc implies use native memcpy.
+ */
+#ifdef OI_USE_NATIVE_MALLOC
+#undef MEMMGR_DEBUG
+#undef MEMMGR_PROFILE
+#endif
+
+/*
+ * OI_Malloc, OI_Calloc
+ *
+ * Allocates the smallest available memory block that is large enough to hold
+ * the specified number of bytes. Returns 0 if there is no memory block of the
+ * required size available
+ *
+ * For debugging, OI_Malloc is a macro which adds file and line number to the
+ * malloc call so that we can trace memory hogs and memory leaks.
+ *
+ * OI_Calloc does the allocation and then zeroes the memory before returning it.
+ */
+
+#ifdef OI_USE_NATIVE_MALLOC
+
+#define OI_Malloc(size)        malloc((size))
+#define OI_Calloc(size)        calloc((size), 1)
+#define OI_Free(x)             free((x))
+#define OI_StaticMalloc(size)  calloc((size),1)
+#define OI_MallocWillFail(x)   (FALSE)
+#define OI_FreeIf(x)           do{if (*(x) != NULL) { free(*(x)); *(x) = NULL;}} while(0)
+
+#else /* OI_USE_NATIVE_MALLOC */
+
+#ifdef MEMMGR_DEBUG
+
+#define OI_Malloc(size) _OI_Malloc_Dbg((size), OI_CURRENT_MODULE, __FILE__, (OI_UINT16)(__LINE__))
+#define OI_Calloc(size) _OI_Calloc_Dbg((size), OI_CURRENT_MODULE, __FILE__, (OI_UINT16)(__LINE__))
+
+void* _OI_Malloc_Dbg(OI_INT32 size, OI_UINT8 module, OI_CHAR *fname, OI_UINT16 lineNum);
+void* _OI_Calloc_Dbg(OI_INT32 size, OI_UINT8 module, OI_CHAR *fname, OI_UINT16 lineNum);
+
+#else
+
+#define OI_Malloc(size) _OI_Malloc(size)
+void* _OI_Malloc(OI_INT32 size);
+
+#define OI_Calloc(size) _OI_Calloc(size)
+void* _OI_Calloc(OI_INT32 size);
+
+#endif /* MEMMGR_DEBUG */
+
+/**
+ * A memory allocation failure is usually a fatal internal stack error
+ * but there are some cases where the size of the block being
+ * allocated is based on data received from a remote device and a NO
+ * RESOURCES error should be reported.
+ *
+ * It is still important to check OI_Malloc or OI_Calloc return values for
+ * NULL, for correct error handling when BM3 is built with OI_USE_NATIVE_MALLOC.
+ *
+ * Check if a call to OI_Malloc (or OI_Calloc) would fail.
+ *
+ * @param size  The size of the memory block to check
+ *
+ * @return TRUE if a call to OI_Malloc (or OI_Calloc) would fail
+ */
+OI_BOOL OI_MallocWillFail(OI_INT32 size);
+
+/*
+ * OI_StaticMalloc
+ *
+ * Allocates memory from the static allocation pool. This is data that is
+ * required for the stack to function and will never explicitly freed.
+ *
+ * The memory allocated will be zero'd before returning to caller.
+ */
+
+#ifdef MEMMGR_DEBUG
+
+#define OI_StaticMalloc(size) _OI_StaticMalloc_Dbg((size), OI_CURRENT_MODULE, __FILE__, (OI_UINT16)(__LINE__))
+
+void* _OI_StaticMalloc_Dbg(OI_INT32 size, OI_UINT8 module, OI_CHAR *fname, OI_UINT16 lineNum);
+
+#else
+
+#define OI_StaticMalloc(size) _OI_StaticMalloc(size)
+void* _OI_StaticMalloc(OI_INT32 size);
+
+#endif /* MEMMGR_DEBUG */
+
+
+/*
+ * OI_Free
+ *
+ * Returns a memory block to the memory pool and makes it available for
+ * subsequent allocations. Fails with an assertion error if the memory was not
+ * allocated by OI_Malloc or if the memory block has become corrupt.
+ *
+ * OI_FreeIf
+ *
+ * Passed a reference to a pointer to a dynamic memory block. If the value
+ * referenced is non-null, frees the memory and sets the referenced value to
+ * null.
+ */
+
+#ifdef MEMMGR_DEBUG
+
+#define OI_Free(block) _OI_Free_Dbg((block), OI_CURRENT_MODULE, __FILE__, (OI_UINT16)(__LINE__))
+void _OI_Free_Dbg(void *block, OI_UINT8 module, OI_CHAR *fname, OI_UINT16 lineNum);
+
+#define OI_FreeIf(p) \
+    do { \
+        _OI_FreeIf_Dbg(*(p), OI_CURRENT_MODULE, __FILE__, (OI_UINT16)(__LINE__)); \
+        *(p) = NULL; \
+    } while (0)
+void _OI_FreeIf_Dbg(const void *blockRef, OI_UINT8 module, OI_CHAR *fname, OI_UINT16 lineNum);
+
+#else
+
+#define OI_Free(block) _OI_Free(block)
+void _OI_Free(void *block);
+
+#define OI_FreeIf(p)  do { _OI_FreeIf(*(p)); *(p) = NULL; } while (0)
+void _OI_FreeIf(const void *blockRef);
+
+#endif /* MEMMGR_DEBUG */
+
+#endif /* OI_USE_NATIVE_MALLOC */
+
+
+/**
+ * OI_MEMMGR_Check, OI_MEMMGR_CheckSize
+ *
+ * For debugging only
+ *
+ * Checks the memory address is a valid memory block address and that has been
+ * allocated (i.e. not on the free list) and checks that the contents at that
+ * memory block has not been corrupted.
+ *
+ * Returns TRUE if the address and contents are ok, FALSE otherwise.
+ *
+ * OI_MEMMGR_CheckSize also checks that the allocated storage for the memory block
+ * is >= Size.
+ *
+ * Intended for use with the ASSERT macro, for example:
+ *
+ *     OI_ASSERT(OI_MEMMGR_Check(ptr));
+ *     OI_ASSERT(OI_MEMMGR_CheckSize(buffer, 96));
+ */
+
+#ifdef MEMMGR_DEBUG
+
+OI_BOOL OI_MEMMGR_Check(void const *Block);
+
+OI_BOOL OI_MEMMGR_CheckSize(void const *Block,
+                            OI_UINT32 Size);
+
+/**
+ * How much dynamic memory is currently allocated
+ */
+OI_UINT32 OI_MEMMGR_CurrentDynamicAllocation(void);
+
+/*
+ * OI_MaxAllocBlock
+ *
+ * Returns the size of the largest memory block currently available for
+ * allocation by a OI_Malloc
+ */
+OI_UINT32 OI_MaxAllocBlock(void);
+
+
+/*
+ * OI_MinAllocBlock
+ *
+ * Returns the size of the smallest memory block currently available for
+ * allocation by a OI_Malloc
+ */
+OI_UINT32 OI_MinAllocBlock(void);
+
+#else
+
+#define OI_MEMMGR_Checksum(B)        (0)
+
+#define OI_MEMMGR_Check(B)        (TRUE)
+
+#define OI_MEMMGR_CheckSize(B, S) (TRUE)
+
+#define OI_MEMMGR_CurrentDynamicAllocation()  (0)
+
+#define OI_MaxAllocBlock() (0)
+
+#define OI_MinAllocBlock() (0)
+
+#endif /* MEMMGR_DEBUG */
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* _MEMMGR_H */
+
diff --git a/obex_profiles/include/oi_obextest.h b/obex_profiles/include/oi_obextest.h
new file mode 100644
index 0000000..593e4ee
--- /dev/null
+++ b/obex_profiles/include/oi_obextest.h
@@ -0,0 +1,61 @@
+#ifndef _OI_OBEXTEST_H
+#define _OI_OBEXTEST_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "oi_stddefs.h"
+
+
+#ifdef OI_TEST_HARNESS
+
+typedef struct {
+    OI_BOOL delaySRM;     /**< Delay start of SRM by sending an SRMP WAIT command */
+    OI_BOOL ignoreSRM;    /**< Ignore negotiated SRM - i.e. behave badly */
+    OI_BOOL disableSRM;   /**< Disable Single Response Mode */
+    OI_BOOL disableL2CAP; /**< Disable OBEX/L2cAP */
+    OI_UINT32 frameSize;  /**< Maximum RFCOMM frame size for OBEX/RFCOMM */
+    OI_BOOL fastAbort;    /**< Abort a put without waiting for a reply */
+    OI_BOOL SendErrorRsp; /**< Send an error in the PUT/GET response */
+} OI_OBEX_TEST_GLOBALS;
+
+
+extern OI_OBEX_TEST_GLOBALS OI_ObexTest;
+
+void OI_OBEX_TestInit(void);
+
+#else
+
+#define OI_OBEX_TestInit()
+
+#endif
+
+
+#endif /* _OI_OBEXTEST_H */
diff --git a/obex_profiles/include/oi_policymgr.h b/obex_profiles/include/oi_policymgr.h
new file mode 100644
index 0000000..6072811
--- /dev/null
+++ b/obex_profiles/include/oi_policymgr.h
@@ -0,0 +1,190 @@
+#ifndef _OI_POLICY_MGR_H
+#define _OI_POLICY_MGR_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * Policy manager API
+ *
+ * This file defines the policy manager api.
+ *
+ * Basically, all multiplexing protocols report when a new connection is created and
+ * when a connection is disconnected.  When a new connection is created, the policy
+ * manager will enforce the acl link policies defined by the various services using
+ * the same ACL link.
+ */
+
+#include "oi_status.h"
+#include "oi_connect_policy.h"
+
+/** \addtogroup PolicyMgr_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*************************************************************
+
+    Policy Manager API uses handles to connections.
+    The handle is an opaque 32-bit value, but zero will never be a valid handle
+
+*************************************************************/
+
+#define OI_POLICYMGR_NULL_HANDLE     0
+
+/*************************************************************
+
+    New connection callback.
+
+    The callback is called when the policy manager has finished enforcing the specified policies.
+    If the policy manager was unsuccessful (i.e. status != OI_OK), the multiplexing protocol
+    must reject the connection.
+
+    @param  handle      Identifier which associates the callback with the original call to
+                        OI_POLICYMGR_NewConnection().
+
+    @param  status      Results of the attempt to enforce the specified policies.
+
+    @param  securityFailure If the status parameter is NOT OI_OK, this boolean indicates whether
+                        the failure occurred as a result of enforcing security policy.
+*************************************************************/
+
+typedef void(*OI_POLICYMGR_NEW_CONNECT_CB)(
+                            OI_UINT32   handle,                 /**< connection identifier */
+                            OI_STATUS   status,                 /**< policy enforcement result */
+                            OI_BOOL     securityFailure) ;
+
+/*************************************************************
+
+    New connection
+
+    The multiplexing protocol calls the policy manager when a new connection is being created.
+    The policy manager will attempt to enforce the various policies on the connection and then
+    call back the multiplexing protocol.  If the policy manager is not successful in enforcing
+    the policies, the multiplexing protocol must reject the connection attempt.
+
+    @param  cb          Callback that will be called after the policies have been enforced.
+
+    @param  pAddr       Device address which is being connected
+
+    @param  pPolicy     Ptr to the policy that is to be applied to the connection.
+
+    @param  pHandle     If the function succeeds, it will return a handle used to identify the
+                        connection in subsequent interactions with the policy manager.
+
+    @param incoming    Incoming (TRUE) or outgoing (FALSE) connection.
+
+    @return             OI_OK, policy manager will attempt to enforce the given policy and will
+                            invoke the callback when done.
+                        Any other value, the policy manager will not attempt to enforce the policy
+                            and will not call the callback.
+
+*************************************************************/
+
+extern OI_STATUS    OI_POLICYMGR_NewConnection(
+                            OI_POLICYMGR_NEW_CONNECT_CB cb,         /**< callback when done */
+                            const OI_BD_ADDR            *pAddr,     /**< Bluetooth device address */
+                            const OI_CONNECT_POLICY     *pPolicy,   /**< policy to be applied to the connection */
+                            OI_UINT32                   *pHandle,   /**< identifier returned to caller */
+                            OI_BOOL                     incoming);  /**< incoming/outgoing connection */
+
+/*************************************************************
+
+    Disconnect
+
+    The multiplexing protocol calls the policy manager when a disconnect occurs.  The handle
+    is the handle that was returned by OI_POLICYMGR_NewConnection().
+
+    This is a synchronous call which always succeeds.
+
+    @param  handle      Identifies the connection which has been disconnected.  Although 0 is not a valid
+                        handle, for caller's convenience, this function will accept a 0 handle without
+                        major complaint (Issues DBGPRINT msg).
+
+*************************************************************/
+
+extern void OI_POLICYMGR_Disconnect(
+                            OI_UINT32   handle) ;
+
+/*************************************************************
+
+    Get the current devmgr policy for an ACL link.
+
+    Devmgr does not cache the policy, but rather uses this accessor function when it needs
+    to query the current devmgr policy.  This query is used when a devmgr api is called which
+    might potentially conflict with the current policy (e.g. setRole).
+
+    The power-saving link policy returned by this function is in HCI format,
+    i.e. a bit mask of power-saving enables.
+
+*************************************************************/
+
+extern void OI_POLICYMGR_GetDevmgrPolicy(OI_BD_ADDR  *pAddr,
+                                  OI_BOOL     *pMustBeMaster,
+                                  OI_UINT16   *pPowerSavePolicy);
+
+/*************************************************************
+
+    Device Manager Disconnect
+
+    This policy manager function is called by the device manager when an ACL link has been dropped.
+    Normally, the policy manager will already have been informed by the multiplexing protocols that
+    services have been disconnected.  This function serves as a double check.
+
+    @param  pAddr      Identifies the device which has been disconnected.
+*************************************************************/
+
+extern void OI_POLICYMGR_DevmgrDisconnect(OI_BD_ADDR *pAddr) ;
+
+/*************************************************************
+
+    L2CAP policy removal notification
+
+        This is a private api for L2CAP.
+        Note that this callback may be invoked from an application thread.
+
+*************************************************************/
+
+typedef void(*OI_POLICYMGR_REMOVAL_CB)(OI_HCI_CONNECTION_HANDLE    connectionHandle);
+
+
+void OI_POLICYMGR_RegisterL2capPolicyRemoval(OI_POLICYMGR_REMOVAL_CB Cb);
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_POLICY_MGR_H */
+
diff --git a/obex_profiles/include/oi_sdp_utils.h b/obex_profiles/include/oi_sdp_utils.h
new file mode 100644
index 0000000..5fda1a3
--- /dev/null
+++ b/obex_profiles/include/oi_sdp_utils.h
@@ -0,0 +1,110 @@
+#ifndef _OI_SDP_UTILS_H
+#define _OI_SDP_UTILS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_obex.h"
+#include "oi_sdpdb.h"
+
+/** \addtogroup SvcDisc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * Initialize SDP attributes for an OBEX profile
+ *
+ * @param lowerProtocols     A list of lower layer protocols.
+ *
+ * @param numLowerProtocols  The length of the lower protocols list.
+ *
+ * @param pdlAttribute       Pointer the attribute structure to be allocated and initialized
+ *                           according to the protocol list. This structure must eventually be freed
+ *                           by calling OI_DataElement_Free().
+ *
+ * @param numAttributes      [in/out] Passes the size of the attributeList to the function and
+ *                           returns the number of attributes set.
+ */
+OI_STATUS OI_SDP_UTILS_OBEX_MakeAttributes(OI_OBEX_LOWER_PROTOCOL *lowerProtocols,
+                                           OI_UINT8 numLowerProtocols,
+                                           OI_SDPDB_ATTRIBUTE *attributeList,
+                                           OI_UINT8 *numAttributes);
+
+
+/*
+ * Verify that a data element conforms to an expected PDL structure and parses it.
+ *
+ * @param   Pointer to a data element. This is expected to be a data element sequence representing a
+ *          protocol stack as it should appear in a protocol descriptor list.
+ *
+ * @param   Pointer to an OBEX lower protocol structure
+ */
+OI_STATUS OI_SDP_UTILS_OBEX_ParsePDL(OI_DATAELEM *elem,
+                                     OI_OBEX_LOWER_PROTOCOL *lowerProtocol);
+
+/*
+ * Initialize a protocol descriptor list attribute for an RFCOMM profile
+ *
+ * @param channelNumber      The rfcomm channel number to include in the PDL.
+ *
+ * @param pdlAttribute       Pointer the attribute structure to be allocated and initialized.
+ *                           This structure must eventually be freed by calling
+ *                           OI_DataElement_Free().
+ */
+OI_STATUS OI_SDP_UTILS_RFCOMM_PDLAttribute(OI_UINT8 channelNumber,
+                                           OI_SDPDB_ATTRIBUTE *pdlAttribute);
+
+
+/*
+ * Verify that a data element conforms to an expected PDL structure and parses it.
+ *
+ * @param   Pointer to a data element. This is expected to be a data element sequence representing a
+ *          protocol stack as it should appear in a protocol descriptor list.
+ *
+ * @param   Pointer to return the RFCOMM channel number
+ */
+OI_STATUS OI_SDP_UTILS_RFCOMM_ParsePDL(OI_DATAELEM *elem,
+                                       OI_UINT8 *channel);
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_SDP_UTILS_H */
+
diff --git a/obex_profiles/include/oi_sdpconsts.h b/obex_profiles/include/oi_sdpconsts.h
new file mode 100644
index 0000000..a4edd2b
--- /dev/null
+++ b/obex_profiles/include/oi_sdpconsts.h
@@ -0,0 +1,147 @@
+#ifndef _SDPCONSTS_H
+#define _SDPCONSTS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "oi_sdp.h"
+#include "oi_bt_assigned_nos.h"
+#include "oi_status.h"
+
+
+/** \addtogroup SvcDisc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * SDP PDU ID codes
+ */
+
+#define SDP_ERROR_RESPONSE                     0x01
+#define SDP_SERVICE_SEARCH_REQUEST             0x02
+#define SDP_SERVICE_SEARCH_RESPONSE            0x03
+#define SDP_SERVICE_ATTRIBUTE_REQUEST          0x04
+#define SDP_SERVICE_ATTRIBUTE_RESPONSE         0x05
+#define SDP_SERVICE_SEARCH_ATTRIBUTE_REQUEST   0x06
+#define SDP_SERVICE_SEARCH_ATTRIBUTE_RESPONSE  0x07
+
+/*
+ * An SDP PDU header is 5 bytes long:
+ *
+ *  -----------------------------------------------------------------------------
+ *  |   PDU ID   |     TRANSACTION ID     |    Parameter Length   |  parameters...
+ *  -----------------------------------------------------------------------------
+ *  <== 1 byte ==><======= 2 bytes =======><====== 2 bytes =======>
+ */
+
+#define TRANSACTION_ID_OFFSET  1   // Where the transaction id starts
+#define PARAM_LENGTH_OFFSET    3   // Where the parameter length starts
+
+#define SDP_PDU_HEADER_SIZE    5
+
+/**
+ * An attributes ID is represented in an SDP PDU by a one byte header and two
+ * bytes of value.
+ */
+#define SDP_ATTRIBUTE_ID_BYTES   (sizeof(OI_UINT8) + sizeof(OI_UINT16))
+
+/**
+ * The size of an error response packet (assumes no additional error info)
+ */
+
+#define SDP_ERROR_RESPONSE_SIZE  (SDP_PDU_HEADER_SIZE + 2)
+
+/**
+ * The SDP specification defines a set of error codes. We map the SDP error
+ * codes into OI_STATUS codes. This macro is the reverse mapping.
+ */
+
+#define SDP_ERROR_CODE(e)    ((e) - OI_SDP_SPEC_ERROR)
+
+
+/**
+ * Maximum number of bytes in a continuation state parameter.
+ *
+ * Defined to be 16 bytes for SDP V1.0
+ */
+#define SDP_CONTINUATION_STATE_MAX_LEN 16
+
+/**
+ * SDP transfer byte order is big endian
+ */
+#define SDP_BO  OI_BIG_ENDIAN_BYTE_ORDER
+
+/**
+ * As defined in the SDP 1.1 specification: the maximum number of service Ids
+ * that can be specified in a single service request
+ */
+#define SDP_MAX_SERVICE_IDS  12
+
+/**
+ * SDP spec says that service record handles from 0x0001 to 0xFFFF are reserved.
+ *
+ * Service record handle 0 is the service record handle for the SDP service
+ * itself.
+ */
+
+#define SDP_MIN_SERVICE_RECORD_HANDLE   ((OI_SDP_SERVICE_RECORD_HANDLE) 0x4F490000)
+
+
+/**
+ * The minimum size of a MaxAttributeByteCount is defined by the SDP
+ * specification to be 7 bytes. This means that the SDP server must be able to
+ * support at least a 7 byte attribute response.
+ */
+
+#define SDP_MIN_ATTRIBUTE_BYTE_COUNT   7
+
+
+/**
+ * The zero service record handle (0x00000000) is always interpreted by an SDP
+ * server to mean the SDP server itself. The service record for an SDP server
+ * lists all of the attributes supported by the SDP server including the
+ * protocol versions, etc.
+ */
+
+#define SDPSERVICE_SERVICE_RECORD_HANDLE 0x00000000
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _SDPCONSTS_H */
+
diff --git a/obex_profiles/include/oi_std_utils.h b/obex_profiles/include/oi_std_utils.h
new file mode 100644
index 0000000..07684f8
--- /dev/null
+++ b/obex_profiles/include/oi_std_utils.h
@@ -0,0 +1,73 @@
+#ifndef _UTILS_H
+#define _UTILS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * This file contains utilities that are commonly found in stdlib libraries.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_bt_spec.h"
+#include "oi_string.h"
+#include "oi_utils.h"
+
+/** \addtogroup Misc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern const OI_BD_ADDR OI_ZeroAddr;
+
+void OI_StrToUpper(OI_CHAR *str);
+
+/** Convert a character to upper case. */
+#define OI_toupper(c) ( ((c) >= 'a') && ((c) <= 'z') ? ((c) - 32) : (c) )
+
+/**
+ * This macro initializes a BD_ADDR. This currently zeros all bytes.
+ */
+
+#define INIT_BD_ADDR(addr)      OI_MemZero((addr), OI_BD_ADDR_BYTE_SIZE)
+
+#define OI_IS_ZERO_ADDR(addr)  SAME_BD_ADDR((addr), &OI_ZeroAddr)
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _UTILS_H */
+
diff --git a/obex_profiles/include/oi_unicodestream.h b/obex_profiles/include/oi_unicodestream.h
new file mode 100644
index 0000000..4142170
--- /dev/null
+++ b/obex_profiles/include/oi_unicodestream.h
@@ -0,0 +1,392 @@
+#ifndef _OI_UNICODESTREAM_H
+#define _OI_UNICODESTREAM_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * This file provides unicode stream read and write macros.  Unicode streams consist
+ * of an array of encoded bytes, where the encoding may be UTF-8, UTF-16, etc.  A
+ * unicode stream is a superset of a bytestream, and all the bytestream macros may be
+ * used on unicode streams as well.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_memmgr.h"
+#include "oi_cpu_dep.h"
+#include "oi_endian.h"
+#include "oi_assert.h"
+#include "oi_bytestream.h"
+#include "oi_unicode.h"
+
+/** \addtogroup Misc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This is the structure definition for an unicode encoded text stream.  This structure
+ * is identical to a byte stream, with the addition of an encoding member added.  This
+ * means that all bytestream macros listed in this file can also be used on the text
+ * stream.
+ *
+ * The members of the unicode stream are *PRIVATE* to this file, and must not be
+ * used, except as accessed through the Macros in this header file.
+ */
+typedef struct {
+    OI_UNICODE_ENCODING __encoding; // The encoding of the bytes
+    OI_BYTE *           __bsdata;     // Pointer to an array of bytes of size trueSize
+    OI_UINT16           __trueSize; // Allocated size of data
+    OI_UINT16           __size;     // Current size of the data
+    OI_UINT16           __pos;      // Current read/write pointer
+    OI_UINT8            __RWFlag;   // Are we reading or writing to the byte stream
+    OI_UINT8            __error;    // Error reading or writing to byte stream
+} OI_UNICODE_STREAM;
+
+/**
+ * Initializes a unicode stream.
+ * Must be called before opening the stream with ByteStream_Open.
+ *
+ * @param bs The unicode stream to initialize
+ * @param buf The data buffer to use with the stream
+ * @param size The size of the data buffer
+ * @param encoding The encoding of the data buffer
+ *
+ * void UnicodeStream_Init(OI_UNICODE_STREAM    bs,
+ *                         OI_BYTE *            buf,
+ *                         OI_UINT16            size,
+ *                         OI_UNICODE_ENDOCDING encoding);
+ *
+ */
+
+#define UnicodeStream_Init(bs, buf, size, encoding) \
+{                                                   \
+    OI_ASSERT(buf);                                 \
+    OI_ASSERT((size) > 0);                          \
+    (bs).__error = 0;                               \
+    (bs).__bsdata = (buf);                            \
+    (bs).__trueSize = (size);                       \
+    (bs).__size = (size);                           \
+    (bs).__encoding = (encoding);                   \
+}
+
+/**
+ * Get the encoding of the specified stream.
+ *
+ * @param bs  The unicode stream to query
+ * @return  The encoding of the stream
+ *
+ * OI_UNICODE_ENCODING UnicodeStream_GetEncoding(OI_UNICODE_STREAM bs);
+ */
+
+#define UnicodeStream_GetEncoding(bs) (bs).__encoding
+
+/**
+ * Skips the next n characters in the unicode stream.
+ *
+ * @param bs The stream in which to skip characters
+ * @param count The number of characters to skip
+ *
+ * void UnicodeStream_SkipChar(OI_UNICODE_STREAM  bs,
+ *                             OI_UINT16       count);
+ */
+
+#define UnicodeStream_SkipChar(bs, count)       \
+{                                               \
+    OI_UINT32 ch;                               \
+    OI_UINT16 n;                                \
+    for (n = (count); n; --n) {                 \
+        UnicodeStream_GetChar(bs, ch);          \
+    }                                           \
+}
+
+/**
+ * Skips the next n characters in the stream, checking for validity
+ * of the operation.
+ *
+ * @param bs The stream in which to skip characters
+ * @param count The number of characters to skip
+ *
+ * void UnicodeStream_Skip_Checked(OI_UNICODE_STREAM  bs,
+ *                                 OI_UINT16       count);
+ */
+#define UnicodeStream_SkipChar_Checked(bs, count)   \
+{                                                   \
+    OI_UINT32 ch;                                   \
+    OI_UINT16 n;                                    \
+    for (n = (count); n; --n) {                     \
+        UnicodeStream_GetChar_Checked(bs, ch);      \
+    }                                               \
+}
+
+/*******************************************************************
+ * Unicode stream read functions
+ ******************************************************************/
+
+/**
+ * Reads a unicode character encoded as UTF-8 from a byte stream.
+ *
+ * @param bs The byte stream from which to read the UTF-8 encoded character
+ * @param ch [out] The character obtained
+ *
+ * void UnicodeStream_GetUTF8(OI_UNICODE_STREAM   bs,
+ *                            OI_UINT32        ch);
+ */
+
+#define UnicodeStream_GetUTF8(bs, ch)                                       \
+{                                                                           \
+    OI_INT count;                                                           \
+    OI_BYTE mask;                                                           \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ);                            \
+    OI_ASSERT(((bs).__pos + 1) <= (bs).__size);                             \
+    (ch) = (OI_UINT32) (bs).__bsdata[(bs).__pos++];                           \
+    if ((ch) >= 0xc0) {                                                     \
+        for (count = 5, mask = 0xfc; (ch) <= mask; --count, mask <<= 1) {   \
+        }                                                                   \
+        OI_ASSERT(((bs).__pos + count) <= (bs).__size);                     \
+        (ch) &= ~mask;                                                      \
+        while (count--) {                                                   \
+            (ch) = ((ch) << 6) | ((bs).__bsdata[(bs).__pos++] & 0x3f);        \
+        }                                                                   \
+    }                                                                       \
+}
+
+/**
+ * Reads a unicode character encoded as UTF-8 from a byte stream, checking it
+ * for validity.
+ *
+ * @param bs The byte stream from which to read the UTF-8 encoded character
+ * @param ch [out] The character obtained
+ *
+ * void UnicodeStream_GetUTF8_Checked(OI_UNICODE_STREAM   bs,
+ *                                    OI_UINT32        ch);
+ */
+
+#define UnicodeStream_GetUTF8_Checked(bs, ch)                                   \
+{                                                                               \
+    OI_INT count;                                                               \
+    OI_BYTE mask;                                                               \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ);                                \
+    if (((bs).__pos + 1) <= (bs).__size) {                                      \
+        (ch) = (OI_UINT32) (bs).__bsdata[(bs).__pos++];                           \
+        if ((ch) >= 0xc0) {                                                     \
+            for (count = 5, mask = 0xfc; (ch) <= mask; --count, mask <<= 1) {   \
+            }                                                                   \
+            if (((bs).__pos + count) <= (bs).__size) {                          \
+                (ch) &= ~mask;                                                  \
+                while (count--) {                                               \
+                    (ch) = ((ch) << 6) | ((bs).__bsdata[(bs).__pos++] & 0x3f);    \
+                }                                                               \
+            } else {                                                            \
+                (bs).__error = 1;                                               \
+            }                                                                   \
+        }                                                                       \
+    } else {                                                                    \
+        (bs).__error = 1;                                                       \
+    }                                                                           \
+}
+
+/*
+ * Reads a unicode character encoded as UTF-16 from a byte stream.
+ *
+ * @param bs The byte stream
+ * @param ch [out] The character obtained
+ * @param bo Byte order (endianness) of the stream
+ *
+ * void UnicodeStream_GetUTF16(OI_UNICODE_STREAM   bs,
+ *                             OI_UINT32        ch,
+ *                             OI_UINT8         bo);
+ */
+#define UnicodeStream_GetUTF16(bs, ch, bo)                                                      \
+{                                                                                               \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ);                                                \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) );   \
+    OI_ASSERT(((bs).__pos + 2) <= (bs).__size);                                                 \
+    if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) {                                                     \
+        (ch) = GetUINT16_BigEndian((bs).__bsdata + (bs).__pos);                                   \
+    } else {                                                                                    \
+        (ch) = GetUINT16_LittleEndian((bs).__bsdata + (bs).__pos);                                \
+    }                                                                                           \
+    (bs).__pos += 2;                                                                            \
+    if ((0xd800 <= (ch)) && ((ch) <= 0xdbff)) {                                                 \
+        (ch) = ((ch) & 0x3ff) << 10;                                                            \
+        OI_ASSERT(((bs).__pos + 2) <= (bs).__size);                                             \
+        if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) {                                                 \
+            (ch) |= (GetUINT16_BigEndian((bs).__bsdata + (bs).__pos) & 0x3ff);                    \
+        } else {                                                                                \
+            (ch) |= (GetUINT16_LittleEndian((bs).__bsdata + (bs).__pos) & 0x3ff);                 \
+        }                                                                                       \
+        (ch) += 0x10000;                                                                        \
+        (bs).__pos += 2;                                                                        \
+    }                                                                                           \
+}
+
+/*
+ * Reads a unicode character encoded as UTF-16 from a byte stream, checking it
+ * for validity.
+ *
+ * @param bs The byte stream
+ * @param ch [out] The character obtained
+ * @param bo Byte order (endianness) of the stream
+ *
+ * void UnicodeStream_GetUTF16_Checked(OI_UNICODE_STREAM   bs,
+ *                                     OI_UINT32        ch,
+ *                                     OI_UINT8         bo);
+ */
+#define UnicodeStream_GetUTF16_Checked(bs, ch, bo)                                              \
+{                                                                                               \
+    OI_ASSERT((bs).__RWFlag == BYTESTREAM_READ);                                                \
+    OI_ASSERT( ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) || ((bo) == OI_LITTLE_ENDIAN_BYTE_ORDER) );   \
+    if (((bs).__pos + 2) <= (bs).__size) {                                                      \
+        if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) {                                                 \
+            (ch) = GetUINT16_BigEndian((bs).__bsdata + (bs).__pos);                               \
+        } else {                                                                                \
+            (ch) = GetUINT16_LittleEndian((bs).__bsdata + (bs).__pos);                            \
+        }                                                                                       \
+        (bs).__pos += 2;                                                                        \
+        if ((0xd800 <= (ch)) && ((ch) <= 0xdbff)) {                                             \
+            (ch) = ((ch) & 0x3ff) << 10;                                                        \
+            if (((bs).__pos + 2) <= (bs).__size) {                                              \
+                if ((bo) == OI_BIG_ENDIAN_BYTE_ORDER) {                                         \
+                    (ch) |= (GetUINT16_BigEndian((bs).__bsdata + (bs).__pos) & 0x3ff);            \
+                } else {                                                                        \
+                    (ch) |= (GetUINT16_LittleEndian((bs).__bsdata + (bs).__pos) & 0x3ff);         \
+                }                                                                               \
+                (ch) += 0x10000;                                                                \
+                (bs).__pos += 2;                                                                \
+            } else {                                                                            \
+                (bs).__error = 1;                                                               \
+            }                                                                                   \
+        }                                                                                       \
+    } else {                                                                                    \
+        (bs).__error = 1;                                                                       \
+    }                                                                                           \
+}
+
+/*
+ * Reads a unicode character from a stream.
+ *
+ * @param bs The stream
+ * @param ch [out] The character obtained
+ *
+ * void UnicodeStream_GetChar(OI_UNICODE_STREAM   bs,
+ *                            OI_UINT32        ch)
+ */
+#define UnicodeStream_GetChar(bs, ch)                                           \
+{                                                                               \
+    OI_ASSERT((bs).__encoding != OI_UNICODE_UNKNOWN);                           \
+    switch ((bs).__encoding) {                                                  \
+        case OI_UNICODE_UTF8:                                                   \
+            UnicodeStream_GetUTF8((bs), (ch));                                  \
+            break;                                                              \
+        case OI_UNICODE_UTF16_BE:                                               \
+            UnicodeStream_GetUTF16((bs), (ch), OI_BIG_ENDIAN_BYTE_ORDER);       \
+            break;                                                              \
+        case OI_UNICODE_UTF16_LE:                                               \
+            UnicodeStream_GetUTF16((bs), (ch), OI_LITTLE_ENDIAN_BYTE_ORDER);    \
+            break;                                                              \
+        default:                                                                \
+            break;                                                              \
+    }                                                                           \
+}
+
+/*
+ * Reads a unicode character from a stream, checking it for validity.
+ *
+ * @param bs The stream
+ * @param ch [out] The character obtained
+ *
+ * void UnicodeStream_GetChar_Checked(OI_UNICODE_STREAM   bs,
+ *                                    OI_UINT32        ch)
+ */
+#define UnicodeStream_GetChar_Checked(bs, ch)                                           \
+{                                                                                       \
+    switch ((bs).__encoding) {                                                          \
+        case OI_UNICODE_UTF8:                                                           \
+            UnicodeStream_GetUTF8_Checked((bs), (ch));                                  \
+            break;                                                                      \
+        case OI_UNICODE_UTF16_BE:                                                       \
+            UnicodeStream_GetUTF16_Checked((bs), (ch), OI_BIG_ENDIAN_BYTE_ORDER);       \
+            break;                                                                      \
+        case OI_UNICODE_UTF16_LE:                                                       \
+            UnicodeStream_GetUTF16_Checked((bs), (ch), OI_LITTLE_ENDIAN_BYTE_ORDER);    \
+            break;                                                                      \
+        default:                                                                        \
+            (bs).__error = 1;                                                           \
+            break;                                                                      \
+    }                                                                                   \
+}
+
+/*
+ * Reads a unicode character from a stream, without updating the stream
+ * position.
+ *
+ * @param bs The stream
+ * @param ch [out] The character obtained
+ *
+ * void UnicodeStream_PeekChar(OI_UNICODE_STREAM   bs,
+ *                             OI_UINT32        ch)
+ */
+#define UnicodeStream_PeekChar(bs, ch)          \
+{                                               \
+    OI_UINT16 pos = (bs).__pos;                 \
+    UnicodeStream_GetChar((bs), (ch))           \
+    (bs).__pos = pos;                           \
+}
+
+/*
+ * Reads a unicode character from a stream, checking it for validity.  This
+ * does not update the stream position.
+ *
+ * @param bs The stream
+ * @param ch [out] The character obtained
+ *
+ * void UnicodeStream_PeekChar_Checked(OI_UNICODE_STREAM   bs,
+ *                                     OI_UINT32        ch)
+ */
+#define UnicodeStream_PeekChar_Checked(bs, ch)  \
+{                                               \
+    OI_UINT16 pos = (bs).__pos;                 \
+    UnicodeStream_GetChar_Checked((bs), (ch))   \
+    (bs).__pos = pos;                           \
+}
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_UNICODESTREAM_H */
+
diff --git a/obex_profiles/include/oi_varstring.h b/obex_profiles/include/oi_varstring.h
new file mode 100644
index 0000000..953e689
--- /dev/null
+++ b/obex_profiles/include/oi_varstring.h
@@ -0,0 +1,203 @@
+#ifndef _OI_VARSTRING_H
+#define _OI_VARSTRING_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *  simple variable-length string package
+ *
+ *  A variable-length string is represented by an OI_VARSTRING that keeps track of the maximum and current
+ *  size of a string buffer.
+ *
+ *  Functions are provided for appending strings, and integer values in
+ *  hex or decimal formats to the string as well as some other convenience functions.
+ *
+ *  Unlike C strings, the string buffer in a var string can contain embedded null characters. A
+ *  helper function is provided for converting a var string to a C string.
+ */
+
+#include <stdarg.h>
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+
+/** \addtogroup Misc_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * VarStrings are either managed or unamanged. A managed VarString allocates
+ * it's own buffer and will reallocate a new buffer (freeing the old one) as
+ * required to grow the string. The buffer in an unmanaged VarString is
+ * allocated by the caller.  Unmanaged VarStrings are truncated when the string
+ * reaches the maximum length, which is one less than MaxLen to allow for null
+ * termination.
+ */
+
+typedef struct {
+    OI_BOOL Managed;   /**< Is string buffer managed by VarString */
+    OI_UINT16 MaxLen;  /**< Size of buffer */
+    OI_UINT16 Len;     /**< Current length of string */
+    OI_CHAR* Buffer;   /**< Character buffer */
+    OI_BOOL  Overflow; /**< Indicates that buffer overflow occured */
+} OI_VARSTRING;
+
+
+/**
+ * Reset a VARSTRING to an empty string.
+ */
+#define OI_VStrClear(vstr)        ((vstr)->Len = 0)
+
+
+/**
+ * Accessor function implemented as a macro to obtain the length of a VARSTRING.
+ */
+#define OI_VStrGetLen(vstr)       ((vstr)->Len)
+
+
+/**
+ * Accessor function implemented as a macro to obtain the underlying buffer from
+ * a VARSTRING.
+ *
+ */
+#define OI_VStrGetBuffer(vstr)    ((vstr)->Buffer)
+
+
+/**
+ * Allocate and initialize an empty managed VarString.
+ */
+
+OI_STATUS OI_VStrAlloc(OI_VARSTRING *Vstr,
+                       OI_UINT       size);
+
+
+/**
+ * Free the string buffer for a managed VarString.
+ */
+
+void OI_VStrFree(OI_VARSTRING *Vstr);
+
+
+/**
+ * Append a null terminated C string to a VarString. The null is not appended.
+ */
+
+OI_STATUS OI_VStrCat(OI_VARSTRING *VStr,
+                     const OI_CHAR *Str);
+
+
+/**
+ * Append N characters to a VarString. Any embedded nulls in the source string
+ * will be appended.
+ */
+
+OI_STATUS OI_VStrnCat(OI_VARSTRING  *VStr,
+                      const OI_CHAR *Str,
+                      OI_UINT        N);
+
+/**
+ * Append white space to a VarString
+ */
+
+OI_STATUS OI_VSpaceCat(OI_VARSTRING *VStr,
+                       OI_UINT       Count);
+
+/**
+ * Append a hex integer string to a VarString
+ *
+ * Size is the number of the significant bytes in the integer. The hex value will
+ * be written as (2 * Size) bytes. Leading zeroes are always written.
+ */
+
+OI_STATUS OI_VHexCat(OI_VARSTRING *VStr,
+                     OI_UINT32 Val,
+                     OI_UINT Size);
+
+
+/**
+ *
+ * Append a signed decimal integer string to a VarString.
+ */
+
+OI_STATUS OI_VDecCat(OI_VARSTRING *VStr,
+                     OI_INT32 Val);
+
+/**
+ * OI_VFormatStr
+ *
+ */
+
+OI_STATUS OI_VFormatStr(OI_VARSTRING *VStr,
+                        const OI_CHAR* format,
+                        va_list argp);
+
+/**
+ * sprintf-like formatting into a VarString.
+ */
+
+OI_STATUS OI_FormatStr(OI_VARSTRING *VStr,
+                       const OI_CHAR *format,
+                       ...);
+
+/**
+ * Get null terminated string from a var string. This appends a final null to the
+ * string buffer and returns a pointer to the buffer.
+ */
+
+OI_CHAR* OI_VStrGetString(OI_VARSTRING *VStr);
+
+
+/**
+ * Compare a var string to a C string
+ */
+OI_INT OI_VStrcmp(OI_VARSTRING *VStr,
+                  const OI_CHAR *cStr);
+
+/**
+ * Compare a var string to a C string
+ */
+OI_INT OI_VStrncmp(OI_VARSTRING  *VStr,
+                   const OI_CHAR *cStr,
+                   OI_UINT        len);
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_VARSTRING_H */
+
diff --git a/obex_profiles/include/profiles/oi_obextext.h b/obex_profiles/include/profiles/oi_obextext.h
new file mode 100644
index 0000000..2e11523
--- /dev/null
+++ b/obex_profiles/include/profiles/oi_obextext.h
@@ -0,0 +1,52 @@
+#ifndef _OI_OBEXTEXT_H
+#define _OI_OBEXTEXT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_obexspec.h"
+#include "oi_varstring.h"
+
+
+/**
+ * Returns the string for an OBEX command.
+ */
+const OI_CHAR* OI_OBEX_PktText(OI_UINT8 code);
+
+
+/**
+ * Parses and OBEX header and appends a string description of the header to the VarString.
+ */
+void OI_OBEX_HeaderTxt(OI_VARSTRING *VStr,
+                       OI_OBEX_HEADER *hdr);
+
+
+#endif /* _OI_OBEXTEXT_H */
diff --git a/obex_profiles/platform/linux/include/oi_eventloop.h b/obex_profiles/platform/linux/include/oi_eventloop.h
new file mode 100644
index 0000000..8b8de96
--- /dev/null
+++ b/obex_profiles/platform/linux/include/oi_eventloop.h
@@ -0,0 +1,200 @@
+#ifndef _OI_EVENT_LOOP_H
+#define _OI_EVENT_LOOP_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * Event loop API: platform-specific loop for Linux.
+ */
+
+#include <sys/select.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * A callback function of this type is used by the event loop to find
+ * out which file descriptors to wait on.  It is run on every
+ * iteration of the event loop - possibly very frequently if the loop
+ * is used by any part of the system to monitor sockets - so the
+ * function should not take long to execute.
+ *
+ * The provided fd_sets may already contain file descriptors and are
+ * modified in-place.
+ *
+ * A callback function of this type must be provided in calls to
+ * OI_EVENTLOOP_Register().
+ *
+ * @param  readFds   File descriptors to watch for new incoming data
+ *
+ * @param  writeFds  File descriptors to watch for available output buffer
+ *                   space.
+ *
+ * @param  exceptFds File descriptors to watch for exceptions
+ *
+ * @param  maxFd     Highest FD number set for read/write/except
+ *
+ * @return           The number of file descriptors added (does not count
+ *                   descriptors that were already included in the lists)
+ */
+typedef int (*OI_EVENTLOOP_GET_DESCRIPTORS_CB)(fd_set* readFds,
+                                               fd_set* writeFds,
+                                               fd_set* exceptFds,
+                                               int* maxFd);
+
+/**
+ * A callback function of this type is used by the event loop to
+ * process I/O when an event is detected.  It will run for every event
+ * that triggers the loop, even events not requested by the companion
+ * OI_EVENTLOOP_GET_DESCRIPTORS_CB function, so this function should
+ * be as quick and efficient as possible.  All operations must be
+ * *non-blocking*, except for locking required for multi-threaded
+ * operation.
+ *
+ * When an event for a given file descriptor is handled, the
+ * descriptor should be cleared from the relevant fd_set.
+ *
+ * A callback function of this type must be provided in calls to
+ * OI_EVENTLOOP_Register().
+ *
+ * @param  numSet    Total number of events in all fd_sets
+ *
+ * @param  readFds   File descriptors with data available for reading
+ *
+ * @param  writeFds  File descriptors with output buffer space available
+ *
+ * @param  exceptFds File descriptors with exceptions
+ *
+ * @return           The number of unprocessed events remaining in
+ *                   all fd_sets.
+ */
+typedef int (*OI_EVENTLOOP_HANDLE_EVENTS_CB)(int numSet,
+                                             fd_set* readFds,
+                                             fd_set* writeFds,
+                                             fd_set* exceptFds);
+
+/**
+ * A validate callback function is invoked only when a bad file
+ * descriptor has been detected.  All file descriptors being tracked
+ * by the registered module should be checked for validity by calling
+ * OI_EVENTLOOP_FdIsValid() on the file descriptor.  If
+ * OI_EVENTLOOP_FdIsValid() returns FALSE, the module should clean up
+ * any data associated with that file descriptor.
+ */
+typedef void (*OI_EVENTLOOP_VALIDATE_CB)(void);
+
+/**
+ * This function initializes the event loop module and starts the event
+ * thread.
+ *
+ * @return OI_OK if init is successful; various error codes
+ *         indicating reason for failure otherwise
+ */
+OI_STATUS OI_EVENTLOOP_Init(void);
+
+/**
+ * This function closes down the event loop module and stops the event
+ * thread.
+ *
+ * @return OI_OK if shutdown is successful; various error codes
+ *         indicating reason for failure otherwise
+ */
+OI_STATUS OI_EVENTLOOP_Shutdown(void);
+
+/**
+ * This function registers pairs of callbacks for the event loop to
+ * call to request events to wait on, and to process those events.
+ * These callbacks are used on every iteration of the event loop.
+ *
+ * Callbacks can be registered only once.
+ *
+ * Registrations flagged with "frequentEvents" will have their
+ * handleEvents functions called first.  This way, those functions
+ * remove their events from the fd_sets early, and later handlers
+ * can skip their processing if there are no remaining events to
+ * process.
+ *
+ * @param  getDescriptors   Callback function to get expected events.
+ *
+ * @param  handleEvents     Callback function to process events.
+ *
+ * @param  frequentEvents   Set to TRUE if this pair of functions is
+ *                          expected to trigger and handle lots of
+ *                          events (like socket I/O).
+ *
+ * @return                  OI_OK if the functions are successfully
+ *                          registered; various error codes indicating
+ *                          reason for failure otherwise
+ */
+
+OI_STATUS OI_EVENTLOOP_Register(OI_EVENTLOOP_GET_DESCRIPTORS_CB getDescriptors,
+                                OI_EVENTLOOP_HANDLE_EVENTS_CB handleEvents,
+                                OI_EVENTLOOP_VALIDATE_CB validate,
+                                OI_BOOL frequentEvents);
+
+/**
+ * This function removes pairs of callbacks from the event loop.
+ *
+ * @param  getDescriptors   Callback function to remove.
+ *
+ * @param  handleEvents     Callback function to remove.
+ *
+ * @return                  OI_OK if the functions are successfully
+ *                          deregistered; various error codes indicating reason
+ *                          for failure otherwise
+ */
+
+OI_STATUS OI_EVENTLOOP_Deregister(OI_EVENTLOOP_GET_DESCRIPTORS_CB getDescriptors,
+                                  OI_EVENTLOOP_HANDLE_EVENTS_CB handleEvents,
+                                  OI_EVENTLOOP_VALIDATE_CB validate);
+
+/**
+ * This function forces an iteration of the event loop, which is useful to
+ * update the descriptors.
+ *
+ */
+
+void OI_EVENTLOOP_Wakeup(void);
+
+/**
+ * This function may be called to determine if a file descriptor is still 
+ * valid.  It is typically called within a module's OI_EVENTLOOP_VALIDATE_CB
+ * function.
+ *
+ * @return       TRUE if FD is valid, FALSE if it is not.
+ */
+OI_BOOL OI_EVENTLOOP_FdIsValid(int fd);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OI_EVENT_LOOP_H */
diff --git a/obex_profiles/platform/linux/include/oi_thread_platform.h b/obex_profiles/platform/linux/include/oi_thread_platform.h
new file mode 100644
index 0000000..62ece5b
--- /dev/null
+++ b/obex_profiles/platform/linux/include/oi_thread_platform.h
@@ -0,0 +1,53 @@
+#ifndef _OI_THREAD_PLATFORM_H
+#define _OI_THREAD_PLATFORM_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * platform-specific types for Linux
+ */
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef pthread_mutex_t OI_MUTEX;
+
+typedef pthread_t OI_THREAD;
+
+typedef pthread_cond_t OI_COND;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OI_THREAD_PLATFORM_H */
diff --git a/obex_profiles/platform/linux/src/oi_assert.c b/obex_profiles/platform/linux/src/oi_assert.c
new file mode 100644
index 0000000..50d4b07
--- /dev/null
+++ b/obex_profiles/platform/linux/src/oi_assert.c
@@ -0,0 +1,74 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+Linux implementation of runtime error checking interface defined in oi_assert.h
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#ifndef LINUX
+    #error This file is targeted for LINUX only!!!
+#endif
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "oi_assert.h"
+#include "oi_utils.h"
+#include "oi_debug.h"
+
+int OI_AssertExpected = 0;
+
+#define OI_ASSERT_FAILURE   (0)
+
+void OI_AssertFail(char* file, int line, char* reason)
+{
+    if (OI_AssertExpected) {
+        OI_Printf("AssertFail expected %s@%d : %s\n", file, line, reason);
+        --OI_AssertExpected;
+    } else {
+        int i = 0;
+        OI_Printf("AssertFail %s@%d : %s\n", file, line, reason);
+        fflush(stdout);
+        /*
+         * Allow debugging
+         */
+        i = i / i;  /* Force division by zero to raise an exception */
+    }
+}
+
+
+
+
+
+
+/*****************************************************************************/
diff --git a/obex_profiles/platform/linux/src/oi_osinterface.c b/obex_profiles/platform/linux/src/oi_osinterface.c
new file mode 100644
index 0000000..9a082b8
--- /dev/null
+++ b/obex_profiles/platform/linux/src/oi_osinterface.c
@@ -0,0 +1,118 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * This file includes functions for fatal error handling, printing, and getting
+ * a time value. This file is targeted to the Linux operating system.
+ *
+ * These functions are defined in oi_osinterface.h.
+ */
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#ifndef LINUX
+    #error This file is targeted for LINUX only!!!
+#endif
+
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "oi_time.h"
+#include "oi_utils.h"
+#include "oi_string.h"
+#include "oi_debug.h"
+
+/**
+ *  Compute CRC16 of the program image.
+ */
+OI_UINT16  OI_ProgramImageCRC16(void)
+{
+    /* Not implemented */
+    return (OI_UINT16)0;
+}
+
+/*
+ * Fatal error handler - never returns
+ */
+
+void OI_FatalError(OI_STATUS reason) {
+    OI_Printf("\nFatal error - %d\n", reason);
+    exit(reason) ;
+}
+
+
+/**
+ * Log error handler - indicate module, line number, and status code of error
+ */
+void OI_LogError(OI_MODULE module, OI_INT lineno, OI_STATUS status)
+{
+    /* Send error info to console */
+    OI_Printf("\nOI_SLOG_ERROR: %d,%d,%d\n", module, lineno, status);
+}
+
+void OI_Time_Now(OI_TIME *now)
+{
+    struct timespec ts;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+
+    now->mseconds = ts.tv_nsec / 1000000;
+    now->seconds = ts.tv_sec;
+}
+
+
+void OI_Sleep(OI_UINT32 milliseconds)
+{
+    struct timespec sleeptime;
+
+    sleeptime.tv_sec = milliseconds / 1000;
+    sleeptime.tv_nsec = (milliseconds % 1000) * 1000000;
+
+    nanosleep(&sleeptime, NULL);
+}
+
+/*
+ * Write a string to stdout
+ */
+void OI_Print(OI_CHAR const *str)
+{
+    if (str != NULL) {
+        fputs(str, stdout);
+    }
+    fflush(stdout);
+}
+
+/*****************************************************************************/
diff --git a/obex_profiles/platform/linux/src/oi_thread.c b/obex_profiles/platform/linux/src/oi_thread.c
new file mode 100644
index 0000000..0a6bf6b
--- /dev/null
+++ b/obex_profiles/platform/linux/src/oi_thread.c
@@ -0,0 +1,268 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_thread.h"
+#include <pthread.h>
+#include <time.h>
+#include <errno.h>
+
+OI_BOOL OI_Mutex_Init(OI_MUTEX *mutex)
+{
+    pthread_mutexattr_t attr;
+    int retval;
+
+    retval = pthread_mutexattr_init(&attr);
+
+    if (retval == 0) {
+        retval = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE_NP);
+        if (retval == 0) {
+            retval = pthread_mutex_init(mutex, &attr);
+        }
+        pthread_mutexattr_destroy(&attr);
+    }
+
+    return (retval == 0);
+}
+
+/** Destroy a mutex */
+OI_BOOL OI_Mutex_Destroy(OI_MUTEX *mutex)
+{
+    int retval;
+
+    retval = pthread_mutex_destroy(mutex);
+    return (retval == 0);
+}
+
+/** Lock a mutex */
+OI_BOOL OI_Mutex_Lock(OI_MUTEX *mutex)
+{
+    int retval;
+
+    retval = pthread_mutex_lock(mutex);
+    return (retval == 0);
+}
+
+/** Unlock a mutex */
+OI_BOOL OI_Mutex_Unlock(OI_MUTEX *mutex)
+{
+    int retval;
+
+    retval = pthread_mutex_unlock(mutex);
+    return (retval == 0);
+}
+
+
+OI_BOOL OI_Thread_Create(OI_THREAD *t,
+                         void *(*startRoutine)(void *),
+                         void *arg)
+{
+    int retval;
+
+    retval = pthread_create(t, NULL, startRoutine, arg);
+    if (retval != 0) {
+        return FALSE;
+    }
+    else {
+        return TRUE;
+    }
+}
+
+void OI_Thread_Join(OI_THREAD t)
+{
+    pthread_join(t, NULL);
+
+}
+
+void OI_Thread_Exit(void *retval)
+{
+    pthread_exit(retval);
+
+}
+
+/**
+ * Initialize a condition variable
+ *
+ * @param  the condition variable to initialize
+ */
+OI_BOOL OI_Cond_Init(OI_COND *cond)
+{
+    int ret;
+
+    ret = pthread_cond_init(cond, NULL);
+
+    if (0 == ret) {
+        return TRUE;
+    }
+    else {
+        return FALSE;
+    }
+}
+
+/**
+ * Wake a single thread waiting on the specified condition variable.
+ *
+ * @param  the condition variable
+ */
+OI_BOOL OI_Cond_Signal(OI_COND *cond)
+{
+    int ret;
+
+    ret = pthread_cond_signal(cond);
+    if (0 == ret) {
+        return TRUE;
+    }
+    else {
+        return FALSE;
+    }
+}
+
+/**
+ * Wake all threads waiting on the specified condition variable.
+ *
+ * @param  the condition variable
+ */
+OI_BOOL OI_Cond_Broadcast(OI_COND *cond)
+{
+    int ret;
+
+    ret = pthread_cond_broadcast(cond);
+    if (0 == ret) {
+        return TRUE;
+    }
+    else {
+        return FALSE;
+    }
+}
+
+/**
+ * Wait for the specified condition variable to become signalled.  The
+ * mutex paramter must be locked before calling this function.
+ *
+ * @param  the condition variable
+ * @param  the mutex
+ */
+OI_BOOL OI_Cond_Wait(OI_COND *cond,
+                     OI_MUTEX *mutex)
+{
+    int ret;
+
+    ret = pthread_cond_wait(cond, mutex);
+    if (0 == ret) {
+        return TRUE;
+    }
+    else {
+        return FALSE;
+    }
+}
+
+/**
+ * Wait for the specified condition variable to become signalled or
+ * until the specified time has been exceeded.  The mutex paramter
+ * must be locked before calling this function.
+ *
+ * @param  the condition variable
+ * @param  the mutex
+ * @param  the number of milliseconds to wait
+ *
+ * @return  OI_OK if signaled, OI_TIMEOUT if a timeout occured, or another value if an error ocurred
+ */
+OI_STATUS OI_Cond_TimedWait(OI_COND *cond,
+                            OI_MUTEX *mutex,
+                            OI_UINT32 msec)
+{
+    int ret;
+    struct timespec ts;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    ts.tv_sec += (msec / 1000);
+    ts.tv_nsec += ((msec % 1000) * 1000000);
+
+    ret = pthread_cond_timedwait(cond, mutex, &ts);
+
+    if (0 == ret) {
+        return OI_OK;
+    }
+    else if (ETIMEDOUT == ret) {
+        return OI_TIMEOUT;
+    }
+    else {
+        return ret;
+    }
+}
+
+/**
+ * Destroy the specified condition variable
+ *
+ * @param  the condition variable
+ */
+OI_BOOL OI_Cond_Destroy(OI_COND *cond)
+{
+    int ret;
+
+    ret = pthread_cond_destroy(cond);
+    if (0 == ret) {
+        return TRUE;
+    }
+    else {
+        return FALSE;
+    }
+}
+
+/* Unsigned divide by 1000. See http://www.hackersdelight.org/divcMore.pdf for
+ * details. Explicitly verified correct for 0 <= x <= 0xFFFFFFFF.
+ * */
+static __inline OI_UINT32 divu1000(OI_UINT32 n)
+{
+    OI_UINT32 q, r, t;
+
+    t = (n >> 7) + (n >> 8) + (n >> 12);
+    q = (n >> 1) + t + (n >> 15) + (t >> 11) + (t >> 14);
+    q >>= 9;
+    r = n - q*1000;
+    return q + ((r + 24) >> 10);
+}
+
+/**
+ * OI_Milliseconds provides the caller with a 32 bit free running ms time base.
+ */
+OI_UINT32 OI_Milliseconds( void )
+{
+    struct timespec ts;
+    OI_UINT32       ret_val;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+
+    ret_val = ((OI_UINT32)ts.tv_sec) * 1000;
+    ret_val += (OI_UINT32)ts.tv_nsec / 1000000;
+
+    return ret_val;
+}
diff --git a/obex_profiles/platform/linux/src/oi_wrapper.c b/obex_profiles/platform/linux/src/oi_wrapper.c
new file mode 100644
index 0000000..540fac3
--- /dev/null
+++ b/obex_profiles/platform/linux/src/oi_wrapper.c
@@ -0,0 +1,441 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * Sample protocol stack manager for Linux
+ *
+ * This example protocol stack wrapper for Linux is provided to demonstrate
+ * application-level management of the BLUEmagic 3.0 protocol stack and support modules.
+ * The stack wrapper initializes the protocol stack and support modules and provides
+ * a stack access token to enforce exclusive access to the protocol stack.
+ *
+ * The stack access token is an operating-system-specific mechanism used to ensure that
+ * only one process at a time attempts to make function calls into the protocol stack code.
+ * Since the Linux operating system provides a mutex capability, the stack access token
+ * for this platform is a mutex. On some other operating systems, other schemes using
+ * binary sempahores may be used.
+ *
+ * The application must call OI_Wrapper_Init() to initialize the stack wrapper module,
+ * including the synchronization scheme.
+ *
+ * The application must get the stack access token with OI_Wrapper_GetToken()
+ * in order to make calls into the BLUEmagic 3.0 protocol stack. The application must
+ * release the stack access token from time to time with OI_Wrapper_ReleaseToken()
+ * in order to give other processes (the transport thread(s) and the dispatch thread)
+ * an opportunity to run.
+ */
+
+#ifndef LINUX
+    #error This file is targeted for LINUX only!!!
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <errno.h>
+
+#include "oi_bt_stack_init.h"
+#include "oi_bt_module_init.h"
+
+#include "oi_debug.h"
+#include "oi_osinterface.h"
+#include "oi_time.h"
+#include "oi_statustext.h"
+#include "oi_wrapper.h"
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_utils.h"
+
+/*
+ * Globals and defines
+ */
+#define LONG_WAIT (60 * 60)     /**< Wait this long (in seconds) while we are idle. */
+#define THREAD_STACK_SIZE 4096  /**< The stack size of the dispatch thread. */
+
+static OI_UINT32 idleLoopSleepTime;
+static pthread_t StackThread;                  /**< AKA the dispatcher thread. */
+static pthread_cond_t idler;                   /**< A condition variable to block the stack loop when the stack has nothing to do. */
+static pthread_mutex_t idlerMutex;             /**< The mutex belonging to the idler condition variable, which also protects ServiceTime. */
+static OI_TIME ServiceTime;                    /**< The time when the Dispatcher next requires service. */
+static OI_BOOL runStackLoop = FALSE;           /**< Semaphore to communicate to the dispatch thread. */
+static OI_BOOL someInitCompleted;              /**< Callback flag signals device configuration completion. */
+static pthread_mutex_t stackAccessMutex;       /**< The stack access mutex is the token that determines which process may enter
+                                                    the protocol stack. */
+
+/**
+ * This function initializes the synchronization mechanism.
+ */
+static OI_STATUS OI_WrapperToken_Init(void)
+{
+    int initStatus;
+
+    pthread_mutexattr_t mutexAttr;
+    pthread_mutexattr_init(&mutexAttr);
+    /*
+     * Initialize a recursive mutex.
+     *
+     * When pthread_mutex_lock() is called on a mutex that is already
+     * locked by the calling thread, it will increment an internal
+     * counter and return immediately.  pthread_mutex_unlock() will
+     * decrement that internal counter, releasing the lock when it has
+     * been unlocked the same number of times it was locked.
+     *
+     * Recursive mutexes also include error checking when unlocking a
+     * mutex owned by another thread, or an already-unlocked mutex.
+     */
+    pthread_mutexattr_settype(&mutexAttr, PTHREAD_MUTEX_RECURSIVE);
+
+    initStatus = pthread_mutex_init(&stackAccessMutex, &mutexAttr);
+    pthread_mutexattr_destroy(&mutexAttr);
+    if (initStatus != 0) {
+        OI_DBGTRACE(("Failed to intialize the stack sync token: %s", strerror(initStatus)));
+        return OI_STATUS_INITIALIZATION_FAILED;
+    } else {
+        return OI_OK;
+    }
+}
+
+
+void OI_Wrapper_GetToken(void)
+{
+    int lockStatus;
+
+    lockStatus = pthread_mutex_lock(&stackAccessMutex);
+    if (lockStatus != 0) {
+        OI_DBGTRACE(("Error getting the stack sync token on thread %x: %s\n",
+            pthread_self(), strerror(lockStatus)));
+    }
+}
+
+
+void OI_Wrapper_GetTokenRecursive(void)
+{
+    /*
+     * Since stackAccessMutex is configured as a recursive mutex, the
+     * normal "get token" operation is already recursive.
+     */
+    OI_Wrapper_GetToken();
+}
+
+
+void OI_Wrapper_ReleaseToken(void)
+{
+    int unlockStatus;
+
+    unlockStatus = pthread_mutex_unlock(&stackAccessMutex);
+    if (unlockStatus != 0) {
+        OI_DBGTRACE(("Error releasing the stack sync token on thread %x: %s\n",
+            pthread_self(), strerror(unlockStatus)));
+    }
+}
+
+
+void OI_Wrapper_ReleaseTokenRecursive(void)
+{
+    /*
+     * Since stackAccessMutex is configured as a recursive mutex, the
+     * normal "release token" operation is already recursive.
+     */
+    OI_Wrapper_ReleaseToken();
+}
+
+static void stackInitCb(OI_STATUS status)
+{
+    if (!OI_SUCCESS(status)) {
+        OI_DBGTRACE(("stackInitCb, status %d\n", status) );
+        OI_FatalError(status);
+    }
+    OI_Wrapper_SignalEvent(&someInitCompleted) ;
+}
+
+
+/**
+ * This callback function handles service requests.  This function saves
+ * requested service time, while the StackLoop() function checks the value.
+ */
+static void ServiceRequestHandler(OI_UINT msec)
+{
+   OI_TIME update;
+   OI_UINT secs;
+
+   if (msec == 0) {
+        /*
+         * The Dispatcher wants service now.
+         */
+       pthread_mutex_lock(&idlerMutex);
+       OI_Time_Now(&ServiceTime);
+       pthread_cond_signal(&idler);
+       pthread_mutex_unlock(&idlerMutex);
+   } else {
+       OI_Time_Now(&update);
+       msec += update.mseconds;
+       secs = msec / 1000;
+       update.seconds += secs;
+       update.mseconds = msec - (secs * 1000);
+       /*
+        * If the updated service time is earlier than the previous service time
+        * we need to let the stack loop know about it.
+        * The mutex must be locked to protect accesses to ServiceTime, but
+        * the condition variable is only signaled if ServiceTime is changed.
+        */
+       pthread_mutex_lock(&idlerMutex);
+       if (OI_Time_Compare(&update, &ServiceTime) < 0) {
+           ServiceTime = update;
+           pthread_cond_signal(&idler);
+       }
+       pthread_mutex_unlock(&idlerMutex);
+   }
+}
+
+
+/**
+ * This is the thread in which the real work gets done. This function uses a
+ * mutex to synchronize execution between the application and the stack. This
+ * function also demonstrates handling of the requested service time.
+ * ServiceRequestHandler() saves the requested value, while this function
+ * decrements the requested time by the amount of time elapsed since the last
+ * run. Once the time has expired, this function calls into the stack. This
+ * implementation is designed to present the basic usage model for the service
+ * request without complex system calls.
+ */
+static void* StackLoop(void *arg)
+{
+    struct timespec timeout;
+
+    while (runStackLoop) {
+        /*
+         * If the service timeout has already expired or we have waited and it has
+         * expired, then the Dispatcher has work to do.
+         */
+        pthread_mutex_lock(&idlerMutex);
+
+        timeout.tv_sec = ServiceTime.seconds;
+        timeout.tv_nsec = 1000000 * ServiceTime.mseconds;
+
+        pthread_cond_timedwait(&idler, &idlerMutex, &timeout);
+
+        if (!runStackLoop) {
+            OI_DBGTRACE(("Exiting StackLoop\n"));
+            pthread_mutex_unlock(&idlerMutex);
+            return NULL;
+        }
+
+        /*
+         * The Dispatcher will reset this value if there is more work
+         * to be done.  Like all access to ServiceTime, this needs to
+         * be done while idlerMutex is locked by this thread.
+         */
+        ServiceTime.seconds += LONG_WAIT;
+
+        pthread_mutex_unlock(&idlerMutex);
+
+        OI_Wrapper_GetToken() ;
+        while(OI_Dispatch_Run());
+        OI_Wrapper_ReleaseToken();
+    }
+    return NULL;
+}
+
+
+/**
+ * Allow the Dispatcher to run. The period that the idle loop sleeps is set in
+ * the call to OI_Wrapper_Init().
+ */
+static void idleLoop(void)
+{
+    if (idleLoopSleepTime) {
+        OI_Sleep(idleLoopSleepTime);
+    } else {
+        OI_Sleep(1);
+    }
+}
+
+
+OI_STATUS OI_OBEX_Init(OI_UINT32 idleSleepMsecs)
+{
+    return(OI_Wrapper_Init_Custom(idleSleepMsecs, NULL)) ;
+}
+
+
+OI_STATUS OI_Wrapper_Init_Custom(OI_UINT32 idleSleepMsecs, void (*customCB)(void))
+{
+    OI_STATUS retVal = OI_OK ;
+
+    idleLoopSleepTime = idleSleepMsecs;
+
+    runStackLoop = TRUE;
+
+    /*
+     * Initialize the stack synchronization module.
+     */
+    retVal = OI_WrapperToken_Init();
+    if (!OI_SUCCESS(retVal)) {
+        OI_Print("OI_WrapperToken_Init failed\n");
+        OI_FatalError(retVal);
+    }
+    /*
+     * Get token to access stack. This will block other threads from
+     * accessing the stack for now.
+     */
+    OI_Wrapper_GetToken() ;
+
+    /*
+     * Initialize a condition variable (and associated mutex) that will be used
+     * to signal to the stack loop when to call the Dispatcher.
+     */
+    pthread_cond_init(&idler, NULL);
+
+    pthread_mutex_init(&idlerMutex, NULL);
+
+    /*
+     * Create and start the stack (Dispatcher) thread. It will not actually be
+     * able to run until we let go of the stack token.
+     */
+    if (pthread_create(&StackThread, NULL, StackLoop, NULL) != 0) {
+        perror("Failed to CreateThread ");
+        OI_FatalError(OI_STATUS_INITIALIZATION_FAILED);
+    }
+    /*
+     * Request stack (Dispatcher) service immediately.
+     */
+    ServiceRequestHandler(0);
+    /*
+     * Initialize the protocol stack.
+     */
+    someInitCompleted = FALSE;
+    retVal = OI_BT_StackInit_Custom(stackInitCb, ServiceRequestHandler, customCB);
+    if (!OI_SUCCESS(retVal)) {
+        OI_Print("OI_BT_StackInit_Custom failed\n");
+        OI_FatalError(retVal);
+    }
+    OI_Wrapper_ReleaseToken();
+
+    return(OI_OK) ;
+}
+
+static OI_BOOL terminateDone = FALSE;
+static void terminateBM3(void)
+{
+    OI_STATUS   status;
+
+    terminateDone = FALSE;
+    OI_DBGTRACE(("Terminating stack\n"));
+    status = OI_BT_Stack_Terminate();
+    if (!OI_SUCCESS(status)) {
+        OI_DBGTRACE(("OI_BT_Stack_Terminate failed: %d\n", status));
+    }
+    OI_DBGTRACE(("Terminating stack done\n"));
+}
+
+void OI_OBEX_Deinit(void)
+{
+    OI_STATUS retVal;
+
+    OI_DBGTRACE(("OI_OBEX_Deinit\n"));
+    /*
+     * First set non-discoverable
+     */
+    OI_Wrapper_GetToken();
+    terminateDone = FALSE;
+    /*
+     * Terminate the stack itself.
+     */
+    terminateBM3();
+    OI_Wrapper_ReleaseToken();     /* Done with token forever */
+    /*
+     * Tell the loop thread to terminate and wait until it has done so.
+     */
+    runStackLoop = FALSE;
+
+    /*
+     * Request stack (Dispatcher) service immediately.
+     */
+    ServiceRequestHandler(0);
+
+    pthread_join(StackThread, NULL);
+
+    pthread_mutex_destroy(&stackAccessMutex);
+    pthread_mutex_destroy(&idlerMutex);
+    pthread_cond_destroy(&idler);
+
+    OI_DBGPRINTSTR(("OI_Wrapper_Terminate done\n")) ;
+}
+
+
+OI_STATUS OI_Wrapper_WaitForEvent(OI_BOOL *pEventFlag,
+                                       OI_UINT timeoutSeconds)
+{
+    OI_BOOL timedOut = FALSE ;
+    OI_TIME endTime ;
+    OI_TIME timeNow ;
+
+    /*
+     * Set up end time.
+     */
+    OI_Time_Now(&endTime) ;
+    endTime.seconds += timeoutSeconds;
+
+    /*
+     * Wait for event or timeout.
+     */
+    while (!(*pEventFlag) && !timedOut) {
+        /*
+         * Take a break so that the CPU is not hoarded.
+         */
+        idleLoop() ;
+        /*
+         * Check for timeout.
+         */
+        if (timeoutSeconds) {
+            OI_Time_Now(&timeNow) ;
+            if (OI_Time_Compare(&timeNow, &endTime) >= 0) {
+                timedOut = TRUE;
+            }
+        }
+    }
+
+    /*
+     * Return appropriate status to caller.  Note that is possible that both termination
+     * conditions may have occurred contemporaneously.
+     */
+    if (*pEventFlag) {
+        *pEventFlag = FALSE;
+        return OI_OK;
+    } else {
+        return OI_TIMEOUT;
+    }
+}
+
+
+OI_STATUS OI_Wrapper_SignalEvent (OI_BOOL *pEventFlag)
+{
+    *pEventFlag = TRUE ;
+    return OI_OK  ;
+}
diff --git a/obex_profiles/platform/linux/src/sockets/oi_eventloop.c b/obex_profiles/platform/linux/src/sockets/oi_eventloop.c
new file mode 100644
index 0000000..107b4d8
--- /dev/null
+++ b/obex_profiles/platform/linux/src/sockets/oi_eventloop.c
@@ -0,0 +1,417 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_SOCKETS
+
+#include "oi_thread.h"
+#include "oi_eventloop.h"
+#include "oi_wrapper.h"
+#include "oi_assert.h"
+#include "oi_utils.h"
+#include "oi_list.h"
+#include "oi_argcheck.h"
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include "oi_debug.h"
+
+// Indexes into the FD array returned by pipe()
+#define READ_PIPE (0)
+#define WRITE_PIPE (1)
+
+typedef struct _EVENTLOOP_REGISTERED_ITEM {
+    OI_EVENTLOOP_GET_DESCRIPTORS_CB getDescriptors;
+    OI_EVENTLOOP_HANDLE_EVENTS_CB handleEvents;
+    OI_EVENTLOOP_VALIDATE_CB validate;
+    OI_LIST_ELEM links;
+} EVENTLOOP_REGISTERED_ITEM;
+
+static int WakeupFD[2];
+static OI_BOOL loopExit;
+
+static OI_LIST_ELEM callbackList;
+static OI_THREAD thread;
+
+void OI_EVENTLOOP_Wakeup(void)
+{
+    // Do not acquire the token in this function, it can cause deadlocks.
+    int result;
+    char aByte = '\0';
+
+    result = write(WakeupFD[WRITE_PIPE], &aByte, 1);
+}
+
+static int getWakeupFds(fd_set* readFds, fd_set* writeFds, fd_set* exceptFds, int* maxFd)
+{
+    /*
+     * Token already held by caller.  WakeupFD[] isn't modified after
+     * init, so it is ok to access without the token.
+     */
+
+    int numFds = 1;
+
+    // Always watch the wakeup pipe
+    FD_SET(WakeupFD[READ_PIPE], readFds);
+    *maxFd = WakeupFD[READ_PIPE];
+
+    return numFds;
+}
+
+static int handleWakeup(int numSet, fd_set* readFds, fd_set* writeFds, fd_set* exceptFds)
+{
+    // Token already held by caller, but is only needed for logging/printing.
+    int result;
+    OI_BYTE readBuf[32];
+
+    if (FD_ISSET(WakeupFD[READ_PIPE], readFds)) {
+        /*
+         * Try to empty the pipe - don't want to leave bytes queued
+         * in the wakeup pipe.
+         */
+        result = read(WakeupFD[READ_PIPE], &readBuf, OI_ARRAYSIZE(readBuf));
+        FD_CLR(WakeupFD[READ_PIPE], readFds);
+        numSet--;
+        OI_DBGPRINTSTR(("handleWakeup()"));
+    }
+
+    if (FD_ISSET(WakeupFD[READ_PIPE], writeFds)) {
+        OI_SLOG_ERROR(OI_STATUS_INTERNAL_ERROR, ("Unexpected write flag on wakeup pipe"));
+        FD_CLR(WakeupFD[READ_PIPE], writeFds);
+        numSet--;
+    }
+
+    if (FD_ISSET(WakeupFD[READ_PIPE], exceptFds)) {
+        OI_SLOG_ERROR(OI_STATUS_INTERNAL_ERROR, ("Exception on wakeup pipe"));
+        FD_CLR(WakeupFD[READ_PIPE], exceptFds);
+        numSet--;
+    }
+
+    return numSet;
+}
+
+
+
+static void* eventThread(void* arg)
+{
+    // "Main loop" integration
+
+    while (!loopExit) {
+        fd_set readFds;
+        fd_set writeFds;
+        fd_set exceptFds;
+        int maxFd;
+        int numFds;
+        int numSet;
+        OI_LIST_ELEM* head;
+        EVENTLOOP_REGISTERED_ITEM marker;
+        OI_DBGPRINT(("%s", __func__));
+        marker.getDescriptors = NULL;
+        marker.handleEvents = NULL;
+
+        FD_ZERO(&readFds);
+        FD_ZERO(&writeFds);
+        FD_ZERO(&exceptFds);
+
+        OI_Wrapper_GetToken();
+
+        numFds = getWakeupFds(&readFds, &writeFds, &exceptFds, &maxFd);
+
+        /*
+         * Set up marker -- used for walking the linked list in a way
+         * that allows on-the-fly modification.
+         */
+        OI_List_DynamicInit(&marker.links);
+        OI_List_AddTail(&marker.links, &callbackList);
+
+        head = OI_List_RemoveHead(&callbackList);
+        while (head != &marker.links) {
+            EVENTLOOP_REGISTERED_ITEM* item;
+            int thisMaxFd;
+
+            item = OI_LIST_ENTRY(head, EVENTLOOP_REGISTERED_ITEM, links);
+            OI_ASSERT(NULL != item);
+            /*
+             * Rotate list element to the end of the linked list,
+             * where it can be safely removed if the getDescriptors()
+             * call chooses to do so.
+             */
+            OI_List_AddTail(&item->links, &callbackList);
+
+            OI_ASSERT(NULL != item->getDescriptors);
+            numFds += item->getDescriptors(&readFds, &writeFds, &exceptFds, &thisMaxFd);
+            maxFd = OI_MAX(maxFd, thisMaxFd);
+
+            head = OI_List_RemoveHead(&callbackList);
+        }
+
+        /*
+         * ! Important - 'marker' is on the stack and cannot be in the
+         * queue when the above while loop exits!
+         */
+        OI_ASSERT(head == &marker.links);
+
+#ifndef ANDROID
+        OI_DBGPRINT(("Waiting on %d FDs: read=%08x, write=%08x, except=%08x",
+                      numFds,
+                      __FDS_BITS(&readFds)[0],
+                      __FDS_BITS(&writeFds)[0],
+                      __FDS_BITS(&exceptFds)[0]));
+#endif
+        OI_DBGPRINTSTR(("Event loop about to call select()"));
+        OI_Wrapper_ReleaseToken();
+
+        numSet = select(maxFd+1,
+                        &readFds,
+                        &writeFds,
+                        &exceptFds,
+                        NULL);
+
+        if (loopExit) {
+            OI_DBGPRINTSTR(("Exiting Event loop"));
+            // If another thread has shut this loop down, exit now.
+            return NULL;
+        }
+
+        // Token is needed while calling handler functions.
+        OI_Wrapper_GetToken();
+        OI_DBGPRINTSTR(("Event loop running."));
+#ifndef ANDROID
+        OI_DBGPRINT(("Got %d events: read=%08x, write=%08x, except=%08x",
+                      numSet,
+                      __FDS_BITS(&readFds)[0],
+                      __FDS_BITS(&writeFds)[0],
+                      __FDS_BITS(&exceptFds)[0]));
+#endif
+
+        if (-1 == numSet) {
+            switch (errno) {
+            case EINTR:
+                /*
+                 * EINTR errors are benign - set numSet to 0 so processing happens
+                 * normally.
+                 */
+                numSet = 0;
+                break;
+            case EBADF:
+                /* select() returned a recoverable error.
+                 * Run the dispatcher in case anything there is trying to
+                 * clean up defunct sockets.
+                 */
+                while(OI_Dispatch_Run());
+                break;
+            default:
+                /*
+                 * Something is severely wrong.
+                 */
+                OI_SLOG_ERROR(OI_OS_ERROR, ("Unexpected select() error %d: %s", errno, strerror(errno)));
+                break;
+            }
+        }
+
+        /*
+         * Set up marker -- used for walking the linked list in a way
+         * that allows on-the-fly modification.
+         */
+        OI_List_DynamicInit(&marker.links);
+        OI_List_AddTail(&marker.links, &callbackList);
+
+        head = OI_List_RemoveHead(&callbackList);
+        while (head != &marker.links) {
+            EVENTLOOP_REGISTERED_ITEM* item;
+            item = OI_LIST_ENTRY(head, EVENTLOOP_REGISTERED_ITEM, links);
+            OI_ASSERT(NULL != item);
+
+            /*
+             * Rotate list element to the end of the linked list,
+             * where it can be safely removed if the getDescriptors()
+             * call chooses to do so.
+             */
+            OI_List_AddTail(&item->links, &callbackList);
+
+            if (numSet >= 0) {
+                /* File descriptors are valid, process them. */
+                OI_ASSERT(NULL != item->handleEvents);
+                numSet = item->handleEvents(numSet, &readFds, &writeFds, &exceptFds);
+            }
+            else {
+                /* select() returned -1 for errors.  Trigger validation. */
+                OI_ASSERT(NULL != item->validate);
+                item->validate();
+            }
+            head = OI_List_RemoveHead(&callbackList);
+        }
+
+        /*
+         * ! Important - 'marker' is on the stack and cannot be in the
+         * queue when the above while loop exits!
+         */
+        OI_ASSERT(head == &marker.links);
+
+        if (numSet > 0) {
+            numSet = handleWakeup(numSet, &readFds, &writeFds, &exceptFds);
+        }
+
+        // All events should have been handled.
+        if (0 != numSet) {
+            OI_DBGPRINT(("Not all events were handled in the event loop (%d remaining).", numSet));
+        }
+
+        OI_Wrapper_ReleaseToken();
+    }
+
+    return NULL;
+}
+
+// Init
+OI_STATUS OI_EVENTLOOP_Init(void)
+{
+    int ret;
+
+    // Set up wakeup pipe
+    if (-1 == pipe(WakeupFD)) {
+        return OI_FAIL;
+    }
+
+    /* Do nonblocking reads & writes on the wakeup pipe, since it is
+     * important to avoid blocking while the stack token or DBUS locks
+     * are held.
+     */
+    fcntl(WakeupFD[READ_PIPE], F_SETFL, O_NONBLOCK);
+    fcntl(WakeupFD[WRITE_PIPE], F_SETFL, O_NONBLOCK);
+
+    // Set up handler list
+    OI_List_DynamicInit(&callbackList);
+
+    // Start thread.
+    OI_DBGPRINTSTR(("Starting event loop"));
+    loopExit = FALSE;
+    ret = OI_Thread_Create(&thread, eventThread, NULL);
+    OI_DBGPRINT(("OI_Thread_Create returned %d", ret));
+
+    return OI_OK;
+}
+
+
+OI_STATUS OI_EVENTLOOP_Shutdown(void)
+{
+    OI_LIST_ELEM* elem;
+
+    loopExit = TRUE;
+    OI_EVENTLOOP_Wakeup();
+
+    OI_Thread_Join(thread);
+
+    close(WakeupFD[WRITE_PIPE]);
+    close(WakeupFD[READ_PIPE]);
+
+    // Free callback list elements.
+    elem = OI_List_RemoveHead(&callbackList);
+    while (NULL != elem) {
+        free(OI_LIST_ENTRY(elem, EVENTLOOP_REGISTERED_ITEM, links));
+        elem = OI_List_RemoveHead(&callbackList);
+    }
+
+    return OI_OK;
+}
+
+OI_STATUS OI_EVENTLOOP_Register(OI_EVENTLOOP_GET_DESCRIPTORS_CB getDescriptors,
+                                OI_EVENTLOOP_HANDLE_EVENTS_CB handleEvents,
+                                OI_EVENTLOOP_VALIDATE_CB validate,
+                                OI_BOOL frequentEvents)
+{
+    EVENTLOOP_REGISTERED_ITEM* newItem;
+
+    OI_ARGCHECK(getDescriptors);
+    OI_ARGCHECK(handleEvents);
+    OI_ARGCHECK(validate);
+
+    newItem = malloc(sizeof(EVENTLOOP_REGISTERED_ITEM));
+    if (NULL == newItem) {
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+
+    newItem->getDescriptors = getDescriptors;
+    newItem->handleEvents = handleEvents;
+
+    if (frequentEvents) {
+        OI_List_Add(&newItem->links, &callbackList);
+    }
+    else {
+        OI_List_AddTail(&newItem->links, &callbackList);
+    }
+
+    return OI_OK;
+}
+
+
+
+OI_STATUS OI_EVENTLOOP_Deregister(OI_EVENTLOOP_GET_DESCRIPTORS_CB getDescriptors,
+                                  OI_EVENTLOOP_HANDLE_EVENTS_CB handleEvents,
+                                  OI_EVENTLOOP_VALIDATE_CB validate)
+{
+    OI_STATUS status = OI_STATUS_INVALID_PARAMETERS;
+    OI_LIST_ELEM* elem;
+
+    OI_LIST_FOREACH(elem, &callbackList) {
+        EVENTLOOP_REGISTERED_ITEM* item;
+        item = OI_LIST_ENTRY(elem, EVENTLOOP_REGISTERED_ITEM, links);
+
+        if ((item->getDescriptors == getDescriptors) &&
+            (item->handleEvents   == handleEvents) &&
+            (item->validate       == validate)) {
+            OI_List_Del(elem);
+            free(item);
+            status = OI_OK;
+            break;
+        }
+    }
+
+    return status;
+}
+
+OI_BOOL OI_EVENTLOOP_FdIsValid(int fd)
+{
+    struct timeval timeout;
+    fd_set readFds;
+
+    if (fd < 0) {
+        return FALSE;
+    }
+
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 0;
+    FD_ZERO(&readFds);
+    FD_SET(fd, &readFds);
+
+    /* Non-negative return value from select() indicates a valid FD */
+    return (0 <= select(fd+1, &readFds, NULL, NULL, &timeout));
+}
diff --git a/obex_profiles/profiles/obex/obex_lower.c b/obex_profiles/profiles/obex/obex_lower.c
new file mode 100644
index 0000000..44acb65
--- /dev/null
+++ b/obex_profiles/profiles/obex/obex_lower.c
@@ -0,0 +1,182 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_OBEX_SRV
+
+#include "oi_stddefs.h"
+#include "oi_memmgr.h"
+#include "oi_status.h"
+#include "oi_connect_policy.h"
+#include "oi_obex_lower.h"
+#include "oi_obextest.h"
+#include "oi_varstring.h"
+#include "oi_argcheck.h"
+
+static btsock_interface_t *sock_ifc;
+
+#ifdef OI_DEBUG
+OI_CHAR* OI_OBEX_LowerProtocolTxt(OI_OBEX_LOWER_PROTOCOL *lowerProtocol)
+{
+    static OI_CHAR txt[16];
+    OI_VARSTRING vstr;
+
+    vstr.Managed = FALSE;
+    vstr.MaxLen = sizeof(txt) - 1;
+    vstr.Len = 0;
+    vstr.Buffer = txt;
+    vstr.Overflow = FALSE;
+
+    switch (lowerProtocol->protocol) {
+        case OI_OBEX_LOWER_NONE:
+            OI_FormatStr(&vstr, "NONE");
+            break;
+        case OI_OBEX_LOWER_RFCOMM:
+            OI_FormatStr(&vstr, "RFCOMM channel=%d", lowerProtocol->svcId.rfcommChannel);
+            break;
+        case OI_OBEX_LOWER_L2CAP:
+            OI_FormatStr(&vstr, "L2CAP psm=%d", lowerProtocol->svcId.l2capPSM);
+            break;
+        case OI_OBEX_LOWER_TCPIP:
+            OI_FormatStr(&vstr, "TCPIP addr=%@", lowerProtocol->svcId.ipAddress, 8);
+            break;
+        default:
+            OI_FormatStr(&vstr, "Unknown protocol %d", lowerProtocol->protocol);
+            break;
+    }
+    return OI_VStrGetString(&vstr);
+
+}
+#endif
+
+
+OI_STATUS OI_OBEX_LOWER_RegisterServer(const OI_OBEX_LOWER_CALLBACKS *callbacks,
+                                       OI_UINT16 mtu,
+                                       const OI_CONNECT_POLICY *policy,
+                                       OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                                       OI_OBEX_LOWER_SERVER *lowerServer)
+{
+    OI_STATUS status;
+    const OI_OBEX_LOWER_INTERFACE *ifc = NULL;
+    OI_OBEX_LOWER_SERVER server;
+
+    OI_ARGCHECK(callbacks);
+    OI_ARGCHECK(lowerProtocol);
+    OI_ARGCHECK(lowerServer);
+
+    *lowerServer = NULL;
+
+    switch (lowerProtocol->protocol) {
+        case OI_OBEX_LOWER_RFCOMM:
+        case OI_OBEX_LOWER_L2CAP:
+            ifc = OI_OBEX_LowerInterface();
+            break;
+        case OI_OBEX_LOWER_TCPIP:
+            // Not implemented.
+            break;
+        default:
+            status = OI_STATUS_INVALID_PARAMETERS;
+            OI_SLOG_ERROR(status, ("Invalid protocol %d", lowerProtocol->protocol));
+            return status;
+    }
+
+    if (ifc == NULL) {
+        return OI_STATUS_NOT_IMPLEMENTED;
+    }
+
+    server = OI_Calloc(sizeof(*server));
+    if (server == NULL) {
+        status = OI_STATUS_NO_RESOURCES;
+    } else {
+        status = ifc->regServer(server, mtu, policy, lowerProtocol, sock_ifc);
+        if (OI_SUCCESS(status)) {
+            server->callbacks = callbacks;
+            server->ifc = ifc;
+            *lowerServer = server;
+            *lowerProtocol = server->lowerProtocol;
+        } else {
+            OI_Free(server);
+        }
+    }
+    return status;
+}
+
+
+
+OI_STATUS OI_OBEX_LOWER_Connect(const OI_OBEX_LOWER_CALLBACKS *callbacks,
+                                OI_BD_ADDR *addr,
+                                OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                                OI_UINT16 mtu,
+                                const OI_CONNECT_POLICY *policy,
+                                OI_OBEX_LOWER_CONNECTION *lowerConnection)
+{
+    OI_STATUS status;
+    const OI_OBEX_LOWER_INTERFACE *ifc;
+    OI_OBEX_LOWER_CONNECTION connection;
+
+    OI_ARGCHECK(callbacks);
+    OI_ARGCHECK(addr);
+    OI_ARGCHECK(lowerProtocol);
+    OI_ARGCHECK(lowerConnection);
+
+    *lowerConnection = NULL;
+
+    switch (lowerProtocol->protocol) {
+        case OI_OBEX_LOWER_RFCOMM:
+        case OI_OBEX_LOWER_L2CAP:
+            ifc = OI_OBEX_LowerInterface();
+            break;
+        case OI_OBEX_LOWER_TCPIP:
+            return OI_STATUS_NOT_IMPLEMENTED;
+        default:
+            status = OI_STATUS_INVALID_PARAMETERS;
+            OI_SLOG_ERROR(status, ("Invalid protocol %d", lowerProtocol->protocol));
+            return status;
+    }
+    connection = OI_Calloc(sizeof(struct _OI_OBEX_LOWER_CONNECTION));
+    if (connection == NULL) {
+        status = OI_STATUS_NO_RESOURCES;
+    } else {
+        connection->callbacks = callbacks;
+        connection->ifc = ifc;
+        status = ifc->connect(connection, addr, lowerProtocol, mtu, policy, sock_ifc);
+        if (OI_SUCCESS(status)) {
+            *lowerConnection = connection;
+        } else {
+            OI_Free(connection);
+        }
+    }
+    OI_LOG_ERROR(("%s returning %d", __func__, status));
+    return status;
+}
+
+void OI_OBEX_LOWER_SetSocketInterface(btsock_interface_t *socket_interface)
+{
+    sock_ifc = socket_interface;
+}
diff --git a/obex_profiles/profiles/obex/obex_lower_socket.c b/obex_profiles/profiles/obex/obex_lower_socket.c
new file mode 100644
index 0000000..b789431
--- /dev/null
+++ b/obex_profiles/profiles/obex/obex_lower_socket.c
@@ -0,0 +1,1278 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_OBEX_SRV
+
+#include "oi_obexspec.h"
+#include "oi_obex_lower.h"
+#include "oi_assert.h"
+#include "oi_debug.h"
+#include "oi_endian.h"
+#include "oi_memmgr.h"
+#include "oi_mbuf.h"
+#include "oi_utils.h"
+#include "oi_list.h"
+#include "oi_eventloop.h"
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+
+typedef struct _SOCK_CONNECT_SIGNAL {
+    OI_UINT16 size;
+    OI_BD_ADDR bd_addr;
+    int channel;
+    int status;
+
+    // The writer must make writes using a buffer of this maximum size
+    // to avoid loosing data. (L2CAP only)
+    OI_UINT16 max_tx_packet_size;
+
+    // The reader must read using a buffer of at least this size to avoid
+    // loosing data. (L2CAP only)
+    OI_UINT16 max_rx_packet_size;
+} __attribute__((packed)) SOCK_CONNECT_SIGNAL;
+
+/*
+ * (RFCOMM/L2CAP) state that is stored in OI_OBEX_LOWER_CONNECTION.lowerPrivate
+ */
+typedef struct _LOWER_CONNECTION_PRIVATE {
+    btsock_interface_t *socket_interface;
+    OI_OBEX_LOWER_CONNECTION handle;      /* Connection handle for making callbacks to upper OBEX */
+    OI_LIST_ELEM links;    /* Linked list pointers */
+    int socket;            /* Client connection socket */
+    OI_BOOL connected;     /* Connection status */
+    OI_CALLBACK_HANDLE disconnectCbHandle; /* Handle is set when there's a pending disconnect */
+    OI_MBUF* writeMbuf;    /* Outgoing MBUF data */
+    OI_BD_ADDR addr;       /* Address for remote device */
+    OI_UINT16 channel;     /* transport (RFCOMM/L2CAP) channel for this connection */
+    OI_UINT16 mtu;         /* Maximum OBEX packet length (read or write) */
+    OI_UINT16 readLen;     /* The length of the reassembled OBEX packet */
+    OI_UINT16 readPos;     /* The current reassembly position in the the packet */
+    OI_UINT8* readBuffer;  /* Buffer for reassembling transport (RFCOMM/L2CAP) frames into a contiguous OBEX packet */
+    OI_UINT16 writeLen;    /* The total length of the outgoing OBEX packet */
+    OI_UINT16 writePos;    /* Where to begin the next write */
+    OI_UINT8* writeBuffer; /* Buffer for staging write data for use with send() */
+    OI_OBEX_LOWER_PROTOCOL_ID protocol;
+    OI_BOOL clientSocket;
+    SOCK_CONNECT_SIGNAL conn_params;
+} LOWER_CONNECTION_PRIVATE;
+
+typedef struct _LOWER_SERVER_PRIVATE {
+    btsock_interface_t *socket_interface;
+    OI_OBEX_LOWER_SERVER handle; /* Server handle for upper OBEX callbacks */
+    OI_LIST_ELEM links;          /* Linked list pointers */
+    int socket;                  /* Server socket (listening for connections) */
+    OI_CALLBACK_HANDLE deregCbHandle; /* Handle is set when there's a pending disconnect */
+    OI_OBEX_LOWER_PROTOCOL_ID protocol;
+} LOWER_SERVER_PRIVATE;
+
+/* List of all active server connections */
+static OI_LIST(serverList);
+/* List of all active client connections */
+static OI_LIST(connectionList);
+
+/*
+ * Forward declarations.
+ */
+static OI_STATUS LowerDisconnect(OI_OBEX_LOWER_CONNECTION connectionHandle);
+static void LowerTransportConnectInd(OI_OBEX_LOWER_SERVER serverHandle);
+static OI_BOOL LowerTransportConnectCfm(OI_OBEX_LOWER_CONNECTION connectionHandle);
+static OI_BOOL LowerTransportRecvDataInd(OI_OBEX_LOWER_CONNECTION connectionHandle);
+static OI_BOOL LowerTransportSendMbuf(OI_OBEX_LOWER_CONNECTION connectionHandle);
+static void LowerTransportDisconnectInd(OI_OBEX_LOWER_CONNECTION connectionHandle);
+static void DeferredDeregServer(void* arg);
+
+
+
+/*
+ * Get fds for the event loop.  Active servers are always trying to
+ * read (listening for incoming connections to accept).  Active
+ * clients always listen for incoming data, and only set their write bit
+ * when an MBUF is available to write.
+ */
+static int getLowerTransportFds(fd_set* readFds, fd_set* writeFds, fd_set* exceptFds, int* maxFd)
+{
+    OI_LIST_ELEM* elem;
+    int numSet = 0;
+    *maxFd = 0;
+
+    OI_DBGPRINT(("getLowerTransportFds()"));
+    /*
+     * Connection fds are always readable, and writeable if there is
+     * an MBUF waiting to be sent.  Sockets that are still connecting
+     * become writeable when the connect procedure is complete.
+     */
+    OI_LIST_FOREACH(elem, &connectionList) {
+        LOWER_CONNECTION_PRIVATE* lowerPrivate;
+        lowerPrivate = OI_LIST_ENTRY(elem, LOWER_CONNECTION_PRIVATE, links);
+
+        if (!lowerPrivate->connected) {
+            OI_DBGPRINT(("Socket %d not connected, watching for write", lowerPrivate->socket));
+            FD_SET(lowerPrivate->socket, writeFds);
+            *maxFd = OI_MAX(*maxFd, lowerPrivate->socket);
+            numSet++;
+        }
+        else {
+            OI_DBGPRINT(("Socket %d watching for read", lowerPrivate->socket));
+            FD_SET(lowerPrivate->socket, readFds);
+            numSet++;
+            *maxFd = OI_MAX(*maxFd, lowerPrivate->socket);
+
+            if (NULL != lowerPrivate->writeMbuf) {
+                OI_DBGPRINT(("Socket %d has pending write data", lowerPrivate->socket));
+                FD_SET(lowerPrivate->socket, writeFds);
+                numSet++;
+                // No need to update *maxFd again
+            }
+        }
+    }
+
+    /*
+     * Server fds become readable when an incoming connection is pending.
+     */
+    OI_LIST_FOREACH(elem, &serverList) {
+        LOWER_SERVER_PRIVATE* lowerPrivate;
+        lowerPrivate = OI_LIST_ENTRY(elem, LOWER_SERVER_PRIVATE, links);
+
+        OI_DBGPRINT(("Server socket %d is listening for connections", lowerPrivate->socket));
+        FD_SET(lowerPrivate->socket, readFds);
+        numSet++;
+        *maxFd = OI_MAX(*maxFd, lowerPrivate->socket);
+    }
+
+    OI_DBGPRINT(("Watching for %d fds", numSet));
+
+    return numSet;
+}
+
+/*
+ * Handle socket activity for servers and clients.
+ */
+static int handleLowerTransportEvents(int numSet, fd_set* readFds, fd_set* writeFds, fd_set* exceptFds)
+{
+    OI_LIST_ELEM* elem;
+    OI_LIST_ELEM marker;
+
+    OI_DBGPRINT(("handleLowerTransportEvents(numSet=%d)", numSet));
+
+    // Process activity on data sockets
+    OI_List_DynamicInit(&marker);
+    OI_List_AddTail(&marker, &connectionList);
+    while ((elem = OI_List_RemoveHead(&connectionList)) != &marker) {
+        LOWER_CONNECTION_PRIVATE* lowerPrivate;
+
+        // Rotate item to end of list.
+        OI_List_AddTail(elem, &connectionList);
+
+        if (numSet < 1) {
+            OI_DBGPRINT(("No more FDs"));
+            OI_List_Del(&marker);
+            elem = &marker;
+            break;
+        }
+
+        lowerPrivate = OI_LIST_ENTRY(elem, LOWER_CONNECTION_PRIVATE, links);
+        if (lowerPrivate == NULL) {
+            continue;
+        }
+
+        OI_DBGPRINT(("Checking socket %d", lowerPrivate->socket));
+
+        if (FD_ISSET(lowerPrivate->socket, readFds)) {
+            OI_DBGPRINT(("Socket %d has new data to read", lowerPrivate->socket));
+            FD_CLR(lowerPrivate->socket, readFds);
+            numSet--;
+            if (!LowerTransportRecvDataInd(lowerPrivate->handle)) {
+                OI_DBGPRINT(("Connection invalidated"));
+                continue;
+            }
+        }
+        if (FD_ISSET(lowerPrivate->socket, writeFds)) {
+            FD_CLR(lowerPrivate->socket, writeFds);
+            numSet--;
+            if (lowerPrivate->connected) {
+                OI_DBGPRINT(("Socket %d has write buffer space available", lowerPrivate->socket));
+                if (!LowerTransportSendMbuf(lowerPrivate->handle)) {
+                    /* In the current control structure, this is a
+                     * no-op.  It is included to draw attention to
+                     * the meaning of LowerTransportSendMbuf()'s return val
+                     */
+                    OI_DBGTRACE(("Connection invalidated"));
+                    continue;
+                }
+            }
+            else {
+                OI_DBGPRINT(("Socket %d has a ready connection", lowerPrivate->socket));
+                if (!LowerTransportConnectCfm(lowerPrivate->handle)) {
+                    /* In the current control structure, this is a
+                     * no-op.  It is included to draw attention to
+                     * the meaning of LowerTransportConnectCfm()'s return val
+                     */
+                    OI_DBGTRACE(("Connection invalidated"));
+                    continue;
+                }
+            }
+        }
+    }
+
+    /*
+     * ! Important - 'marker' is on the stack and cannot be in the
+     * queue when the above while loop exits!
+     */
+    OI_ASSERT(elem == &marker);
+
+    // Look for incoming connections or errors from server sockets.
+    OI_List_DynamicInit(&marker);
+    OI_List_AddTail(&marker, &serverList);
+    while ((elem = OI_List_RemoveHead(&serverList)) != &marker) {
+        LOWER_SERVER_PRIVATE* lowerPrivate;
+
+        // Rotate item to end of list.
+        OI_List_AddTail(elem, &serverList);
+
+        if (numSet < 1) {
+            OI_DBGPRINT(("No more FDs"));
+            OI_List_Del(&marker);
+            elem = &marker;
+            break;
+        }
+
+        lowerPrivate = OI_LIST_ENTRY(elem, LOWER_SERVER_PRIVATE, links);
+        if (lowerPrivate == NULL) {
+            continue;
+        }
+
+        OI_DBGPRINT(("Checking server socket %d", lowerPrivate->socket));
+
+        if (FD_ISSET(lowerPrivate->socket, readFds)) {
+            OI_DBGPRINT(("Server socket %d has an incoming connection", lowerPrivate->socket));
+            FD_CLR(lowerPrivate->socket, readFds);
+            numSet--;
+            LowerTransportConnectInd(lowerPrivate->handle);
+        }
+    }
+
+    /*
+     * ! Important - 'marker' is on the stack and cannot be in the
+     * queue when the above while loop exits!
+     */
+    OI_ASSERT(elem == &marker);
+
+    OI_DBGPRINT(("%d fds remaining", numSet));
+    return numSet;
+}
+
+static void validateLowerTransportFds(void)
+{
+    OI_LIST_ELEM* elem;
+
+    /*
+     * Look through all server and client fds.  If any are invalid, clean
+     * them up.
+     */
+
+    OI_LIST_FOREACH(elem, &connectionList) {
+        LOWER_CONNECTION_PRIVATE* lowerPrivate;
+        lowerPrivate = OI_LIST_ENTRY(elem, LOWER_CONNECTION_PRIVATE, links);
+
+        if (!OI_EVENTLOOP_FdIsValid(lowerPrivate->socket)) {
+            LowerDisconnect(lowerPrivate->handle);
+        }
+    }
+
+    OI_LIST_FOREACH(elem, &serverList) {
+        LOWER_SERVER_PRIVATE* lowerPrivate;
+        lowerPrivate = OI_LIST_ENTRY(elem, LOWER_SERVER_PRIVATE, links);
+
+        if (!OI_EVENTLOOP_FdIsValid(lowerPrivate->socket)) {
+            OI_ScheduleCallbackFunction(DeferredDeregServer,
+                                        (void*) lowerPrivate->handle,
+                                        0,
+                                        &lowerPrivate->deregCbHandle);
+        }
+    }
+}
+
+// Utility functions for handling callback registration w/ OI_EVENTLOOP
+static void updateEventLoopRegistration(void)
+{
+    if (OI_List_IsEmpty(&connectionList) &&
+        OI_List_IsEmpty(&serverList)) {
+        OI_DBGPRINT(("Adding event handlers"));
+        OI_EVENTLOOP_Register(getLowerTransportFds, handleLowerTransportEvents, validateLowerTransportFds, TRUE);
+    }
+}
+
+static void updateEventLoopDeregistration(void)
+{
+    if (OI_List_IsEmpty(&connectionList) &&
+        OI_List_IsEmpty(&serverList)) {
+        OI_DBGPRINT(("Removing event handlers"));
+        OI_EVENTLOOP_Deregister(getLowerTransportFds, handleLowerTransportEvents, validateLowerTransportFds);
+    }
+}
+
+/*
+ * Memory allocation and initialization for LOWER_CONNECTION_PRIVATE
+ */
+static LOWER_CONNECTION_PRIVATE* allocLowerConnectionPrivate(OI_UINT16 mtu)
+{
+    LOWER_CONNECTION_PRIVATE* lowerPrivate;
+
+    lowerPrivate = OI_Calloc(sizeof(LOWER_CONNECTION_PRIVATE));
+    if (NULL == lowerPrivate) {
+        return NULL;
+    }
+
+    // Set up buffer pointers.
+    lowerPrivate->readBuffer = OI_Malloc(mtu);
+    lowerPrivate->writeBuffer = OI_Malloc(OI_UINT16_MAX);
+    if ((NULL == lowerPrivate->readBuffer) ||
+        (NULL == lowerPrivate->writeBuffer)) {
+        OI_FreeIf(&lowerPrivate->readBuffer);
+        OI_FreeIf(&lowerPrivate->writeBuffer);
+        OI_Free(lowerPrivate);
+        return NULL;
+    }
+
+    OI_List_DynamicInit(&lowerPrivate->links);
+    lowerPrivate->mtu = mtu;
+
+    // Other struct members are initialized to 0 or NULL by OI_Calloc()
+
+    return lowerPrivate;
+}
+
+/*
+ * Convenient freeing for LOWER_CONNECTION_PRIVATE
+ */
+static void deallocLowerConnectionPrivate(OI_OBEX_LOWER_CONNECTION handle)
+{
+    if (NULL != handle->lowerPrivate) {
+        OI_DBGTRACE(("Deallocating private data at %08x", handle->lowerPrivate));
+
+        if (0 != handle->lowerPrivate->disconnectCbHandle) {
+            OI_CancelCallbackFunction(handle->lowerPrivate->disconnectCbHandle);
+        }
+
+        OI_FreeIf(&handle->lowerPrivate->readBuffer);
+        OI_FreeIf(&handle->lowerPrivate->writeBuffer);
+        OI_FreeIf(&handle->lowerPrivate);
+    }
+}
+
+static int readAll(int sock_fd, unsigned char *b, int len)
+{
+    OI_DBGTRACE(("readAll: about to read %d bytes", len));
+    int left = len;
+    while(left > 0) {
+        int ret = recv(sock_fd, b + (len - left), left, MSG_WAITALL);
+        if(ret <= 0) {
+            OI_DBGTRACE(("read failed, socket might closed or timeout, read ret %d: ",
+                         ret));
+            return ret;
+        }
+        left -= ret;
+        if(left != 0)
+            OI_DBGTRACE(("readAll() looping, read partial size: %d, expect size: %d" ,
+                        (len- left) , len));
+    }
+    return len;
+}
+
+static int readInt(int sock_fd, unsigned char *b)
+{
+    if (sizeof(int) == readAll(sock_fd, b, sizeof(int))) {
+        return (int)GetUINT32_LittleEndian(b);
+    }
+    return 0;
+}
+
+static int readMsg(int sock_fd, unsigned char *b, int len, int *new_fd)
+{
+    struct iovec iov[1];
+    union {
+        struct cmsghdr cm;
+        char control[CMSG_SPACE(sizeof(int))];
+    } control_un;
+    struct msghdr msg = { NULL, 0, iov, 1, control_un.control,
+                          sizeof(control_un), 0 };
+    struct cmsghdr *cmsg = &control_un.cm;
+
+    OI_DBGTRACE(("readMsg: about to read %d bytes from fd = %d", len, sock_fd));
+
+    iov[0].iov_base = b;
+    iov[0].iov_len = len;
+
+    int ret = recvmsg(sock_fd, &msg, MSG_WAITALL);
+    if(ret <= 0) {
+        OI_DBGTRACE(("recvmsg failed, socket might closed or timeout, read ret %d: %s",
+                     ret, strerror(errno)));
+        return ret;
+    }
+    OI_DBGTRACE(("recvmsg received ret %d", ret));
+    cmsg = CMSG_FIRSTHDR(&msg);
+    while (cmsg) {
+      if (cmsg->cmsg_level == SOL_SOCKET &&
+         cmsg->cmsg_type == SCM_RIGHTS &&
+         cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {
+         *new_fd = *((int *) CMSG_DATA(cmsg));
+         break;
+      }
+
+      cmsg = CMSG_NXTHDR(&msg, cmsg);
+    }
+    return ret;
+}
+
+static void waitForConnectSignal(int sock_fd, SOCK_CONNECT_SIGNAL *conn_params,
+    int *new_fd)
+{
+    unsigned char read_bytes[20];
+    int ret;
+    OI_DBGTRACE(("waitForConnectSignal fd:%d", sock_fd));
+    /* Set status as error by default */
+    conn_params->status = -1;
+    if (new_fd == NULL) {
+        ret = readAll(sock_fd, read_bytes, sizeof(*conn_params));
+    } else {
+        ret = readMsg(sock_fd, read_bytes, sizeof(*conn_params), new_fd);
+    }
+    if (ret == sizeof(*conn_params)) {
+        conn_params->size = GetUINT16_LittleEndian(&read_bytes[0]);
+        OI_MemCopy(&conn_params->bd_addr.addr[0], &read_bytes[2], sizeof(OI_BD_ADDR));
+        conn_params->channel = GetUINT32_LittleEndian(&read_bytes[8]);
+        conn_params->status = GetUINT32_LittleEndian(&read_bytes[12]);
+        conn_params->max_rx_packet_size = GetUINT16_LittleEndian(&read_bytes[16]);
+        conn_params->max_tx_packet_size = GetUINT16_LittleEndian(&read_bytes[18]);
+        OI_DBGTRACE(("status = %d recvMtu = %d sendMtu = %d ", conn_params->status,
+            conn_params->max_rx_packet_size, conn_params->max_tx_packet_size));
+    }
+}
+
+static bool HandleLowerConnectCfmFailure(OI_OBEX_LOWER_CONNECTION connectionHandle)
+{
+    OI_DBGTRACE(("Lower Connect Failed"));
+    /*
+     * Remove the socket from the active list, and close the
+     * socket, and let the upper layer know that the connect
+     * failed.
+     */
+    OI_List_Del(&connectionHandle->lowerPrivate->links);
+    updateEventLoopDeregistration();
+
+    // Waking up the event loop to ensure that select is not blocking pre-close (BlueZ issue?).
+    OI_EVENTLOOP_Wakeup();
+    close(connectionHandle->lowerPrivate->socket);
+
+    deallocLowerConnectionPrivate(connectionHandle);
+    //TODO: Map the error from FD stack to BM3 Obex
+    connectionHandle->callbacks->connectCfm(connectionHandle, 0, 0,
+        OI_STATUS_INTERNAL_ERROR);
+    OI_Free(connectionHandle);
+    return FALSE;
+}
+
+/*
+ * Socket-based analog for BM3 Lower transport (RFCOMM/L2CAP) connect confirm.
+ * Should be called when a socket becomes writeable after a non-blocking
+ * connect().
+ *
+ * Returns FALSE if there was an error on the connection -- and when
+ * FALSE is returned, the caller must assume the connection handle
+ * passed in to this function is no longer valid (it may have been
+ * deallocated before this function returned).
+ */
+static OI_BOOL LowerTransportConnectCfm(OI_OBEX_LOWER_CONNECTION connectionHandle)
+{
+    LOWER_CONNECTION_PRIVATE* lowerPrivate;
+    OI_STATUS status = OI_OK;
+    OI_BOOL connectionOk = TRUE;
+
+    OI_DBGTRACE(("LowerTransportConnectCfm(%08x)", connectionHandle));
+
+    OI_ASSERT(NULL != connectionHandle);
+    OI_ASSERT(!connectionHandle->lowerPrivate->connected);
+
+    lowerPrivate = connectionHandle->lowerPrivate;
+
+    if (connectionHandle->lowerPrivate->clientSocket) {
+        unsigned char read_bytes[sizeof(int)];
+        int channel = readInt(connectionHandle->lowerPrivate->socket, read_bytes);
+        OI_DBGTRACE(("Channel = 0x%04x", channel));
+        if (channel <= 0) {
+            status = OI_STATUS_NOT_CONNECTED;
+            connectionOk = HandleLowerConnectCfmFailure(connectionHandle);
+            return connectionOk;
+        }
+        waitForConnectSignal(connectionHandle->lowerPrivate->socket,
+            &connectionHandle->lowerPrivate->conn_params, NULL);
+    }
+    if (!connectionHandle->lowerPrivate->conn_params.status) {
+        OI_DBGTRACE(("Lower Connect Successful"));
+        lowerPrivate->connected = TRUE;
+        /*
+         * RFCOMM is a stream protocol so imposes no inherent limit on
+         * the size of the OBEX packets.
+         */
+        if (OI_OBEX_LOWER_RFCOMM == connectionHandle->lowerPrivate->protocol)
+            connectionHandle->callbacks->connectCfm(connectionHandle,
+                OI_UINT16_MAX,
+                OI_UINT16_MAX,
+                OI_OK);
+        else {
+            connectionHandle->callbacks->connectCfm(connectionHandle,
+                connectionHandle->lowerPrivate->conn_params.max_rx_packet_size,
+                connectionHandle->lowerPrivate->conn_params.max_tx_packet_size,
+                OI_OK);
+        }
+    } else {
+        connectionOk = HandleLowerConnectCfmFailure(connectionHandle);
+    }
+
+    return connectionOk;
+}
+
+/*
+ * Socket-based analog for BM3 Lower transport (RFCOMM/L2CAP) connect indication.
+ * Should be called when a server socket becomes readable.
+ */
+static void LowerTransportConnectInd(OI_OBEX_LOWER_SERVER serverHandle)
+{
+    OI_OBEX_LOWER_CONNECTION connectionHandle;
+    int remoteSocket;
+    OI_BD_ADDR bdaddr;
+    struct sockaddr_un cliaddr;
+    int length;
+
+    OI_DBGTRACE(("LowerTransportConnectInd(%08x)", serverHandle));
+
+    OI_ASSERT(serverHandle);
+
+    /*
+     * Allocate a connection handle - disconnect if the allocation
+     * fails.  Populate all relevant fields for a connection.  The
+     * connection is not complete until it is confirmed by the upper
+     * layer.
+     */
+    connectionHandle = OI_Calloc(sizeof(*connectionHandle));
+    if (!connectionHandle) {
+        // Waking up the event loop to ensure that select is not blocking pre-close (BlueZ issue?).
+        OI_EVENTLOOP_Wakeup();
+        close(serverHandle->lowerPrivate->socket);
+        OI_SLOG_ERROR(OI_STATUS_OUT_OF_MEMORY, ("Failed to allocate connection handle"));
+        return;
+    }
+
+    connectionHandle->lowerPrivate = allocLowerConnectionPrivate(serverHandle->mtu);
+
+    if (NULL == connectionHandle->lowerPrivate) {
+        // Waking up the event loop to ensure that select is not blocking pre-close (BlueZ issue?).
+        OI_EVENTLOOP_Wakeup();
+        close(serverHandle->lowerPrivate->socket);
+        OI_Free(connectionHandle);
+        OI_SLOG_ERROR(OI_STATUS_OUT_OF_MEMORY, ("Failed to allocate connection handle"));
+        return;
+    }
+
+    waitForConnectSignal(serverHandle->lowerPrivate->socket,
+        &connectionHandle->lowerPrivate->conn_params, &remoteSocket);
+    if (!connectionHandle->lowerPrivate->conn_params.status) {
+        connectionHandle->lowerPrivate->clientSocket = FALSE;
+        connectionHandle->lowerPrivate->handle = connectionHandle;
+        connectionHandle->lowerPrivate->addr = connectionHandle->lowerPrivate->conn_params.bd_addr;
+        connectionHandle->lowerPrivate->channel = connectionHandle->lowerPrivate->conn_params.channel;
+        connectionHandle->lowerPrivate->socket = remoteSocket;
+        if ((connectionHandle->lowerPrivate->conn_params.max_rx_packet_size ==
+            connectionHandle->lowerPrivate->conn_params.max_tx_packet_size) &&
+            (connectionHandle->lowerPrivate->conn_params.max_rx_packet_size == 0))
+            connectionHandle->lowerPrivate->protocol = OI_OBEX_LOWER_RFCOMM;
+        else
+            connectionHandle->lowerPrivate->protocol = OI_OBEX_LOWER_L2CAP;
+        connectionHandle->ifc = serverHandle->ifc;
+        connectionHandle->callbacks = serverHandle->callbacks;
+        /*
+         * Indicate the connection to OBEX
+         */
+        connectionHandle->callbacks->connectInd(serverHandle, connectionHandle,
+            &connectionHandle->lowerPrivate->addr);
+
+        /*
+         * The connection will be added to the active list if it is
+         * accepted by the app.
+         */
+    } else {
+        // Waking up the event loop to ensure that select is not blocking pre-close (BlueZ issue?).
+        OI_EVENTLOOP_Wakeup();
+        close(serverHandle->lowerPrivate->socket);
+        OI_Free(connectionHandle);
+        OI_SLOG_ERROR(OI_STATUS_INTERNAL_ERROR, ("Connection status failed"));
+        return;
+    }
+
+}
+
+/*
+ * Socket-based analog for BM3 Lower transport (RFCOMM/L2CAP) disconnect indication.  This is
+ * responsible for both propagating the disconnect indication upward,
+ * and for actually closing the socket & freeing resources.
+ */
+static void LowerTransportDisconnectInd(OI_OBEX_LOWER_CONNECTION connectionHandle)
+{
+    OI_CALLBACK_HANDLE deferredDisconnect;
+
+    OI_DBGTRACE(("LowerTransportDisconnectInd(%08x)", connectionHandle));
+
+    deferredDisconnect = connectionHandle->lowerPrivate->disconnectCbHandle;
+    if (0 != deferredDisconnect) {
+        OI_DBGTRACE(("Cancelling deferred disconnect"));
+        OI_CancelCallbackFunction(deferredDisconnect);
+    }
+
+    /*
+     * Remove the socket from the active list, and trigger a disconnect.
+     */
+    OI_List_Del(&connectionHandle->lowerPrivate->links);
+    updateEventLoopDeregistration();
+
+    if (connectionHandle->lowerPrivate->connected) {
+        OI_DBGTRACE(("LowerTransportDisconnectInd: closing socket %d.", connectionHandle->lowerPrivate->socket));
+
+        // Waking up the event loop to ensure that select is not blocking pre-close (BlueZ issue?).
+        OI_EVENTLOOP_Wakeup();
+        int closeRet = close(connectionHandle->lowerPrivate->socket);
+        if (closeRet) {
+            OI_DBGTRACE(("Could not close socket. Error info: ", strerror(errno)));
+        }
+    }
+
+    connectionHandle->callbacks->disconnectInd(connectionHandle, OI_RFCOMM_LOCAL_DEVICE_DISCONNECTED);
+
+    /*
+     * Free the private connection data, and the handle itself.
+     */
+    deallocLowerConnectionPrivate(connectionHandle);
+    OI_Free(connectionHandle);
+}
+
+/*
+ * Propagate a disconnect indication from the dispatcher.
+ */
+static void DeferredLowerTransportDisconnectInd(void* arg) {
+    OI_OBEX_LOWER_CONNECTION connection = (OI_OBEX_LOWER_CONNECTION) arg;
+
+    connection->lowerPrivate->disconnectCbHandle = 0;
+
+    LowerTransportDisconnectInd(connection);
+}
+
+/*
+ * Socket-based analog for the BM3 Lower transport (RFCOMM/L2CAP) receive data indication.
+ * This is responsible for reassembly of the OBEX packet, and only
+ * propagates data upward when a complete packet is available.
+ *
+ * Returns FALSE if there was an error on the connection -- and when
+ * FALSE is returned, the caller must assume the connection handle
+ * passed in to this function is no longer valid (it may have been
+ * deallocated before this function returned).
+ */
+static OI_BOOL LowerTransportRecvDataInd(OI_OBEX_LOWER_CONNECTION connectionHandle)
+{
+    OI_STATUS status = OI_OK;
+    ssize_t recvBytes = 0;
+    LOWER_CONNECTION_PRIVATE* lowerPrivate;
+    int readLen;
+
+    OI_DBGTRACE(("LowerTransportRecvDataInd(%08x)", connectionHandle));
+
+    if (connectionHandle == NULL) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("OBEX received data for unknown connection"));
+        return FALSE;
+    }
+
+    lowerPrivate = connectionHandle->lowerPrivate;
+
+    OI_DBGPRINT(("readPos = %d, readLen = %d",
+                  lowerPrivate->readPos,
+                  lowerPrivate->readLen));
+
+    if (lowerPrivate->readLen == 0) {
+        /*
+         * Robustness testers may send tiny frames so we need to allow
+         * for the possibility that we don't have enough of the header
+         * to extract the packet length.
+         */
+
+        if (OI_OBEX_LOWER_RFCOMM == connectionHandle->lowerPrivate->protocol) {
+            /*
+             * RFCOMM sockets seem to have quirky behavior when reading.
+             * If we just read the maximum buffer length, recv() will
+             * block a long time on shorter packets and throughput will
+             * suffer.  As a workaround, read a very small number of bytes
+             * first - enough to determine the actual packet size - then
+             * read the expected number of bytes remaining.
+             */
+            readLen = OI_OBEX_SMALLEST_PKT;
+        } else {
+            readLen = connectionHandle->lowerPrivate->conn_params.max_rx_packet_size;
+        }
+        recvBytes = recv(connectionHandle->lowerPrivate->socket,
+                         lowerPrivate->readBuffer + lowerPrivate->readPos,
+                         readLen - lowerPrivate->readPos,
+                         MSG_DONTWAIT);
+
+        if (recvBytes > 0) {
+            lowerPrivate->readPos += recvBytes;
+        }
+        else {
+            status = OI_STATUS_READ_ERROR;
+            OI_SLOG_ERROR(status, ("Error %d reading socket %d",
+                                   errno,
+                                   connectionHandle->lowerPrivate->socket));
+            // strerror() isn't thread safe, so let's not use it in release mode
+            OI_DBGTRACE(("Error info: ", strerror(errno)));
+            LowerTransportDisconnectInd(connectionHandle);
+            return FALSE;
+        }
+
+        if (lowerPrivate->readPos < OI_OBEX_SMALLEST_PKT) {
+            /*
+             * recv() didn't get enough data to determine the packet
+             * size, so return to the event loop.
+             */
+            OI_DBGTRACE(("Not enough data to get OBEX packet length"));
+            return TRUE;
+        }
+
+        /*
+         * Extract the packet length from the packet header.
+         */
+        lowerPrivate->readLen = GetUINT16_BigEndian(lowerPrivate->readBuffer +
+                                                    sizeof(OI_UINT8));
+        OI_DBGTRACE(("OBEX packet length is %d", lowerPrivate->readLen));
+
+        /*
+         * Check that the packet will fit our mtu
+         */
+        if (lowerPrivate->readLen > lowerPrivate->mtu) {
+            status = OI_STATUS_MTU_EXCEEDED;
+            OI_SLOG_ERROR(status, ("OBEX packet exceeds MTU - disconnecting"));
+            LowerTransportDisconnectInd(connectionHandle);
+            return FALSE;
+        }
+    }
+
+    OI_DBGPRINT(("readPos = %d, readLen = %d",
+                  lowerPrivate->readPos,
+                  lowerPrivate->readLen));
+    /*
+     * Try to read the remainder of the packet if it's not already done.
+     */
+    if (lowerPrivate->readPos != lowerPrivate->readLen) {
+        recvBytes = recv(connectionHandle->lowerPrivate->socket,
+                         lowerPrivate->readBuffer + lowerPrivate->readPos,
+                         lowerPrivate->readLen - lowerPrivate->readPos,
+                         MSG_WAITALL);
+
+        if (recvBytes > 0) {
+            lowerPrivate->readPos += recvBytes;
+        }
+        else {
+            status = OI_STATUS_READ_ERROR;
+            OI_SLOG_ERROR(status, ("Error %d reading socket %d",
+                                   errno,
+                                   connectionHandle->lowerPrivate->socket));
+            OI_DBGTRACE(("Error info: ", strerror(errno)));
+            LowerTransportDisconnectInd(connectionHandle);
+            return FALSE;
+        }
+    }
+
+
+    OI_DBGPRINT(("readPos = %d, readLen = %d",
+                  lowerPrivate->readPos,
+                  lowerPrivate->readLen));
+
+    /*
+     * The OBEX packet is complete, pass it up the stack.
+     */
+    if (lowerPrivate->readPos == lowerPrivate->readLen) {
+        OI_UINT16 readLen = lowerPrivate->readLen;
+
+        /*
+         * Clear readLen and readPos in preparation for next OBEX packet.
+         */
+        lowerPrivate->readPos = 0;
+        lowerPrivate->readLen = 0;
+
+        OI_DBGTRACE(("Passing %d new bytes to the upper layer", readLen));
+
+        connectionHandle->callbacks->recvDataInd(connectionHandle,
+                                                 lowerPrivate->readBuffer,
+                                                 readLen);
+    }
+
+    return TRUE;
+}
+
+/*
+ * Create a new server instance.
+ */
+static OI_STATUS LowerRegServer(OI_OBEX_LOWER_SERVER serverHandle,
+                                OI_UINT16 mtu,
+                                const OI_CONNECT_POLICY* policy,
+                                OI_OBEX_LOWER_PROTOCOL* lowerProtocol,
+                                btsock_interface_t *socket_interface)
+{
+    OI_UINT16 channel;
+    OI_STATUS status = OI_OK;
+    bt_status_t connectStatus = BT_STATUS_FAIL;
+    btsock_type_t sock_type;
+
+    OI_DBGTRACE(("LowerRegServer(%d)", lowerProtocol->protocol));
+
+    // Set up private data.
+    serverHandle->lowerPrivate = OI_Calloc(sizeof(LOWER_SERVER_PRIVATE));
+    if (NULL != serverHandle->lowerPrivate) {
+
+        serverHandle->mtu = mtu;
+        if (lowerProtocol->protocol == OI_OBEX_LOWER_RFCOMM) {
+            OI_DBGTRACE(("Listening on RFCOMM"));
+            channel = lowerProtocol->svcId.rfcommChannel;
+            sock_type = BTSOCK_RFCOMM;
+        } else {
+            OI_DBGTRACE(("Listening on L2CAP"));
+            sock_type = BTSOCK_L2CAP;
+            channel = lowerProtocol->svcId.l2capPSM;
+        }
+    }
+    else {
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+
+    int securityFlags = 0;
+    OI_DATAELEM oppUuid = OI_ELEMENT_UUID32(OI_UUID_OBEXObjectPush);
+    if ((NULL != policy) && !OI_DATAELEM_SameUUID(&policy->serviceUuid, &oppUuid)) {
+        /* Set higher security for non-OPP servers */
+        securityFlags = BTSOCK_FLAG_ENCRYPT | BTSOCK_FLAG_AUTH;
+    }
+    OI_DBGTRACE(("Listening on %s socket", OI_UUIDDataelemText(&policy->serviceUuid)));
+    //TODO: check and update last argument of below call.
+    //Added 0 to compile
+    if (OI_SUCCESS(status) && socket_interface) {
+        connectStatus = socket_interface->listen(sock_type,
+                OI_UUIDDataelemText(&policy->serviceUuid),
+                NULL,
+                channel,
+                &serverHandle->lowerPrivate->socket,
+                securityFlags, 0);
+    }
+
+    if (BT_STATUS_SUCCESS == connectStatus) {
+        serverHandle->lowerPrivate->handle = serverHandle;
+        serverHandle->lowerPrivate->socket_interface = socket_interface;
+        serverHandle->policy = policy;
+        OI_DBGTRACE(("Waiting for channel on %d socket", serverHandle->lowerPrivate->socket));
+        /* Wait for Connect Ind from Lower Layer */
+        unsigned char read_bytes[sizeof(int)];
+        int channel = readInt(serverHandle->lowerPrivate->socket, read_bytes);
+        OI_DBGTRACE(("Channel = 0x%04x", channel));
+        if (channel <= 0) {
+            // Waking up the event loop to ensure that select is not blocking pre-close
+            OI_EVENTLOOP_Wakeup();
+            close(serverHandle->lowerPrivate->socket);
+            status = OI_STATUS_INTERNAL_ERROR;
+        } else {
+            updateEventLoopRegistration();
+            OI_List_Add(&serverHandle->lowerPrivate->links, &serverList);
+            // Force an iteration of the eventloop so getLowerTransportFds() is called
+            OI_EVENTLOOP_Wakeup();
+        }
+    } else {
+        // Waking up the event loop to ensure that select is not blocking pre-close
+        OI_EVENTLOOP_Wakeup();
+        close(serverHandle->lowerPrivate->socket);
+        status = OI_STATUS_INTERNAL_ERROR;
+    }
+
+    return status;
+}
+
+/*
+ * Remove a server instance.
+ */
+static OI_STATUS LowerDeregServer(OI_OBEX_LOWER_SERVER serverHandle)
+{
+    OI_CALLBACK_HANDLE deferredDereg;
+
+    OI_DBGTRACE(("LowerDeregServer(%08x)", serverHandle));
+
+    OI_ASSERT(serverHandle->lowerPrivate);
+
+    deferredDereg = serverHandle->lowerPrivate->deregCbHandle;
+    if (0 != deferredDereg) {
+        OI_DBGTRACE(("Cancelling deferred deregistration"));
+        OI_CancelCallbackFunction(deferredDereg);
+    }
+
+    OI_List_Del(&serverHandle->lowerPrivate->links);
+    updateEventLoopDeregistration();
+
+    // Waking up the event loop to ensure that select is not blocking pre-close (BlueZ issue?).
+    OI_EVENTLOOP_Wakeup();
+    close(serverHandle->lowerPrivate->socket);
+    OI_Free(serverHandle->lowerPrivate);
+    OI_Free(serverHandle);
+
+    return OI_STATUS_SUCCESS;
+}
+
+/*
+ * Propagate a disconnect indication from the dispatcher.
+ */
+static void DeferredDeregServer(void* arg) {
+    OI_OBEX_LOWER_SERVER server = (OI_OBEX_LOWER_SERVER) arg;
+
+    server->lowerPrivate->deregCbHandle = 0;
+
+    LowerDeregServer(server);
+}
+
+/*
+ * Connect to a remote OBEX server.
+ */
+static OI_STATUS LowerConnect(OI_OBEX_LOWER_CONNECTION connectionHandle,
+                              OI_BD_ADDR *addr,
+                              OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                              OI_UINT16 mtu,
+                              const OI_CONNECT_POLICY *policy,
+                              btsock_interface_t *socket_interface)
+{
+    bt_status_t connectStatus = BT_STATUS_FAIL;
+    OI_STATUS status = OI_OK;
+
+    OI_DBGTRACE(("LowerConnect(%08x, %d)", connectionHandle, mtu));
+
+    if (mtu < OI_OBEX_SMALLEST_PKT) {
+        // LowerTransportRecvDataInd() relies on an mtu >= OI_OBEX_SMALLEST_PACKET
+        return OI_OBEX_VALUE_NOT_ACCEPTABLE;
+    }
+
+    connectionHandle->lowerPrivate = allocLowerConnectionPrivate(mtu);
+
+    if (NULL == connectionHandle->lowerPrivate) {
+        status = OI_STATUS_OUT_OF_MEMORY;
+        OI_SLOG_ERROR(status, ("Failed to allocate connection handle"));
+        return status;
+    }
+
+    btsock_type_t sock_type;
+    int securityFlags = 0;
+    OI_DATAELEM oppUuid = OI_ELEMENT_UUID32(OI_UUID_OBEXObjectPush);
+    if ((NULL != policy) && !OI_DATAELEM_SameUUID(&policy->serviceUuid, &oppUuid)) {
+        /* Set higher security for non-OPP servers */
+        securityFlags = BTSOCK_FLAG_ENCRYPT | BTSOCK_FLAG_AUTH;
+    }
+    if (lowerProtocol->protocol == OI_OBEX_LOWER_RFCOMM) {
+        OI_DBGTRACE(("Connecting RFCOMM"));
+        sock_type = BTSOCK_RFCOMM;
+        connectionHandle->lowerPrivate->channel = lowerProtocol->svcId.rfcommChannel;
+    } else {
+        OI_DBGTRACE(("Connecting L2CAP"));
+        sock_type = BTSOCK_L2CAP;
+        connectionHandle->lowerPrivate->channel = lowerProtocol->svcId.l2capPSM;
+    }
+    connectionHandle->lowerPrivate->handle = connectionHandle;
+    connectionHandle->lowerPrivate->addr = *addr;
+    connectionHandle->lowerPrivate->socket_interface = socket_interface;
+    connectionHandle->lowerPrivate->protocol = lowerProtocol->protocol;
+
+    /*
+     * Do a nonblocking connect to the nonblocking socket.  The
+     * connection may not be complete when connect() returns, but the
+     * socket will not become writeable until the connection is done.
+     * When a completed connect is detected in handleLowerTransportEvents(),
+     * lowerPrivate->connect will be updated.
+     */
+
+    //TODO: check and update last argument of below call.
+    //Added 0 to compile
+    if (socket_interface) {
+        connectStatus = socket_interface->connect(addr, sock_type,
+                NULL, /* UUID is set to NULL as channel has required info */
+                connectionHandle->lowerPrivate->channel,
+                &connectionHandle->lowerPrivate->socket,
+                securityFlags, 0);
+    }
+
+    // Other fields in connectionHandle are populated by the caller
+
+    // Link the connection to the list, and update the event loop.
+    if (BT_STATUS_SUCCESS == connectStatus) {
+        connectionHandle->lowerPrivate->clientSocket = TRUE;
+        OI_DBGTRACE(("Adding connection to list"));
+        updateEventLoopRegistration();
+        OI_List_Add(&connectionHandle->lowerPrivate->links, &connectionList);
+        OI_EVENTLOOP_Wakeup();
+    } else {
+        status = OI_STATUS_NOT_CONNECTED;
+        // The caller will free the connection
+        deallocLowerConnectionPrivate(connectionHandle);
+    }
+
+    OI_DBGTRACE(("%s returning %d", __func__, status));
+    return status;
+}
+
+/*
+ * Accept or reject an incoming transport (RFCOMM/L2CAP) connection, in response to a
+ * connect indication.
+ */
+static OI_STATUS LowerAccept(OI_OBEX_LOWER_CONNECTION connectionHandle,
+                             OI_BOOL accept)
+{
+    OI_STATUS status = OI_OK;
+
+    OI_DBGTRACE(("LowerAccept accept(%08x,%b)", connectionHandle, accept));
+
+    if (accept) {
+        /*
+         * The connection is already allocated and populated, just add
+         * it to the list.
+         */
+        updateEventLoopRegistration();
+        OI_List_Add(&connectionHandle->lowerPrivate->links, &connectionList);
+        OI_EVENTLOOP_Wakeup();
+    }
+    else {
+        /*
+         * Must close the socket here, because the connection wasn't
+         * completed in LowerTransportConnectCfm() (which would have been
+         * called if this connection ever got added to the
+         * connectionList).
+         */
+
+        // Waking up the event loop to ensure that select is not blocking pre-close (BlueZ issue?).
+        OI_EVENTLOOP_Wakeup();
+        close(connectionHandle->lowerPrivate->socket);
+        status = LowerDisconnect(connectionHandle);
+    }
+    return status;
+}
+
+/*
+ * Trigger a disconnect.
+ */
+static OI_STATUS LowerDisconnect(OI_OBEX_LOWER_CONNECTION connectionHandle)
+{
+    OI_DBGTRACE(("LowerDisconnect(%08x)", connectionHandle));
+
+    // Call must be deferred, because LowerTransportDisconnectInd() calls back upward
+    OI_ScheduleCallbackFunction(DeferredLowerTransportDisconnectInd,
+                                (void*) connectionHandle,
+                                0,
+                                &connectionHandle->lowerPrivate->disconnectCbHandle);
+
+    return OI_STATUS_SUCCESS;
+}
+
+/*
+ * Send Lower transport (RFCOMM/L2CAP) data.  There's no guarantee that an
+ * entire buffer will be accepted by send(), so partial  sends are handled.
+ * When the socket becomes writeable in the future, the remaining data will be
+ * sent.  When all data is sent, the write confirm callback is called.
+ *
+ * In practice, the entire buffer is accepted in one call.
+ *
+ * Returns FALSE if there was an error on the connection -- and when
+ * FALSE is returned, the caller must assume the connection handle
+ * passed in to this function is no longer valid (it may have been
+ * deallocated before this function returned).  (Ok - the current
+ * implementation never returns FALSE, but it is set up this way for
+ * symmetry with LowerTransportRecvDataInd() and LowerTransportConnectCfm())
+ */
+static OI_BOOL LowerTransportSendMbuf(OI_OBEX_LOWER_CONNECTION connectionHandle)
+{
+    LOWER_CONNECTION_PRIVATE* lowerPrivate = connectionHandle->lowerPrivate;
+    ssize_t sendBytes;
+    OI_BOOL sendOk = FALSE;
+
+    OI_DBGPRINT(("LowerTransportSendMbuf(%08x)", connectionHandle));
+
+    // Do a non-blocking send of as many bytes as possible, and update position
+    OI_DBGPRINT(("writePos = %d, writeLen = %d",
+                  lowerPrivate->writePos,
+                  lowerPrivate->writeLen));
+    sendBytes = send(lowerPrivate->socket,
+                     lowerPrivate->writeBuffer + lowerPrivate->writePos,
+                     lowerPrivate->writeLen - lowerPrivate->writePos,
+                     MSG_DONTWAIT);
+
+    if (sendBytes > 0) {
+        sendOk = TRUE;
+        lowerPrivate->writePos += sendBytes;
+    }
+    else {
+        sendOk = FALSE;
+    }
+
+    if (!sendOk || (lowerPrivate->writePos == lowerPrivate->writeLen)) {
+        OI_STATUS status = sendOk ? OI_OK : OI_FAIL;
+        OI_MBUF* mbuf = connectionHandle->lowerPrivate->writeMbuf;
+
+        OI_DBGPRINT(("Done writing %d bytes", lowerPrivate->writeLen));
+
+        connectionHandle->lowerPrivate->writeMbuf = NULL;
+        connectionHandle->lowerPrivate->writePos = 0;
+        connectionHandle->lowerPrivate->writeLen = 0;
+
+        connectionHandle->callbacks->writeCfm(connectionHandle,
+                                              mbuf,
+                                              FALSE,
+                                              status);
+    }
+
+    /*
+     * If there are bytes remaining, the event loop will call this
+     * function again when the socket is writeable.
+     */
+    return sendOk;
+}
+
+/*
+ * Write data to an existing connection.
+ */
+static OI_STATUS LowerWrite(OI_OBEX_LOWER_CONNECTION connectionHandle,
+                            OI_MBUF *mbuf,
+                            OI_BOOL accelerateCfm,
+                            OI_BOOL *queueFull)
+{
+    OI_STATUS status = OI_STATUS_SUCCESS;
+    LOWER_CONNECTION_PRIVATE* lowerPrivate;
+
+    OI_DBGTRACE(("LowerWrite(%08x,%08x,%d)", connectionHandle, mbuf, accelerateCfm));
+    OI_DBGTRACE(("%d bytes to write", OI_MBUF_NumBytes(mbuf)));
+
+    lowerPrivate = connectionHandle->lowerPrivate;
+
+    if (NULL != lowerPrivate->writeMbuf) {
+        /* Write is in progress, it must complete before another write starts */
+        return OI_STATUS_WRITE_IN_PROGRESS;
+    }
+
+    /*
+     * Copy MBUF data to a single, contiguous buffer.
+     *
+     * While each MBUF cell could be sent with a separate socket
+     * send(), that would lead to more system calls and suboptimal
+     * RFCOMM payload sizes.
+     */
+    lowerPrivate->writeLen = OI_MBUF_PullBytes(lowerPrivate->writeBuffer,
+                                               mbuf,
+                                               OI_UINT16_MAX);
+    lowerPrivate->writePos = 0;
+
+    if (0 != OI_MBUF_NumBytes(mbuf)) {
+        // The mbuf isn't empty, the packet was too long.
+        status = OI_STATUS_MTU_EXCEEDED;
+        OI_SLOG_ERROR(status, ("OBEX tried to send an oversized packet. extra=%d", OI_MBUF_NumBytes(mbuf)));
+        lowerPrivate->writeLen = 0;
+        *queueFull = FALSE;
+        // Force an RFCOMM disconnect so the OBEX session doesn't stall
+        LowerDisconnect(connectionHandle);
+    }
+    else {
+        OI_DBGPRINT(("Writing %d bytes", lowerPrivate->writeLen));
+
+        lowerPrivate->writeMbuf = mbuf;
+        *queueFull = TRUE;
+
+        // Force the eventloop to re-check the FDs it's waiting for.
+        OI_EVENTLOOP_Wakeup();
+    }
+
+    return status;
+}
+
+static OI_OBEX_LOWER_PROTOCOL_ID LowerProtocolId(OI_OBEX_LOWER_CONNECTION connectionHandle)
+{
+    if (connectionHandle && connectionHandle->lowerPrivate) {
+        OI_DBGPRINT(("LowerProtocolId %d ", connectionHandle->lowerPrivate->protocol));
+        return connectionHandle->lowerPrivate->protocol;
+    }
+    /* Return rfcomm by default */
+    return OI_OBEX_LOWER_RFCOMM;
+}
+
+// Stub - RFCOMM flow control isn't supported.
+static void LowerFlowControl(OI_OBEX_LOWER_CONNECTION connectionHandle,
+                             OI_BOOL flow)
+{
+    return;
+}
+
+// Stub - Getting the L2CAP channel id is not supported
+static OI_L2CAP_CID LowerGetCID(OI_OBEX_LOWER_CONNECTION lowerConnection)
+{
+    return 0;
+}
+
+/*
+ * Inform the caller of our interface.
+ */
+const OI_OBEX_LOWER_INTERFACE* OI_OBEX_LowerInterface(void)
+{
+    static const OI_OBEX_LOWER_INTERFACE lowerInterface = {
+        LowerRegServer,
+        LowerDeregServer,
+        LowerConnect,
+        LowerAccept,
+        LowerDisconnect,
+        LowerWrite,
+        LowerProtocolId,
+        LowerFlowControl,
+        LowerGetCID
+    };
+    return &lowerInterface;
+}
+
+/*
+ * Tell other profile code that only L2CAP basic mode is supported, so
+ * there are no attempts to use ERTM features (like OBEX over L2CAP).
+ */
+OI_BOOL OI_L2CAP_IsModeSupported(OI_L2CAP_MODE mode)
+{
+    return (OI_L2CAP_ENHANCED_RETRANSMISSION_MODE == mode);
+}
diff --git a/obex_profiles/profiles/obex/obexauth.c b/obex_profiles/profiles/obex/obexauth.c
new file mode 100644
index 0000000..c74c839
--- /dev/null
+++ b/obex_profiles/profiles/obex/obexauth.c
@@ -0,0 +1,366 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_OBEX_SRV
+
+#include "oi_debug.h"
+#include "oi_argcheck.h"
+#include "oi_assert.h"
+#include "oi_time.h"
+#include "oi_memmgr.h"
+#include "oi_obexspec.h"
+#include "oi_utils.h"
+#include "oi_obexauth.h"
+#include "md5_hash.h"
+
+
+
+void OI_OBEXAUTH_Reset(OBEX_COMMON *common)
+{
+    OI_DBGTRACE(("OI_OBEXAUTH_Reset\n"));
+
+    OI_MemZero(common->authentication, sizeof(OBEX_AUTHENTICATION));
+}
+
+
+
+OI_STATUS OI_OBEXAUTH_SaveAuthInfo(OBEX_COMMON *common,
+                                   const OI_BYTE *userId,
+                                   OI_UINT8 userIdLen,
+                                   const OI_CHAR *password)
+{
+    OI_UINT len = OI_StrLen(password);
+
+    OI_DBGTRACE(("OI_OBEXAUTH_SaveAuthInfo(userId=%s,password=%s)\n", userId, userIdLen, password));
+
+    /*
+     * Truncate to maximum password length. This means that authentication
+     * with really long passwords will not work.
+     */
+    if (len > OI_OBEX_MAX_PASSWORD_LEN) {
+       return OI_OBEX_PASSWORD_TOO_LONG;
+    }
+    OI_MemCopy(common->authentication->password, password, len);
+    common->authentication->passwordLen = len;
+
+    if(userIdLen > OI_OBEX_MAX_USERID_LEN) {
+        OI_DBGPRINT2(("Incorrect user Id length %d", userIdLen));
+        return OI_OBEX_USERID_TOO_LONG;
+    }
+
+    if ((userId != NULL) && (userIdLen > 0)) {
+        OI_MemCopy(common->authentication->userId, userId, userIdLen);
+        common->authentication->userIdLen = userIdLen;
+    } else {
+        common->authentication->userIdLen = 0;
+    }
+
+    return OI_OK;
+}
+
+
+
+OI_STATUS OI_OBEXAUTH_SaveChallenge(OBEX_COMMON *common,
+                                    OI_OBEX_HEADER *challenge)
+{
+    OBEX_AUTHENTICATION *auth = common->authentication;
+    OI_STATUS status = OI_OK;
+    OI_UINT8 options = 0;
+    OI_UINT i = 0;
+
+    OI_DBGTRACE(("OI_OBEXAUTH_SaveChallenge\n"));
+
+    OI_ASSERT(auth);
+    OI_ASSERT(challenge->id == OI_OBEX_HDR_AUTHENTICATION_CHALLENGE);
+
+    /*
+     * Locate the digest challenge nonce and save it.
+     */
+    while (i < challenge->val.byteseq.len) {
+        OI_UINT8 tag = challenge->val.byteseq.data[i++];
+        OI_UINT8 len = challenge->val.byteseq.data[i++];
+        switch(tag) {
+            case OI_OBEX_CHALLENGE_DIGEST_REALM_TAG:
+                auth->realm.len = len - 1;
+                auth->realm.charSet = challenge->val.byteseq.data[i];
+                OI_MemCopy(auth->realm.realm, &challenge->val.byteseq.data[i + 1], auth->realm.len);
+                OI_DBGPRINT2(("OBEX receive realm charSet= %d %s", auth->realm.charSet, auth->realm.realm, auth->realm.len));
+                break;
+            case OI_OBEX_CHALLENGE_DIGEST_OPTIONS_TAG:
+                if (len != 1) {
+                    status = OI_OBEX_INVALID_AUTH_DIGEST;
+                } else {
+                    options = challenge->val.byteseq.data[i];
+                    OI_DBGPRINT2(("OBEX receive challenge options = %1x", options));
+                }
+                break;
+            case OI_OBEX_CHALLENGE_DIGEST_NONCE_TAG:
+                if (len != OI_OBEX_AUTH_DIGEST_LEN) {
+                    status = OI_OBEX_INVALID_AUTH_DIGEST;
+                } else {
+                    OI_MemCopy(auth->challengeDigest, &challenge->val.byteseq.data[i], OI_OBEX_AUTH_DIGEST_LEN);
+                }
+                break;
+            default:
+                OI_DBGPRINT2(("Unexpected tag in challenge %d", tag));
+                break;
+        }
+        i += len;
+    }
+    /*
+     * Set options.
+     */
+    auth->userIdRequested = (options & OI_OBEX_AUTH_USERID_OPTION) != 0;
+    common->readOnly = (options & OI_OBEX_AUTH_READONLY_OPTION) != 0;
+
+    return status;
+}
+
+
+OI_STATUS OI_OBEXAUTH_SaveResponse(OBEX_COMMON *common,
+                                   OI_OBEX_HEADER *response)
+{
+    OBEX_AUTHENTICATION *auth = common->authentication;
+    OI_STATUS status = OI_OK;
+    OI_UINT i = 0;
+
+    OI_DBGTRACE(("OI_OBEXAUTH_SaveResponse\n"));
+
+    OI_ASSERT(auth);
+    OI_ASSERT(response->id == OI_OBEX_HDR_AUTHENTICATION_RESPONSE);
+
+    OI_MemZero(auth->userIdRemote, OI_OBEX_MAX_USERID_LEN);
+    auth->userIdRemoteLen = 0;
+
+
+    while (i < response->val.byteseq.len) {
+        OI_UINT8 tag = response->val.byteseq.data[i++];
+        OI_UINT8 len = response->val.byteseq.data[i++];
+        switch (tag) {
+            case OI_OBEX_RESPONSE_DIGEST_REQUEST_TAG:
+                if (len != OI_OBEX_AUTH_DIGEST_LEN) {
+                    status = OI_OBEX_INVALID_AUTH_DIGEST;
+                } else {
+                    OI_MemCopy(auth->responseDigest, &response->val.byteseq.data[i], OI_OBEX_AUTH_DIGEST_LEN);
+                }
+                break;
+            case OI_OBEX_RESPONSE_DIGEST_USERID_TAG:
+                if (len > 0) {
+                    if (len > OI_OBEX_MAX_USERID_LEN) {
+                        status = OI_OBEX_INVALID_AUTH_DIGEST;
+                    } else {
+                        OI_MemCopy(auth->userIdRemote, &response->val.byteseq.data[i], len);
+                        OI_DBGPRINT2(("Obex authentication response user id = %s", auth->userIdRemote));
+                        auth->userIdRemoteLen = len;
+                    }
+                }
+                break;
+        }
+        i += len;
+    }
+
+    return status;
+}
+
+
+
+/**
+ * Compose the response to an OBEX authentication challenge.
+ */
+
+void OI_OBEXAUTH_ComposeResponse(OBEX_COMMON *common,
+                                 OI_OBEX_HEADER *response)
+{
+    OI_UINT16 len = 0;
+    MD5_CONTEXT md5Context;
+    OBEX_AUTHENTICATION *auth = common->authentication;
+
+    OI_DBGTRACE(("OI_OBEXAUTH_ComposeResponse\n"));
+
+    OI_ASSERT(auth);
+
+    /*
+     * Compose a digest response to the authentication challenge by appending
+     * the password to the nonce received in the challenge and computing the MD5
+     * hash of the resultant string.
+     */
+    OI_MD5_Init(&md5Context);
+    /*
+     * Hash in the challenge digest (nonce), a separator (colon per OBEX spec),
+     * and the password
+     */
+    OI_MD5_Update(&md5Context, common->authentication->challengeDigest, OI_OBEX_AUTH_DIGEST_LEN);
+    OI_MD5_Update(&md5Context, (OI_BYTE*)":", 1);
+    OI_MD5_Update(&md5Context, common->authentication->password, common->authentication->passwordLen);
+    /*
+     * Generate the MD5 result and compose the response digest.
+     */
+    auth->responseHeader[len++] = OI_OBEX_RESPONSE_DIGEST_REQUEST_TAG;
+    auth->responseHeader[len++] = OI_OBEX_AUTH_DIGEST_LEN;
+    OI_MD5_Final(&auth->responseHeader[len], &md5Context);
+    len += OI_OBEX_AUTH_DIGEST_LEN;
+    /*
+     * Append the user id if we have one.
+     */
+    if (auth->userIdLen > 0) {
+        auth->responseHeader[len++] = OI_OBEX_RESPONSE_DIGEST_USERID_TAG;
+        auth->responseHeader[len++] = auth->userIdLen;
+        OI_MemCopy(&auth->responseHeader[len], auth->userId, auth->userIdLen);
+        len += auth->userIdLen;
+    }
+    /*
+     * Initialize the authentication response header.
+     */
+    response->id = OI_OBEX_HDR_AUTHENTICATION_RESPONSE;
+    response->val.authenticationResponse.data = auth->responseHeader;
+    response->val.authenticationResponse.len = len;
+}
+
+
+
+/**
+ * Generate an OBEX authentication challenge.
+ */
+
+void OI_OBEXAUTH_ComposeChallenge(const OI_CHAR* privateKey,
+                                  const OI_OBEX_REALM* realm,
+                                  OBEX_COMMON *common,
+                                  OI_OBEX_HEADER *challenge)
+{
+    OBEX_AUTHENTICATION *auth = common->authentication;
+    OI_UINT8 options = 0;
+    OI_UINT16 len = 0;
+    OI_UINT16 keyLen;
+    MD5_CONTEXT md5Context;
+    OI_TIME timestamp;
+
+    OI_DBGTRACE(("OI_OBEXAUTH_ComposeChallenge(privateKey=%s)\n", privateKey));
+
+    OI_ASSERT(auth);
+    OI_ASSERT(privateKey != NULL);
+
+    if((auth == NULL) || (privateKey == NULL)) {
+        return;
+    }
+
+    keyLen = OI_StrLen(privateKey);
+
+    /*
+     * Compose a digest challenge by appending a private key t(provided as a
+     * configuration parameter)o a time stamp and computing the MD5 hash of the
+     * resultant string.
+     */
+    OI_MD5_Init(&md5Context);
+    OI_Time_Now(&timestamp);
+    /*
+     * Hash in the timestamp and the private key. Private key is a NULL
+     * terminated string.
+     */
+    OI_MD5_Update(&md5Context, (OI_BYTE*) &timestamp, sizeof(timestamp));
+    OI_MD5_Update(&md5Context, (OI_BYTE*) privateKey, keyLen);
+    /*
+     * Generate the MD5 result and compose the challenge digest.
+     */
+    auth->challengeHeader[len++] = OI_OBEX_CHALLENGE_DIGEST_NONCE_TAG;
+    auth->challengeHeader[len++] = OI_OBEX_AUTH_DIGEST_LEN;
+    OI_MD5_Final(&auth->challengeHeader[len], &md5Context);
+    len += OI_OBEX_AUTH_DIGEST_LEN;
+    /*
+     * Send options if needed.
+     */
+    if (common->readOnly) {
+        options |= OI_OBEX_AUTH_READONLY_OPTION;
+    }
+    if (auth->userIdRequired) {
+        options |= OI_OBEX_AUTH_USERID_OPTION;
+    }
+    if (options) {
+        OI_DBGPRINT2(("OBEX compose challenge options = %1x", options));
+        auth->challengeHeader[len++] = OI_OBEX_CHALLENGE_DIGEST_OPTIONS_TAG;
+        auth->challengeHeader[len++] = 1;
+        auth->challengeHeader[len++] = options;
+    }
+    if (realm) {
+        OI_DBGPRINT2(("OBEX compose challenge realm charSet:%d %s", realm->charSet, realm->realm, realm->len));
+        auth->challengeHeader[len++] = OI_OBEX_CHALLENGE_DIGEST_REALM_TAG;
+        auth->challengeHeader[len++] = 1 + realm->len;
+        auth->challengeHeader[len++] = realm->charSet;
+        OI_MemCopy(&auth->challengeHeader[len], realm->realm, realm->len);
+        len += realm->len;
+    }
+    /*
+     * Initialize the authentication challenge header.
+     */
+    challenge->id = OI_OBEX_HDR_AUTHENTICATION_CHALLENGE;
+    challenge->val.authenticationChallenge.data = auth->challengeHeader;
+    challenge->val.authenticationChallenge.len = len;
+}
+
+
+OI_STATUS OI_OBEXAUTH_Authenticate(OBEX_COMMON *common)
+{
+    OBEX_AUTHENTICATION *auth = common->authentication;
+    MD5_CONTEXT md5Context;
+    OI_BYTE digest[OI_OBEX_AUTH_DIGEST_LEN];
+
+    OI_DBGTRACE(("OI_OBEXAUTH_Authenticate\n"));
+
+    OI_ASSERT(auth);
+
+    OI_DBGPRINT(("Authentication user id: %s password: %s\n", auth->userId,
+                 auth->userIdLen, auth->password, auth->passwordLen));
+
+    /*
+     * Compose the expected response to the challenge.
+     */
+    OI_MD5_Init(&md5Context);
+    /*
+     * Hash in the digest from the challenge we sent earlier followed by the
+     * separator (colon) and the passowrd.
+     */
+    OI_MD5_Update(&md5Context, &auth->challengeHeader[2], OI_OBEX_AUTH_DIGEST_LEN);
+    OI_MD5_Update(&md5Context, (OI_BYTE*)":", 1);
+    OI_MD5_Update(&md5Context, auth->password, auth->passwordLen);
+    /*
+     * Generate the MD5 result.
+     */
+    OI_MD5_Final(digest, &md5Context);
+    /*
+     * Compare the computed digest with the response digest
+     */
+    if (OI_MemCmp(digest, auth->responseDigest, OI_OBEX_AUTH_DIGEST_LEN) == 0) {
+        OI_DBGPRINT(("Authentication successful\n"));
+        return OI_OK;
+    } else {
+        OI_DBGPRINT(("Authentication failed\n"));
+        return OI_OBEX_UNAUTHORIZED;
+    }
+}
+
diff --git a/obex_profiles/profiles/obex/obexcli.c b/obex_profiles/profiles/obex/obexcli.c
new file mode 100644
index 0000000..5725693
--- /dev/null
+++ b/obex_profiles/profiles/obex/obexcli.c
@@ -0,0 +1,3056 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+API's for OBEX Client
+*/
+
+#define __OI_MODULE__ OI_MODULE_OBEX_CLI
+
+#include "oi_dispatch.h"
+#include "oi_bytestream.h"
+#include "oi_osinterface.h"
+#include "oi_memmgr.h"
+#include "oi_argcheck.h"
+#include "oi_utils.h"
+#include "oi_assert.h"
+#include "oi_debug.h"
+#include "oi_handle.h"
+
+#include "oi_init_flags.h"
+#include "oi_config_table.h"
+#include "oi_bt_profile_config.h"
+
+#include "oi_obextest.h"
+#include "oi_obex_lower.h"
+#include "oi_obexcommon.h"
+#include "oi_obexauth.h"
+#include "oi_obexcli.h"
+
+
+/*
+ * Timeout for a response to an abort command
+ */
+#define OBEX_ABORT_TIMEOUT   OI_SECONDS(2)
+
+/*
+ * How long we will wait for a disconnect to complete
+ */
+#define OBEX_DISCONNECT_TIMEOUT   OI_SECONDS(5)
+
+
+
+#define CONNECT_REQ_LEN     16
+#define DISCONNECT_REQ_LEN  3
+#define ABORT_RSP_LEN       3
+
+#define TMP_BYTESTREAM_SIZE 8
+
+
+/**
+ * Connection states - the order matters.
+ */
+
+typedef enum {
+    INVALID_CONNECTION     = 0,
+    LOWER_LAYER_CONNECTING = 1,
+    LOWER_LAYER_CONNECTED  = 2,
+    OBEX_DISCONNECTING     = 3,
+    OBEX_CONNECTED         = 4,
+    OBEX_ABORTING          = 5,
+    OBEX_GETTING           = 6,
+    OBEX_PUTTING           = 7,
+    OBEX_SETTING_PATH      = 8,
+    OBEX_BULK_PUTTING      = 9,
+    OBEX_DO_ACTION         = 10,
+} CONNECTION_STATE;
+
+
+#define COMMAND_IN_PROGRESS(state)   ((state) >= OBEX_GETTING)
+
+
+typedef enum {
+    NO_ABORT,
+    ABORT_PENDING,  /**< Abort has been request but an operation is in progress */
+    ABORT_SENT      /**< Abort has been sent and we are waiting for a response */
+} ABORT_STATE;
+
+
+struct _BULK_PUT {
+    OI_STATUS status;
+    OBEX_BULK_DATA_LIST current; /**< Block currently being written */
+    OBEX_BULK_DATA_LIST head;    /**< Oldest block not yet confirmed */
+    OBEX_BULK_DATA_LIST tail;    /**< Newest block not yet sent or confirmed */
+};
+
+struct _PUT {
+    OI_OBEXCLI_PUT_CFM confirm;
+};
+
+struct _GET {
+    OI_OBEXCLI_GET_RECV_DATA recvData;
+};
+
+struct _CONNECT {
+    OI_OBEXCLI_CONNECT_CFM confirm;
+};
+
+struct _SETPATH {
+    OI_OBEXCLI_SETPATH_CFM confirm;
+};
+
+struct _ACTION {
+    OI_OBEXCLI_ACTION_CFM confirm;
+};
+
+
+/**
+ * Connection state
+ */
+
+typedef struct {
+
+    OBEX_COMMON common;
+
+    /**
+     * Application specific context.
+     */
+    void *context;
+
+    OI_INTERVAL responseTimeout;     /** current timeout value on this connection */
+    DISPATCH_CB_HANDLE timeoutCB;    /** dispatch function handle for timeout function */
+
+    OI_OBEXCLI_DISCONNECT_IND disconnectInd;
+
+    /**
+     * Callback function for obtaining a password from the application.
+     */
+    OI_OBEXCLI_AUTH_CHALLENGE_IND challengeCB;
+
+    OI_OBEXCLI_PROGRESS_IND progressCB; /** Callback to allow upper layer to track progress */
+
+    OI_OBEXCLI_BULK_PUT_CFM bulkPutCfm; /** Callback to confirm bulk puts */
+
+    /**
+     * Union of callback information for each cmd
+     */
+    union {
+        struct _PUT put;
+        struct _BULK_PUT bulkPut;
+        struct _GET get;
+        struct _CONNECT connect;
+        struct _SETPATH setpath;
+        struct _ACTION action;
+    } CB;
+
+    /**
+     * Copy of the headers passed in to a connect request.
+     */
+    OI_OBEX_HEADER connectHdrs[OI_OBEX_MAX_CONNECT_HDRS];
+    OI_UINT8 connectHdrCount;
+
+    /**
+     * If a target was specified != OI_OBEX_INVALID_CONNECTION_ID
+     */
+    OI_UINT32 cid;
+
+    /**
+     * Indicates if the current operation is being aborted.
+     */
+    ABORT_STATE abort;
+    /**
+     * The operation that was being aborted
+     */
+    CONNECTION_STATE abortingState;
+    OI_OBEXCLI_ABORT_CFM abortConfirm;
+
+    /**
+     * TRUE if an transaction from the upper layer is in progress
+     */
+    OI_BOOL busy;
+
+    /**
+     * TRUE if srm has been requested for the current operation
+     */
+    OI_BOOL srmRequested;
+
+    /*
+     * Indicates that we are in the process of dropping the lower layer connection.
+     */
+    OI_BOOL disconnectingLowerLayer;
+
+    /*
+     * Indicates whether the client requires server authentication.
+     */
+    OI_OBEXCLI_AUTHENTICATION authRequired;
+
+    CONNECTION_STATE state;
+
+} OBEXCLI_CONNECTION;
+
+
+/**
+ * Context for asynchronously reporting an error.
+ */
+
+typedef struct {
+    OBEXCLI_CONNECTION *connection;
+    OI_STATUS status;
+} OBEXCLI_ERROR_CONTEXT;
+
+
+
+/**
+ * Type for an OBEX client handle
+ */
+static const OI_CHAR* ObexClientHandleType = "OBEXCLI_CONNECTION";
+
+
+/***************** Forward function definition *************************/
+
+static void SendAbort(OBEXCLI_CONNECTION *connection);
+
+static void LowerConnectCfm(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                            OI_UINT16 recvMtu,
+                            OI_UINT16 sendMtu,
+                            OI_STATUS result);
+
+
+static void LowerDisconnectInd(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                               OI_STATUS reason);
+
+static void LowerWriteCfm(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                          OI_MBUF *mbuf,
+                          OI_BOOL queueFull,
+                          OI_STATUS result);
+
+
+static void LowerRecvDataInd(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                             OI_BYTE *dataBuf,
+                             OI_UINT16 dataLen);
+
+
+static const OI_OBEX_LOWER_CALLBACKS lowerCallbacks =
+{
+    LowerConnectCfm,
+    NULL,
+    LowerDisconnectInd,
+    LowerWriteCfm,
+    LowerRecvDataInd
+};
+
+
+/************************************************************************/
+
+
+
+/*
+ * Get a connection struct from a connection handle
+ */
+#define LookupConnection(connectionHandle)  ((OBEXCLI_CONNECTION*)OI_HANDLE_Deref(connectionHandle))
+
+
+/*
+ * Macro so we can see where the fatal error originated
+ */
+#define FatalClientError(connection, status) \
+    do { \
+        OI_SLOG_ERROR(status, ("Fatal OBEXCLI error")); \
+        FatalObexError(connection, status); \
+    } while (0)
+
+
+
+#define SetState(connection, newState) \
+    do { \
+        OI_DBGTRACE(("State %s -> %s", ClientStateTxt((connection)->state), ClientStateTxt(newState))); \
+        (connection)->state = (newState); \
+    } while(0);
+
+#define SetAbortState(connection, newState) \
+    do { \
+        if ((connection)->abort != (newState)) { OI_DBGTRACE(("Abort State %s -> %s", AbortStateTxt((connection)->abort), AbortStateTxt(newState))); }\
+        (connection)->abort = (newState); \
+    } while(0);
+
+#ifdef OI_DEBUG
+static const OI_CHAR* ClientStateTxt(CONNECTION_STATE state)
+{
+    switch (state) {
+        case INVALID_CONNECTION:     return "INVALID_CONNECTION";
+        case LOWER_LAYER_CONNECTING: return "LOWER_LAYER_CONNECTING";
+        case LOWER_LAYER_CONNECTED:  return "LOWER_LAYER_CONNECTED";
+        case OBEX_DISCONNECTING:     return "OBEX_DISCONNECTING";
+        case OBEX_CONNECTED:         return "OBEX_CONNECTED";
+        case OBEX_ABORTING:          return "OBEX_ABORTING";
+        case OBEX_GETTING:           return "OBEX_GETTING";
+        case OBEX_PUTTING:           return "OBEX_PUTTING";
+        case OBEX_SETTING_PATH:      return "OBEX_SETTING_PATH";
+        case OBEX_BULK_PUTTING:      return "OBEX_BULK_PUTTING";
+        case OBEX_DO_ACTION:         return "OBEX_DO_ACTION";
+        default:                     return "Invalid";
+    }
+}
+
+static const OI_CHAR* AbortStateTxt(ABORT_STATE state)
+{
+    switch (state) {
+        case NO_ABORT:      return "NO_ABORT";
+        case ABORT_PENDING: return "ABORT_PENDING";
+        case ABORT_SENT:    return "ABORT_SENT";
+        default:            return "Invalid";
+    }
+}
+
+#endif
+
+
+typedef enum {
+    CONFIRM_COMPLETED,
+    CONFIRM_ALL
+} CONFIRM_FILTER;
+
+
+/*
+ * Maximum number of buffers we will confirm at one time
+ */
+#define MAX_CONFIRM 16
+
+
+/*
+ * Determines if all bulk puts can be safely confirmed.
+ */
+static OI_BOOL CanConfirmAllBulkPuts(OBEXCLI_CONNECTION *connection)
+{
+    OBEX_BULK_DATA_LIST bulkData = connection->CB.bulkPut.head;
+    while (bulkData) {
+        /*
+         * A bulk data block can be confirmed to the upper layer if all the bytes sent to the lower
+         * layer have been confirmed by the lower layer.
+         */
+        if (bulkData->bytesConfirmed < bulkData->bytesSent) {
+            return FALSE;
+        }
+        bulkData = bulkData->next;
+    }
+    return TRUE;
+}
+
+
+/*
+ * Called to confirm BulkPut operations.
+ * Returns TRUE if all the blocks were confirmed.
+ */
+static OI_BOOL ConfirmBulkPuts(OBEXCLI_CONNECTION *connection,
+                               OI_STATUS status,
+                               CONFIRM_FILTER  filter)
+{
+    OI_STATUS cfmStatus = OI_OK;
+    OBEX_BULK_DATA_LIST bulkData = connection->CB.bulkPut.head;
+    OI_UINT cfmCount = 0;
+    OI_UINT8 *cfmBuffers[MAX_CONFIRM];
+    OI_UINT32 cfmLengths[MAX_CONFIRM];
+
+    OI_DBGPRINT2(("ConfirmBulkPuts %d %s", status, (filter == CONFIRM_ALL) ? "ALL" : "COMPLETED"));
+
+    while (bulkData) {
+        OI_DBGPRINT2(("bulkData %#08x sent:%d confirmed:%d final:%d",
+            bulkData, bulkData->bytesSent, bulkData->bytesConfirmed,
+            bulkData->final));
+        /*
+         * Stored error status overrides the one passed in.
+         */
+        if (!OI_SUCCESS(connection->CB.bulkPut.status)) {
+            cfmStatus = connection->CB.bulkPut.status;
+        } else {
+            cfmStatus = status;
+        }
+        /*
+         * If only confirming completed blocks return if this block is incomplete
+         */
+        if ((filter == CONFIRM_COMPLETED) && (bulkData->bytesConfirmed < bulkData->blockSize)) {
+            /*
+             * Save the error for use with the remaining confirm callbacks
+             */
+            connection->CB.bulkPut.status = (cfmStatus == OI_OBEX_CONTINUE) ? OI_OK : cfmStatus;
+            break;
+        }
+        if (bulkData->final) {
+            /*
+             *  Final block needs an OI_OK to confirm it.
+             */
+            if (cfmStatus == OI_OBEX_CONTINUE) {
+                break;
+            }
+        } else {
+            /*
+             * Not the final block so unless there is an error use the CONTINUE status
+             */
+            if (OI_SUCCESS(cfmStatus)) {
+                cfmStatus = OI_OBEX_CONTINUE;
+            }
+        }
+        cfmBuffers[cfmCount] = bulkData->blockBuffer;
+        cfmLengths[cfmCount] = bulkData->blockSize;
+        connection->CB.bulkPut.head = bulkData->next;
+        /*
+         * If there is no head there is no tail
+         */
+        if (!connection->CB.bulkPut.head) {
+            connection->CB.bulkPut.tail = NULL;
+            connection->CB.bulkPut.current = NULL;
+        }
+        OI_DBGPRINT2(("Free bulk data %#08x", bulkData));
+        OI_Free(bulkData);
+        bulkData = connection->CB.bulkPut.head;
+        if (++cfmCount == MAX_CONFIRM) {
+            OI_DBGTRACE(("ConfirmBulkPuts confirmed %d", cfmCount));
+            connection->bulkPutCfm(connection->common.connectionHandle, cfmCount, cfmBuffers, cfmLengths, cfmStatus);
+            cfmCount = 0;
+        }
+    }
+    OI_DBGPRINT2(("ConfirmBulkPuts confirmed %s%d", bulkData ? "" : "all ", cfmCount));
+    connection->bulkPutCfm(connection->common.connectionHandle,
+        cfmCount, cfmBuffers, cfmLengths, cfmStatus);
+    return (bulkData == NULL);
+}
+
+
+static void AbortConfirm(OBEXCLI_CONNECTION *connection)
+{
+    /*
+     * Cleanup after we receive the abort response
+     */
+    switch (connection->abortingState) {
+        case OBEX_BULK_PUTTING:
+            if (connection->CB.bulkPut.head) {
+                /*
+                 * Confirm bulk put in case where there are no blocks queued
+                 */
+                ConfirmBulkPuts(connection, OI_OBEX_CLIENT_ABORTED_COMMAND, CONFIRM_ALL);
+            } else {
+                connection->bulkPutCfm(connection->common.connectionHandle, 0, NULL, NULL, connection->CB.bulkPut.status);
+            }
+            break;
+        case OBEX_PUTTING:
+            connection->CB.put.confirm(connection->common.connectionHandle, NULL, OI_OBEX_CLIENT_ABORTED_COMMAND);
+            break;
+        case OBEX_GETTING:
+            connection->CB.get.recvData(connection->common.connectionHandle, NULL, OI_OBEX_CLIENT_ABORTED_COMMAND);
+            break;
+        default:
+            break;
+    }
+    /*
+     * This should be the response to the abort command.
+     */
+    SetAbortState(connection, NO_ABORT);
+    SetState(connection, OBEX_CONNECTED);
+    /*
+     * Call the appropriate callback to let the application know
+     * that the last GET or PUT operation was aborted.
+     */
+    connection->busy = FALSE;
+    connection->abortConfirm(connection->common.connectionHandle);
+}
+
+
+/*
+ * Call appropriate callback functions when a connection is dropped then free
+ * the connection state information.
+ *
+ * For GETTING/PUTTING we check the busy flag to determine if the get/put callback
+ * needs to be called.
+ */
+static void FreeConnection(OBEXCLI_CONNECTION *connection,
+                           OI_STATUS status)
+{
+    CONNECTION_STATE state = connection->state;
+
+    OI_DBGPRINT2(("FreeConnection %d", status));
+
+    /*
+     * Invalidate state in case upper layer calls back in on the callback
+     * thread and attempts to use the now invalid connection handle.
+     */
+    SetState(connection, INVALID_CONNECTION);
+    /*
+     * Clear connection timeout if one is set.
+     */
+    if (connection->timeoutCB) {
+        OI_Dispatch_CancelFunc(connection->timeoutCB);
+        connection->timeoutCB = 0;
+    }
+
+    if (NULL != connection->common.mbuf) {
+        OI_DBGTRACE(("Mbuf was not freed prior to disconnect"));
+        OI_MBUF_Free(connection->common.mbuf);
+        connection->common.mbuf = NULL;
+    }
+    /*
+     * Let abort status override the disconnect status if an abort was requested.
+     */
+    if (connection->abort != NO_ABORT) {
+        SetAbortState(connection, NO_ABORT);
+        status = OI_OBEX_CLIENT_ABORTED_COMMAND;
+    }
+    /*
+     * Report disconnect to application if there is an operation in progress.
+     */
+    switch (state) {
+        case LOWER_LAYER_CONNECTING:
+        case LOWER_LAYER_CONNECTED:
+            /*
+             * If we didn't establish  the OBEX connection we need to confirm
+             * that the connect attempt failed rather than indicating a
+             * disconnect.
+             */
+            connection->CB.connect.confirm(connection->common.connectionHandle, FALSE, status);
+            /*
+             * This will prevent us from indicating a disconnect.
+             */
+            connection->disconnectInd = NULL;
+            break;
+        case OBEX_GETTING:
+            OI_DBGPRINTSTR(("FreeConnection getting"));
+            if (connection->busy) {
+                connection->CB.get.recvData(connection->common.connectionHandle, NULL, status);
+            }
+            if (connection->abort != NO_ABORT) {
+                connection->abortConfirm(connection->common.connectionHandle);
+            }
+            break;
+        case OBEX_BULK_PUTTING:
+            /*
+             * Callback all pending cfms in the order they were issued.
+             */
+            ConfirmBulkPuts(connection, status, CONFIRM_ALL);
+            if (connection->abort != NO_ABORT) {
+                connection->abortConfirm(connection->common.connectionHandle);
+            }
+            break;
+        case OBEX_PUTTING:
+            OI_DBGPRINTSTR(("FreeConnection putting"));
+            if (connection->busy) {
+                connection->CB.put.confirm(connection->common.connectionHandle, NULL, status);
+            }
+            if (connection->abort != NO_ABORT) {
+                connection->abortConfirm(connection->common.connectionHandle);
+            }
+            break;
+        case OBEX_DO_ACTION:
+            connection->CB.action.confirm(connection->common.connectionHandle, status);
+            break;
+        case OBEX_SETTING_PATH:
+            connection->CB.setpath.confirm(connection->common.connectionHandle, status);
+            break;
+        case OBEX_ABORTING:
+            OI_DBGPRINTSTR(("FreeConnection while aborting"));
+            AbortConfirm(connection);
+            break;
+        default:
+            break;
+    }
+    OI_FreeIf(&connection->common.authentication);
+    if (connection->disconnectInd != NULL) {
+        connection->disconnectInd(connection->common.connectionHandle);
+    }
+    OI_HANDLE_Free(connection->common.connectionHandle);
+    OI_Free(connection);
+    OI_INIT_FLAG_DECREMENT(OBEX_CLI);
+}
+
+
+static void LowerDisconnectInd(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                               OI_STATUS reason)
+{
+    OBEXCLI_CONNECTION *connection = (OBEXCLI_CONNECTION*)lowerConnection->context;
+
+    OI_DBGTRACE(("LowerDisconnectInd %d", reason));
+
+    if (connection != NULL) {
+        /*
+         * If the lower layer connection was dropped by the server while we have an
+         * operation in progress we need to report a generic error status.
+         */
+        if (OI_SUCCESS(reason) && (connection->state >= OBEX_CONNECTED)) {
+            reason = OI_OBEX_NOT_CONNECTED;
+        }
+        FreeConnection(connection, reason);
+    }
+}
+
+
+/*
+ * Handle a fatal error - drop the lower connection, cleanup, and try to let
+ * the application know what happened.
+ */
+
+static void FatalObexError(OBEXCLI_CONNECTION *connection,
+                           OI_STATUS status)
+{
+    SetAbortState(connection, NO_ABORT);
+
+    /*
+     * If there is a lower layer connection disconnect it.
+     */
+    if (connection->state >= LOWER_LAYER_CONNECTED) {
+        connection->disconnectingLowerLayer = TRUE;
+        status = connection->common.lowerConnection->ifc->disconnect(connection->common.lowerConnection);
+        /*
+         * We are going to trust that the lower lower will complete the disconnect.
+         */
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Lower layer disconnect failed"));
+        }
+    } else {
+        /*
+         * Free resources allocated for the connection.
+         */
+        FreeConnection(connection, status);
+    }
+}
+
+
+/*
+ * Dispatch function for asynchronously reporting an aborted commmand.
+ */
+
+static void CommandError(DISPATCH_ARG *darg)
+{
+    OBEXCLI_ERROR_CONTEXT ctxt;
+
+    ctxt = Dispatch_GetArg(darg, OBEXCLI_ERROR_CONTEXT);
+    FatalClientError(ctxt.connection, ctxt.status);
+}
+
+
+static void ReportError(OBEXCLI_CONNECTION *connection,
+                        OI_STATUS status)
+{
+    OBEXCLI_ERROR_CONTEXT ctxt;
+    DISPATCH_ARG darg;
+
+    ctxt.connection = connection;
+    ctxt.status = status;
+    Dispatch_SetArg(darg, ctxt);
+    OI_Dispatch_RegisterFunc(CommandError, &darg, NULL);
+}
+
+
+/**
+ * Timeout an OBEX operation.
+ */
+
+static void ResponseTimeout(DISPATCH_ARG *darg)
+{
+    OBEXCLI_CONNECTION *connection = Dispatch_GetArg(darg, OBEXCLI_CONNECTION*);
+    FatalClientError(connection, OI_OBEX_CONNECTION_TIMEOUT);
+}
+
+
+/**
+ * When we start to send an obex command we expect to receive a response within
+ * some reasonable timeout period.
+ */
+
+static void SetCommandTimeout(OBEXCLI_CONNECTION *connection,
+                              OI_INTERVAL timeout)
+{
+    DISPATCH_ARG darg;
+
+    if (OI_Dispatch_IsValidHandle(connection->timeoutCB)) {
+        /*
+         * Timeout has already been registered - just extend the timeout period.
+         */
+        OI_Dispatch_SetFuncTimeout(connection->timeoutCB, timeout);
+    } else {
+        /*
+         * Register a new timeout.
+         */
+        Dispatch_SetArg(darg, connection);
+        OI_Dispatch_RegisterTimedFunc(ResponseTimeout, &darg, timeout, &connection->timeoutCB);
+    }
+}
+
+
+/**
+ * Map an OBEX response to an OI_STATUS
+ */
+
+static OI_STATUS MapResponse(OI_UINT8 rspCode,
+                             OI_STATUS status)
+{
+    switch (rspCode) {
+        case OI_OBEX_FINAL(OI_OBEX_RSP_OK):
+            status = OI_OK;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_CONTINUE):
+            status = OI_OBEX_CONTINUE;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_BAD_REQUEST):
+            status = OI_OBEX_BAD_REQUEST;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_FORBIDDEN):
+            status = OI_OBEX_ACCESS_DENIED;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NOT_FOUND):
+            status = OI_OBEX_NOT_FOUND;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NOT_IMPLEMENTED):
+            status = OI_OBEX_NOT_IMPLEMENTED;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_LENGTH_REQUIRED):
+            status = OI_OBEX_LENGTH_REQUIRED;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_SERVICE_UNAVAILABLE):
+            status = OI_OBEX_SERVICE_UNAVAILABLE;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NOT_ACCEPTABLE):
+            status = OI_OBEX_VALUE_NOT_ACCEPTABLE;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_PRECONDITION_FAILED):
+            status = OI_OBEX_PRECONDITION_FAILED;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_DATABASE_FULL):
+            status = OI_OBEX_DATABASE_FULL;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_CONFLICT):
+            status = OI_OBEX_CONFLICT;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NOT_MODIFIED):
+            status = OI_OBEX_NOT_MODIFIED;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_DATABASE_LOCKED):
+            status = OI_OBEX_DATABASE_LOCKED;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_INTERNAL_SERVER_ERROR):
+            status = OI_OBEX_INTERNAL_SERVER_ERROR;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_UNSUPPORTED_MEDIA_TYPE):
+            status = OI_OBEX_UNSUPPORTED_MEDIA_TYPE;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_UNAUTHORIZED):
+            status = OI_OBEX_UNAUTHORIZED;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_PARTIAL_CONTENT):
+            status = OI_OBEX_PARTIAL_CONTENT;
+            break;
+        case OI_OBEX_FINAL(OI_OBEX_RSP_METHOD_NOT_ALLOWED):
+            status = OI_OBEX_METHOD_NOT_ALLOWED;
+            break;
+    }
+    return status;
+}
+
+
+static OI_STATUS SendBulk(OBEXCLI_CONNECTION *connection)
+{
+    OI_STATUS status;
+    OI_BOOL final;
+
+    OI_ASSERT(!connection->busy);
+
+    if (!connection->CB.bulkPut.head) {
+        OI_DBGTRACE(("SendBulk - nothing to send"));
+        return OI_OK;
+    }
+    status = OI_OBEXCOMMON_SendBulk(&connection->common, &connection->CB.bulkPut.current, &connection->busy, &final);
+    if (OI_SUCCESS(status)) {
+        /*
+         * Start a command timer if this was the last send or we are not doing SRM
+         */
+        if (final || !(connection->common.srm & OI_OBEX_SRM_ENABLED)) {
+            SetCommandTimeout(connection, connection->responseTimeout);
+        }
+    } else {
+        OI_DBGTRACE(("OI_OBEXCOMMON_SendBulk failed %d", status));
+    }
+    return status;
+}
+
+
+static OI_STATUS BulkPutWriteCfm(OBEXCLI_CONNECTION *connection,
+                                 OI_UINT16 bytesConfirmed,
+                                 OBEX_BULK_DATA_LIST bulkData,
+                                 OI_BOOL queueFull,
+                                 OI_STATUS status)
+{
+    OBEX_BULK_DATA_LIST list = bulkData;
+
+    OI_DBGPRINT2(("BulkPutWriteCfm bytesConfirmed %d queueFull:%d %d", bytesConfirmed, queueFull, status));
+
+    /*
+     * Track progress for body data
+     */
+    connection->common.progressBytes += bytesConfirmed;
+    /*
+     * Figure out which bulk puts are being confirmed
+     */
+    while (bytesConfirmed) {
+        OI_UINT32 max = list->bytesSent - list->bytesConfirmed;
+        if (bytesConfirmed >= max) {
+            bytesConfirmed -= (OI_UINT16)max;
+        } else {
+            max = bytesConfirmed;
+        }
+        list->bytesConfirmed += max;
+        OI_DBGPRINT2(("bulkData %#08x blockSize:%d sent:%d confirmed:%d", list, list->blockSize, list->bytesSent, list->bytesConfirmed));
+        if (list->bytesConfirmed < list->blockSize) {
+            break;
+        }
+        list = list->next;
+    }
+    /*
+     * Report that the operation was aborted if we are aborting the transaction.
+     */
+    if (connection->abort != NO_ABORT) {
+        status = OI_OBEX_CLIENT_ABORTED_COMMAND;
+    }
+    /*
+     * Previous error status overrides the one passed in
+     */
+    if (!OI_SUCCESS(connection->CB.bulkPut.status)) {
+        status = connection->CB.bulkPut.status;
+    } else {
+        connection->CB.bulkPut.status = status;
+    }
+    /*
+     * If we had an error confirm all outstanding bulk puts.
+     */
+    if (!OI_SUCCESS(status)) {
+        /*
+         * If all bulk puts are confirmed we either disconnect or abort
+         */
+        if (CanConfirmAllBulkPuts(connection)) {
+            if (connection->abort != NO_ABORT) {
+                OI_DBGTRACE(("OBEX client aborting BULK_PUT operation"));
+                SendAbort(connection);
+            } else {
+                FatalClientError(connection, status);
+            }
+        }
+        return OI_OK;
+    }
+    /*
+     * If we are not doing SRM we are done for now.
+     */
+    if (!(connection->common.srm & OI_OBEX_SRM_ENABLED)) {
+        return OI_OK;
+    }
+    /*
+     * Confirm all completed bulk data blocks except the final block
+     */
+    ConfirmBulkPuts(connection, OI_OBEX_CONTINUE, CONFIRM_COMPLETED);
+    /*
+     * If the queue is not full we can write more data if we have any
+     */
+    if (!queueFull) {
+        connection->busy = FALSE;
+        status = SendBulk(connection);
+        if (!OI_SUCCESS(status)) {
+            /*
+             * Cannot report an error status if there is any data queued with lower layer
+             */
+            if (connection->CB.bulkPut.head->bytesConfirmed < connection->CB.bulkPut.head->bytesSent) {
+                connection->CB.bulkPut.status = status;
+                status = OI_OK;
+            }
+        }
+    }
+    return status;
+}
+
+
+static void LowerWriteCfm(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                          OI_MBUF *mbuf,
+                          OI_BOOL queueFull,
+                          OI_STATUS result)
+{
+    OBEXCLI_CONNECTION *connection = (OBEXCLI_CONNECTION*)lowerConnection->context;
+    OI_UINT16 numBytes;
+    void *context = mbuf->context.v;
+
+    if (connection == NULL) {
+        OI_SLOG_ERROR(OI_OBEX_NOT_CONNECTED, ("Write confirmation %d for unknown connection", result));
+        return;
+    }
+
+    numBytes = OI_MBUF_Free(mbuf);
+    connection->common.mbuf = NULL;
+
+    OI_DBGTRACE(("Write completed %d bytes: freed mbuf %#x %d", numBytes, mbuf, result));
+
+    if (connection->state == OBEX_BULK_PUTTING) {
+        #ifdef OI_TEST_HARNESS
+            if (OI_ObexTest.fastAbort) {
+                SendAbort(connection);
+                return;
+            }
+        #endif
+        result = BulkPutWriteCfm(connection, numBytes - BULK_PUT_HDR_SIZE, (OBEX_BULK_DATA_LIST)context, queueFull, result);
+    }
+    if (OI_SUCCESS(result)) {
+        if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+            /*
+             * Report progress if the upper layer has provided a progress callback
+             */
+            if (connection->progressCB && connection->common.progressBytes &&
+                ((connection->state == OBEX_PUTTING) || (connection->state == OBEX_BULK_PUTTING))) {
+                connection->progressCB(connection->common.connectionHandle, OI_OBEX_CMD_PUT,
+                    connection->common.progressBytes);
+            }
+        }
+    } else {
+        FatalClientError(connection, result);
+    }
+}
+
+
+static OI_STATUS ClientSendPacket(OBEXCLI_CONNECTION *connection,
+                                  OI_INTERVAL timeout)
+{
+    OI_STATUS status;
+    OI_BOOL queueFull;
+
+    OI_DBGPRINT2(("Sending mbuf %#x", connection->common.mbuf));
+
+    status = connection->common.lowerConnection->ifc->write(connection->common.lowerConnection, connection->common.mbuf, FALSE, &queueFull);
+    if (OI_SUCCESS(status)) {
+        SetCommandTimeout(connection, timeout);
+    } else {
+        OI_MBUF_Free(connection->common.mbuf);
+        connection->common.mbuf = NULL;
+    }
+    return status;
+}
+
+
+static OI_STATUS ClientSendBodySegment(OBEXCLI_CONNECTION *connection)
+{
+    OI_STATUS status;
+
+    OI_DBGTRACE(("ClientSendBodySegment"));
+
+    status = OI_OBEXCOMMON_MarshalBodySegment(&connection->common);
+    if (OI_SUCCESS(status)) {
+        status = ClientSendPacket(connection, connection->responseTimeout);
+    }
+    return status;
+}
+
+
+/*
+ * Send an parameterless OBEX command.
+ */
+static OI_STATUS ClientSendCommand(OBEXCLI_CONNECTION   *connection,
+                                   OI_UINT8             opcode,
+                                   OI_INTERVAL          timeout,
+                                   const OI_OBEX_HEADER_LIST *optHeaders)
+{
+    OI_STATUS status;
+    OI_OBEX_HEADER headers[1];
+    OI_UINT16 headerCount = 0;
+    OI_BYTE_STREAM pkt;
+
+    OI_ASSERT(OI_OBEX_IS_FINAL(opcode));
+
+    OI_OBEXCOMMON_InitPacket(&connection->common, opcode, &pkt);
+    /*
+     * If a target was specified at connect time we must send the connection id
+     * in the command
+     */
+    if (connection->cid != OI_OBEX_INVALID_CONNECTION_ID) {
+        OI_OBEX_HEADER *hdr = &headers[headerCount++];
+        hdr->id = OI_OBEX_HDR_CONNECTION_ID;
+        hdr->val.connectionId = connection->cid;
+    }
+    status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, optHeaders);
+    if (OI_SUCCESS(status)) {
+        status = ClientSendPacket(connection, timeout);
+    }
+    /*
+     * OBEX client is busy until we confirm the put to the upper layer
+     */
+    connection->busy = TRUE;
+    return status;
+}
+
+
+
+/**
+ * Handle response to an OBEX disconnect request.
+ */
+
+static void DisconnectResponse(OBEXCLI_CONNECTION *connection,
+                               OI_BYTE_STREAM *rcvPacket,
+                               OI_UINT8 rspCode)
+{
+    OI_STATUS status;
+
+    status = MapResponse(rspCode, OI_OBEX_DISCONNECT_FAILED);
+    if (!OI_SUCCESS(status)) {
+        FatalClientError(connection, status);
+    } else {
+        /*
+         * Terminate the underlying lower layer connection
+         */
+        connection->disconnectingLowerLayer = TRUE;
+        status = connection->common.lowerConnection->ifc->disconnect(connection->common.lowerConnection);
+        if (!OI_SUCCESS(status)) {
+            FatalClientError(connection, OI_OBEX_DISCONNECT_FAILED);
+        }
+    }
+}
+
+
+static void DefaultAbortCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId)
+{
+    OI_DBGTRACE(("Commmand aborted connection:%d", connectionId));
+}
+
+
+static void SendAbort(OBEXCLI_CONNECTION *connection)
+{
+    OI_STATUS status;
+
+    if (connection->abort == ABORT_SENT) {
+        return;
+    }
+    if (!COMMAND_IN_PROGRESS(connection->state)) {
+        OI_DBGTRACE(("Nothing to abort"));
+        return;
+    }
+
+    OI_DBGTRACE(("Sending abort command"));
+
+    /*
+     * Save the state we were in when we send the ABORT
+     */
+    connection->abortingState = connection->state;
+
+    if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+        /*
+         * Make sure lower layer flow is enabled. We will discard any data received
+         */
+        connection->common.lowerConnection->ifc->flowControl(connection->common.lowerConnection, TRUE /* ON */);
+    }
+    SetState(connection, OBEX_ABORTING);
+    /*
+     * Use default abort confirm if there isn't one set.
+     */
+    if (!connection->abortConfirm) {
+        connection->abortConfirm = DefaultAbortCfm;
+    }
+    status = ClientSendCommand(connection, OI_OBEX_CMD_ABORT, OBEX_ABORT_TIMEOUT, NULL);
+    if (OI_SUCCESS(status)) {
+        connection->busy = TRUE;
+        SetAbortState(connection, ABORT_SENT);
+    } else {
+        /*
+         * If we could not send the abort command something has gone badly
+         * wrong so we need to attempt to disconnect.
+         */
+        OI_SLOG_ERROR(status, ("Could not send abort command"));
+        FatalClientError(connection, OI_OBEX_ERROR);
+    }
+}
+
+
+
+static void AppendBulkData(OBEXCLI_CONNECTION *connection,
+                           OBEX_BULK_DATA_LIST bulkDataHead,
+                           OBEX_BULK_DATA_LIST bulkDataTail)
+{
+    if (connection->CB.bulkPut.tail) {
+        OI_ASSERT(!connection->CB.bulkPut.tail->final);
+        connection->CB.bulkPut.tail->next = bulkDataHead;
+    } else {
+        OI_ASSERT(connection->CB.bulkPut.head == NULL);
+        connection->CB.bulkPut.head = bulkDataHead;
+    }
+    connection->CB.bulkPut.tail = bulkDataTail;
+    if (!connection->CB.bulkPut.current) {
+        connection->CB.bulkPut.current = bulkDataHead;
+    }
+}
+
+
+OI_STATUS OI_OBEXCLI_BulkPut(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                             OI_UINT8 numBuffers,
+                             OI_UINT8 *bulkDataBuffer[],
+                             OI_UINT32 bufferLength[],
+                             OI_STATUS status)
+{
+    OI_BOOL final = (status != OI_OBEX_CONTINUE);
+    OBEXCLI_CONNECTION *connection;
+    OBEX_BULK_DATA_LIST bulkDataHead;
+    OBEX_BULK_DATA_LIST bulkDataTail;
+
+    /*
+     * Must be connected to an OBEX server.
+     */
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    /*
+     * Check that bulk put is supported
+     */
+    if (!connection->bulkPutCfm) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    if (connection->abort != NO_ABORT) {
+        return OI_OBEX_CLIENT_ABORTED_COMMAND;
+    }
+    /*
+     * Unlike other operations we allow multiple bulk puts
+     */
+    if (connection->busy && (connection->state != OBEX_BULK_PUTTING)) {
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    if (connection->state == OBEX_PUTTING) {
+        OI_DBGTRACE(("Starting bulk put"));
+        SetState(connection, OBEX_BULK_PUTTING);
+        connection->CB.bulkPut.head = NULL;
+        connection->CB.bulkPut.tail = NULL;
+        connection->CB.bulkPut.current = NULL;
+        connection->CB.bulkPut.status = (status == OI_OBEX_CONTINUE) ? OI_OK : status;
+    }
+    OI_DBGTRACE(("OI_OBEXCLI_BulkPut numBuffers:%d busy:%d final:%d %d", numBuffers, connection->busy, final, status));
+    /*
+     * The only way to terminate a PUT is to send an abort so if the application
+     * called us with an error status we need to abort the PUT.
+     */
+    if (!OI_SUCCESS(status) && (status != OI_OBEX_CONTINUE)) {
+        SetAbortState(connection, ABORT_PENDING);
+        connection->CB.bulkPut.status = status;
+        /*
+         * If we can confirm all bulk puts send the abort otherwise the abort will be sent from BulkPutWriteCfm
+         */
+        if (CanConfirmAllBulkPuts(connection)) {
+            OI_DBGTRACE(("OBEX client aborting BULK_PUT operation %d", status));
+            SendAbort(connection);
+        }
+        return OI_OK;
+    }
+    /*
+     * Must be already in a Put transaction
+     */
+    if (connection->state != OBEX_BULK_PUTTING) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_STATE, ("BulkPut state %s", ClientStateTxt(connection->state)));
+        return OI_STATUS_INVALID_STATE;
+    }
+    /*
+     * No more puts allowed after the final one.
+     */
+    if (connection->CB.bulkPut.tail && connection->CB.bulkPut.tail->final) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_STATE, ("BulkPut after final"));
+        return OI_STATUS_INVALID_STATE;
+    }
+    /*
+     * Unless we got an error status we require at least one buffer to send.
+     */
+    if (numBuffers == 0) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    /*
+     * Allocate data structures to track the bulk data transfer
+     */
+    status = OI_OBEXCOMMON_AllocBulkData(numBuffers, bulkDataBuffer, bufferLength, &bulkDataHead, &bulkDataTail);
+    if (OI_SUCCESS(status)) {
+        OI_ASSERT(bulkDataTail != NULL);
+        bulkDataTail->final = final;
+        AppendBulkData(connection, bulkDataHead, bulkDataTail);
+        /*
+         * Queue bulk data buffers if the lower layer is busy
+         */
+        if (!connection->busy) {
+            status = SendBulk(connection);
+        } else {
+            OI_DBGPRINT2(("OI_OBEXCLI_BulkPut queuing bulk data block"));
+        }
+    }
+    /*
+     * Initiate a disconnect if the bulk put operation failed internally.
+     */
+    if (!OI_SUCCESS(status)) {
+        OI_DBGTRACE(("OI_OBEXCLI_BulkPut failed: %d letting disconnect handle cleanup", status));
+        FatalClientError(connection, status);
+    }
+    return OI_OK;
+}
+
+
+/**
+ * Called by the application to put data.
+ */
+
+OI_STATUS OI_OBEXCLI_Put(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                         OI_OBEX_HEADER_LIST const *cmdHeaders,
+                         OI_OBEXCLI_PUT_CFM putCfm,
+                         OI_STATUS status)
+{
+    OI_OBEX_HEADER headers[2];
+    OI_UINT16 headerCount = 0;
+    OI_BYTE_STREAM pkt;
+    OI_OBEX_HEADER *hdr;
+    OBEXCLI_CONNECTION *connection;
+    OI_UINT8 cmd = (status == OI_OBEX_CONTINUE) ? OI_OBEX_CMD_PUT : OI_OBEX_FINAL(OI_OBEX_CMD_PUT);
+
+    OI_DBGTRACE(("OI_OBEXCLI_Put connectionId:%x %d cmdHeaders:%d=",
+                 connectionId, status, cmdHeaders ? cmdHeaders->list : NULL, cmdHeaders ? cmdHeaders->count : 0));
+
+    OI_ARGCHECK(putCfm != NULL);
+    /*
+     * Must be connected to an OBEX server.
+     */
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        OI_DBGTRACE(("Invalid OBEX connection %s", connection ? ClientStateTxt(connection->state) : "NULL"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    if (connection->abort != NO_ABORT) {
+        return OI_OBEX_CLIENT_ABORTED_COMMAND;
+    }
+    /*
+     * Only one operation at a time on each connection.
+     */
+    if (connection->busy || ((connection->state != OBEX_CONNECTED) && (connection->state != OBEX_PUTTING))) {
+        OI_DBGTRACE(("OBEX client PUT: another operation %s is in progress", ClientStateTxt(connection->state)));
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    /*
+     * Save callback function.
+     */
+    connection->CB.put.confirm = putCfm;
+    /*
+     * The only way to terminate a PUT is to send an abort so if the application
+     * called us with an error status we need to abort the put.
+     */
+    if (!OI_SUCCESS(status) && (status != OI_OBEX_CONTINUE)) {
+        OI_SLOG_ERROR(status, ("OBEX client terminating PUT operation"));
+        SendAbort(connection);
+        return OI_OK;
+    }
+
+    OI_DBGTRACE(("OBEX client issuing PUT request"));
+
+    if (NULL == cmdHeaders) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    OI_DBGPRINT2(("OBEX client issuing %s PUT request", OI_SUCCESS(status) ? "final" : "continue"));
+
+    OI_OBEXCOMMON_InitPacket(&connection->common, cmd, &pkt);
+
+    /*
+     * If a target was specified at connect time we must send the connection id
+     * in the first PUT packet.
+     */
+    if (connection->state == OBEX_CONNECTED) {
+        connection->srmRequested = FALSE;
+        if (connection->cid != OI_OBEX_INVALID_CONNECTION_ID) {
+            hdr = &headers[headerCount++];
+            hdr->id = OI_OBEX_HDR_CONNECTION_ID;
+            hdr->val.connectionId = connection->cid;
+        }
+        /*
+         * SRM is not enabled unless the server responds with SRM_ENABLED
+         */
+        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+        SetState(connection, OBEX_PUTTING);
+        connection->common.progressBytes = 0;
+    }
+    /*
+     * If SRM is supported for this connection request that it be enabled for this PUT
+     */
+    if (!connection->srmRequested && (connection->common.srm & OI_OBEX_SRM_SUPPORTED)) {
+        hdr = &headers[headerCount++];
+        hdr->id = OI_OBEX_HDR_SINGLE_RESPONSE_MODE;
+        hdr->val.srmParam = OI_OBEX_SRM_ENABLED;
+        connection->srmRequested = TRUE;
+        OI_DBGTRACE(("OBEX client requesing SRM for this PUT"));
+    }
+    status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, cmdHeaders);
+    if (OI_SUCCESS(status)) {
+        status = ClientSendPacket(connection, connection->responseTimeout);
+    }
+    if (!OI_SUCCESS(status)) {
+        goto PutReqError;
+    }
+    /*
+     * OBEX client is busy until we confirm the put to the upper layer
+     */
+    connection->busy = TRUE;
+    return OI_OK;
+
+PutReqError:
+
+    OI_SLOG_ERROR(status, ("OBEXCLI_PutReq"));
+    SetState(connection, OBEX_CONNECTED);
+
+    return status;
+}
+
+
+/**
+ * Request data from an OBEX server.
+ */
+
+OI_STATUS OI_OBEXCLI_Get(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                         OI_OBEX_HEADER_LIST const *cmdHeaders,
+                         OI_OBEXCLI_GET_RECV_DATA getRecvData,
+                         OI_BOOL final)
+{
+    OI_OBEX_HEADER headers[2];
+    OI_UINT16 headerCount = 0;
+    OI_UINT8 cmd = (final) ? OI_OBEX_FINAL(OI_OBEX_CMD_GET) : OI_OBEX_CMD_GET;
+    OI_OBEX_HEADER *hdr;
+    OI_BYTE_STREAM pkt;
+    OI_STATUS status;
+    OBEXCLI_CONNECTION *connection;
+
+    OI_DBGTRACE(("OI_OBEXCLI_Get connectionId:%x final:%d cmdHeaders:%x count:%d",
+                 connectionId, final, cmdHeaders ? cmdHeaders->list : NULL,
+                 cmdHeaders ? cmdHeaders->count : 0));
+
+    OI_ARGCHECK(getRecvData != NULL);
+
+    /*
+     * Must be connected to an OBEX server.
+     */
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        OI_DBGTRACE(("Invalid OBEX connection %s", connection ? ClientStateTxt(connection->state) : "NULL"));
+        return OI_OBEX_NOT_CONNECTED;
+
+    }
+    /*
+     * Check we are in the correct state for a GET request.
+     */
+    if (connection->busy || ((connection->state != OBEX_CONNECTED) && (connection->state != OBEX_GETTING))) {
+        OI_DBGTRACE(("OBEX client GET: another operation is in progress"));
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    /*
+     * In SRM mode we turn flow off until we get this request from the upper layer so we
+     * need to turn flow on again.
+     */
+    if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+        connection->common.lowerConnection->ifc->flowControl(connection->common.lowerConnection, TRUE /* ON */);
+    }
+    /*
+     *  If the current operation is being aborted silently ignore the GET request.
+     */
+    if (connection->abort != NO_ABORT) {
+        return OI_OK;
+    }
+    /*
+     * Save the callback function.
+     */
+    connection->CB.get.recvData = getRecvData;
+    /*
+     * In SRM we don't send a GET command unless the server requested one in the response packet.
+     */
+    if (final && (connection->state == OBEX_GETTING) && (connection->common.srm & OI_OBEX_SRM_ENABLED)) {
+        OI_DBGTRACE(("OBEX client doing SRM - GET supressed"));
+        /*
+         * Set a timeout in case the server goes unresponsive
+         */
+        SetCommandTimeout(connection, connection->responseTimeout);
+        return OI_OK;
+    }
+
+    OI_DBGTRACE(("OBEX client issuing GET request"));
+
+    OI_OBEXCOMMON_InitPacket(&connection->common, cmd, &pkt);
+    /*
+     * If a target was specified at connect time we must send the connection id
+     * in the first get packet.
+     */
+    if (connection->state == OBEX_CONNECTED) {
+        connection->srmRequested = FALSE;
+        if (connection->cid != OI_OBEX_INVALID_CONNECTION_ID) {
+            hdr = &headers[headerCount++];
+            hdr->id = OI_OBEX_HDR_CONNECTION_ID;
+            hdr->val.connectionId = connection->cid;
+        }
+        /*
+         * SRM is not enabled unless the server responds with SRM_ENABLED
+         */
+        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+        SetState(connection, OBEX_GETTING);
+        connection->common.progressBytes = 0;
+    }
+    /*
+     * If SRM is supported for this connection request that it be enabled for this GET. Note that we
+     * don't do this until the GET is final.
+     */
+    if (final && !connection->srmRequested && (connection->common.srm & OI_OBEX_SRM_SUPPORTED)) {
+        hdr = &headers[headerCount++];
+        hdr->id = OI_OBEX_HDR_SINGLE_RESPONSE_MODE;
+        hdr->val.srmParam = OI_OBEX_SRM_ENABLED;
+        /* Reset SRMP Headers on new Get Request */
+        connection->common.srmpValid = false;
+        connection->common.srmpWaitReceived = false;
+        connection->srmRequested = TRUE;
+        OI_DBGTRACE(("OBEX client requesing SRM for this GET"));
+    }
+    status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, cmdHeaders);
+    if (OI_SUCCESS(status)) {
+        status = ClientSendPacket(connection, connection->responseTimeout);
+    }
+    if (!OI_SUCCESS(status)) {
+        goto GetReqError;
+    }
+    /*
+     * OBEX client is busy until we receive data from the remote peer.
+     */
+    connection->busy = TRUE;
+    return OI_OK;
+
+GetReqError:
+
+    OI_SLOG_ERROR(status, ("OBEXCLI_GetReq"));
+    SetState(connection, OBEX_CONNECTED);
+
+    return status;
+
+}
+
+
+/**
+ * Handle response to an OBEX setpath command
+ */
+
+static void SetpathResponse(OBEXCLI_CONNECTION *connection,
+                            OI_BYTE_STREAM *rcvPacket,
+                            OI_UINT8 rspCode)
+{
+    OI_STATUS           status;
+    OI_OBEX_HEADER_LIST headers = { 0, 0 };
+
+    /*
+     * For interop - some non-compliant implementations return a CREATED
+     * response instead of an OK response if a new folder was created.
+     */
+    if (rspCode == OI_OBEX_FINAL(OI_OBEX_RSP_CREATED)) {
+        rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_OK);
+    }
+
+    status = MapResponse(rspCode, OI_OBEX_ERROR);
+    if (status == OI_OBEX_NOT_FOUND) {
+        /*
+         * Refine error message.
+         */
+        status = OI_OBEX_NO_SUCH_FOLDER;
+    }
+
+    OI_DBGTRACE(("OBEX client response to SETPATH %#x %d", rspCode, status));
+
+    SetState(connection, OBEX_CONNECTED);
+    /*
+     * Save headers in common struct in case callback wants to fetch raw headers
+     */
+    OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    connection->common.pRawHeaders = &headers;
+    /*
+     * Confirm to the application that the path has been set or report an error.
+     */
+    connection->busy = FALSE;
+    connection->CB.setpath.confirm(connection->common.connectionHandle, status);
+    connection->common.pRawHeaders = NULL;
+    OI_FreeIf(&headers.list);
+}
+
+
+/**
+ * Handle response to an OBEX action command
+ */
+
+static void ActionResponse(OBEXCLI_CONNECTION *connection,
+                           OI_BYTE_STREAM *rcvPacket,
+                           OI_UINT8 rspCode)
+{
+    OI_STATUS           status = MapResponse(rspCode, OI_OBEX_ERROR);
+    OI_OBEX_HEADER_LIST headers = { 0, 0 };
+
+    OI_DBGTRACE(("OBEX client response to ACTION %d", status));
+
+    SetState(connection, OBEX_CONNECTED);
+
+    /*
+     * Save headers in common struct in case callback wants to fetch raw headers
+     */
+    OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    connection->common.pRawHeaders = &headers;
+    /*
+     * Confirm to the application that the action has been completed or report an error.
+     */
+    connection->busy = FALSE;
+    connection->CB.action.confirm(connection->common.connectionHandle, status);
+    connection->common.pRawHeaders = NULL;
+    OI_FreeIf(&headers.list);
+}
+
+
+/*
+ * Handle response to an OBEX bulk put request
+ */
+static void BulkPutResponse(OBEXCLI_CONNECTION *connection,
+                            OI_BYTE_STREAM *rcvPacket,
+                            OI_UINT8 rspCode)
+{
+    OI_STATUS status;
+    OI_OBEX_HEADER *srmHdr;
+    OI_OBEX_HEADER *srmpHdr;
+    OI_OBEX_HEADER_LIST headers;
+
+    OI_DBGTRACE(("OBEX client response to bulk PUT request %d", rspCode));
+
+    /*
+     * Map the OBEX response into a OI_STATUS code.
+     */
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (OI_SUCCESS(status)) {
+        status = MapResponse(rspCode, OI_OBEX_PUT_RESPONSE_ERROR);
+    }
+
+    /*
+     * Check if we are aborting this PUT
+     */
+    if (connection->abort != NO_ABORT) {
+        /*
+         * If we cannot confirm all data blocks the abort will be handed in BulkPutWriteCfm
+         */
+        if ((connection->abort == ABORT_PENDING) && CanConfirmAllBulkPuts(connection)) {
+            OI_DBGTRACE(("Aborting BulkPUT %s", AbortStateTxt(connection->abort)));
+            /*
+             * If the PUT is complete we don't send an abort we just call the abort callback
+             */
+            if (connection->state == OBEX_BULK_PUTTING) {
+                SendAbort(connection);
+            } else {
+                ConfirmBulkPuts(connection, OI_OBEX_CLIENT_ABORTED_COMMAND, CONFIRM_ALL);
+                SetState(connection, OBEX_CONNECTED);
+                SetAbortState(connection, NO_ABORT);
+                connection->busy = FALSE;
+                connection->abortConfirm(connection->common.connectionHandle);
+            }
+        }
+        return;
+    }
+    srmHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+    if (srmHdr) {
+        if (srmHdr->val.srm == OI_OBEX_SRM_ENABLED) {
+            connection->common.srm |= OI_OBEX_SRM_ENABLED;
+            OI_DBGTRACE(("SRM enabled for this PUT"));
+            /*
+             * We don't want to pass the SRM header to the upper-layer.
+             */
+            OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+        }
+    }
+    srmpHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+    if (srmpHdr) {
+        if (srmHdr) {
+            /* SRMP Header should be sent with first Get Response, otherwise it is invalid */
+            OI_DBGTRACE(("SRMP parameter is %d, srm = %d",
+                srmpHdr->val.srmParam, connection->common.srm));
+            /* SRM Param received in first response, set SRMP as valid */
+            connection->common.srmpValid = true;
+            /* If client has set SRMP param to wait, we should disable SRM if enabled*/
+            if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_WAIT &&
+                connection->common.srm & OI_OBEX_SRM_ENABLED) {
+                connection->common.srmpWaitReceived = true;
+                connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                OI_DBGTRACE(("srmpWaitReceived %d, srm = %d",
+                    connection->common.srmpWaitReceived, connection->common.srm));
+            }
+        } else {
+            /* Remote is sending SRMP header in subsequent OBEX response */
+            OI_DBGTRACE(("SRMP valid %d", connection->common.srmpValid));
+            if (connection->common.srmpValid) {
+                if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_WAIT) {
+                    if (!connection->common.srmpWaitReceived) {
+                        /* If client has set SRMP param to wait, we should disable SRM
+                         * if enabled */
+                        connection->common.srmpWaitReceived = true;
+                        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                    }
+                } else if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_RSVP) {
+                    /* If client has set SRMP param to remove wait, we should enable SRM
+                     * if disabled */
+                    if (connection->common.srmpWaitReceived) {
+                        connection->common.srm |= OI_OBEX_SRM_ENABLED;
+                        connection->common.srmpWaitReceived = false;
+                    }
+                }
+                OI_DBGTRACE(("srmpWaitReceived %d, srm = %d",
+                    connection->common.srmpWaitReceived, connection->common.srm));
+            }
+        }
+        /*
+         * We don't want to pass the SRMP header to the upper-layer.
+         */
+        OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+    } else {
+        /* Re-enable SRM mode if disabled because of remote device has sent response without
+         * SRMP Header */
+        if (connection->common.srmpWaitReceived) {
+            OI_DBGTRACE(("Re-enabling SRM as remote removed wait"));
+            connection->common.srm |= OI_OBEX_SRM_ENABLED;
+            connection->common.srmpWaitReceived = false;
+            ConfirmBulkPuts(connection, status, CONFIRM_COMPLETED);
+            connection->busy = FALSE;
+            SendBulk(connection);
+            return;
+        }
+    }    /*
+     * Set busy flag to force any bulk puts during the confirm callback to be queued.
+     */
+    connection->busy = TRUE;
+
+    /*
+     * Potentially unsolicited results on a Bulk Put should abort the connection.
+     * However, because this is may not be an explicit remote confirmation to a
+     * truely sent block, clean-up should proceed normally.
+     */
+    if (!OI_SUCCESS(status) &&
+        ((connection->common.srm & OI_OBEX_SRM_ENABLED) ||
+         (status != OI_OBEX_CONTINUE))) {
+        /*
+         * In order to pass PTS TC_CLIENT_BCE_BV_06_I and TC_CLIENT_BCE_BV_07_I, we must not
+         * disconnect if response is FORBIDDEN (aka OI_OBEX_ACCESS_DENIED)
+         * Before we make this exception, we must make sure that we will be able to confirm
+         * all transmits pending, otherwise that somehow leads to errant pointer crashes.
+         */
+        if ((status == OI_OBEX_ACCESS_DENIED) && CanConfirmAllBulkPuts(connection)) {
+            OI_DBGPRINT2(("Received forbidden response, bulk puts will be confirmed"));
+        } else {
+            /*
+             * Save error to report back to upper layers if prior error didn't exist.
+             */
+            if (OI_SUCCESS(connection->CB.bulkPut.status)) {
+                connection->CB.bulkPut.status = status;
+            }
+            OI_SLOG_ERROR(status, ("Remote error during bulk PUT"));
+            FatalClientError(connection, status);
+            return;
+        }
+    } else {
+        if (!(connection->common.srm & OI_OBEX_SRM_SUPPORTED)) {
+            /*
+             * Report progress if the upper layer has provided a progress callback
+             */
+            if (connection->progressCB && connection->common.progressBytes &&
+                ((connection->state == OBEX_PUTTING) || (connection->state == OBEX_BULK_PUTTING))) {
+                connection->progressCB(connection->common.connectionHandle, OI_OBEX_CMD_PUT,
+                    connection->common.progressBytes);
+            }
+        }
+    }
+
+    if (ConfirmBulkPuts(connection, status, CONFIRM_COMPLETED)) {
+        /*
+         * We are done when the status is OI_OK or an ERROR and all blocks are confirmed
+         */
+        if (status != OI_OBEX_CONTINUE) {
+            SetState(connection, OBEX_CONNECTED);
+            connection->busy = FALSE;
+            return;
+        }
+    } else {
+        /*
+         * We expect to continue if there are unconfirmed blocks
+         */
+        if (status != OI_OBEX_CONTINUE) {
+            SetState(connection, OBEX_CONNECTED);
+            if (OI_SUCCESS(status)) {
+                status = OI_OBEX_ERROR;
+            }
+            connection->busy = FALSE;
+            connection->CB.bulkPut.status = OI_OBEX_ERROR;
+            return;
+        }
+    }
+    /*
+     * Now we can send any queued bulk puts
+     */
+    connection->busy = FALSE;
+    SendBulk(connection);
+}
+
+
+/*
+ * Handle response to an OBEX put request.
+ */
+static void PutResponse(OBEXCLI_CONNECTION *connection,
+                        OI_BYTE_STREAM *rcvPacket,
+                        OI_UINT8 rspCode)
+{
+    OI_OBEX_HEADER *srmHdr;
+    OI_OBEX_HEADER *srmpHdr;
+    OI_OBEX_HEADER_LIST headers;
+    OI_STATUS status;
+
+    OI_DBGTRACE(("OBEX client response to PUT request %d", rspCode));
+
+    /*
+     * Map the OBEX response into a OI_STATUS code.
+     */
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (OI_SUCCESS(status)) {
+        status = MapResponse(rspCode, OI_OBEX_PUT_RESPONSE_ERROR);
+    }
+    /*
+     * No longer putting if the status is not CONTINUE.
+     */
+    if (status != OI_OBEX_CONTINUE) {
+        SetState(connection, OBEX_CONNECTED);
+    }
+    /*
+     * Check if we are aborting this PUT
+     */
+    if (connection->abort != NO_ABORT) {
+        if (connection->abort == ABORT_PENDING) {
+            OI_DBGTRACE(("Aborting PUT %s", AbortStateTxt(connection->abort)));
+            /*
+             * If the PUT is complete we don't send the abort we just call the abort callback
+             */
+            if (connection->state == OBEX_PUTTING) {
+                SendAbort(connection);
+            } else {
+                SetState(connection, OBEX_CONNECTED);
+                SetAbortState(connection, NO_ABORT);
+                connection->busy = FALSE;
+                connection->CB.put.confirm(connection->common.connectionHandle, NULL, OI_OBEX_CLIENT_ABORTED_COMMAND);
+                connection->abortConfirm(connection->common.connectionHandle);
+            }
+        }
+        return;
+    }
+
+    srmHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+    if (srmHdr) {
+        if (srmHdr->val.srm == OI_OBEX_SRM_ENABLED) {
+            connection->common.srm |= OI_OBEX_SRM_ENABLED;
+            OI_DBGTRACE(("SRM enabled for this PUT"));
+            /*
+             * We don't want to pass the SRM header to the upper-layer.
+             */
+            OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+            #ifdef OI_TEST_HARNESS
+                if (OI_ObexTest.ignoreSRM) {
+                    connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                    OI_SLOG_ERROR(OI_STATUS_TEST_HARNESS, ("Ignoring SRM!!!"));
+                }
+            #endif
+        }
+    }
+    srmpHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+    if (srmpHdr) {
+        if (srmHdr) {
+            /* SRMP Header should be sent with first Get Response, otherwise it is invalid */
+            OI_DBGTRACE(("SRMP parameter is %d, srm = %d",
+                srmpHdr->val.srmParam, connection->common.srm));
+            /* SRM Param received in first response, set SRMP as valid */
+            connection->common.srmpValid = true;
+            /* If client has set SRMP param to wait, we should disable SRM if enabled*/
+            if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_WAIT &&
+                connection->common.srm & OI_OBEX_SRM_ENABLED) {
+                connection->common.srmpWaitReceived = true;
+                connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                OI_DBGTRACE(("srmpWaitReceived %d, srm = %d",
+                    connection->common.srmpWaitReceived, connection->common.srm));
+            }
+        } else {
+            /* Remote is sending SRMP header in subsequent OBEX response */
+            OI_DBGTRACE(("SRMP valid %d", connection->common.srmpValid));
+            if (connection->common.srmpValid) {
+                if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_WAIT) {
+                    if (!connection->common.srmpWaitReceived) {
+                        /* If client has set SRMP param to wait, we should disable SRM
+                         * if enabled */
+                        connection->common.srmpWaitReceived = true;
+                        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                    }
+                } else if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_RSVP) {
+                    /* If client has set SRMP param to remove wait, we should enable SRM
+                     * if disabled */
+                    if (connection->common.srmpWaitReceived) {
+                        connection->common.srm |= OI_OBEX_SRM_ENABLED;
+                        connection->common.srmpWaitReceived = false;
+                    }
+                }
+                OI_DBGTRACE(("srmpWaitReceived %d, srm = %d",
+                    connection->common.srmpWaitReceived, connection->common.srm));
+            }
+        }
+        /*
+         * We don't want to pass the SRMP header to the upper-layer.
+         */
+        OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+    } else {
+        /* Re-enable SRM mode if disabled because of remote device has sent response without
+         * SRMP Header */
+        if (connection->common.srmpWaitReceived) {
+            OI_DBGTRACE(("Re-enabling SRM as remote removed wait"));
+            connection->common.srm |= OI_OBEX_SRM_ENABLED;
+            connection->common.srmpWaitReceived = false;
+        }
+    }
+    /*
+     * Keep sending body segments if there are more to send.
+     */
+    if ((connection->state == OBEX_PUTTING) &&
+        OI_OBEX_IS_A_BODY_HEADER(connection->common.bodySegment.id)) {
+        status = ClientSendBodySegment(connection);
+        if (OI_SUCCESS(status)) {
+            OI_FreeIf(&headers.list);
+            return;
+        }
+    }
+    connection->busy = FALSE;
+    connection->CB.put.confirm(connection->common.connectionHandle, &headers, status);
+    OI_FreeIf(&headers.list);
+}
+
+
+/**
+ * Handle response to an OBEX get request.
+ */
+
+static void GetResponse(OBEXCLI_CONNECTION *connection,
+                        OI_BYTE_STREAM *rcvPacket,
+                        OI_UINT8 rspCode)
+{
+    OI_OBEX_HEADER *srmHdr;
+    OI_OBEX_HEADER *srmpHdr;
+    OI_OBEX_HEADER_LIST headers;
+    OI_STATUS status;
+
+    OI_DBGTRACE(("OBEX client response to GET request %d", MapResponse(rspCode, OI_OBEX_GET_RESPONSE_ERROR)));
+
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (OI_SUCCESS(status)) {
+        status = MapResponse(rspCode, OI_OBEX_GET_RESPONSE_ERROR);
+    }
+    /*
+     * No longer getting if the status is not CONTINUE.
+     */
+    if (status != OI_OBEX_CONTINUE) {
+        SetState(connection, OBEX_CONNECTED);
+        SetAbortState(connection, NO_ABORT);
+    }
+    /*
+     * Check if we have an abort pending.
+     */
+    if (connection->abort != NO_ABORT) {
+        OI_FreeIf(&headers.list);
+        SendAbort(connection);
+        return;
+    }
+    srmHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+    if (srmHdr) {
+        if (srmHdr->val.srm == OI_OBEX_SRM_ENABLED) {
+            connection->common.srm |= OI_OBEX_SRM_ENABLED;
+            OI_DBGTRACE(("SRM enabled for this GET"));
+            #ifdef OI_TEST_HARNESS
+                if (OI_ObexTest.ignoreSRM) {
+                    connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                    OI_SLOG_ERROR(OI_STATUS_TEST_HARNESS, ("Ignoring SRM!!!"));
+                }
+            #endif
+        }
+        /*
+         * We don't want to pass the SRM header to the upper-layer.
+         */
+        OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+    }
+    srmpHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+    if (srmpHdr) {
+        if (srmHdr) {
+            /* SRMP Header should be sent with first Get Response, otherwise it is invalid */
+            OI_DBGTRACE(("SRMP parameter is %d, srm = %d",
+                srmpHdr->val.srmParam, connection->common.srm));
+            /* SRM Param received in first response, set SRMP as valid */
+            connection->common.srmpValid = true;
+            /* If client has set SRMP param to wait, we should disable SRM if enabled*/
+            if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_WAIT &&
+                connection->common.srm & OI_OBEX_SRM_ENABLED) {
+                connection->common.srmpWaitReceived = true;
+                connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                OI_DBGTRACE(("srmpWaitReceived %d, srm = %d",
+                    connection->common.srmpWaitReceived, connection->common.srm));
+            }
+        } else {
+            /* Remote is sending SRMP header in subsequent OBEX response */
+            OI_DBGTRACE(("SRMP valid %d", connection->common.srmpValid));
+            if (connection->common.srmpValid) {
+                if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_WAIT) {
+                    if (!connection->common.srmpWaitReceived) {
+                        /* If client has set SRMP param to wait, we should disable SRM
+                         * if enabled */
+                        connection->common.srmpWaitReceived = true;
+                        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                    }
+                } else if (srmpHdr->val.srmParam == OI_OBEX_SRM_PARAM_RSVP) {
+                    /* If client has set SRMP param to remove wait, we should enable SRM
+                     * if disabled */
+                    if (connection->common.srmpWaitReceived) {
+                        connection->common.srm |= OI_OBEX_SRM_ENABLED;
+                        connection->common.srmpWaitReceived = false;
+                    }
+                }
+                OI_DBGTRACE(("srmpWaitReceived %d, srm = %d",
+                    connection->common.srmpWaitReceived, connection->common.srm));
+            }
+        }
+        /*
+         * We don't want to pass the SRMP header to the upper-layer.
+         */
+        OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+    } else {
+        /* Re-enable SRM mode if disabled because of remote device has sent response without
+         * SRMP Header */
+        if (connection->common.srmpWaitReceived) {
+            OI_DBGTRACE(("Re-enabling SRM as remote removed wait"));
+            connection->common.srm |= OI_OBEX_SRM_ENABLED;
+            connection->common.srmpWaitReceived = false;
+        }
+    }
+
+    /*
+     * Keep sending body segments if there are more to send.
+     */
+    if ((connection->state == OBEX_GETTING) && OI_OBEX_IS_A_BODY_HEADER(connection->common.bodySegment.id)) {
+        status = ClientSendBodySegment(connection);
+        if (OI_SUCCESS(status)) {
+            OI_FreeIf(&headers.list);
+            return;
+        }
+    }
+    /*
+     * In SRM mode we must turn flow off until we get another get request from the upper layer.
+     */
+    if ((status == OI_OBEX_CONTINUE) && (connection->common.srm & OI_OBEX_SRM_ENABLED)) {
+        connection->common.lowerConnection->ifc->flowControl(connection->common.lowerConnection, FALSE /* OFF */);
+    }
+    connection->busy = FALSE;
+    connection->CB.get.recvData(connection->common.connectionHandle, &headers, status);
+    OI_FreeIf(&headers.list);
+
+    /*
+     * Report progress if the upper layer has provided a progress callback and has been progress
+     */
+    if (connection->progressCB && connection->common.progressBytes) {
+        connection->progressCB(connection->common.connectionHandle, OI_OBEX_CMD_GET, connection->common.progressBytes);
+    }
+}
+
+
+
+/**
+ * Handle response to an OBEX connect request.
+ */
+
+static void ConnectResponse(OBEXCLI_CONNECTION *connection,
+                            OI_BYTE_STREAM *rcvPacket,
+                            OI_UINT8 rspCode)
+{
+    OI_OBEX_HEADER_LIST headers = { 0, 0 };
+    OI_OBEX_HEADER *connectionId;
+    OI_OBEX_HEADER *authChallenge;
+    OI_OBEX_HEADER *authResponse;
+    OI_BYTE *userIdLocal = NULL;
+    OI_UINT8 userIdLocalLen = 0;
+    OI_BYTE *userIdRemote = NULL;
+    OI_UINT8 userIdRemoteLen = 0;
+    OI_BOOL notAuthorized = FALSE;
+    OI_STATUS status;
+    OI_UINT8 version = 0;
+    OI_UINT16 maxSendPktLen = 0;
+
+    status = MapResponse(rspCode, OI_OBEX_CONNECT_FAILED);
+    if (!OI_SUCCESS(status)) {
+        /*
+         * Server responds with NOT_AUTHORIZED if authentication is required.
+         */
+        if (status == OI_OBEX_UNAUTHORIZED) {
+            OI_DBGTRACE(("OBEX Client authentication requested"));
+            notAuthorized = TRUE;
+        } else {
+            OI_DBGTRACE(("OBEX Client connection rejected %d", status));
+            goto ConnectFailed;
+        }
+    }
+
+    ByteStream_GetUINT8_Checked(*rcvPacket, version);
+    /*
+     * Due to a misreading on the specification some implementations (including
+     * earlier versions of BM3) send the OBEX spec version number instead of the
+     * OBEX protocol version number. For interoperability we will only check the
+     * major version number.
+     */
+    if (OI_OBEX_MAJOR_VERSION_NUMBER(version) != OI_OBEX_MAJOR_VERSION) {
+        status = OI_OBEX_UNSUPPORTED_VERSION;
+        OI_SLOG_ERROR(status, ("OBEX Client connect - version mismatch %d.%d", OI_OBEX_MAJOR_VERSION_NUMBER(version), OI_OBEX_MINOR_VERSION_NUMBER(version)));
+        goto ConnectFailed;
+    }
+    OI_DBGPRINT2(("OBEX Client connect - version %d.%d", OI_OBEX_MAJOR_VERSION_NUMBER(version), OI_OBEX_MINOR_VERSION_NUMBER(version)));
+
+    /* We don't currently use flags -- Skipping */
+    /* ByteStream_GetUINT8_Checked(rcvPacket, flags); */
+    ByteStream_Skip(*rcvPacket, 1);
+
+    ByteStream_GetUINT16_Checked(*rcvPacket, maxSendPktLen, OI_OBEX_BO);
+
+    if (ByteStream_Error(*rcvPacket)) {
+        status = OI_OBEX_INCOMPLETE_PACKET;
+        goto ConnectFailed;
+    }
+
+    OI_DBGPRINT2(("OBEX Client MaxSendPktLen was: %d, now %d", connection->common.maxSendPktLen, OI_MIN(maxSendPktLen, connection->common.maxSendPktLen)));
+    connection->common.maxSendPktLen = OI_MIN(connection->common.maxSendPktLen, maxSendPktLen);
+
+    /*
+     * The OBEX specification defines a minimum packet length. Reject
+     * connections that do not conform to the specification.
+     */
+    if (connection->common.maxSendPktLen < OI_OBEX_MIN_PACKET_SIZE) {
+        status = OI_OBEX_VALUE_NOT_ACCEPTABLE;
+        goto ConnectFailed;
+    }
+
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (!OI_SUCCESS(status)) {
+        goto ConnectFailed;
+    }
+    /*
+     * If the server returned an unauthorized response we cannot complete the
+     * connection at this time. Instead we call back the application to request
+     * a password.
+     */
+    if (notAuthorized) {
+
+        connection->common.authenticating = TRUE;
+
+        authChallenge = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_AUTHENTICATION_CHALLENGE);
+        /*
+         * If the server returned an unauthorized response but did not return an
+         * authentication challenge, something is broken with the server.
+         */
+        if (authChallenge == NULL) {
+            status = OI_OBEX_REQUIRED_HEADER_NOT_FOUND;
+            goto ConnectFailed;
+        }
+        OI_DBGTRACE(("OBEX client received authentication challenge"));
+        if (connection->common.authentication == NULL) {
+            /*
+             * If the application is not allowing authentication we
+             * have to reject the connnection.
+             */
+            status = OI_OBEX_NOT_IMPLEMENTED;
+            goto ConnectFailed;
+        }
+        /*
+         * Save the challenge digest
+         */
+        OI_OBEXAUTH_SaveChallenge(&connection->common, authChallenge);
+        /*
+         * Request a password and, if required, user id from the application.
+         */
+        if (connection->challengeCB != NULL) {
+            connection->busy = FALSE;
+            /* Save headers in common struct in case callback wants to fetch raw headers */
+            connection->common.pRawHeaders = &headers;
+            if (connection->common.authentication->realm.len > 0) {
+                connection->challengeCB(connection->common.connectionHandle, connection->common.authentication->userIdRequested, &connection->common.authentication->realm);
+            } else {
+                connection->challengeCB(connection->common.connectionHandle, connection->common.authentication->userIdRequested, NULL);
+            }
+            connection->common.pRawHeaders = NULL;
+        }
+        /*
+         * We will be resending the connection request so we are done with the
+         * connection response.
+         */
+        OI_Free(headers.list);
+        return;
+    }
+
+    /*
+     * Get the connection id if there was one.
+     */
+    connectionId = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_CONNECTION_ID);
+    if (connectionId != NULL) {
+        connection->cid = connectionId->val.connectionId;
+    }
+    /*
+     * If this connection is being authenticated we should have got an
+     * authentication response from the server.
+     */
+    if (connection->authRequired) {
+        authResponse = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_AUTHENTICATION_RESPONSE);
+        if (authResponse == NULL) {
+            status = OI_OBEX_REQUIRED_HEADER_NOT_FOUND;
+            goto ConnectFailed;
+        }
+        OI_DBGTRACE(("OBEX client received authentication response"));
+        OI_OBEXAUTH_SaveResponse(&connection->common, authResponse);
+
+        userIdRemoteLen = connection->common.authentication->userIdRemoteLen;
+        if (userIdRemoteLen > 0) {
+            userIdRemote = &connection->common.authentication->userIdRemote[0];
+            OI_DBGPRINT2(("Connection includes user id %s (%d)", userIdRemote, userIdRemoteLen));
+        }
+
+        /*
+         * Does the client require a user id as well as a password?
+         */
+        if (connection->common.authentication->userIdRequired) {
+            if (userIdRemoteLen) {
+                userIdLocal = connection->common.authentication->userId;
+                userIdLocalLen = connection->common.authentication->userIdLen;
+                OI_DBGPRINT2(("Local user id %s (%d)", userIdLocal, userIdLocalLen));
+
+                /* Check if we have a match fot User Id */
+                if (!((userIdLocalLen == userIdRemoteLen) &&
+                      (OI_Strncmp((OI_CHAR*)userIdLocal, (OI_CHAR*)userIdRemote, userIdLocalLen) == 0))) {
+                    OI_DBGTRACE(("Incorrect user id"));
+                    status = OI_OBEX_ACCESS_DENIED;
+                }
+            } else {
+                OI_DBGTRACE(("Incorrect user id"));
+                status = OI_OBEX_ACCESS_DENIED;
+            }
+
+        }
+
+        if (OI_SUCCESS(status)) {
+            status = OI_OBEXAUTH_Authenticate(&connection->common);
+        }
+
+        if (!OI_SUCCESS(status)) {
+
+            status = OI_OBEX_ACCESS_DENIED;
+
+            /*
+             * Reject the connection attempt.
+             */
+            OI_OBEXAUTH_Reset(&connection->common);
+            goto ConnectFailed;
+        }
+    }
+
+    /*
+     * Let the application know the connection has been established.
+     */
+    OI_DBGTRACE(("OBEX client connection confirmed%s", connection->common.srm & OI_OBEX_SRM_ENABLED ? " SRM enabled" : ""));
+    OI_DBGTRACE(("   maxRecvPktLen %d, maxSendPktLen %d",
+                connection->common.maxRecvPktLen, connection->common.maxSendPktLen));
+
+    SetState(connection, OBEX_CONNECTED);
+    connection->busy = FALSE;
+    /* Save headers in common struct in case callback wants to fetch raw headers */
+    connection->common.pRawHeaders = &headers;
+    connection->CB.connect.confirm(connection->common.connectionHandle, connection->common.readOnly, OI_OK);
+    connection->common.pRawHeaders = NULL;
+    /*
+     * All done with the received headers.
+     */
+    OI_FreeIf(&headers.list);
+
+    return;
+
+ConnectFailed:
+
+    OI_FreeIf(&headers.list);
+    OI_SLOG_ERROR(status, ("OBEX Client connection failed"));
+    /*
+     * Terminate the lower layer connection
+     */
+    FatalClientError(connection, status);
+}
+
+
+static OI_STATUS SendConnectRequest(OBEXCLI_CONNECTION  *connection,
+                                    OI_INTERVAL         timeout,
+                                    const OI_OBEX_REALM *realm)
+{
+    OI_OBEX_HEADER_LIST cmdHdrs;
+    OI_OBEX_HEADER headers[3];
+    OI_UINT16 headerCount = 0;
+    OI_BYTE_STREAM pkt;
+    OI_STATUS status;
+
+    OI_ASSERT(connection->state == LOWER_LAYER_CONNECTED);
+
+    OI_OBEXCOMMON_InitPacket(&connection->common, OI_OBEX_CMD_CONNECT, &pkt);
+
+    /*
+     * Write the command fields.
+     */
+    ByteStream_PutUINT8(pkt, OI_OBEX_VERSION_NUMBER);
+    ByteStream_PutUINT8(pkt, OI_OBEX_CONNECT_FLAGS);
+    ByteStream_PutUINT16(pkt, connection->common.maxRecvPktLen, OI_OBEX_BO);
+
+    OI_DBGTRACE(("OBEX Client SendConnectRequest %2x %2x %4x", OI_OBEX_VERSION_NUMBER, OI_OBEX_CONNECT_FLAGS, connection->common.maxRecvPktLen));
+
+    /*
+     * The Bluetooth GOEP specification is very vague about OBEX authentication
+     * it seems to imply that authentication is always mutual and is always
+     * initiated by the server. So if we are authenticating it means we are
+     * doing so in response to a challenge from the server.
+     */
+
+    if (connection->authRequired) {
+        /*
+         * Generate the client's challenge header.
+         */
+        OI_DBGTRACE(("OBEX Client calling OI_OBEXAUTH_ComposeChallenge"));
+        OI_OBEXAUTH_ComposeChallenge(OI_CONFIG_TABLE_GET(OBEX_CLI)->privateKey, realm, &connection->common, &headers[headerCount++]);
+    }
+
+    if (connection->common.authenticating) {
+        /*
+         * Respond to the server's challenge.
+         */
+        OI_DBGTRACE(("OBEX Client calling OI_OBEXAUTH_ComposeResponse"));
+        OI_OBEXAUTH_ComposeResponse(&connection->common, &headers[headerCount++]);
+    }
+
+    cmdHdrs.list = connection->connectHdrs;
+    cmdHdrs.count = connection->connectHdrCount;
+
+    status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, &cmdHdrs);
+    if (OI_SUCCESS(status)) {
+        status = ClientSendPacket(connection, timeout);
+    }
+    if (!OI_SUCCESS(status)) {
+        goto ConnectReqError;
+    }
+    /*
+     * OBEX client is busy until we get a connect response from the remote peer
+     */
+    connection->busy = TRUE;
+    return OI_OK;
+
+ConnectReqError:
+
+    return status;
+}
+
+
+/**
+ * Handle authentication data to generate authentication challenge and/or response
+ * in connection request.
+ */
+
+OI_STATUS OI_OBEXCLI_Authentication(OI_OBEXCLI_CONNECTION_HANDLE    connectionId,
+                                    const OI_BYTE                   *userId,
+                                    OI_UINT8                        userIdLen,
+                                    const OI_CHAR                   *password,
+                                    const OI_OBEX_REALM             *realm)
+{
+    OI_STATUS status;
+    OBEXCLI_CONNECTION *connection;
+
+    OI_DBGTRACE(("OI_OBEXCLI_Authentication (connectionId = %d, userId = \"%s\", userIdLen = %d, password = \"%s\")\n",
+                 connectionId, userId, userIdLen, userIdLen, password ? password : "<NULL>"));
+
+    connection = LookupConnection(connectionId);
+    if (connection == NULL) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (connection->busy) {
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    /*
+     * Make sure we are doing authentication.
+     */
+    if ((!connection->common.authenticating) && (!connection->authRequired)) {
+        return OI_OBEX_METHOD_NOT_ALLOWED;
+    }
+
+    if (password == NULL) {
+        /*
+         * Application is abandoning the connection attempt.
+         */
+        OI_DBGTRACE(("Application didn't specify password. aborting connection."));
+        status = OI_OBEX_CLIENT_ABORTED_COMMAND;
+        goto AuthResponseError;
+    }
+
+    status = OI_OBEXAUTH_SaveAuthInfo(&connection->common, userId, userIdLen, password);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("OI_OBEXAUTH_SaveAuthInfo"));
+        goto AuthResponseError;
+    }
+
+    /*
+     * Re-issue the connection request with authentication information.
+     */
+    status = SendConnectRequest(connection, OI_CONFIG_TABLE_GET(OBEX_CLI)->responseTimeout, realm);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("SendConnectRequest"));
+        goto AuthResponseError;
+    }
+    /*
+     * OBEX client is busy until we a response from the remote peer
+     */
+    connection->busy = TRUE;
+    return OI_OK;
+
+AuthResponseError:
+
+    OI_OBEXAUTH_Reset(&connection->common);
+    ReportError(connection, OI_OBEX_CLIENT_ABORTED_COMMAND);
+
+    return status;
+}
+
+
+/**
+ * Data received from an OBEX server.
+ */
+
+static void LowerRecvDataInd(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                             OI_BYTE *dataBuf,
+                             OI_UINT16 dataLen)
+{
+    OI_BYTE_STREAM rcvPacket;
+    OI_UINT8 rspCode;
+    OBEXCLI_CONNECTION *connection = (OBEXCLI_CONNECTION*)lowerConnection->context;
+
+    if (connection == NULL) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("OBEX received data for unknown connection"));
+        return;
+    }
+
+    OI_DBGPRINT2(("OBEX client %s received %d bytes", ClientStateTxt(connection->state), dataLen));
+
+    /*
+     * Cancel the timeout function.
+     */
+    if (connection->timeoutCB) {
+        OI_Dispatch_CancelFunc(connection->timeoutCB);
+        connection->timeoutCB = 0;
+    }
+    /*
+     * Ignore any OBEX data we receive while we are dropping the lower layer link.
+     */
+    if (connection->disconnectingLowerLayer) {
+        return;
+    }
+
+    ByteStream_Init(rcvPacket, dataBuf, dataLen);
+    ByteStream_Open(rcvPacket, BYTESTREAM_READ);
+    /*
+     * Get the OBEX response code and skip over the packet length.
+     */
+    ByteStream_GetUINT8(rcvPacket, rspCode);
+    ByteStream_Skip(rcvPacket, sizeof(OI_UINT16));
+
+    switch (connection->state) {
+    case LOWER_LAYER_CONNECTED:
+        ConnectResponse(connection, &rcvPacket, rspCode);
+        break;
+    case OBEX_DISCONNECTING:
+        DisconnectResponse(connection, &rcvPacket, rspCode);
+        break;
+    case OBEX_BULK_PUTTING:
+        BulkPutResponse(connection, &rcvPacket,  rspCode);
+        break;
+    case OBEX_PUTTING:
+        if (connection->abort != NO_ABORT) {
+            SendAbort(connection);
+        } else {
+            PutResponse(connection, &rcvPacket, rspCode);
+        }
+        break;
+    case OBEX_GETTING:
+        if (connection->abort != NO_ABORT) {
+            SendAbort(connection);
+        } else {
+            GetResponse(connection, &rcvPacket, rspCode);
+        }
+        break;
+    case OBEX_SETTING_PATH:
+        SetpathResponse(connection, &rcvPacket, rspCode);
+        break;
+    case OBEX_DO_ACTION:
+        ActionResponse(connection, &rcvPacket, rspCode);
+        break;
+    case OBEX_ABORTING:
+        /*
+         * In SRM we can expect to continue receiving packets after we sent the ABORT.
+         */
+        if ((rspCode != OI_OBEX_FINAL(OI_OBEX_RSP_OK)) || (dataLen > ABORT_RSP_LEN)) {
+            /*
+             * Ignore anything that obviously isn't an ABORT response.
+             */
+            OI_DBGTRACE(("Aborting - discarding packet"));
+            /*
+             * This is not a response to the abort so restart the timeout
+             */
+            SetCommandTimeout(connection, OBEX_ABORT_TIMEOUT);
+            break;
+        }
+        AbortConfirm(connection);
+        break;
+    default:
+        /*
+         * No data expected from server in this state.
+         */
+        OI_SLOG_ERROR(OI_OBEX_ERROR, ("Unexpected reponse packet"));
+        FatalClientError(connection, OI_OBEX_ERROR);
+    }
+}
+
+
+/**
+ * Confirmation that an lower layer link has been established to a remote OBEX
+ * server. Now we set up the OBEX connection over this link.
+ */
+
+static void LowerConnectCfm(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                            OI_UINT16 recvMtu,
+                            OI_UINT16 sendMtu,
+                            OI_STATUS result)
+{
+    OBEXCLI_CONNECTION *connection = (OBEXCLI_CONNECTION*)lowerConnection->context;
+
+    OI_DBGTRACE(("LowerConnectCfm %d recvMtu:%d sendMtu:%d", result, recvMtu, sendMtu));
+
+    /*
+     * We expect to find a matching entry - with no match there is
+     * no callback we can call so silently return.
+     */
+    if (connection == NULL) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Null connection handle!"));
+        return;
+    }
+
+    OI_ASSERT(connection->state == LOWER_LAYER_CONNECTING);
+
+    if (OI_SUCCESS(result)) {
+        /*
+         * Maximum OBEX packet size depends on the size of the lower layer MTU
+         */
+        connection->common.maxRecvPktLen = OI_MIN(recvMtu, connection->common.maxRecvPktLen);
+        connection->common.maxSendPktLen = sendMtu;
+
+        SetState(connection, LOWER_LAYER_CONNECTED);
+
+        if(!connection->authRequired) {
+            /*
+             * Use the default timeout on a connect request rather than application
+             * specified response timeout.
+             */
+            result = SendConnectRequest(connection, OI_CONFIG_TABLE_GET(OBEX_CLI)->responseTimeout, NULL);
+        } else {
+            /*
+             * don't need to check for connection->challengeCB != NULL
+             * since it was done when connection->authRequired was set to a nonzero value
+             */
+            connection->busy = FALSE;
+            connection->challengeCB(connection->common.connectionHandle, connection->common.authentication->userIdRequired, NULL);
+        }
+    }
+    /*
+     * If the lower connection failed, free the entry and propogate the error
+     * status to the application via the connect confirm callback.
+     */
+    if (!OI_SUCCESS(result)) {
+        FatalClientError(connection, result);
+    }
+}
+
+
+/**
+ * Establishes a connection to an OBEX server by creating a lower layer connection and then sending
+ * an OBEX connect request. The connect confirmation callback is not called until an OBEX connect
+ * response is received from the remote lower layer.
+ */
+
+OI_STATUS OI_OBEXCLI_Connect(OI_BD_ADDR *addr,
+                             OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                             OI_OBEX_CONNECTION_OPTIONS *connectOptions,
+                             OI_OBEXCLI_AUTHENTICATION authentication,
+                             const OI_OBEX_HEADER_LIST *cmdHeaders,
+                             const OI_OBEXCLI_CB_LIST *callbacks,
+                             OI_OBEXCLI_CONNECTION_HANDLE *connectionHandle,
+                             const OI_CONNECT_POLICY *policy)
+
+{
+    OI_STATUS status;
+    OBEXCLI_CONNECTION *connection = NULL;
+
+    OI_ARGCHECK(addr);
+    OI_ARGCHECK(callbacks);
+    OI_ARGCHECK(callbacks->connectCfmCB);
+    OI_ARGCHECK(callbacks->disconnectIndCB);
+    OI_ARGCHECK(connectionHandle);
+    OI_ARGCHECK(policy);
+
+    OI_DBGTRACE(("OI_OBEXCLI_Connect addr:%: %s authentication:%d connectionHandle:%x",
+                 addr, OI_OBEX_LowerProtocolTxt(lowerProtocol), authentication, connectionHandle));
+
+    /*
+     * Allocate a connection record
+     */
+    connection = OI_Calloc(sizeof(OBEXCLI_CONNECTION));
+    if (connection == NULL) {
+        return OI_STATUS_NO_RESOURCES;
+    }
+    /*
+     * Allocate a connection handle and associate it with the connection record
+     */
+    connection->common.connectionHandle = OI_HANDLE_Alloc(ObexClientHandleType, connection);
+    if (!connection->common.connectionHandle) {
+        OI_Free(connection);
+        return OI_STATUS_NO_RESOURCES;
+    }
+    /*
+     * Default timeout can be overriden by OI_OBEXCLI_SetResponseTimeout()
+     */
+    connection->responseTimeout = OI_CONFIG_TABLE_GET(OBEX_CLI)->responseTimeout;
+    /*
+     * The maximum packet size we can receive is specified by a configuration
+     * parameter. This may need to adjusted down after the lower layer transport has been
+     * configured.
+     */
+    connection->common.maxRecvPktLen = OI_CONFIG_TABLE_GET(OBEX_CLI)->maxPktLen;
+    /*
+     * Global connection state
+     */
+    SetState(connection, LOWER_LAYER_CONNECTING);
+    connection->disconnectInd = callbacks->disconnectIndCB;
+    connection->common.authenticating = FALSE;
+    connection->cid = OI_OBEX_INVALID_CONNECTION_ID;
+    connection->progressCB = callbacks->progressIndCB;
+    connection->bulkPutCfm = callbacks->bulkPutCfm;
+
+    /*
+     * Command specific state
+     */
+    connection->CB.connect.confirm = callbacks->connectCfmCB;
+
+    /*
+     * An application indicates that is supports authentication by passing
+     * authentication challenge callback function. If authentication is required
+     * allocate memory for managing the authentication state information.
+     */
+    connection->authRequired = authentication;
+
+    if (callbacks->authChallengeIndCB != NULL || authentication) {
+        connection->common.authentication = OI_Calloc(sizeof(OBEX_AUTHENTICATION));
+        if (connection->common.authentication == NULL) {
+            status = OI_STATUS_OUT_OF_MEMORY;
+            goto ConnectErrorExit;
+        }
+
+        if(authentication == OI_OBEXCLI_AUTH_USERID_AND_PASSWORD) {
+            connection->common.authentication->userIdRequired = TRUE;
+        }
+
+        if (callbacks->authChallengeIndCB != NULL) {
+            connection->challengeCB = callbacks->authChallengeIndCB;
+        } else {
+            /*
+             * If client requires authentication of a server, a callback must be provided
+             */
+            status = OI_OBEX_BAD_REQUEST;
+            goto ConnectErrorExit;
+        }
+    }
+
+    /*
+     * Copy the connect command headers
+     */
+    if (cmdHeaders == NULL) {
+        connection->connectHdrCount = 0;
+    } else {
+        OI_ASSERT(cmdHeaders->count <= OI_OBEX_MAX_CONNECT_HDRS);
+        OI_MemCopy(connection->connectHdrs, cmdHeaders->list, sizeof(OI_OBEX_HEADER) * cmdHeaders->count);
+        connection->connectHdrCount = cmdHeaders->count;
+    }
+
+    /*
+     * Use the requested packet length for the maximum frame size.
+     */
+    status = OI_OBEX_LOWER_Connect(&lowerCallbacks,
+                                   addr,
+                                   lowerProtocol,
+                                   OI_CONFIG_TABLE_GET(OBEX_CLI)->maxPktLen,
+                                   policy,
+                                   &connection->common.lowerConnection);
+
+    if (!OI_SUCCESS(status)) {
+        goto ConnectErrorExit;
+    }
+    /*
+     * Set the context on the connection handle to point to the OBEXCLI connection struct
+     */
+    connection->common.lowerConnection->context = connection;
+    /*
+     * Check if the caller wants to use SRM for this connection
+     */
+    if (connectOptions && connectOptions->enableSRM && (lowerProtocol->protocol == OI_OBEX_LOWER_L2CAP)) {
+        connection->common.srm = OI_OBEX_SRM_SUPPORTED;
+    }
+    #ifdef OI_TEST_HARNESS
+        OI_OBEX_TestInit();
+        if (OI_ObexTest.disableSRM) {
+            connection->common.srm &= ~OI_OBEX_SRM_SUPPORTED;
+        }
+    #endif
+    /*
+     * Return the connection handle
+     */
+    *connectionHandle = connection->common.connectionHandle;
+
+    OI_INIT_FLAG_INCREMENT(OBEX_CLI);
+
+    return OI_OK;
+
+ConnectErrorExit:
+
+    if (connection) {
+        if (connection->common.connectionHandle) {
+            OI_HANDLE_Free(connection->common.connectionHandle);
+        }
+        OI_FreeIf(&connection->common.authentication);
+        OI_Free(connection);
+    }
+
+    return status;
+}
+
+
+
+/**
+ * Request to disconnect a link to an OBEX server. The disconnect will complete
+ * asynchronously.
+ */
+
+OI_STATUS OI_OBEXCLI_Disconnect(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                const OI_OBEX_HEADER_LIST    *cmdHeaders)
+{
+    OI_STATUS status;
+    OBEXCLI_CONNECTION *connection = LookupConnection(connectionId);
+
+    OI_DBGTRACE(("OI_OBEXCLI_Disconnect (connectionId = %d)\n", connectionId));
+
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        return OI_STATUS_NOT_CONNECTED;
+    }
+    /*
+     * If there is an operation in progress disconnect the lower layer otherwise disconnect cleanly
+     * at the OBEX layer.
+     */
+    if (connection->state > OBEX_CONNECTED) {
+        status = OI_OBEX_OPERATION_IN_PROGRESS;
+    } else {
+        status = ClientSendCommand(connection, OI_OBEX_CMD_DISCONNECT, OBEX_DISCONNECT_TIMEOUT, cmdHeaders);
+    }
+    if (OI_SUCCESS(status)) {
+        connection->busy = TRUE;
+        SetState(connection, OBEX_DISCONNECTING);
+    } else {
+        FatalClientError(connection, status);
+    }
+    return OI_OK;
+}
+
+
+OI_STATUS OI_OBEXCLI_SetResponseTimeout(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                        OI_INTERVAL timeout)
+{
+    OBEXCLI_CONNECTION *connection;
+
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        OI_DBGTRACE(("OI_OBEXCLI_SetResponseTimeout: not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    OI_ARGCHECK(timeout > 0);
+    connection->responseTimeout = timeout;
+    return OI_OK;
+}
+
+
+OI_STATUS OI_OBEXCLI_Abort(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                           OI_OBEXCLI_ABORT_CFM         abortCfm)
+{
+    OBEXCLI_CONNECTION *connection;
+
+    OI_DBGTRACE(("OI_OBEXCLI_Abort connectionId:%d", connectionId));
+
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        OI_DBGTRACE(("OI_OBEXCLI_Abort: not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    /*
+     * Can only abort PUT and GET operations
+     */
+    if ((connection->state != OBEX_GETTING) && (connection->state != OBEX_PUTTING) && (connection->state != OBEX_BULK_PUTTING)) {
+        OI_DBGTRACE(("OI_OBEXCLI_Abort: no operation to abort"));
+        return OI_STATUS_INVALID_STATE;
+    }
+    if (connection->busy) {
+        /*
+         * The upper layer has called PUT or GET and is expecting a callback. We cannot send an
+         * ABORT immediately so we will return a pending status and send the ABORT as soon as we
+         * have called the upper layer.
+         */
+        OI_DBGTRACE(("Abort of %s pending", ClientStateTxt(connection->state)));
+        SetAbortState(connection, ABORT_PENDING);
+    } else {
+        /*
+         * The upper layer is between operations and is not waiting for a PUT or GET callback so we
+         * send the ABORT now and will call the abort confirm callback when we get a response.
+         */
+        OI_DBGTRACE(("Sending abort of %s", ClientStateTxt(connection->state)));
+        SendAbort(connection);
+    }
+    /*
+     * Save callback function.
+     */
+    connection->abortConfirm = abortCfm;
+    return OI_OK;
+}
+
+
+OI_STATUS OI_OBEXCLI_SetPath(OI_OBEXCLI_CONNECTION_HANDLE   connectionId,
+                             OI_OBEX_UNICODE const          *folder,
+                             OI_BOOL                        dontCreate,
+                             OI_BOOL                        upLevel,
+                             OI_OBEXCLI_SETPATH_CFM         setpathCfm,
+                             const OI_OBEX_HEADER_LIST      *cmdHeaders)
+{
+    OI_OBEX_HEADER headers[2];
+    OI_UINT16 headerCount = 0;
+    OI_OBEX_HEADER *hdr;
+    OI_BYTE_STREAM pkt;
+    OI_STATUS status;
+    OI_UINT8 flags;
+    const OI_UINT8 constants = 0;
+    OBEXCLI_CONNECTION *connection;
+#if defined(OI_DEBUG)
+    const OI_CHAR16 nullStr16[] = { '<', 'n', 'u' ,'l', 'l', '>', '\0' };
+#endif
+
+    OI_DBGTRACE(("OI_OBEXCLI_SetPath connectionId:%d folder:\"%s\" dontCreate:%d upLevel:%d",
+                 connectionId, (folder && folder->str) ? folder->str : nullStr16,
+                 (folder && folder->str) ? folder->len : OI_ARRAYSIZE(nullStr16) - 1,
+                 dontCreate, upLevel));
+
+    OI_ARGCHECK(setpathCfm != NULL);
+
+    /*
+     * Must be connected to an OBEX server.
+     */
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    OI_DBGPRINTSTR(("OBEX client issuing SETPATH request"));
+
+    if (connection->busy) {
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    /*
+     * Make sure there are no PUT or GET operations in progress.
+     */
+    if (connection->state != OBEX_CONNECTED) {
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    /*
+     * Cannot specify a folder name when using uplevel.
+     */
+ #if 0
+    if (upLevel && (folder != NULL)) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+#endif
+    /*
+     * Save the callback function.
+     */
+    connection->CB.setpath.confirm = setpathCfm;
+    /*
+     * If a target was specified at connect time we must send the connection id.
+     */
+    if (connection->cid != OI_OBEX_INVALID_CONNECTION_ID) {
+        hdr = &headers[headerCount++];
+        hdr->id = OI_OBEX_HDR_CONNECTION_ID;
+        hdr->val.connectionId = connection->cid;
+    }
+
+
+        hdr = &headers[headerCount++];
+        hdr->id = OI_OBEX_HDR_NAME;
+        /*
+         * An empty name header sets the path to the root folder.
+         */
+        if (folder == NULL) {
+            hdr->val.name.str = NULL;
+            hdr->val.name.len = 0;
+        } else {
+            hdr->val.name = *folder;
+        }
+
+
+    OI_OBEXCOMMON_InitPacket(&connection->common, OI_OBEX_FINAL(OI_OBEX_CMD_SET_PATH), &pkt);
+    flags = 0;
+    if (dontCreate) {
+        flags |= OI_OBEX_SETPATH_NO_CREATE;
+    }
+    if (upLevel) {
+        flags |= OI_OBEX_SETPATH_UP_LEVEL;
+    }
+    ByteStream_PutUINT8(pkt, flags);
+    ByteStream_PutUINT8(pkt, constants);
+
+    SetState(connection, OBEX_SETTING_PATH);
+
+    status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, cmdHeaders);
+    if (OI_SUCCESS(status)) {
+        status = ClientSendPacket(connection, connection->responseTimeout);
+    }
+    if (!OI_SUCCESS(status)) {
+        goto SetPathError;
+    }
+    /*
+     * OBEX client is busy until we get a response from the remote peer
+     */
+    connection->busy = TRUE;
+    return OI_OK;
+
+SetPathError:
+
+    SetState(connection, OBEX_CONNECTED);
+
+    return status;
+}
+
+
+OI_STATUS OI_OBEXCLI_DoAction(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                              OI_UINT8 actionId,
+                              OI_OBEX_UNICODE const *objectName,
+                              OI_OBEX_HEADER_LIST const *actionHdrs,
+                              OI_OBEXCLI_ACTION_CFM actionCfm)
+{
+    OI_OBEX_HEADER headers[3];
+    OI_UINT16 headerCount = 0;
+    OI_OBEX_HEADER *hdr;
+    OI_BYTE_STREAM pkt;
+    OI_STATUS status;
+    OBEXCLI_CONNECTION *connection;
+
+    OI_DBGTRACE(("OI_OBEXCLI_SDoAction connectionId:%d actionId:%d object:\"%s\" hdrs:%d=",
+        connectionId, actionId, objectName, actionHdrs->list, actionHdrs->count));
+
+
+    OI_ARGCHECK(actionHdrs != NULL);
+    OI_ARGCHECK(actionCfm != NULL);
+
+    /*
+     * Must be connected to an OBEX server.
+     */
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    OI_DBGPRINTSTR(("OBEX client issuing ACTION request"));
+
+    if (connection->busy) {
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    /*
+     * Make sure there are no PUT or GET operations in progress.
+     */
+    if (connection->state != OBEX_CONNECTED) {
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    /*
+     * Save the callback function.
+     */
+    connection->CB.action.confirm = actionCfm;
+    /*
+     * If a target was specified at connect time we must send the connection id first.
+     */
+    if (connection->cid != OI_OBEX_INVALID_CONNECTION_ID) {
+        hdr = &headers[headerCount++];
+        hdr->id = OI_OBEX_HDR_CONNECTION_ID;
+        hdr->val.connectionId = connection->cid;
+    }
+    hdr = &headers[headerCount++];
+    hdr->id = OI_OBEX_HDR_ACTION_ID;
+    hdr->val.actionId = actionId;
+    hdr = &headers[headerCount++];
+    hdr->id = OI_OBEX_HDR_NAME;
+    hdr->val.name = *objectName;
+
+    OI_OBEXCOMMON_InitPacket(&connection->common, OI_OBEX_FINAL(OI_OBEX_CMD_ACTION), &pkt);
+    SetState(connection, OBEX_DO_ACTION);
+
+    status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, actionHdrs);
+    if (OI_SUCCESS(status)) {
+        status = ClientSendPacket(connection, connection->responseTimeout);
+    }
+    if (!OI_SUCCESS(status)) {
+        goto DoActionError;
+    }
+    /*
+     * OBEX client is busy until we get a response from the remote peer
+     */
+    connection->busy = TRUE;
+    return OI_OK;
+
+DoActionError:
+
+    SetState(connection, OBEX_CONNECTED);
+
+    return status;
+}
+
+
+OI_UINT16 OI_OBEXCLI_OptimalBodyHeaderSize(OI_OBEXCLI_CONNECTION_HANDLE connectionId)
+{
+    OBEXCLI_CONNECTION *connection;
+    OI_UINT16   optimalSize;
+
+
+    /*
+     * We don't know the packet length until we are connected.
+     */
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTED)) {
+        optimalSize = 0;
+    } else {
+        optimalSize = connection->common.maxSendPktLen - OI_OBEX_BODY_PKT_OVERHEAD;
+    }
+    OI_DBGPRINT2(("OI_OBEXCLI_OptimalBodyHeaderSize (connectionId %d) is %d\n", connectionId, optimalSize));
+    return optimalSize;
+}
+
+
+OI_STATUS OI_OBEXCLI_SetConnectionContext(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                          void *context)
+{
+    OBEXCLI_CONNECTION *connection = NULL;
+
+    OI_DBGTRACE(("OI_OBEXCLI_SetConnectionContext connectionId:%#x context:%x", connectionId, context));
+
+    if (connectionId) {
+        connection = LookupConnection(connectionId);
+    }
+    if (connection == NULL) {
+        return OI_STATUS_NOT_FOUND;
+    } else {
+        connection->context = context;
+        return OI_OK;
+    }
+
+}
+
+
+void* OI_OBEXCLI_GetConnectionContext(OI_OBEXCLI_CONNECTION_HANDLE connectionId)
+{
+    OBEXCLI_CONNECTION *connection = NULL;
+
+    OI_DBGPRINT2(("OI_OBEXCLI_GetConnectionContext connectionId:%#x", connectionId));
+
+    if (connectionId) {
+        connection = LookupConnection(connectionId);
+    }
+    if (connection == NULL) {
+        return NULL;
+    } else {
+        return connection->context;
+    }
+}
+
+
+OI_STATUS OI_OBEXCLI_GetL2capCID(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                 OI_L2CAP_CID *cid)
+{
+    OI_STATUS status = OI_STATUS_NOT_FOUND;
+    OBEXCLI_CONNECTION *connection = NULL;
+
+    OI_ARGCHECK(cid != NULL);
+
+    if (connectionId) {
+        connection = LookupConnection(connectionId);
+        if (connection) {
+            switch (connection->state) {
+            case INVALID_CONNECTION:
+            case LOWER_LAYER_CONNECTING:
+            case OBEX_DISCONNECTING:
+                status = OI_STATUS_NOT_CONNECTED;
+                break;
+            default:
+                *cid = connection->common.lowerConnection->ifc->getCID(connection->common.lowerConnection);
+                status = OI_OK;
+                break;
+            }
+        }
+    }
+    return status;
+}
+
+
+OI_STATUS OI_OBEXCLI_GetRawHeaderList(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                      OI_OBEX_HEADER_LIST          **pRawHeaderList)
+{
+    OBEXCLI_CONNECTION *connection = LookupConnection(connectionId);
+
+    OI_ARGCHECK(pRawHeaderList);
+
+    if (connection == NULL) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+
+    *pRawHeaderList = connection->common.pRawHeaders;
+
+    return OI_OK;
+}
+/*****************************************************************************/
diff --git a/obex_profiles/profiles/obex/obexcommon.c b/obex_profiles/profiles/obex/obexcommon.c
new file mode 100644
index 0000000..c4a9168
--- /dev/null
+++ b/obex_profiles/profiles/obex/obexcommon.c
@@ -0,0 +1,1013 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+functions shared between OBEX server and OBEX client
+*/
+
+#define __OI_MODULE__ OI_MODULE_OBEX_SRV
+
+#include "oi_obex_lower.h"
+#include "oi_obexcommon.h"
+#include "oi_obextext.h"
+#include "oi_obexspec.h"
+#include "oi_memmgr.h"
+#include "oi_utils.h"
+#include "oi_mbuf.h"
+#include "oi_status.h"
+#include "oi_assert.h"
+#include "oi_text.h"
+#include "oi_debug.h"
+#include "oi_argcheck.h"
+
+#define PRIORITY_HEADER(h) ((OI_OBEX_HDR_TARGET == h) || (OI_OBEX_HDR_CONNECTION_ID == h) || (OI_OBEX_HDR_SESSION_PARAMS == h))
+
+#ifdef OI_DEBUG
+static void DumpHeaderLists(OI_OBEX_HEADER *hdrs,
+                            OI_INT count,
+                            const OI_OBEX_HEADER_LIST* hdrList)
+{
+    OI_INT i;
+
+    /*
+     * First, dump priority headers.  Maintain same order
+     * created in AddHeader() (priority headers are prepended).
+     */
+    if (NULL != hdrList) {
+        for (i = hdrList->count-1; i >= 0; i--) {
+            if (PRIORITY_HEADER(hdrList->list[i].id)) {
+                OI_DBGPRINT2(("\t%=\n", &hdrList->list[i]));
+            }
+        }
+    }
+    for (i = count-1; i >= 0; i--) {
+        if (PRIORITY_HEADER(hdrs[i].id)) {
+            OI_DBGPRINT2(("\t%=\n", &hdrs[i]));
+        }
+    }
+
+    /*
+     * Now, dump normal headers in their expected order.
+     */
+    for (i = 0; i < count; i++) {
+        if (!PRIORITY_HEADER(hdrs[i].id)) {
+            OI_DBGPRINT2(("\t%=\n", &hdrs[i]));
+        }
+    }
+    if (NULL != hdrList) {
+        for (i = 0; i < hdrList->count; i++) {
+            if (!PRIORITY_HEADER(hdrList->list[i].id)) {
+                OI_DBGPRINT2(("\t%=\n", &hdrList->list[i]));
+            }
+        }
+    }
+}
+#else
+#define DumpHeaderLists(h, c, l)
+#endif
+
+
+
+
+static OI_UINT16 HeaderSize(OI_OBEX_HEADER *header)
+{
+    OI_UINT16 length = 0;
+
+    switch (OI_OBEX_HDR_KIND(header->id)) {
+        case OI_OBEX_HDR_ID_UNICODE:
+            length = OI_OBEX_HEADER_PREFIX_LEN;
+            if (header->val.unicode.len > 0) {
+                /*
+                 * Non-empty unicode strings must be NULL terminated.
+                 */
+                if (header->val.unicode.str[header->val.unicode.len - 1] != 0) {
+                    OI_LOG_ERROR(("OBEX unicode must be NUL terminated"));
+                }
+                length += header->val.unicode.len * sizeof(OI_CHAR16);
+            }
+            break;
+        case OI_OBEX_HDR_ID_BYTESEQ:
+            length = OI_OBEX_HEADER_PREFIX_LEN + header->val.byteseq.len;
+            break;
+        case OI_OBEX_HDR_ID_UINT8:
+            length = sizeof(OI_UINT8) + sizeof(OI_UINT8);
+            break;
+        case OI_OBEX_HDR_ID_UINT32:
+            length = sizeof(OI_UINT8) + sizeof(OI_UINT32);
+            break;
+        default:
+            OI_LOG_ERROR(("Bad OBEX header"));
+            break;
+    }
+    return length;
+}
+
+
+OI_UINT16 OI_OBEXCOMMON_HeaderListSize(const OI_OBEX_HEADER_LIST *headers)
+{
+    OI_UINT i;
+    OI_UINT16 size = 0;
+
+    if (headers != NULL) {
+        for (i = 0; i < headers->count; ++i) {
+            size += HeaderSize(headers->list + i);
+        }
+    }
+    return size;
+}
+
+
+static OI_STATUS AddHeader(OBEX_COMMON *common,
+                           OI_MBUF *mbuf,
+                           OI_OBEX_HEADER *header,
+                           OI_UINT16 *pktLen)
+{
+    OI_UINT hdrId = header->id;
+    OI_STATUS status;
+    OI_BYTE tmp[8];
+    OI_BYTE *buf;
+    OI_BYTE_STREAM bs;
+    OI_UINT i;
+    OI_UINT16 pos;
+    OI_UINT16 length = HeaderSize(header);
+    OI_STATUS (*addToMbuf)(OI_MBUF*, const OI_BYTE*, OI_UINT16, OI_MBUF_DISPOSITION);
+
+    if (length == 0) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    /*
+     * Check the packet has room for this header. We will segment body and
+     * end-of-body headers across multiple packets if necessary.
+     */
+    if ((*pktLen + length) > common->maxSendPktLen) {
+        if (!OI_OBEX_IS_A_BODY_HEADER(header->id)) {
+            return OI_OBEX_PACKET_OVERFLOW;
+        }
+        OI_DBGPRINT(("Segmenting body header total=%d", length + *pktLen));
+        /*
+         * How much data will fit in this packet?
+         */
+        length = common->maxSendPktLen - *pktLen;
+        if (length <= OI_OBEX_HEADER_PREFIX_LEN) {
+            OI_DBGPRINT(("Segmenting body header - no room to send body this time"));
+            return OI_OK;
+        }
+        OI_DBGPRINT(("Segmenting size=%d", length));
+        OI_MemCopy(&common->bodySegment, header, sizeof(OI_OBEX_HEADER));
+        common->bodySegment.val.byteseq.data += (length - OI_OBEX_HEADER_PREFIX_LEN);
+        common->bodySegment.val.byteseq.len -= (length - OI_OBEX_HEADER_PREFIX_LEN);
+        /*
+         * Always a body not end-of-body
+         */
+        hdrId = OI_OBEX_HDR_BODY;
+    }
+
+    *pktLen += length;
+
+    /*
+     * Certain headers are required to come first in the header list.
+     */
+    if (PRIORITY_HEADER(hdrId)) {
+        addToMbuf = &OI_MBUF_Prepend;
+    }
+    else {
+        addToMbuf = &OI_MBUF_Append;
+    }
+
+    switch (OI_OBEX_HDR_KIND(hdrId)) {
+        case OI_OBEX_HDR_ID_UNICODE:
+            /*
+             * We want to preserve the byte order of the unicode string so we
+             * have to allocate a buffer and copy the string over.
+             */
+            buf = OI_Malloc(length);
+            if (buf == NULL) {
+                return OI_STATUS_OUT_OF_MEMORY;
+            }
+            ByteStream_Init(bs, buf, length);
+            ByteStream_Open(bs, BYTESTREAM_WRITE);
+            ByteStream_PutUINT8(bs, hdrId);
+            ByteStream_PutUINT16(bs, length, OI_OBEX_BO);
+            for (i = 0; i < header->val.unicode.len; ++i) {
+                ByteStream_PutUINT16(bs, header->val.unicode.str[i], OI_OBEX_BO);
+            }
+            /*
+             * Unicode strings are supposed to be NUL terminated if this one
+             * isn't HeaderSize() will have allocated space for one.
+             */
+            pos = ByteStream_GetPos(bs);
+            if (pos < length) {
+                ByteStream_PutUINT16(bs, 0, OI_OBEX_BO);
+            }
+            ByteStream_Close(bs);
+            /*
+             * MBUF will free the buffer when it is no longer needed.
+             */
+            status = addToMbuf(mbuf,
+                               ByteStream_GetDataPointer(bs),
+                               ByteStream_GetSize(bs),
+                               MBUF_FREE);
+
+            break;
+        case OI_OBEX_HDR_ID_BYTESEQ:
+            tmp[0] = hdrId;
+            SetUINT16_BigEndian(&tmp[1], length);
+
+            if (&OI_MBUF_Append == addToMbuf) {
+                /*
+                 * Appending, so add hdrId first
+                 */
+                status = OI_MBUF_Append(mbuf, tmp, OI_OBEX_HEADER_PREFIX_LEN, MBUF_COPY);
+                if (OI_SUCCESS(status)) {
+                    status = OI_MBUF_Append(mbuf, header->val.byteseq.data, (OI_UINT16)(length - OI_OBEX_HEADER_PREFIX_LEN), MBUF_KEEP);
+                }
+            }
+            else {
+                /*
+                 * When prepending, reverse order of calls to make
+                 * hdrId show up before data.
+                 */
+                status = OI_MBUF_Prepend(mbuf, header->val.byteseq.data, (OI_UINT16)(length - OI_OBEX_HEADER_PREFIX_LEN), MBUF_KEEP);
+                if (OI_SUCCESS(status)) {
+                    status = OI_MBUF_Prepend(mbuf, tmp, OI_OBEX_HEADER_PREFIX_LEN, MBUF_COPY);
+                }
+            }
+
+            if (OI_SUCCESS(status)) {
+                /*
+                 * Track progress for body data
+                 */
+                if (OI_OBEX_IS_A_BODY_HEADER(hdrId)) {
+                    common->progressBytes += length;
+                }
+            }
+            break;
+        case OI_OBEX_HDR_ID_UINT8:
+            tmp[0] = hdrId;
+            tmp[1] = header->val.uInt8;
+            status = addToMbuf(mbuf, tmp, 2 * sizeof(OI_UINT8), MBUF_COPY);
+            break;
+        case OI_OBEX_HDR_ID_UINT32:
+            tmp[0] = hdrId;
+            SetUINT32_BigEndian(&tmp[1], header->val.uInt32);
+            status = addToMbuf(mbuf, tmp, sizeof(OI_UINT8) + sizeof(OI_UINT32), MBUF_COPY);
+            break;
+        default:
+            status = OI_FAIL;
+    }
+    return status;
+}
+
+
+/*
+ * Marshall packet flags and headers into an mbuf.
+ */
+OI_STATUS OI_OBEXCOMMON_MarshalPacketMbuf(OBEX_COMMON       *common,
+                                          OI_BYTE_STREAM    *pktHdr,
+                                          OI_OBEX_HEADER    *hdrs,
+                                          OI_UINT16         hdrCount,
+                                          OI_OBEX_HEADER_LIST const *hdrList,
+                                          OI_MBUF           **callersMbuf)
+{
+    OI_STATUS status;
+    OI_UINT8 cells;
+    OI_UINT16 pos;
+    OI_UINT16 pktLen;
+    OI_UINT16 hdrCount2 = (hdrList == NULL) ? 0 : hdrList->count;
+    OI_UINT i;
+    OI_MBUF *mbuf = NULL;
+
+    OI_DBGPRINT2(("OI_OBEXCOMMON_MarshalPacketMbuf"));
+
+    OI_ASSERT(callersMbuf != NULL);
+    OI_ASSERT(common->bodySegment.id == 0);
+
+#ifdef OI_DEBUG
+    OI_DBGPRINT2(("Headers out {"));
+    DumpHeaderLists(hdrs, hdrCount, hdrList);
+    OI_DBGPRINT2(("}"));
+#endif
+
+    /*
+     * One cell for the packet header + at least one cell per OBEX header.
+     */
+    cells = (OI_UINT8) (hdrCount + hdrCount2 + 1);
+    /*
+     * Byteseq headers use two mbuf cells.
+     */
+    for (i = 0; i < hdrCount; ++i) {
+        if (OI_OBEX_HDR_KIND(hdrs[i].id) == OI_OBEX_HDR_ID_BYTESEQ) {
+            ++cells;
+        }
+    }
+    for (i = 0; i < hdrCount2; ++i) {
+        if (OI_OBEX_HDR_KIND(hdrList->list[i].id) == OI_OBEX_HDR_ID_BYTESEQ) {
+            ++cells;
+        }
+    }
+    /*
+     * Get the initial packet length.
+     */
+    pktLen = ByteStream_GetPos(*pktHdr);
+    /*
+     * Allocate and initialize the mbufs.
+     */
+    mbuf = OI_MBUF_Alloc(cells);
+    OI_DBGPRINT2(("Allocating MBUF %lx", mbuf));
+    if (mbuf == NULL) {
+        status = OI_STATUS_OUT_OF_MEMORY;
+        goto ErrorExit;
+    }
+    for (i = 0; i < hdrCount; ++i) {
+        status = AddHeader(common, mbuf, &hdrs[i], &pktLen);
+        if (!OI_SUCCESS(status)) {
+            goto ErrorExit;
+        }
+    }
+    for (i = 0; i < hdrCount2; ++i) {
+        status = AddHeader(common, mbuf, &hdrList->list[i], &pktLen);
+        if (!OI_SUCCESS(status)) {
+            goto ErrorExit;
+        }
+    }
+
+    pos = ByteStream_GetPos(*pktHdr);
+    ByteStream_SetPos(*pktHdr, 0);
+    /*
+     * The packet is not "final" if a body header had to be segmented.
+     */
+    if (OI_OBEX_IS_A_BODY_HEADER(common->bodySegment.id)) {
+        OI_UINT op = common->currentOpcode;
+        if (op == OI_OBEX_FINAL(OI_OBEX_RSP_OK) || (op == OI_OBEX_FINAL(OI_OBEX_RSP_CONTINUE))) {
+            op = OI_OBEX_FINAL(OI_OBEX_RSP_CONTINUE);
+        } else {
+            op &= ~OI_OBEX_FINAL_BIT;
+        }
+        ByteStream_PutUINT8(*pktHdr, op);
+    } else {
+        ByteStream_PutUINT8(*pktHdr, common->currentOpcode);
+    }
+    ByteStream_PutUINT16(*pktHdr, pktLen, OI_OBEX_BO);
+    ByteStream_SetPos(*pktHdr, pos);
+    ByteStream_Close(*pktHdr);
+
+    status = OI_MBUF_Prepend(mbuf,
+                             ByteStream_GetDataPointer(*pktHdr),
+                             ByteStream_GetSize(*pktHdr),
+                             MBUF_COPY);
+
+    if (!OI_SUCCESS(status)) {
+        goto ErrorExit;
+    }
+
+    OI_DBGPRINT2(("OI_OBEXCOMMON_MarshalPacketMbuf len = %d", pktLen));
+
+    *callersMbuf = mbuf;
+
+    return OI_OK;
+
+ErrorExit:
+
+    OI_DBGPRINT(("OI_OBEXCOMMON_MarshalPacketMbuf error exit %d", status));
+
+    if (mbuf) {
+        OI_MBUF_Free(mbuf);
+    }
+    *callersMbuf = NULL;
+    return status;
+}
+
+/*
+ * Marshall packet flags and headers into a the mbuf in common structure.
+ */
+OI_STATUS OI_OBEXCOMMON_MarshalPacket(OBEX_COMMON *common,
+                                      OI_BYTE_STREAM *pktHdr,
+                                      OI_OBEX_HEADER *hdrs,
+                                      OI_UINT16 hdrCount,
+                                      OI_OBEX_HEADER_LIST const *hdrList)
+{
+    OI_DBGPRINT2(("OBEXCOMMON_MarshalPacket"));
+
+    OI_ASSERT(common->mbuf == NULL);
+    return OI_OBEXCOMMON_MarshalPacketMbuf(common, pktHdr, hdrs, hdrCount, hdrList, &common->mbuf);
+}
+
+
+OI_STATUS OI_OBEXCOMMON_MarshalBodySegment(OBEX_COMMON *common)
+{
+    OI_BYTE_STREAM pkt;
+    OI_OBEX_HEADER hdr;
+
+    OI_ASSERT(OI_OBEX_IS_A_BODY_HEADER(common->bodySegment.id));
+
+    OI_DBGPRINT(("MarshalBodySegment"));
+
+    OI_MemCopy(&hdr, &common->bodySegment, sizeof(OI_OBEX_HEADER));
+    common->bodySegment.id = 0;
+
+    OI_OBEXCOMMON_InitPacket(common, common->currentOpcode, &pkt);
+    return OI_OBEXCOMMON_MarshalPacket(common, &pkt, &hdr, 1, NULL);
+}
+
+
+OI_STATUS OI_OBEXCOMMON_SendBulk(OBEX_COMMON *common,
+                                 OBEX_BULK_DATA_LIST *current,
+                                 OI_BOOL *busy,
+                                 OI_BOOL *final)
+{
+    OI_STATUS status = OI_OK;
+    OI_UINT8 headerId = OI_OBEX_HDR_BODY;
+    OI_UINT8 opcode = common->currentOpcode;
+    OBEX_BULK_DATA_LIST bulkDataCurrent = *current;
+    OI_UINT8 hdrBuf[BULK_PUT_HDR_SIZE];
+
+    OI_DBGPRINT2(("OI_OBEXCOMMON_SendBulk current:%#08x", *current));
+
+    if (final) {
+        *final = FALSE;
+    }
+    /*
+     * Check if we have anything to send
+     */
+    if (bulkDataCurrent == NULL) {
+        return OI_OK;
+    }
+
+    OI_ASSERT(bulkDataCurrent->bytesSent <= bulkDataCurrent->blockSize);
+    OI_ASSERT(bulkDataCurrent->bytesConfirmed <= bulkDataCurrent->blockSize);
+
+    do {
+        OI_BYTE_STREAM bs;
+        OI_MBUF *mbuf;
+        OI_UINT numBlocks = 0;
+        OI_UINT32 bodyMax = common->maxSendPktLen - sizeof(hdrBuf);
+        OI_UINT32 bodyLen = 0;
+        OBEX_BULK_DATA_LIST bulkData;
+
+        for (bulkData = bulkDataCurrent; bulkData != NULL; bulkData = bulkData->next) {
+            OI_UINT32 toSend = (bulkData->blockSize - bulkData->bytesSent);
+            ++numBlocks;
+            /*
+             * Can we only send a partial block?
+             */
+            if (toSend > bodyMax) {
+                OI_DBGPRINT2(("%#08x SendBulk[%d] partial %d", bulkData, numBlocks, bodyMax));
+                bodyLen += bodyMax;
+                break;
+            }
+            /*
+             * If the entire final data block can be sent this is the final send.
+             */
+            if (bulkData->final) {
+                OI_DBGPRINT2(("%#08x SendBulk[%d] final %d", bulkData, numBlocks, toSend));
+                /*
+                 * The final response needs the final bit set and END_OF_BODY header.
+                 */
+                if (OI_OBEX_FINAL(opcode) == OI_OBEX_FINAL(OI_OBEX_RSP_CONTINUE)) {
+                    opcode = OI_OBEX_RSP_OK;
+                }
+                headerId = OI_OBEX_HDR_END_OF_BODY;
+                opcode = OI_OBEX_FINAL(opcode);
+                if (final) {
+                    *final = TRUE;
+                }
+                OI_ASSERT(bulkData->next == NULL);
+            } else {
+                OI_DBGPRINT2(("%#08x SendBulk[%d] complete %d", bulkData, numBlocks, toSend));
+            }
+            bodyMax -= toSend;
+            bodyLen += toSend;
+        }
+        /*
+         * We need one cell for the packet header + body header and one for each data block.
+         */
+        mbuf = OI_MBUF_Alloc(1 + numBlocks);
+        OI_DBGPRINT2(("Allocating MBUF %lx", mbuf));
+        if (mbuf == NULL) {
+            status = OI_STATUS_OUT_OF_MEMORY;
+            break;
+        }
+        ByteStream_Init(bs, hdrBuf, sizeof(hdrBuf));
+        ByteStream_Open(bs, BYTESTREAM_WRITE);
+        /*
+         * Put the OBEX packet header
+         */
+        ByteStream_PutUINT8(bs, opcode);
+        ByteStream_PutUINT16(bs, bodyLen + sizeof(hdrBuf), OI_OBEX_BO);
+        /*
+         * Put the Body packet header
+         */
+        ByteStream_PutUINT8(bs, headerId);
+        ByteStream_PutUINT16(bs, bodyLen + OI_OBEX_HEADER_PREFIX_LEN, OI_OBEX_BO);
+        ByteStream_Close(bs);
+
+        OI_MBUF_Append(mbuf, ByteStream_GetDataPointer(bs), ByteStream_GetSize(bs), MBUF_COPY);
+
+        OI_DBGPRINT2(("SendBulk numBlocks:%d bytes:%d", numBlocks, bodyLen));
+
+        bulkData = bulkDataCurrent;
+        while (numBlocks--) {
+            OI_UINT32 len = bulkData->blockSize - bulkData->bytesSent;
+            if (len > bodyLen) {
+                len = bodyLen;
+            }
+            OI_MBUF_Append(mbuf, bulkData->blockBuffer + bulkData->bytesSent, (OI_UINT16)len, MBUF_KEEP);
+            bodyLen -= len;
+            bulkData->bytesSent += len;
+            if (bulkData->bytesSent == bulkData->blockSize) {
+                bulkData = bulkData->next;
+            }
+        }
+        /*
+         * Accelerate the write confirm if we have run out of data
+         */
+        status = common->lowerConnection->ifc->write(common->lowerConnection, mbuf, (bulkData == NULL), busy);
+        if (OI_SUCCESS(status)) {
+            /*
+             * Set bulkDataCurrent as context on mbuf so it is available in the write confirm callback
+             */
+            mbuf->context.v = bulkDataCurrent;
+        } else {
+            OI_MBUF_Free(mbuf);
+            OI_DBGPRINT(("OBEXCOMMON send bulk failed (%d)", status));
+            break;
+        }
+        /*
+         * Update current bulk data pointer
+         */
+        bulkDataCurrent = bulkData;
+        /*
+         * If we are not doing SRM sends are serialized.
+         */
+        if (!(common->srm & OI_OBEX_SRM_ENABLED)) {
+            OI_DBGPRINT2(("SRM not enabled - writes serialized"));
+            /*
+             * This prevents any more data from being sent until the response packet is received.
+             */
+            *busy = TRUE;
+            break;
+        }
+        /*
+         * Continue while the queue is not full and we have data to send.
+         */
+    } while ((bulkDataCurrent != NULL) && !(*busy));
+
+    OI_DBGPRINT2(("SendBulk exiting current:%#08x busy:%d", bulkDataCurrent, *busy));
+    /*
+     * Return the updated current
+     */
+    *current = bulkDataCurrent;
+    return status;
+
+}
+
+/*
+ * Allocate data structures to track the bulk data transfer
+ */
+OI_STATUS OI_OBEXCOMMON_AllocBulkData(OI_UINT8 numBuffers,
+                                      OI_UINT8 *bulkDataBuffer[],
+                                      OI_UINT32 bufferLength[],
+                                      OBEX_BULK_DATA_LIST *bulkDataHead,
+                                      OBEX_BULK_DATA_LIST *bulkDataTail)
+{
+    OI_STATUS status = OI_OK;
+    OI_UINT i;
+
+    *bulkDataHead = NULL;
+    *bulkDataTail = NULL;
+
+    /*
+     * Allocate data structures to track the bulk data transfer
+     */
+    for (i = 0; i < numBuffers; ++i) {
+        OBEX_BULK_DATA_LIST newBD = OI_Malloc(sizeof(*newBD));
+        if (newBD == NULL) {
+            status = OI_STATUS_NO_RESOURCES;
+            break;
+        }
+        OI_DBGPRINT2(("Alloc bulk data %#08x", newBD));
+        newBD->blockSize = bufferLength[i];
+        if (newBD->blockSize > 0) {
+            newBD->blockBuffer = bulkDataBuffer[i];
+        } else {
+            newBD->blockBuffer = NULL;
+        }
+        newBD->next = NULL;
+        newBD->final = FALSE;
+        newBD->bytesSent = 0;
+        newBD->bytesConfirmed = 0;
+        if (*bulkDataHead == NULL) {
+            *bulkDataHead = newBD;
+        }
+        if (*bulkDataTail != NULL) {
+            (*bulkDataTail)->next = newBD;
+        }
+        *bulkDataTail = newBD;
+    }
+    if (!OI_SUCCESS(status)) {
+        OI_OBEXCOMMON_FreeBulkData(*bulkDataHead);
+        *bulkDataHead = NULL;
+        *bulkDataTail = NULL;
+    }
+    return status;
+}
+
+
+void OI_OBEXCOMMON_FreeBulkData(OBEX_BULK_DATA_LIST list)
+{
+    while (list) {
+        OBEX_BULK_DATA_LIST next = list->next;
+        OI_DBGPRINT2(("Free bulk data %#08x", list));
+        OI_Free(list);
+        list = next;
+    }
+}
+
+
+void OI_OBEXCOMMON_InitPacket(OBEX_COMMON *common,
+                              OI_UINT8 opcode,
+                              OI_BYTE_STREAM *pkt)
+{
+    OI_DBGPRINT2(("OI_OBEXCOMMON_InitPacket %s%s", OI_OBEX_PktText(opcode), OI_OBEX_IS_FINAL(opcode) ? "(final)" : ""));
+
+    common->currentOpcode = opcode;
+    common->bodySegment.id = 0;
+
+    ByteStream_Init(*pkt, common->hdrBuf, OI_OBEX_HDR_BUFSIZE);
+    ByteStream_Open(*pkt, BYTESTREAM_WRITE);
+    /*
+     * Packet opcode and size will be filled in later.
+     */
+    ByteStream_Skip(*pkt, sizeof(OI_UINT8) + sizeof(OI_UINT16));
+}
+
+
+/**
+ * Send a simple OBEX command packet - just an opcode with no headers.
+ */
+OI_STATUS OI_OBEXCOMMON_SendSimple(OBEX_COMMON *common,
+                                   OI_UINT8 opcode)
+{
+    OI_STATUS status;
+    OI_MBUF *mbuf;
+    OI_BYTE cmdBuf[3];
+    OI_BOOL queueFull;
+
+    OI_DBGPRINT2(("OBEXCOMMON send %s%s", OI_OBEX_PktText(opcode), OI_OBEX_IS_FINAL(opcode) ? "(final)" : ""));
+
+    cmdBuf[0] = opcode;
+    cmdBuf[1] = 0;
+    cmdBuf[2] = sizeof(cmdBuf);
+    mbuf = OI_MBUF_Wrap(cmdBuf, sizeof(cmdBuf), MBUF_COPY);
+    if (mbuf == NULL)
+        return OI_STATUS_OUT_OF_MEMORY;
+    status = common->lowerConnection->ifc->write(common->lowerConnection, mbuf, TRUE, &queueFull);
+    if (!OI_SUCCESS(status)) {
+        OI_MBUF_Free(mbuf);
+        OI_SLOG_ERROR(status, ("lower layer write() failed"));
+    }
+    return status;
+}
+
+static OI_STATUS ScanHeader(OI_BYTE_STREAM *bs)
+{
+    OI_UINT8  kind;
+    OI_UINT8  id = 0;
+    OI_UINT16 len = 0;
+
+    ByteStream_GetUINT8_Checked(*bs, id);
+    kind = OI_OBEX_HDR_KIND(id);
+
+    OI_DBGPRINT(("Header Type = %d  Id =%d\n",kind,id));
+    switch (kind)
+    {
+    case OI_OBEX_HDR_ID_BYTESEQ:
+    case OI_OBEX_HDR_ID_UNICODE:
+        ByteStream_GetUINT16_Checked(*bs, len, OI_OBEX_BO);
+        OI_DBGPRINT(("Len decoded = %d \n",len));
+        len -= OI_OBEX_HEADER_PREFIX_LEN;
+        OI_DBGPRINT(("Len decoded = %d \n",len));
+        if ((len & 1) && (kind == OI_OBEX_HDR_ID_UNICODE)) {
+            OI_LOG_ERROR(("Bad OBEX Unicode len: %d (odd)\n", len));
+            return OI_OBEX_ERROR;
+        }
+        break;
+    case OI_OBEX_HDR_ID_UINT8:
+        len = sizeof(OI_UINT8);
+        break;
+    case OI_OBEX_HDR_ID_UINT32:
+        len = sizeof(OI_UINT32);
+        break;
+    default:
+        OI_LOG_ERROR(("Unrecognized OBEX Header %2x\n", id));
+        return OI_OBEX_ERROR;
+    }
+
+	OI_DBGPRINT((" ByteStream size = %d Header length =%d Byte Stream Current pos = %d\n",bs->__size,len,bs->__pos));
+    ByteStream_Skip_Checked(*bs, len);
+    if (ByteStream_Error(*bs)) {
+        OI_LOG_ERROR(("Bad OBEX Header:(%2x) len: (%d)\n", id, len));
+        return OI_OBEX_ERROR;
+    } else {
+        return OI_OK;
+    }
+}
+
+
+static void ParseHeader(OBEX_COMMON *common,
+                        OI_BYTE_STREAM *bs,
+                        OI_OBEX_HEADER *header)
+{
+    OI_BYTE *base;
+    OI_UINT16 dchar;
+    OI_UINT i;
+    OI_UINT16 len;
+
+    ByteStream_GetUINT8(*bs, header->id);
+
+    switch (OI_OBEX_HDR_KIND(header->id)) {
+    case OI_OBEX_HDR_ID_UNICODE:
+        ByteStream_GetUINT16(*bs, len, OI_OBEX_BO);
+        len -= OI_OBEX_HEADER_PREFIX_LEN;
+        OI_ASSERT((len % sizeof(OI_CHAR16)) == 0);
+        header->val.unicode.len = len / sizeof(OI_CHAR16);
+        if (header->val.unicode.len) {
+            /*
+             * Some architecture require that arrays of 16 bit values are
+             * aligned on a 16 bit boundary. We can safely adjust the start
+             * address of the unicode string to a 16 bit boundary because we
+             * no longer need the preceding length byte.
+             */
+            base = ByteStream_GetCurrentBytePointer(*bs);
+            if (((OI_UINT32) base) & 1) {
+                --base;
+            }
+            header->val.unicode.str = (OI_CHAR16*) base;
+            /*
+             * Do in-place byte order conversion for double byte characters.
+             */
+            for (i = 0; i < header->val.unicode.len; ++i) {
+                ByteStream_GetUINT16(*bs, dchar, OI_OBEX_BO);
+                header->val.unicode.str[i] = (OI_CHAR16)dchar;
+            }
+        } else {
+            header->val.unicode.str = NULL;
+        }
+        break;
+    case OI_OBEX_HDR_ID_BYTESEQ:
+        ByteStream_GetUINT16(*bs, len, OI_OBEX_BO);
+        len -= OI_OBEX_HEADER_PREFIX_LEN;
+        header->val.byteseq.len = len;
+        if (header->val.byteseq.len) {
+            header->val.byteseq.data = (OI_BYTE*) ByteStream_GetCurrentBytePointer(*bs);
+        } else {
+            header->val.byteseq.data = NULL;
+        }
+        ByteStream_Skip(*bs, len);
+        /*
+         * Track progress for body data
+         */
+        if (OI_OBEX_IS_A_BODY_HEADER(header->id)) {
+            common->progressBytes += len;
+        }
+        break;
+    case OI_OBEX_HDR_ID_UINT8:
+        ByteStream_GetUINT8(*bs, header->val.uInt8);
+        break;
+    case OI_OBEX_HDR_ID_UINT32:
+        ByteStream_GetUINT32(*bs, header->val.uInt32, OI_OBEX_BO);
+        break;
+    default:
+        OI_LOG_ERROR(("OBEX Common Parse Header corrupt header"));
+        break;
+    }
+}
+
+
+/*
+ * Look for a specific OBEX header in a header list.
+ */
+OI_STATUS OI_OBEXCOMMON_DeleteHeaderFromList(OI_OBEX_HEADER_LIST *headers,
+                                             OI_UINT8 headerId)
+{
+    OI_UINT i;
+
+    /*
+     * Find the header to remove
+     */
+    for (i = 0; i < headers->count; ++i) {
+        if (headers->list[i].id == headerId) {
+            break;
+        }
+    }
+    if (i == headers->count) {
+        return OI_STATUS_NOT_FOUND;
+    } else {
+        headers->count -= 1;
+        /*
+         * Close the gap
+         */
+        while (i < headers->count) {
+            headers->list[i] = headers->list[i + 1];
+            ++i;
+        }
+    }
+    return OI_OK;
+}
+
+
+/*
+ * Look for a specific OBEX header in a header list.
+ */
+OI_OBEX_HEADER* OI_OBEX_FindHeader(OI_OBEX_HEADER_LIST const *headers,
+                                   OI_UINT8 headerId)
+{
+    OI_UINT i;
+
+    for (i = 0; i < headers->count; ++i) {
+        if (headers->list[i].id == headerId) {
+            return headers->list + i;
+        }
+    }
+    return NULL;
+}
+
+
+/**
+ * Get all headers. This is done without copying data from the original
+ * bytestream, so headers reference directly into the appropriate locations in
+ * the bytestream. As a side-effect the byte stream may be modified.
+ */
+
+OI_STATUS OI_OBEXCOMMON_ParseHeaderList(OBEX_COMMON *common,
+                                        OI_OBEX_HEADER_LIST *headers,
+                                        OI_BYTE_STREAM *bs)
+{
+    OI_STATUS status;
+    OI_UINT i;
+    OI_UINT16 pos;
+
+    /*
+     * First count the headers.
+     */
+    headers->count = 0;
+    headers->list = NULL;
+    pos = ByteStream_GetPos(*bs);
+    while (ByteStream_NumReadBytesAvail(*bs) > 0) {
+        status = ScanHeader(bs);
+        if (!OI_SUCCESS(status)) {
+            headers->count = 0;
+            return OI_OBEX_BAD_PACKET;
+        }
+        ++headers->count;
+    }
+    ByteStream_SetPos(*bs, pos);
+
+    if (headers->count > 0) {
+        headers->list = OI_Malloc(sizeof(OI_OBEX_HEADER) * headers->count);
+        if (headers->list == NULL) {
+            return OI_STATUS_OUT_OF_MEMORY;
+        }
+        /*
+         * Now get the header values into the header list. We checked that
+         * the headers were all valid in the scan pass.
+         */
+        for (i = 0; i < headers->count; ++i) {
+            ParseHeader(common, bs, headers->list + i);
+        }
+    }
+    ByteStream_Close(*bs);
+
+#ifdef OI_DEBUG
+    OI_DBGPRINT2(("Headers in {"));
+    DumpHeaderLists(headers->list, headers->count, NULL);
+    OI_DBGPRINT2(("}"));
+#endif
+    return OI_OK;
+}
+
+static OI_STATUS ScanAppParamsEntry(OI_BYTE_STREAM *bs)
+{
+    OI_UINT8 len = 0;
+
+    ByteStream_Skip_Checked(*bs, sizeof(OI_UINT8)); /* The length doesn't depend on the value of the param tag */
+    ByteStream_GetUINT8_Checked(*bs, len);
+    ByteStream_Skip_Checked(*bs, len);
+
+    if (ByteStream_Error(*bs)) {
+        return OI_OBEX_ERROR;
+    } else {
+        return OI_OK;
+    }
+}
+
+static void ParseAppParamsEntry(OI_BYTE_STREAM *bs,
+                                OI_OBEX_APP_PARAM *param)
+{
+    /* Not using checked bytestream operations because ScanAppParamsEntry has already validated the field layout */
+    ByteStream_GetUINT8(*bs, param->tag);
+    ByteStream_GetUINT8(*bs, param->len);
+    param->data = ByteStream_GetCurrentBytePointer(*bs);
+    ByteStream_Skip(*bs, param->len);
+}
+
+OI_STATUS OI_OBEX_ParseAppParamsHeader(const OI_OBEX_BYTESEQ *rawData,
+                                       OI_OBEX_APP_PARAM_LIST *params)
+{
+    OI_BYTE_STREAM bs;
+    OI_STATUS status;
+    OI_UINT i;
+
+    ByteStream_Init(bs, rawData->data, rawData->len);
+    ByteStream_Open(bs, BYTESTREAM_READ);
+
+    params->count = 0;
+    params->list = NULL;
+
+    while (ByteStream_NumReadBytesAvail(bs) > 0) {
+        status = ScanAppParamsEntry(&bs);
+        if (!OI_SUCCESS(status)) {
+            params->count = 0;
+            return OI_OBEX_BAD_PACKET;
+        }
+        params->count++;
+    }
+    ByteStream_SetPos(bs, 0);
+
+    if (params->count > 0) {
+        params->list = OI_Malloc(sizeof(OI_OBEX_APP_PARAM) * params->count);
+        if (params->list == NULL) {
+            return OI_STATUS_OUT_OF_MEMORY;
+        }
+        /*
+         * Now get the param values into the header list. We checked that
+         * the values were all valid during the scan pass.
+         */
+        for (i = 0; i < params->count; ++i) {
+            ParseAppParamsEntry(&bs, params->list + i);
+        }
+    }
+    ByteStream_Close(bs);
+
+    return OI_OK;
+}
+
+OI_STATUS OI_OBEXCOMMON_BuildAppParamsHeader(OI_OBEX_BYTESEQ *data,
+                                             const OI_OBEX_APP_PARAM_LIST *params)
+{
+    OI_UINT i;
+    OI_BYTE_STREAM bs;
+
+    data->len = 0;
+    for (i = 0; i < params->count; i++) {
+        data->len += sizeof(params->list[i].tag) + sizeof(params->list[i].len) + params->list[i].len;
+    }
+
+    data->data = OI_Malloc(data->len);
+    if (data->data == NULL) {
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+
+    ByteStream_Init(bs, data->data, data->len);
+    ByteStream_Open(bs, BYTESTREAM_WRITE);
+
+    for (i = 0; i < params->count; i++) {
+        ByteStream_PutUINT8(bs, params->list[i].tag);
+        ByteStream_PutUINT8(bs, params->list[i].len);
+        ByteStream_PutBytes(bs, params->list[i].data, params->list[i].len);
+    }
+
+    OI_ASSERT(ByteStream_NumWriteBytesAllowed(bs) == 0);
+
+    return OI_OK;
+}
diff --git a/obex_profiles/profiles/obex/obexsrv.c b/obex_profiles/profiles/obex/obexsrv.c
new file mode 100644
index 0000000..bddb72f
--- /dev/null
+++ b/obex_profiles/profiles/obex/obexsrv.c
@@ -0,0 +1,3551 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+API for OBEX server
+*/
+
+#define __OI_MODULE__ OI_MODULE_OBEX_SRV
+
+#include "oi_memmgr.h"
+#include "oi_dispatch.h"
+#include "oi_bytestream.h"
+#include "oi_assert.h"
+#include "oi_utils.h"
+#include "oi_debug.h"
+#include "oi_argcheck.h"
+#include "oi_obextest.h"
+#include "oi_handle.h"
+#include "oi_list.h"
+
+#include "oi_init_flags.h"
+#include "oi_config_table.h"
+#include "oi_bt_profile_config.h"
+
+#include "oi_obex_lower.h"
+#include "oi_obexcommon.h"
+#include "oi_obexauth.h"
+#include "oi_obexsrv.h"
+
+/*
+ * This is an internal state that tracks when SRM has been requested for a PUT but we haven't yet
+ * actually enabled it because we need to send a reponse to the PUT request.
+ */
+#define OI_OBEX_SRM_REQUESTED 0x80
+
+/*
+ * An invalid SRM parameter value to indicate no parameter set.
+ */
+#define SRM_PARAM_NONE   255
+
+
+/*
+ * Number of failed authentication attempts allowed before the server drops the
+ * lower layer connection.
+ */
+
+#define MAX_AUTHENTICATION_ATTEMPTS   3
+
+
+/*
+ * Order of the initial states matters.
+ */
+typedef enum {
+    DISCONNECTED            = 0, /**< The connection is gone */
+    LOWER_LAYER_CONNECTING  = 1, /**< A client is establishing a lower layer link to the server. */
+    LOWER_LAYER_CONNECTED   = 2, /**< A client has established a lower layer link to the server. */
+    OBEX_CONNECTING         = 3, /**< OBEX connection has been indicated to upper layer */
+    CONNECT_COMPLETING      = 4, /**< Waiting for the connect to complete */
+    OBEX_CONNECTED          = 5, /**< A OBEX connection has been established over the lower layer link. */
+    GET_IN_PROGRESS,
+    GET_COMPLETING,
+    BULK_GET_IN_PROGRESS,
+    BULK_GET_COMPLETING,
+    BULK_GET_FAILED,
+    PUT_IN_PROGRESS,
+    PUT_COMPLETING,
+    SETTING_PATH,
+    DO_ACTION,
+    OBEX_DISCONNECTING,          /**< Server has received a disconnect command */
+    OBEX_DISCONNECT_COMPLETING   /**< Server has issued a disconnect request to the underlying layer */
+} CONNECTION_STATE;
+
+
+typedef struct _OBEXSRV_TARGET_INFO {
+    OI_OBEX_BYTESEQ target;                 /**< Target for this connection */
+    const OI_OBEXSRV_CB_LIST *CBList;       /**< Callbacks for this connection*/
+    OI_OBEXSRV_AUTHENTICATION authRequired; /**< Level of authentication required on this server */
+    struct _OBEXSRV_TARGET_INFO *next;
+} OBEXSRV_TARGET_INFO;
+
+
+typedef struct {
+
+    void *context;                           /**< Application specific context.  */
+
+    OI_OBEX_SERVER_HANDLE handle;            /**< Handle for this server */
+    OI_LIST_ELEM connectionList;             /**< Connections using this server */
+    OBEXSRV_TARGET_INFO targetInfo;          /**< Pimary target and list of any secondary targets and associated callbacks */
+    OI_UINT8 srm;                            /**< SRM flags set at registration time */
+    OI_OBEX_LOWER_SERVER *lowerProtocolList; /**< Null terminated list of lower layer server handles for this server */
+
+} OBEX_SERVER;
+
+
+typedef struct _OBEXSRV_CONNECTION {
+
+    void *context;                          /**< Application specific context.  */
+
+    OBEX_SERVER *obexServer;                /**< OBEX server for this connection */
+    OI_OBEX_LOWER_SERVER lowerServer;       /**< Lower layer service for this client connection */
+    OI_LIST_ELEM link;                      /**< Connection link into server connection list */
+
+    OBEX_COMMON common;
+    OI_BOOL clientSpecifiedTarget;          /**< Indicates if the client specified a target */
+    OBEXSRV_TARGET_INFO *currentTarget;     /**< Pointer to currently connected target */
+
+    DISPATCH_CB_HANDLE connectTimeout;      /**< Timeout to initiate disconnect if there is no
+                                                 connect request to a multiplexed service above OBEX
+                                                 after lower layer connection has been established */
+
+    OI_BOOL  abortPending;                  /**< TRUE if an abort has been received and abort
+                                                    response has not yet been sent to client */
+    OI_BOOL  abortResponsePending;           /**< TRUE if abort has been signalled to callback and
+                                                    server is waiting for response from application */
+    OI_MBUF  *abortMbuf;                    /**< Contains abortResponse packet, may be NULL */
+    OI_UINT8 authTries;                     /**< How many authentication attempts */
+    OI_UINT8 forcedDisconnect;              /**< Application has forced a disconnect */
+    OI_UINT8 unauthorized;                  /**< Connection in progress not authorized */
+    OI_UINT8 authRequested;                 /**< Client requested authentication of the OBEX server */
+    OI_UINT8 connectIndicated;              /**< Connection has been indicated to the upper-layer */
+    OI_UINT8 final;                         /**< Final packet for a transaction has been received */
+    CONNECTION_STATE state;
+
+    /**
+     * State for handling a GET that uses the bulk get APIs
+     */
+    struct {
+        OI_BOOL busy;                /* TRUE if we are busy */
+        OBEX_BULK_DATA_LIST current; /* Bulk data block that is currently being sent - will be partially sent */
+        OBEX_BULK_DATA_LIST head;    /* Head of the bulk data list */
+        OBEX_BULK_DATA_LIST tail;    /* Tailt of the bulk data list */
+    } bulkGet;
+
+    OI_BD_ADDR clientBdAddr;                /**< BDADDR of connected client */
+} OBEXSRV_CONNECTION;
+
+
+
+
+/***************** Forward function definition *************************/
+
+
+static void LowerConnectCfm(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                            OI_UINT16 recvMtu,
+                            OI_UINT16 sendMtu,
+                            OI_STATUS result);
+
+
+static void LowerConnectInd(OI_OBEX_LOWER_SERVER serverHandle,
+                            OI_OBEX_LOWER_CONNECTION lowerConnection,
+                            OI_BD_ADDR *addr);
+
+
+static void LowerDisconnectInd(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                               OI_STATUS reason);
+
+static void LowerWriteCfm(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                          OI_MBUF *mbuf,
+                          OI_BOOL queueFull,
+                          OI_STATUS result);
+
+
+static void LowerRecvDataInd(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                             OI_BYTE *dataBuf,
+                             OI_UINT16 dataLen);
+
+
+static const OI_OBEX_LOWER_CALLBACKS lowerCallbacks =
+{
+    LowerConnectCfm,
+    LowerConnectInd,
+    LowerDisconnectInd,
+    LowerWriteCfm,
+    LowerRecvDataInd
+};
+
+static OI_STATUS sendSimpleWithHeaders(OBEX_COMMON   *common,
+                                       OI_UINT8      opcode,
+                                       const OI_OBEX_HEADER_LIST *headerList);
+
+/************************************************************************/
+
+/**
+ * Type for an OBEX server connection handle
+ */
+static const OI_CHAR* ObexSrvConnectionHandleType = "OBEXSRV_CONNECTION";
+
+/**
+ * Type for an OBEX server handle
+ */
+static const OI_CHAR* ObexServerHandleType = "OBEX_SERVER";
+
+
+/*
+ * Get a connection struct from a connection handle
+ */
+#define LookupConnection(connectionHandle)  ((OBEXSRV_CONNECTION*)OI_HANDLE_Deref(connectionHandle))
+
+
+#define SetState(connection, newState) \
+    do { \
+        OI_DBGPRINT(("State %s -> %s", ServerStateTxt((connection)->state), ServerStateTxt(newState))); \
+        (connection)->state = (newState); \
+    } while(0);
+
+
+#ifdef OI_DEBUG
+static const OI_CHAR* ServerStateTxt(CONNECTION_STATE state)
+{
+    switch (state) {
+        case DISCONNECTED:               return "DISCONECTED";
+        case LOWER_LAYER_CONNECTING:     return "LOWER_LAYER_CONNECTING";
+        case LOWER_LAYER_CONNECTED:      return "LOWER_LAYER_CONNECTED";
+        case OBEX_CONNECTING:            return "OBEX_CONNECTING";
+        case CONNECT_COMPLETING:         return "CONNECT_COMPLETING";
+        case OBEX_CONNECTED:             return "OBEX_CONNECTED";
+        case GET_IN_PROGRESS:            return "GET_IN_PROGRESS";
+        case GET_COMPLETING:             return "GET_COMPLETING";
+        case BULK_GET_IN_PROGRESS:       return "BULK_GET_IN_PROGRESS";
+        case BULK_GET_COMPLETING:        return "BULK_GET_COMPLETING";
+        case BULK_GET_FAILED:            return "BULK_GET_FAILED";
+        case PUT_IN_PROGRESS:            return "PUT_IN_PROGRESS";
+        case PUT_COMPLETING:             return "PUT_COMPLETING";
+        case SETTING_PATH:               return "SETTING_PATH";
+        case DO_ACTION:                  return "DO_ACTION";
+        case OBEX_DISCONNECTING:         return "OBEX_DISCONNECTING";
+        case OBEX_DISCONNECT_COMPLETING: return "OBEX_DISCONNECT_COMPLETING";
+        default:                         return "Invalid";
+    }
+}
+
+
+const OI_CHAR* OI_OBEXSRV_AuthenticationText(OI_OBEXSRV_AUTHENTICATION authentication)
+{
+    switch (authentication) {
+        case OI_OBEXSRV_AUTH_NONE:                return "NONE";
+        case OI_OBEXSRV_AUTH_PASSWORD:            return "PASSWORD only";
+        case OI_OBEXSRV_AUTH_USERID_AND_PASSWORD: return "USERID+PASSWORD";
+        default:                                  return "Invalid";
+    }
+}
+
+#else
+
+const OI_CHAR* OI_OBEXSRV_AuthenticationText(OI_OBEXSRV_AUTHENTICATION authentication)
+{
+    return "";
+}
+
+#endif  /* OI_DEBUG */
+
+
+/*
+ * Map error status into an OBEX response code and send to the client.
+ * Whatever transaction we were in has ended so clear SRM flag if it was set.
+ */
+#define ErrorResponse(connection, status) \
+    do { \
+        OI_DBGPRINT(("OBEX Server sending error response %d", status)); \
+        connection->common.srm &= ~OI_OBEX_SRM_ENABLED; \
+        OI_OBEXCOMMON_SendSimple(&connection->common, MapStatus(status)); \
+    } while (0)
+
+#define ErrorResponseWithHeaders(connection, status, hdrs) \
+    do { \
+        OI_DBGPRINT(("OBEX Server sending error response %d", status)); \
+        connection->common.srm &= ~OI_OBEX_SRM_ENABLED; \
+        sendSimpleWithHeaders(&connection->common, MapStatus(status), hdrs); \
+    } while (0)
+
+
+
+
+
+typedef enum {
+    CONFIRM_COMPLETED,
+    CONFIRM_ALL
+} CONFIRM_FILTER;
+
+
+/*
+ * Maximum number of buffers we will confirm at one time
+ */
+#define MAX_CONFIRM 16
+
+/**
+ * Send a simple OBEX command packet, but append caller's optional headers.
+ */
+static OI_STATUS sendSimpleWithHeaders(OBEX_COMMON   *common,
+                                       OI_UINT8      opcode,
+                                       const OI_OBEX_HEADER_LIST *headerList)
+{
+    OI_BYTE_STREAM  pkt;
+    OI_STATUS       status;
+    OI_BOOL         queueFull;
+
+    if ((NULL == headerList ) || (0== headerList->count)) {
+        OI_DBGPRINT2(("sendSimpleWithHeaders, no headers provided"));
+        return OI_OBEXCOMMON_SendSimple(common, opcode);
+    }
+
+    OI_DBGPRINT2(("sendSimpleWithHeaders, %d headers provided",
+                        (NULL == headerList)? 0: headerList->count));
+
+    OI_OBEXCOMMON_InitPacket(common, opcode, &pkt);
+
+    status = OI_OBEXCOMMON_MarshalPacket(common, &pkt, NULL, 0, headerList);
+    if (OI_SUCCESS(status)) {
+        status = common->lowerConnection->ifc->write(common->lowerConnection, common->mbuf, TRUE, &queueFull);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Lower layer write failed"));
+            OI_MBUF_Free(common->mbuf);
+            common->mbuf = NULL;
+        }
+    }
+
+    return status;
+}
+
+/*
+ *
+ * Called to confirm incomplete BulkGet operations in the case of a disconnect or abort
+ * Returns TRUE if all blocks are confirmed.
+ */
+static OI_BOOL ConfirmBulkGets(OBEXSRV_CONNECTION *connection,
+                               OI_STATUS status,
+                               CONFIRM_FILTER filter,
+                               OI_BOOL *final)
+{
+    OBEX_BULK_DATA_LIST bulkData = connection->bulkGet.head;
+    OI_UINT cfmCount = 0;
+    OI_UINT8 *cfmBuffers[MAX_CONFIRM];
+    OI_UINT32 cfmLengths[MAX_CONFIRM];
+    OI_STATUS cfmStatus = (status == OI_OBEX_CONTINUE) ? status : OI_OK;
+
+    OI_DBGPRINT(("ConfirmBulkGets %d", status));
+
+    if (final) {
+        *final = FALSE;
+    }
+
+    while (bulkData) {
+        /*
+         * Cannot confirm blocks that are being sent
+         */
+        if (bulkData->bytesConfirmed < bulkData->bytesSent) {
+            break;
+        }
+        /*
+         * If only confirming completed blocks exit if this block is incomplete
+         */
+        if ((filter == CONFIRM_COMPLETED) && (bulkData->bytesConfirmed < bulkData->blockSize)) {
+            break;
+        }
+        cfmBuffers[cfmCount] = bulkData->blockBuffer;
+        cfmLengths[cfmCount] = bulkData->blockSize;
+        connection->bulkGet.head = bulkData->next;
+        /*
+         * If there is no head there is no tail
+         */
+        if (!connection->bulkGet.head) {
+            connection->bulkGet.tail = NULL;
+            connection->bulkGet.current = NULL;
+        }
+        OI_DBGPRINT2(("Free bulk data %#08x final:%d", bulkData, bulkData->final));
+        if (final) {
+            *final = bulkData->final;
+        }
+        OI_Free(bulkData);
+        bulkData = connection->bulkGet.head;
+        /*
+         * Only report an error status when confirming last block
+         */
+        if (bulkData == NULL) {
+            cfmStatus = status;
+        }
+        if (++cfmCount == MAX_CONFIRM) {
+            OI_DBGPRINT2(("ConfirmBulkGets confirmed %d", cfmCount));
+            connection->currentTarget->CBList->bulkGetInd(connection->common.connectionHandle, cfmCount, cfmBuffers, cfmLengths, cfmStatus);
+            cfmCount = 0;
+        }
+    }
+    if (cfmCount > 0) {
+        OI_DBGPRINT2(("ConfirmBulkGets confirmed %s%d", bulkData ? "" : "all ", cfmCount));
+        connection->currentTarget->CBList->bulkGetInd(connection->common.connectionHandle, cfmCount, cfmBuffers, cfmLengths, cfmStatus);
+    }
+    return (bulkData == NULL);
+}
+
+
+/*
+ * Cleanup after a connection has terminated. This function is called during
+ * normal and abnormal disconnects.
+ */
+
+static void ServerDisconnect(OBEXSRV_CONNECTION *connection,
+                             OI_STATUS reason)
+{
+    CONNECTION_STATE state = connection->state;
+
+    OI_DBGTRACE(("ServerDisconnect(reason=%d)\n", reason));
+
+    SetState(connection, DISCONNECTED);
+
+    /*
+     * Stop connection timer if it is running
+     */
+    if (connection->connectTimeout) {
+        OI_Dispatch_CancelFunc(connection->connectTimeout);
+    }
+
+    switch (state) {
+        case PUT_IN_PROGRESS:
+        case PUT_COMPLETING:
+            connection->currentTarget->CBList->putInd(connection->common.connectionHandle, NULL, OI_OBEX_NOT_CONNECTED);
+            break;
+        case GET_IN_PROGRESS:
+        case GET_COMPLETING:
+            connection->currentTarget->CBList->getInd(connection->common.connectionHandle, NULL, OI_OBEX_NOT_CONNECTED);
+            break;
+        case BULK_GET_IN_PROGRESS:
+        case BULK_GET_COMPLETING:
+        case BULK_GET_FAILED:
+            /*
+             * We expect that the lower layer will have already confirmed all sends.
+             */
+            if (!ConfirmBulkGets(connection, reason, CONFIRM_ALL, NULL)) {
+                OI_SLOG_ERROR(OI_STATUS_INVALID_STATE, ("Server disconnect with incomplete sends pending"));
+            }
+            break;
+        default:
+            break;
+    }
+
+    OI_FreeIf(&connection->common.authentication);
+    /*
+     * Unlink the connection from the server
+     */
+    OI_List_Del(&connection->link);
+    /*
+     * If the connection was indicated to the upper layer now indicate the disconnect
+     */
+    if (connection->connectIndicated) {
+        connection->connectIndicated = FALSE;
+        connection->currentTarget->CBList->disconnectInd(connection->common.connectionHandle);
+    }
+    OI_HANDLE_Free(connection->common.connectionHandle);
+    OI_Free(connection);
+}
+
+
+static void ConnectTimeout(DISPATCH_ARG *darg)
+{
+    OI_OBEXSRV_CONNECTION_HANDLE connectionHandle = Dispatch_GetArg(darg, OI_OBEXSRV_CONNECTION_HANDLE);
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionHandle);
+
+    OI_SLOG_ERROR(OI_TIMEOUT, ("Connection timeout: lower layer disconnected"));
+
+    if (connection) {
+        OI_ASSERT(connection->state != OBEX_CONNECTED);
+        connection->connectTimeout = 0;
+        OI_OBEXSRV_ForceDisconnect(connectionHandle);
+    }
+}
+
+
+static void LowerDisconnectInd(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                               OI_STATUS reason)
+{
+    OBEXSRV_CONNECTION *connection = (OBEXSRV_CONNECTION*)lowerConnection->context;
+
+    OI_DBGPRINT(("LowerDisconnectInd %d", reason));
+
+    if (connection != NULL) {
+        if (connection->forcedDisconnect) {
+            reason = OI_OBEX_SERVER_FORCED_DISCONNECT;
+        }
+        ServerDisconnect(connection, reason);
+    }
+}
+
+
+/**
+ * Map OI status into an OBEX response.
+ */
+
+static OI_UINT8 MapStatus(OI_STATUS status)
+{
+    OI_UINT8 rspCode;
+
+    switch (status) {
+        case OI_OK:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_OK);
+            break;
+        case OI_OBEX_ERROR:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_INTERNAL_SERVER_ERROR);
+            break;
+        case OI_OBEX_BAD_PACKET:
+        case OI_OBEX_BAD_REQUEST:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_BAD_REQUEST);
+            break;
+        case OI_OBEX_OPERATION_IN_PROGRESS:
+        case OI_OBEX_ACCESS_DENIED:
+        case OI_OBEX_FORBIDDEN:
+        case OI_STATUS_ACCESS_DENIED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_FORBIDDEN);
+            break;
+        case OI_OBEX_NOT_FOUND:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_NOT_FOUND);
+            break;
+        case OI_OBEX_UNKNOWN_COMMAND:
+        case OI_OBEX_NOT_IMPLEMENTED:
+        case OI_STATUS_NOT_IMPLEMENTED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_NOT_IMPLEMENTED);
+            break;
+        case OI_OBEX_LENGTH_REQUIRED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_LENGTH_REQUIRED);
+            break;
+        case OI_OBEX_SERVICE_UNAVAILABLE:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_SERVICE_UNAVAILABLE);
+            break;
+        case OI_OBEX_VALUE_NOT_ACCEPTABLE:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_NOT_ACCEPTABLE);
+            break;
+        case OI_OBEX_REQUIRED_HEADER_NOT_FOUND:
+        case OI_OBEX_UNSUPPORTED_VERSION:
+        case OI_OBEX_INCOMPLETE_PACKET:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_BAD_REQUEST);
+            break;
+        case OI_OBEX_PRECONDITION_FAILED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_PRECONDITION_FAILED);
+            break;
+        case OI_OBEX_DATABASE_FULL:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_DATABASE_FULL);
+            break;
+        case OI_OBEX_DATABASE_LOCKED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_DATABASE_LOCKED);
+            break;
+        case OI_OBEX_UNSUPPORTED_MEDIA_TYPE:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_UNSUPPORTED_MEDIA_TYPE);
+            break;
+        case OI_OBEX_CONFLICT:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_CONFLICT);
+            break;
+        case OI_OBEX_UNAUTHORIZED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_UNAUTHORIZED);
+            break;
+        case OI_OBEX_PARTIAL_CONTENT:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_PARTIAL_CONTENT);
+            break;
+        case OI_OBEX_METHOD_NOT_ALLOWED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_METHOD_NOT_ALLOWED);
+            break;
+        case OI_OBEX_FOLDER_BROWSING_NOT_ALLOWED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_UNAUTHORIZED);
+            break;
+        case OI_OBEX_NOT_MODIFIED:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_NOT_MODIFIED);
+            break;
+        default:
+            rspCode = OI_OBEX_FINAL(OI_OBEX_RSP_INTERNAL_SERVER_ERROR);
+            break;
+    }
+    return rspCode;
+}
+
+
+static OI_STATUS BulkGetWriteCfm(OBEXSRV_CONNECTION *connection,
+                                 OI_UINT16 bytesConfirmed,
+                                 OBEX_BULK_DATA_LIST bulkData,
+                                 OI_BOOL queueFull,
+                                 OI_STATUS status)
+{
+    OBEX_BULK_DATA_LIST list = bulkData;
+    OI_STATUS continueStatus = (connection->state == BULK_GET_IN_PROGRESS) ? OI_OBEX_CONTINUE : OI_OK;
+
+    OI_DBGPRINT(("BulkGetWriteCfm bytesConfirmed %d queueFull:%d %d", bytesConfirmed, queueFull, status));
+
+    OI_ASSERT(bulkData->bytesConfirmed <= bulkData->bytesSent);
+
+    /*
+     * Track progress for body data
+     */
+    connection->common.progressBytes += bytesConfirmed;
+    /*
+     * Figure out which bulk puts are being confirmed
+     */
+    while (bytesConfirmed) {
+        OI_UINT32 max = list->bytesSent - list->bytesConfirmed;
+        if (bytesConfirmed >= max) {
+            bytesConfirmed -= (OI_UINT16)max;
+        } else {
+            max = bytesConfirmed;
+        }
+        list->bytesConfirmed += max;
+        OI_DBGPRINT2(("%#08x blockSize:%d bytesSent:%d bytesConfirmed:%d", list, list->blockSize, list->bytesSent, list->bytesConfirmed));
+        if (list->bytesConfirmed < list->blockSize) {
+            break;
+        }
+        list = list->next;
+    }
+    /*
+     * Report that the operation was aborted if we are aborting the transaction.
+     */
+    if (connection->abortPending) {
+        status = OI_OBEX_CLIENT_ABORTED_COMMAND;
+    }
+    /*
+     * If we had an error confirm all outstanding bulk gets.
+     */
+    if (!OI_SUCCESS(status)) {
+        /*
+         * Try to confirm all unsent blocks
+         */
+        if (ConfirmBulkGets(connection, status, CONFIRM_ALL, NULL)) {
+            /*
+             * Send a response to the abort.  If we're waiting for application to
+             * respond to abort request, keep waiting.
+             */
+            if (connection->abortPending && !connection->abortResponsePending) {
+                OI_DBGPRINT(("Confirming abort"));
+                OI_OBEXCOMMON_SendOk(&connection->common);
+                connection->abortPending = FALSE;
+            }
+            connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+            SetState(connection, OBEX_CONNECTED);
+        }
+        return OI_OK;
+    }
+    /*
+     * If we are doing SRM or we are completely done confirm completed bulk data blocks otherwise
+     * confirm when we receive the next GET command.
+     */
+    if ((connection->common.srm & OI_OBEX_SRM_ENABLED) || (continueStatus == OI_OK)) {
+        OI_BOOL final;
+        ConfirmBulkGets(connection, continueStatus, CONFIRM_COMPLETED, &final);
+        /*
+         * If we just confirmed the final bulk data block the GET is complete.
+         */
+        if (final) {
+            OI_ASSERT(connection->bulkGet.head == NULL);
+            connection->currentTarget->CBList->bulkGetInd(connection->common.connectionHandle, 0, NULL, NULL, OI_OBEX_CLEANUP);
+            connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+            SetState(connection, OBEX_CONNECTED);
+        }
+    }
+    /*
+     * If we are doing SRM and the queue is not full we can write data now. Otherwise we cannot
+     * write data until we get a get command from the remote peer.
+     */
+    if (!queueFull && (connection->common.srm & OI_OBEX_SRM_ENABLED)) {
+        status = OI_OBEXCOMMON_SendBulk(&connection->common, &connection->bulkGet.current, &queueFull, NULL);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("OI_OBEXCOMMON_SendBulk failed"));
+            /*
+             * Cannot report an error status if there is any data queued with lower layer
+             */
+            if (connection->bulkGet.head->bytesConfirmed < connection->bulkGet.head->bytesSent) {
+                status = OI_OK;
+            }
+        }
+        connection->bulkGet.busy = queueFull;
+    }
+    return status;
+}
+
+
+static void LowerWriteCfm(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                          OI_MBUF *mbuf,
+                          OI_BOOL queueFull,
+                          OI_STATUS result)
+{
+    OI_STATUS status;
+    OBEXSRV_CONNECTION *connection = (OBEXSRV_CONNECTION*)lowerConnection->context;
+    OI_UINT16 numBytes;
+    void *context = mbuf->context.v;
+
+    if (connection == NULL) {
+        OI_SLOG_ERROR(result, ("Write confirmation for unknown connection"));
+        return;
+    }
+
+    numBytes = OI_MBUF_Free(mbuf);
+    if (mbuf == connection->common.mbuf) {
+        connection->common.mbuf = NULL;
+    } else if (mbuf == connection->abortMbuf) {
+        connection->abortMbuf = NULL;
+    }
+
+    OI_DBGPRINT2(("Write completed %d bytes: freed mbuf %#x %d", numBytes, mbuf, result));
+
+    /*
+     * On an error drop the lower layer connection - it is probably already gone...
+     */
+    if (!OI_SUCCESS(result)) {
+        lowerConnection->ifc->disconnect(lowerConnection);
+    }
+
+    /*
+     * Check for operations that need to be completed.
+     */
+    switch (connection->state) {
+    case CONNECT_COMPLETING:
+        /*
+         * No longer need the authentication state info.
+         */
+        OI_FreeIf(&connection->common.authentication);
+        SetState(connection, OBEX_CONNECTED);
+        OI_DBGPRINT(("Connected, maxRecvPktLen %d, maxSendPktLen %d",
+                connection->common.maxRecvPktLen, connection->common.maxSendPktLen));
+
+        /* Stop connection timer if it is running */
+        if (0 != connection->connectTimeout) {
+            OI_DBGPRINT2(("Cancel connect timeout"));
+            OI_Dispatch_CancelFunc(connection->connectTimeout);
+            connection->connectTimeout = 0;
+        }
+        break;
+    case GET_COMPLETING:
+        if (OI_OBEX_IS_A_BODY_HEADER(connection->common.bodySegment.id)) {
+            /*
+             * We are doing automatic body header segmentation so we are not done until the
+             * entire body payload has been sent.
+             */
+            break;
+        }
+        SetState(connection, OBEX_CONNECTED);
+        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+        if (OI_SUCCESS(result)) {
+            result = OI_OBEX_CLEANUP;
+        }
+        connection->currentTarget->CBList->getInd(connection->common.connectionHandle, NULL, result);
+        break;
+    case PUT_COMPLETING:
+        SetState(connection, OBEX_CONNECTED);
+        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+        if (OI_SUCCESS(result)) {
+            result = OI_OBEX_CLEANUP;
+        }
+        connection->currentTarget->CBList->putInd(connection->common.connectionHandle, NULL, result);
+        break;
+    case OBEX_DISCONNECTING:
+        /*
+         * Drop the lower layer connection.
+         */
+        SetState(connection, OBEX_DISCONNECT_COMPLETING);
+        status = lowerConnection->ifc->disconnect(lowerConnection);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Lower layer disconnect failed"));
+            ServerDisconnect(connection, status);
+        }
+        break;
+    case BULK_GET_FAILED:
+        result = OI_OBEX_ERROR;
+        /* Falling through */
+    case BULK_GET_COMPLETING:
+    case BULK_GET_IN_PROGRESS:
+        BulkGetWriteCfm(connection, numBytes - BULK_GET_HDR_SIZE, (OBEX_BULK_DATA_LIST)context, queueFull, result);
+        if (OI_SUCCESS(result)) {
+            /*
+             * Report progress (if any) if the upper layer has provided a progress callback
+             */
+            if (connection->common.progressBytes && connection->currentTarget->CBList->progressInd) {
+                connection->currentTarget->CBList->progressInd(connection->common.connectionHandle, OI_OBEX_CMD_GET, connection->common.progressBytes);
+            }
+        }
+        break;
+    case GET_IN_PROGRESS:
+        if (!OI_SUCCESS(result)) {
+            SetState(connection, GET_COMPLETING);
+            break;
+        }
+        if (connection->final) {
+            /*
+             * If we are through the initial GET phase switch over to the bulk GET APIs if the
+             * upper profile supports bulk get.
+             */
+            if (connection->currentTarget->CBList->bulkGetInd) {
+                SetState(connection, BULK_GET_IN_PROGRESS);
+                /*
+                 * If we are doing SRM we are not going to get a response packet so we need to
+                 * call getInd to request data from the upper layer profile.
+                 */
+                if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+                    connection->currentTarget->CBList->bulkGetInd(connection->common.connectionHandle, 0, NULL, NULL, OI_OBEX_CONTINUE);
+                }
+            } else {
+                /*
+                 * If we are doing SRM we are not going to get a response packet so we need to
+                 * call getInd to request data from the upper layer profile.
+                 */
+                if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+                    connection->currentTarget->CBList->getInd(connection->common.connectionHandle, NULL, OI_OBEX_CONTINUE);
+                }
+                /*
+                 * Report progress (if any) if the upper layer has provided a progress callback
+                 */
+                if (connection->currentTarget->CBList->progressInd && connection->common.progressBytes) {
+                    connection->currentTarget->CBList->progressInd(connection->common.connectionHandle, OI_OBEX_CMD_GET, connection->common.progressBytes);
+                }
+            }
+        }
+        break;
+    default:
+        /* Nothing to do */
+        break;
+    }
+}
+
+
+static OI_STATUS ServerSendPacket(OBEXSRV_CONNECTION *connection)
+{
+    OI_STATUS status;
+    OI_BOOL queueFull;
+
+    OI_DBGPRINT2(("Sending mbuf %#x", connection->common.mbuf));
+
+    status = connection->common.lowerConnection->ifc->write(connection->common.lowerConnection, connection->common.mbuf, TRUE, &queueFull);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("Lower layer write failed"));
+        OI_MBUF_Free(connection->common.mbuf);
+        connection->common.mbuf = NULL;
+    }
+    return status;
+}
+
+
+static OI_STATUS ServerSendBodySegment(OBEXSRV_CONNECTION *connection)
+{
+    OI_STATUS status;
+
+    OI_DBGPRINT(("ServerSendBodySegment"));
+
+    status = OI_OBEXCOMMON_MarshalBodySegment(&connection->common);
+    if (OI_SUCCESS(status)) {
+        status = ServerSendPacket(connection);
+    }
+    else {
+        OI_SLOG_ERROR(status, ("OI_OBEXCOMMON_MarshalBodySegment failed"));
+    }
+
+    return status;
+}
+
+/*
+ * Cleanup and callback the application to indicate that the current operation
+ * has been terminated by an ABORT command from the client.
+ */
+
+static OI_STATUS AbortOperation(OBEXSRV_CONNECTION *connection)
+{
+    OI_STATUS   status;
+
+    OI_DBGPRINT(("Server got abort command in state %s", ServerStateTxt(connection->state)));
+
+    switch (connection->state) {
+    case PUT_IN_PROGRESS:
+    case PUT_COMPLETING:
+        SetState(connection, OBEX_CONNECTED);
+        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+        connection->currentTarget->CBList->putInd(connection->common.connectionHandle, NULL, OI_OBEX_CLIENT_ABORTED_COMMAND);
+        break;
+    case GET_IN_PROGRESS:
+    case GET_COMPLETING:
+        SetState(connection, OBEX_CONNECTED);
+        connection->currentTarget->CBList->getInd(connection->common.connectionHandle, NULL, OI_OBEX_CLIENT_ABORTED_COMMAND);
+        break;
+    case BULK_GET_IN_PROGRESS:
+    case BULK_GET_COMPLETING:
+    case BULK_GET_FAILED:
+        if (!connection->bulkGet.head) {
+            /*
+             *  Nothing to confirm - just cleanup the state and indicate the abort
+             */
+            connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+            SetState(connection, OBEX_CONNECTED);
+            connection->currentTarget->CBList->bulkGetInd(connection->common.connectionHandle, 0, NULL, NULL, OI_OBEX_CLIENT_ABORTED_COMMAND);
+        } else if (ConfirmBulkGets(connection, OI_OBEX_CLIENT_ABORTED_COMMAND, CONFIRM_ALL, NULL)) {
+            connection->abortPending = FALSE;
+            connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+            SetState(connection, OBEX_CONNECTED);
+        } else {
+            /*
+             * Unable to confirm all blocks - wait for the lower layer confirms to clean up
+             */
+            connection->abortPending = TRUE;
+        }
+        break;
+    default:
+        break;
+    }
+    if (connection->abortPending) {
+        /*
+         * We will respond to the abort after the cleanup.
+         */
+        status = OI_OK;
+    } else {
+        /*
+         * Acknowledge receipt of ABORT command.
+         */
+        OI_DBGPRINT(("Confirming abort"));
+        if (connection->abortMbuf) {
+            OI_BOOL queueFull;
+
+            /*
+             *  Send abort response sitting waiting in the abortMbuf
+             */
+            status = connection->common.lowerConnection->ifc->write(connection->common.lowerConnection, connection->abortMbuf, TRUE, &queueFull);
+            if (!OI_SUCCESS(status)) {
+                OI_SLOG_ERROR(status, ("Lower layer write failed"));
+                OI_MBUF_Free(connection->abortMbuf);
+                connection->abortMbuf = NULL;
+            }
+        } else {
+            /*
+             *  Send standard OK abort response
+             */
+            status = OI_OBEXCOMMON_SendOk(&connection->common);
+        }
+    }
+    return status;
+}
+
+
+static void AppendBulkData(OBEXSRV_CONNECTION *connection,
+                           OBEX_BULK_DATA_LIST bulkDataHead,
+                           OBEX_BULK_DATA_LIST bulkDataTail)
+{
+    if (connection->bulkGet.tail) {
+        connection->bulkGet.tail->next = bulkDataHead;
+    } else {
+        OI_ASSERT(connection->bulkGet.head == NULL);
+        connection->bulkGet.head = bulkDataHead;
+    }
+    connection->bulkGet.tail = bulkDataTail;
+    if (!connection->bulkGet.current) {
+        connection->bulkGet.current = bulkDataHead;
+    }
+}
+
+
+OI_STATUS OI_OBEXSRV_BulkGetResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                     OI_UINT8 numBuffers,
+                                     OI_UINT8 *bulkDataBuffer[],
+                                     OI_UINT32 bufferLength[],
+                                     OI_STATUS rspStatus)
+{
+    OI_STATUS status = (rspStatus != OI_OBEX_CONTINUE) ? rspStatus : OI_OK;
+    OBEXSRV_CONNECTION* connection;
+    OBEX_BULK_DATA_LIST bulkDataHead;
+    OBEX_BULK_DATA_LIST bulkDataTail;
+
+    connection = LookupConnection(connectionId);
+    if (connection == NULL) {
+        OI_DBGPRINT2(("GetResponse bad connectionId"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    OI_DBGPRINT(("OI_OBEXSRV_BulkGetResponse numBuffers:%d %d", numBuffers, rspStatus));
+
+    /*
+     * We don't expect to be called if a bulk put is failing
+     */
+    if (connection->state == BULK_GET_FAILED) {
+        return OI_STATUS_INVALID_STATE;
+    }
+    /*
+     * If the bulk put is completing we don't expect any new data
+     */
+    if (connection->state == BULK_GET_COMPLETING) {
+        if (numBuffers > 0) {
+            OI_DBGPRINT(("BulkGetResponse expected numBuffers == 0"));
+            return OI_STATUS_INVALID_STATE;
+        } else {
+            return OI_OK;
+        }
+    }
+    /*
+     * This function can only be called if we indicated a bulk get
+     */
+    if (connection->state != BULK_GET_IN_PROGRESS) {
+        OI_DBGPRINT(("BulkGetResponse when other operation in progress"));
+        return OI_STATUS_INVALID_STATE;
+    }
+    /*
+     * Reject data if we have an abort pending
+     */
+    if (connection->abortPending) {
+        return OI_OBEX_CLIENT_ABORTED_COMMAND;
+    }
+    /*
+     * No more get responses allowed after the final one.
+     */
+    if (connection->bulkGet.tail && connection->bulkGet.tail->final) {
+        OI_DBGPRINT(("BulkGetResponse final already seen"));
+        return OI_STATUS_INVALID_STATE;
+    }
+    /*
+     * Cleanup if we got an error status
+     */
+    if (!OI_SUCCESS(status)) {
+        goto BulkGetResponseError;
+    }
+    /*
+     * Unless we got an error status we require at least one buffer to send.
+     */
+    if (numBuffers == 0) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+#ifdef OI_TEST_HARNESS
+    if (OI_ObexTest.SendErrorRsp) {
+        status = OI_OBEX_ERROR;
+        OI_ObexTest.SendErrorRsp = FALSE;
+        goto BulkGetResponseError;
+    }
+#endif
+
+    /*
+     * Allocate data structures to track the bulk data transfer
+     */
+    status = OI_OBEXCOMMON_AllocBulkData(numBuffers, bulkDataBuffer, bufferLength, &bulkDataHead, &bulkDataTail);
+    if (!OI_SUCCESS(status)) {
+        goto BulkGetResponseError;
+    }
+    OI_ASSERT(bulkDataTail != NULL);
+    if (rspStatus != OI_OBEX_CONTINUE) {
+        bulkDataTail->final = TRUE;
+        SetState(connection, BULK_GET_COMPLETING);
+    }
+    /*
+     * We queue this bulk data if we are already putting a block or the lower layer is busy
+     */
+    if (connection->bulkGet.current || connection->bulkGet.busy) {
+        OI_DBGPRINT(("OI_OBEXSRV_BulkGetResponse queuing bulk data block"));
+        AppendBulkData(connection, bulkDataHead, bulkDataTail);
+    } else {
+        AppendBulkData(connection, bulkDataHead, bulkDataTail);
+        status = OI_OBEXCOMMON_SendBulk(&connection->common, &connection->bulkGet.current, &connection->bulkGet.busy, NULL);
+        if (!OI_SUCCESS(status)) {
+            /*
+             * Free the bulk data list if nothing was sent otherwise start a disconnect and let the
+             * disconnect process cleanup for us.
+             */
+            if (bulkDataHead->bytesSent == bulkDataHead->bytesConfirmed) {
+                OI_OBEXCOMMON_FreeBulkData(bulkDataHead);
+                goto BulkGetResponseError;
+            }
+            status = OI_OBEXSRV_ForceDisconnect(connectionId);
+        }
+    }
+    if (OI_SUCCESS(status)) {
+        return OI_OK;
+    }
+
+BulkGetResponseError:
+
+    SetState(connection, BULK_GET_FAILED);
+    if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+        /*
+         * If there is nothing to confirm we are done.
+         */
+        if (connection->bulkGet.head == NULL) {
+            connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+            SetState(connection, OBEX_CONNECTED);
+        }
+        ErrorResponse(connection, status);
+    }
+    return OI_OBEX_ERROR;
+}
+
+
+/*
+ * Called by application to write headers to satisfy a GET request.
+ */
+
+OI_STATUS OI_OBEXSRV_GetResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                 OI_OBEX_HEADER_LIST *rspHeaders,
+                                 OI_STATUS rspStatus)
+{
+    OI_OBEX_HEADER headers[2];
+    OI_UINT16 headerCount = 0;
+    OI_UINT8 rsp;
+    OI_STATUS status = OI_OK;
+    OI_BYTE_STREAM pkt;
+    OBEXSRV_CONNECTION* connection;
+
+    OI_DBGTRACE(("OI_OBEXSRV_GetResponse (connectionId = %d, <*headers = %x>, rspStatus = %d)\n",
+                 connectionId, rspHeaders, rspStatus));
+
+    connection = LookupConnection(connectionId);
+    if (connection == NULL) {
+        OI_DBGPRINT2(("GetResponse bad connectionId"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    /*
+     * Only one operation at a time on each connection.
+     */
+    if (connection->state != GET_IN_PROGRESS) {
+        OI_DBGPRINT2(("GetResponse when other operation in progress"));
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+
+    OI_DBGPRINT2(("GetResponse %d", rspStatus));
+
+    if ((rspStatus != OI_OK) && (rspStatus != OI_OBEX_CONTINUE)) {
+        goto GetResponseError;
+    }
+
+#ifdef OI_TEST_HARNESS
+    if (OI_ObexTest.SendErrorRsp) {
+        status = OI_OBEX_ERROR;
+        rspStatus = status;
+        OI_ObexTest.SendErrorRsp = FALSE;
+        goto GetResponseError;
+    }
+#endif
+
+    if (rspStatus == OI_OBEX_CONTINUE) {
+        rsp = OI_OBEX_FINAL(OI_OBEX_RSP_CONTINUE);
+    } else {
+        SetState(connection, GET_COMPLETING);
+        rsp = OI_OBEX_FINAL(OI_OBEX_RSP_OK);
+    }
+    OI_OBEXCOMMON_InitPacket(&connection->common, rsp, &pkt);
+    /*
+     * Enable SRM if the client requested it
+     */
+    if (connection->common.srm & OI_OBEX_SRM_REQUESTED) {
+        connection->common.srm &= ~OI_OBEX_SRM_REQUESTED;
+        connection->common.srm |= OI_OBEX_SRM_ENABLED;
+        headers[headerCount].id = OI_OBEX_HDR_SINGLE_RESPONSE_MODE;
+        headers[headerCount].val.srm = OI_OBEX_SRM_ENABLED;
+        headerCount++;
+#ifdef OI_TEST_HARNESS
+        if (OI_ObexTest.ignoreSRM) {
+            connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+            OI_SLOG_ERROR(OI_STATUS_TEST_HARNESS, ("Ignoring SRM!!!"));
+        }
+#endif
+    }
+    /*
+     * If we are doing SRM request but we got an incomplete GET (i.e. !final) request another GET
+     * command.
+     */
+    if (!connection->final && (connection->common.srm & OI_OBEX_SRM_ENABLED)) {
+        headers[headerCount].id = OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS;
+        headers[headerCount].val.srmParam = OI_OBEX_SRM_PARAM_RSVP;
+        headerCount++;
+    }
+    status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, rspHeaders);
+    if (OI_SUCCESS(status)) {
+        status = ServerSendPacket(connection);
+    }
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("OI_OBEXSRV_GetResponse failed"));
+        rspStatus = status;
+        goto GetResponseError;
+    }
+
+    return OI_OK;
+
+GetResponseError:
+
+    /*
+     * Report an error result to the client.
+     */
+    SetState(connection, OBEX_CONNECTED);
+    ErrorResponse(connection, rspStatus);
+    return status;
+}
+
+
+static OI_BOOL ResponseRequired(OBEXSRV_CONNECTION* connection)
+{
+    if (!(connection->common.srm & OI_OBEX_SRM_ENABLED)) {
+        return TRUE;
+    }
+    /*
+     * Final packet always requires a response.
+     */
+    if (connection->final) {
+        connection->common.srmParam = SRM_PARAM_NONE;
+        return TRUE;
+    }
+    /*
+     * One time request for a response
+     */
+    if (connection->common.srmParam == OI_OBEX_SRM_PARAM_RSVP) {
+        OI_DBGPRINT2(("SRM client requested response"));
+        connection->common.srmParam = SRM_PARAM_NONE;
+        return TRUE;
+    }
+    /*
+     * Request for a response and wait for the next packet
+     */
+    if (connection->common.srmParam == OI_OBEX_SRM_PARAM_RSVP_AND_WAIT) {
+        OI_DBGPRINT2(("SRM client requested response and wait"));
+        return TRUE;
+    }
+    /*
+     * We are in SRM mode so should not send a response packet
+     */
+    OI_DBGPRINT2(("SRM no response required"));
+    return FALSE;
+}
+
+
+/*
+ * Called by application to acknowledge a PUT request. Most servers will
+ * respond with NULL headers, but the Sync profile requires Application
+ * Parameter headers in some PUT responses.
+ */
+
+OI_STATUS OI_OBEXSRV_PutResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                 OI_OBEX_HEADER_LIST *rspHeaders,
+                                 OI_STATUS rspStatus)
+{
+    OI_OBEX_HEADER headers[1];
+    OI_UINT16 headerCount = 0;
+    OI_UINT8 rsp;
+    OI_STATUS status = OI_OK;
+    OI_BYTE_STREAM pkt;
+    OBEXSRV_CONNECTION* connection;
+
+    OI_DBGTRACE(("OI_OBEXSRV_PutResponse connectionId:%d %d headers:%d=",
+                 connectionId, rspStatus, rspHeaders ? rspHeaders->list : NULL, rspHeaders ? rspHeaders->count : 0));
+
+    connection = LookupConnection(connectionId);
+    if (connection == NULL) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    /*
+     * Only one operation at a time on each connection.
+     */
+    if (connection->state != PUT_IN_PROGRESS) {
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+
+    OI_DBGPRINT2(("OI_OBEXSRV_PutResponse(%d, %8x, %d)", connectionId, headers, rspStatus));
+
+    /*
+     * In SRM mode we turned flow off until we get this confirmation call from the upper layer so
+     * now we need to turn flow on again.
+     */
+    if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+        connection->common.lowerConnection->ifc->flowControl(connection->common.lowerConnection, TRUE /* ON */);
+    }
+
+    if ((rspStatus != OI_OK) && (rspStatus != OI_OBEX_CONTINUE) && (rspStatus != OI_OBEX_PARTIAL_CONTENT)) {
+        goto PutResponseError;
+    }
+
+    if (rspStatus == OI_OBEX_CONTINUE) {
+        /*
+         * We don't expect a continue after reporting the final put
+         */
+        if (connection->final) {
+            OI_DBGPRINT(("OBEX Server in Invalid state\n "));
+            status = OI_STATUS_INVALID_STATE;
+            goto PutResponseError;
+        }
+        rsp = OI_OBEX_FINAL(OI_OBEX_RSP_CONTINUE);
+    } else {
+        SetState(connection, PUT_COMPLETING);
+        connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+        rsp = MapStatus(rspStatus);
+    }
+
+    /*
+     * If we are in SRM mode we cannot send a response unless we are asked for one
+     */
+    if (ResponseRequired(connection)) {
+        /*
+         * Enable SRM if it has been requested and the PUT is continuing
+         */
+        if ((rspStatus == OI_OBEX_CONTINUE) && connection->common.srm & OI_OBEX_SRM_REQUESTED) {
+            connection->common.srm &= ~OI_OBEX_SRM_REQUESTED;
+            connection->common.srm |= OI_OBEX_SRM_ENABLED;
+            headers[headerCount].id = OI_OBEX_HDR_SINGLE_RESPONSE_MODE;
+            headers[headerCount].val.srm = OI_OBEX_SRM_ENABLED;
+            headerCount++;
+#ifdef OI_TEST_HARNESS
+            if (OI_ObexTest.ignoreSRM) {
+                connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+                OI_SLOG_ERROR(OI_STATUS_TEST_HARNESS, ("Ignoring SRM!!!"));
+            }
+#endif
+        }
+        if ((NULL != rspHeaders) || (headerCount > 0)) {
+            OI_OBEXCOMMON_InitPacket(&connection->common, rsp, &pkt);
+            status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, rspHeaders);
+            if (OI_SUCCESS(status)) {
+                status = ServerSendPacket(connection);
+            }
+        } else {
+            status = OI_OBEXCOMMON_SendSimple(&connection->common, rsp);
+        }
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("OI_OBEXSRV_PutResponse failed"));
+            rspStatus = status;
+            goto PutResponseError;
+        }
+    }
+
+    return OI_OK;
+
+PutResponseError:
+
+    SetState(connection, OBEX_CONNECTED);
+    ErrorResponse(connection, rspStatus);
+    return status;
+}
+
+
+OI_STATUS OI_OBEXSRV_ActionResponse(OI_OBEXSRV_CONNECTION_HANDLE    connectionId,
+                                    OI_UINT8                        actionId,
+                                    OI_STATUS                       rspStatus,
+                                    const OI_OBEX_HEADER_LIST       *optHeaders)
+{
+    OI_STATUS status = OI_OK;
+    OBEXSRV_CONNECTION* connection;
+
+    OI_DBGTRACE(("OI_OBEXSRV_ActionResponse connectionId:%d %d", connectionId, rspStatus));
+
+    connection = LookupConnection(connectionId);
+    if (connection == NULL) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    /*
+     * Only one operation at a time on each connection.
+     */
+    if (connection->state != DO_ACTION) {
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+
+    status = sendSimpleWithHeaders(&connection->common, MapStatus(rspStatus), optHeaders);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("OI_OBEXSRV_ActionResponse failed"));
+        rspStatus = status;
+        goto ActionResponseError;
+    }
+
+    SetState(connection, OBEX_CONNECTED);
+    return OI_OK;
+
+ActionResponseError:
+
+    SetState(connection, OBEX_CONNECTED);
+    ErrorResponse(connection, rspStatus);
+    return status;
+}
+
+
+/**
+ * Bluetooth specification 5.6 - if a Target was used to establish the
+ * connection a ConnectionId is required in all subesquent requests.
+ */
+static OI_STATUS VerifyConnectionId(OBEXSRV_CONNECTION *connection,
+                                    OI_OBEX_HEADER_LIST *headers)
+{
+    OI_STATUS status = OI_OK;
+    OI_OBEX_HEADER *conId;
+
+    if (connection->clientSpecifiedTarget) {
+        conId = OI_OBEX_FindHeader(headers, OI_OBEX_HDR_CONNECTION_ID);
+        if (conId == NULL) {
+            status = OI_OBEX_REQUIRED_HEADER_NOT_FOUND;
+        } else {
+            if (conId->val.connectionId != (OI_UINT32) connection) {
+                status = OI_OBEX_SERVICE_UNAVAILABLE;
+            }
+        }
+    }
+    return status;
+}
+
+
+/**
+ *
+ */
+
+static OI_STATUS GetCommand(OBEXSRV_CONNECTION *connection,
+                            OI_BYTE_STREAM *rcvPacket,
+                            OI_BOOL final)
+{
+    OI_OBEX_HEADER_LIST headers = { NULL, 0 };
+    OI_BOOL newRequest = FALSE;
+    OI_OBEX_HEADER *srmParamHdr;
+    OI_OBEX_HEADER *srmHdr;
+    OI_STATUS status;
+
+#ifdef OI_TEST_HARNESS
+    if (OI_ObexTest.SendErrorRsp) {
+        status = OI_OBEX_ERROR;
+        OI_ObexTest.SendErrorRsp = FALSE;
+        goto GetCommandError;
+    }
+#endif
+
+    /*
+     * Not busy after receiving a get request
+     */
+    connection->bulkGet.busy = FALSE;
+
+    switch (connection->state) {
+    case OBEX_CONNECTED:
+        /*
+         * This the start of a new GET request
+         */
+        OI_DBGPRINT2(("OBEX server received new get command"));
+        newRequest = TRUE;
+        SetState(connection, GET_IN_PROGRESS);
+        connection->bulkGet.head = NULL;
+        connection->bulkGet.tail = NULL;
+        connection->bulkGet.busy = FALSE;
+        connection->final = FALSE;
+        connection->common.progressBytes = 0;
+        break;
+    case GET_IN_PROGRESS:
+    case GET_COMPLETING:
+        /*
+         * Check that there is an upper layer server to handle the continuing get request.
+         */
+        if (connection->currentTarget->CBList->getInd == NULL) {
+            status = OI_OBEX_SERVICE_UNAVAILABLE;
+            OI_SLOG_ERROR(status, ("OBEX server received get without application to service it"));
+            goto GetCommandError;
+        }
+        break;
+    case BULK_GET_IN_PROGRESS:
+    case BULK_GET_COMPLETING:
+        /*
+         * Check that there is an upper layer server to handle the continuing get request.
+         */
+        if (connection->currentTarget->CBList->bulkGetInd == NULL) {
+            status = OI_OBEX_SERVICE_UNAVAILABLE;
+            OI_SLOG_ERROR(status, ("OBEX server received get without application to service it"));
+            goto GetCommandError;
+        }
+        break;
+    case BULK_GET_FAILED:
+        status = OI_OBEX_ERROR;
+        goto GetCommandError;
+    default:
+        /*
+         * Not expecting a get in this state.
+         */
+        status = OI_OBEX_OPERATION_IN_PROGRESS;
+        goto GetCommandError;
+
+    }
+    /*
+     * If SRM is enabled we don't expect GET commands after the GET is final.
+     */
+    if (connection->final && (connection->common.srm & OI_OBEX_SRM_ENABLED)) {
+        status = OI_OBEX_OPERATION_IN_PROGRESS;
+        OI_SLOG_ERROR(status, ("Unexpected GET received while doing SRM"));
+        goto GetCommandError;
+    }
+    connection->final = final;
+    /*
+     * Parse the command into a list of headers.
+     */
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("OI_OBEXCOMMON_ParseHeaderList failed"));
+        goto GetCommandError;
+    }
+    /*
+     * Check if client is requesting single response mode for this get
+     */
+    srmHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+    if (srmHdr && (srmHdr->val.srm == OI_OBEX_SRM_ENABLED)) {
+        if (connection->common.srm & OI_OBEX_SRM_SUPPORTED) {
+            OI_DBGPRINT(("Client requesting SRM for this get"));
+            connection->common.srm |= OI_OBEX_SRM_REQUESTED;
+        } else {
+            OI_DBGPRINT(("Client requesting SRM for this get (denied by server)"));
+        }
+        /*
+         * We don't want to pass the SRM header to the upper-layer.
+         */
+        OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+    }
+    /*
+     * Look for an SRM parameter header
+     */
+    srmParamHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+    if (srmParamHdr) {
+        OI_DBGPRINT2(("SRM parameter %d", srmParamHdr->val.srmParam));
+        /*
+         * save the srm parameter, we will need it later
+         */
+        connection->common.srmParam = srmParamHdr->val.srmParam;
+        /*
+         * We don't want to pass the SRM header to the upper-layer.
+         */
+        OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+    } else {
+        connection->common.srmParam = SRM_PARAM_NONE;
+    }
+    if (newRequest) {
+        /*
+         * Bluetooth specification 5.6 - either the Type header or the Name header
+         * must be included in the GET request.
+         */
+        if (!OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_NAME) && !OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_TYPE)) {
+            status = OI_OBEX_REQUIRED_HEADER_NOT_FOUND;
+            goto GetCommandError;
+        }
+        /*
+         * Only the first command packet has a connection id.
+         */
+        status = VerifyConnectionId(connection, &headers);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("VerifyConnectionId failed"));
+            goto GetCommandError;
+        }
+        /*
+         * Make sure the body segmentation header is cleared.
+         */
+        connection->common.bodySegment.id = 0;
+    } else {
+        /*
+         * If we are sending a segmented body header we will not be calling the
+         * application for more data until we are done with this body header.
+         */
+        if (OI_OBEX_IS_A_BODY_HEADER(connection->common.bodySegment.id)) {
+            status = ServerSendBodySegment(connection);
+            if (!OI_SUCCESS(status)) {
+                goto GetCommandError;
+            }
+            OI_FreeIf(&headers.list);
+            return OI_OK;
+        }
+    }
+    if ((connection->state == BULK_GET_IN_PROGRESS) || (connection->state == BULK_GET_COMPLETING)) {
+        OI_ASSERT(!(connection->common.srm & OI_OBEX_SRM_ENABLED));
+        if (connection->bulkGet.head) {
+            ConfirmBulkGets(connection, OI_OBEX_CONTINUE, CONFIRM_COMPLETED, NULL);
+        } else {
+            connection->currentTarget->CBList->bulkGetInd(connection->common.connectionHandle, 0, NULL, NULL, OI_OBEX_CONTINUE);
+        }
+        /*
+         * If there is data queued to send, send it.
+         */
+        if (connection->bulkGet.current) {
+            status = OI_OBEXCOMMON_SendBulk(&connection->common, &connection->bulkGet.current, &connection->bulkGet.busy, NULL);
+        }
+    } else {
+        OI_STATUS indStatus = final ? OI_OBEX_CONTINUE : OI_OBEXSRV_INCOMPLETE_GET;
+        status = connection->currentTarget->CBList->getInd(connection->common.connectionHandle, &headers, indStatus);
+    }
+    if (!OI_SUCCESS(status)) {
+        goto GetCommandError;
+    }
+
+    OI_FreeIf(&headers.list);
+    return OI_OK;
+
+GetCommandError:
+
+    OI_DBGPRINT(("OBEX get command %d", status));
+
+    OI_ASSERT(!OI_SUCCESS(status));
+
+    connection->common.srm &= ~OI_OBEX_SRM_ENABLED;
+    /*
+     * Cleanup depending on state we are in
+     */
+    switch (connection->state) {
+    case OBEX_CONNECTED:
+        break;
+    case GET_IN_PROGRESS:
+    case GET_COMPLETING:
+        if (connection->currentTarget->CBList->getInd != NULL) {
+            connection->currentTarget->CBList->getInd(connection->common.connectionHandle, NULL, status);
+        }
+        break;
+    case BULK_GET_IN_PROGRESS:
+    case BULK_GET_COMPLETING:
+        if (connection->currentTarget->CBList->bulkGetInd != NULL) {
+            connection->currentTarget->CBList->bulkGetInd(connection->common.connectionHandle, 0, NULL, NULL, status);
+        }
+        break;
+    case BULK_GET_FAILED:
+        if (!ConfirmBulkGets(connection, status, CONFIRM_ALL, NULL)) {
+            OI_SLOG_ERROR(OI_STATUS_INVALID_STATE, ("Bulk get done with incomplete sends pending"));
+        }
+        break;
+    default:
+        break;
+    }
+    SetState(connection, OBEX_CONNECTED);
+    OI_FreeIf(&headers.list);
+    ErrorResponse(connection, status);
+
+    return status;
+}
+
+
+/**
+ *  Handle abort command, either immediately or via registered callback
+ *
+ */
+
+static OI_STATUS handleAbortCommand(OBEXSRV_CONNECTION *connection, OI_BYTE_STREAM *rcvPacket)
+{
+    OI_STATUS           status;
+
+    /*
+     * Any previous abort command handling should have finished.  Don't assert this because
+     * misbehaving remote device could trigger this logic.
+     */
+    if (NULL != connection->abortMbuf) {
+        OI_LOG_ERROR(("Received abort command while still processing previous abort command"));
+        connection->abortMbuf = NULL;
+    }
+
+    if (connection->currentTarget) {
+        if (connection->currentTarget->CBList->abortInd) {
+            /*
+             * Defer handling abort command until application calls abortResponse API
+             * As always, keep in mind that OBEXSRV_AbortResponse() might be called from within the callback.
+             */
+            OI_OBEX_HEADER_LIST headers;
+
+            status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+            if (OI_SUCCESS(status)) {
+                connection->abortPending = TRUE;
+                connection->abortResponsePending = TRUE;
+                connection->abortMbuf = NULL;
+                connection->currentTarget->CBList->abortInd(connection->common.connectionHandle, &headers);
+
+            } else {
+                ErrorResponse(connection, status);
+            }
+        } else {
+            /*
+             *  Process the abort command now.
+             */
+            status = AbortOperation(connection);
+        }
+    } else {
+        status = OI_OBEX_NOT_CONNECTED;
+    }
+    return status;
+}
+
+/**
+ * Handle a request from the client to perform a put operation.
+ */
+
+static OI_STATUS PutCommand(OBEXSRV_CONNECTION *connection,
+                            OI_BYTE_STREAM *rcvPacket,
+                            OI_BOOL final)
+{
+    OI_OBEX_HEADER_LIST headers;
+    OI_OBEX_HEADER *srmParamHdr;
+    OI_OBEX_HEADER *srmHdr;
+    OI_STATUS status;
+
+#ifdef OI_TEST_HARNESS
+    if (OI_ObexTest.SendErrorRsp) {
+        status = OI_OBEX_ERROR;
+        OI_ObexTest.SendErrorRsp = FALSE;
+        goto PutCommandError;
+    }
+#endif
+
+    /*
+     * Parse the command into a list of headers.
+     */
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+
+    if (OI_SUCCESS(status)) {
+        /*
+         * Is this the start of a new PUT request?
+         */
+        if (connection->state == OBEX_CONNECTED) {
+            OI_DBGPRINT(("OBEX server received new PUT command final:%d", final));
+            /*
+             * Only the first command packet has a connection id.
+             */
+            status = VerifyConnectionId(connection, &headers);
+            if (!OI_SUCCESS(status)) {
+                goto PutCommandError;
+            }
+            SetState(connection, PUT_IN_PROGRESS);
+            connection->common.progressBytes = 0;
+            /*
+             * Check if client is requesting single response mode for this put
+             */
+            srmHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_MODE);
+            if (srmHdr && (srmHdr->val.srm == OI_OBEX_SRM_ENABLED)) {
+                if (connection->common.srm & OI_OBEX_SRM_SUPPORTED) {
+                    OI_DBGPRINT(("Client requesting SRM for this put"));
+                    connection->common.srm |= OI_OBEX_SRM_REQUESTED;
+                } else {
+                    OI_DBGPRINT(("Client requesting SRM for this put (denied by server)"));
+                }
+                /*
+                 * We don't want to pass the SRM header to the upper-layer.
+                 */
+                OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+            }
+        } else {
+            if (connection->state != PUT_IN_PROGRESS) {
+                status = OI_OBEX_OPERATION_IN_PROGRESS;
+                goto PutCommandError;
+            }
+            OI_DBGPRINT2(("OBEX server received PUT command final:%d", final));
+        }
+        connection->final = final;
+        /*
+         * Check that there is a server to handle the put request.
+         */
+        if (connection->currentTarget->CBList->putInd == NULL) {
+            status = OI_OBEX_SERVICE_UNAVAILABLE;
+            goto PutCommandError;
+        }
+        /*
+         * Look for an SRM parameter header
+         */
+        srmParamHdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+        if (srmParamHdr) {
+            OI_DBGPRINT2(("SRM parameter %d", srmParamHdr->val.srmParam));
+            /*
+             * save the srm parameters, we will need them later
+             */
+            connection->common.srmParam = srmParamHdr->val.srmParam;
+            /*
+             * We don't want to pass the SRM header to the upper-layer.
+             */
+            OI_OBEXCOMMON_DeleteHeaderFromList(&headers, OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS);
+        } else {
+            connection->common.srmParam = SRM_PARAM_NONE;
+        }
+        /*
+         * In SRM mode we need to turn flow off until we get a confirm from the upper layer. Because
+         * of buffering in the lower layer this will not normally stop the flow of data from the
+         * remote peer unless the upper layer delays calling the confirm API.
+         */
+        if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+            connection->common.lowerConnection->ifc->flowControl(connection->common.lowerConnection, FALSE /* OFF */);
+        }
+        /*
+         * Call upper layer server with the PUT request headers.
+         */
+        status = connection->currentTarget->CBList->putInd(connection->common.connectionHandle, &headers, final ? OI_OK : OI_OBEX_CONTINUE);
+        if (OI_SUCCESS(status)) {
+
+            /*
+             * Report progress if the upper layer has provided a progress callback and there has been progress
+             */
+            if (connection->currentTarget->CBList->progressInd && connection->common.progressBytes) {
+                connection->currentTarget->CBList->progressInd(connection->common.connectionHandle, OI_OBEX_CMD_PUT, connection->common.progressBytes);
+            }
+        } else {
+            /*
+             * Turn flow on again if it was turned off above
+             */
+            if (connection->common.srm & OI_OBEX_SRM_ENABLED) {
+                connection->common.lowerConnection->ifc->flowControl(connection->common.lowerConnection, TRUE /* ON */);
+            }
+            /*
+             * Application reported an error - we need to return this error status
+             * to the OBEX client.
+             */
+            SetState(connection, OBEX_CONNECTED);
+            ErrorResponse(connection, status);
+        }
+        OI_FreeIf(&headers.list);
+        return OI_OK;
+    }
+
+PutCommandError:
+
+    OI_SLOG_ERROR(status, ("PutCommand error"));
+
+    OI_ASSERT(!OI_SUCCESS(status));
+
+    OI_FreeIf(&headers.list);
+    if ((connection->state == OBEX_CONNECTED) || (connection->state == PUT_IN_PROGRESS) || (connection->state == PUT_COMPLETING)) {
+        connection->currentTarget->CBList->putInd(connection->common.connectionHandle, NULL, status);
+        SetState(connection, OBEX_CONNECTED);
+    }
+    ErrorResponse(connection, status);
+    return status;
+}
+
+
+/**
+ *
+ */
+
+static OI_STATUS SetPathCommand(OBEXSRV_CONNECTION *connection,
+                                OI_BYTE_STREAM *rcvPacket)
+{
+    OI_OBEX_HEADER_LIST headers = { NULL, 0 };
+    OI_OBEX_HEADER *hdr;
+    OI_OBEX_UNICODE *name = NULL;
+    OI_UINT8 flags = 0;
+    OI_BOOL uplevel;
+    OI_BOOL create;
+    OI_STATUS status;
+
+    OI_DBGPRINT(("OBEX Server - SetPathCommand"));
+
+    if (connection->state != OBEX_CONNECTED) {
+        status = OI_OBEX_OPERATION_IN_PROGRESS;
+        goto SetPathCommandError;
+    }
+
+    /*
+     * Check that there is a server to handle the setpath request.
+     */
+    if (connection->currentTarget->CBList->setPathInd == NULL) {
+        status = OI_OBEX_SERVICE_UNAVAILABLE;
+        goto SetPathCommandError;
+    }
+
+
+    ByteStream_GetUINT8_Checked(*rcvPacket, flags);
+
+    /* We don't currently use constants -- Skipping*/
+    /* ByteStream_GetUINT8_Checked(rcvPacket, constants); */
+    ByteStream_Skip_Checked(*rcvPacket, 1);
+
+    if (ByteStream_Error(*rcvPacket)) {
+        status = OI_OBEX_BAD_REQUEST;
+        goto SetPathCommandError;
+    }
+
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (!OI_SUCCESS(status)) {
+        goto SetPathCommandError;
+    }
+
+    status = VerifyConnectionId(connection, &headers);
+    if (!OI_SUCCESS(status)) {
+        goto SetPathCommandError;
+    }
+
+    uplevel = (flags & OI_OBEX_SETPATH_UP_LEVEL) != 0;
+    create = (flags & OI_OBEX_SETPATH_NO_CREATE) == 0;
+
+    hdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_NAME);
+    if ((hdr != NULL) && (hdr->val.name.len != 0)) {
+        name = &hdr->val.name;
+    }
+
+    /*
+     * Reject illegal argument combinations.
+     */
+    if (((name != NULL) && uplevel) || ((name == NULL) && create)) {
+        status = OI_OBEX_VALUE_NOT_ACCEPTABLE;
+        goto SetPathCommandError;
+
+    }
+
+    SetState(connection, SETTING_PATH);
+
+    /*
+     * Call the application to set the path.
+     */
+    connection->common.pRawHeaders = &headers;
+    status = connection->currentTarget->CBList->setPathInd(connection->common.connectionHandle, name, uplevel, create);
+    connection->common.pRawHeaders = NULL;
+    if (!OI_SUCCESS(status)) {
+        goto SetPathCommandError;
+    }
+
+    OI_FreeIf(&headers.list);
+
+    return OI_OK;
+
+SetPathCommandError:
+
+    OI_SLOG_ERROR(status, ("SetPathCommand error"));
+
+    if (connection->state == SETTING_PATH) {
+        SetState(connection, OBEX_CONNECTED);
+    }
+    OI_FreeIf(&headers.list);
+    ErrorResponse(connection, status);
+    return status;
+}
+
+
+/**
+ *
+ */
+
+static OI_STATUS ActionCommand(OBEXSRV_CONNECTION *connection,
+                               OI_BYTE_STREAM *rcvPacket)
+{
+    OI_OBEX_HEADER_LIST headers = { NULL, 0 };
+    OI_OBEX_HEADER *hdr;
+    OI_OBEX_UNICODE *name = NULL;
+    OI_UINT8 actionId;
+    OI_STATUS status;
+
+    OI_DBGPRINT(("OBEX Server - ActionCommand"));
+
+    if (connection->state != OBEX_CONNECTED) {
+        status = OI_OBEX_OPERATION_IN_PROGRESS;
+        goto ActionCommandError;
+    }
+
+    /*
+     * Check that there is a server to handle the action request.
+     */
+    if (connection->currentTarget->CBList->actionInd == NULL) {
+        status = OI_OBEX_NOT_IMPLEMENTED;
+        goto ActionCommandError;
+    }
+
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (!OI_SUCCESS(status)) {
+        goto ActionCommandError;
+    }
+
+    status = VerifyConnectionId(connection, &headers);
+    if (!OI_SUCCESS(status)) {
+        goto ActionCommandError;
+    }
+
+    hdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_ACTION_ID);
+    if (hdr == NULL) {
+        status = OI_OBEX_REQUIRED_HEADER_NOT_FOUND;
+        goto ActionCommandError;
+    }
+    actionId = hdr->val.actionId;
+
+    hdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_NAME);
+    if (hdr == NULL) {
+        status = OI_OBEX_REQUIRED_HEADER_NOT_FOUND;
+        goto ActionCommandError;
+    }
+    name = &hdr->val.name;
+
+    SetState(connection, DO_ACTION);
+
+    /*
+     * Call the application with the action command.
+     */
+    status = connection->currentTarget->CBList->actionInd(connection->common.connectionHandle, actionId, name, &headers);
+    if (!OI_SUCCESS(status)) {
+        SetState(connection, OBEX_CONNECTED);
+        goto ActionCommandError;
+    }
+
+    OI_FreeIf(&headers.list);
+
+    return OI_OK;
+
+ActionCommandError:
+
+    OI_SLOG_ERROR(status, ("ActionCommand error"));
+
+    OI_FreeIf(&headers.list);
+    ErrorResponse(connection, status);
+    return status;
+}
+
+
+static OI_STATUS SessionCommand(OBEXSRV_CONNECTION *connection,
+                                OI_BYTE_STREAM *rcvPacket)
+{
+    OI_OBEX_HEADER_LIST headers = { NULL, 0 };
+    OI_OBEX_HEADER *hdr;
+    OI_UINT16 paramlen;
+    OI_UINT8 *params;
+    OI_UINT8 opcode;
+    OI_STATUS status;
+
+    OI_DBGPRINT(("OBEX Server - SessionCommand"));
+
+    if (connection->state != OBEX_CONNECTED) {
+        status = OI_OBEX_OPERATION_IN_PROGRESS;
+        goto SessionCommandError;
+    }
+
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (!OI_SUCCESS(status)) {
+        goto SessionCommandError;
+    }
+    hdr = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_SESSION_PARAMS);
+    if (hdr == NULL) {
+        status = OI_OBEX_REQUIRED_HEADER_NOT_FOUND;
+        goto SessionCommandError;
+    }
+    /*
+     * Parse the session parameters
+     */
+    params = hdr->val.sessionParams.data;
+    paramlen = hdr->val.sessionParams.len;
+
+    if (paramlen < 3) {
+        status = OI_OBEX_INCOMPLETE_PACKET;
+        OI_SLOG_ERROR(status, ("Session parameters too short"));
+        goto SessionCommandError;
+    }
+    /*
+     * First TLV value is the one byte session opcode
+     */
+    if ((params[0] != OI_OBEX_SESSION_PARAM_OPCODE) || (params[1] != 1)) {
+        status = OI_STATUS_INVALID_PARAMETERS;
+        OI_SLOG_ERROR(status, ("First session parameter must be the session opcode"));
+        goto SessionCommandError;
+    }
+    opcode = params[2];
+    paramlen -= 3;
+    params += 3;
+
+    /*
+     * Parse the remaining session parameters
+     */
+    while (paramlen >= 2) {
+        OI_UINT8 tag = params[0];
+        OI_UINT8 len = params[1];
+
+        paramlen -= 2;
+        if (paramlen < len) {
+            OI_SLOG_ERROR(OI_OBEX_INCOMPLETE_PACKET, ("Session parameters too short"));
+            break;
+        }
+        params += 2;
+        switch (tag) {
+        case OI_OBEX_SESSION_PARAM_DEVICE_ADDR:
+            break;
+        case OI_OBEX_SESSION_PARAM_NONCE:
+            break;
+        case OI_OBEX_SESSION_PARAM_ID:
+            break;
+        case OI_OBEX_SESSION_PARAM_NEXT_SEQ_NUM:
+            break;
+        case OI_OBEX_SESSION_PARAM_TIMEOUT:
+            break;
+        default:
+            OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS, ("Invalid session parameter %02#x", params[0]));
+            break;
+        }
+        paramlen -= len;
+        params += len;
+    }
+
+    /*
+     * Sessions are not yet implemented so all responses are error responses
+     */
+    switch (opcode) {
+    case OI_OBEX_SESSION_CREATE:
+        status = OI_OBEX_SERVICE_UNAVAILABLE;
+        break;
+    case OI_OBEX_SESSION_CLOSE:
+        status = OI_OBEX_FORBIDDEN;
+        break;
+    case OI_OBEX_SESSION_SUSPEND:
+        status = OI_OBEX_NOT_IMPLEMENTED;
+        break;
+    case OI_OBEX_SESSION_RESUME:
+        status = OI_OBEX_SERVICE_UNAVAILABLE;
+        break;
+    case OI_OBEX_SESSION_SET_TIMEOUT:
+        status = OI_OBEX_NOT_IMPLEMENTED;
+        break;
+    }
+
+    if (!OI_SUCCESS(status)) {
+        goto SessionCommandError;
+    }
+
+    OI_FreeIf(&headers.list);
+
+    return OI_OBEX_SERVICE_UNAVAILABLE;
+
+SessionCommandError:
+
+    OI_SLOG_ERROR(status, ("SessionCommand error"));
+
+    OI_FreeIf(&headers.list);
+    ErrorResponse(connection, status);
+    return status;
+}
+
+
+static OI_STATUS acceptConnect(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                               const OI_OBEX_REALM          *realm,
+                               OI_BOOL                      accept,
+                               OI_STATUS                    status,
+                               const OI_OBEX_HEADER_LIST    *optHeaders)
+{
+
+    OBEXSRV_CONNECTION *connection;
+    OI_OBEX_HEADER headers[4];
+    OI_UINT16 headerCount = 0;
+    OI_UINT8 rsp = OI_OBEX_FINAL(OI_OBEX_RSP_OK);
+    OI_OBEX_HEADER *hdr;
+    OI_BYTE_STREAM pkt;
+    OI_STATUS inStatus = status;
+
+    OI_DBGPRINT2(("acceptConnect connectionId %x accept %d %d", connectionId, accept, status));
+
+    connection = LookupConnection(connectionId);
+
+    if (connection == NULL) {
+        OI_SLOG_ERROR(OI_OBEX_INVALID_OPERATION, ("Null connection handle!"));
+        return OI_OBEX_INVALID_OPERATION;
+    }
+
+    if (accept) {
+        if (connection->unauthorized) {
+            /*
+             * The OBEX connection has not been established
+             */
+            SetState(connection, LOWER_LAYER_CONNECTED);
+            /*
+             * Reject the connection request and send an authentication challenge
+             * header in the response.
+             */
+            rsp = OI_OBEX_FINAL(OI_OBEX_RSP_UNAUTHORIZED);
+            OI_OBEXAUTH_ComposeChallenge(OI_CONFIG_TABLE_GET(OBEX_SRV)->privateKey, realm, &connection->common, &headers[headerCount++]);
+        } else {
+            /*
+             * The connection will be complete when the connect response packet has
+             * been sent.
+             */
+            SetState(connection, CONNECT_COMPLETING);
+            /*
+             * If the connect request specified a target we must respond with a
+             * ConnectionId header and a Who header.
+             */
+            if (connection->clientSpecifiedTarget) {
+                hdr = &headers[headerCount++];
+                hdr->id = OI_OBEX_HDR_CONNECTION_ID;
+                hdr->val.connectionId = (OI_UINT32) connection;
+                hdr = &headers[headerCount++];
+                hdr->id = OI_OBEX_HDR_WHO;
+                hdr->val.who.len = connection->currentTarget->target.len;
+                hdr->val.who.data = connection->currentTarget->target.data;
+            }
+            /*
+             * If authentication is required include an authentication challenge
+             * in the connection response.
+             */
+            if (connection->authRequested) {
+                OI_OBEXAUTH_ComposeResponse(&connection->common, &headers[headerCount++]);
+            }
+            /*
+             * If the upper layer server wants to use SRM include the SRM header in the response.
+             */
+            if ((connection->common.srm & OI_OBEX_SRM_SUPPORTED) &&
+                (connection->common.srm & OI_OBEX_SRM_REQUESTED)) {
+                headers[headerCount].id = OI_OBEX_HDR_SINGLE_RESPONSE_MODE;
+                headers[headerCount].val.srm = OI_OBEX_SRM_SUPPORTED;
+                headerCount++;
+                OI_DBGPRINT(("SRM supported for this connection"));
+            }
+        }
+    } else {
+        /*
+         * Lower layer connection is still alive.
+         */
+        SetState(connection, LOWER_LAYER_CONNECTED);
+        rsp = MapStatus(inStatus);
+        /*
+         * The upper did not accept so forget we indicated the connection
+         */
+        connection->connectIndicated = FALSE;
+    }
+
+    /*
+     * Initialize the packet header.
+     */
+    OI_OBEXCOMMON_InitPacket(&connection->common, rsp, &pkt);
+    ByteStream_PutUINT8(pkt, OI_OBEX_VERSION_NUMBER);
+    ByteStream_PutUINT8(pkt, 0); /* flags */
+    ByteStream_PutUINT16(pkt, connection->common.maxRecvPktLen, OI_OBEX_BO);
+
+    status = OI_OBEXCOMMON_MarshalPacket(&connection->common, &pkt, headers, headerCount, optHeaders);
+
+    if (OI_SUCCESS(status)) {
+        status = ServerSendPacket(connection);
+    }
+    if (!OI_SUCCESS(status)) {
+        goto ConnectRspError;
+    }
+
+    return OI_OK;
+
+ConnectRspError:
+
+    OI_SLOG_ERROR(status, ("acceptConnect error"));
+    /*
+     * The lower layer connection is still up, the OBEX connection is not.
+     */
+    SetState(connection, LOWER_LAYER_CONNECTED);
+    OI_FreeIf(&connection->common.authentication);
+    connection->connectIndicated = FALSE;
+    return status;
+
+}
+
+OI_STATUS OI_OBEXSRV_AcceptConnect(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                   OI_BOOL                      accept,
+                                   OI_STATUS                    status,
+                                   const OI_OBEX_HEADER_LIST    *optHeaders)
+{
+    OBEXSRV_CONNECTION *connection;
+
+    OI_DBGTRACE(("OI_OBEXSRV_AcceptConnect (connectionId = %d, accept = %d, status = %d)\n",
+                 connectionId, accept, status));
+
+    if (!OI_INIT_FLAG_VALUE(OBEX_SRV)) {
+        return OI_STATUS_NOT_INITIALIZED;
+    }
+
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state != OBEX_CONNECTING)) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+
+    if ((accept && !OI_SUCCESS(status)) || (!accept && OI_SUCCESS(status))) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS, ("Invalid combination of accept and status"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    status = acceptConnect(connectionId, NULL, accept, status, optHeaders);
+
+    return status;
+}
+
+/*
+ * Dispatch function for re-indicating a connection to the upper layer. This has
+ * to be done via the dispatcher because a call into the stack cannot generate
+ * a call out.
+ */
+
+static void ReIndicateConnect(DISPATCH_ARG *darg)
+{
+    OBEXSRV_CONNECTION *connection = Dispatch_GetArg(darg, OBEXSRV_CONNECTION*);
+
+    OI_ASSERT(!connection->unauthorized);
+
+    OI_DBGPRINT(("Re-indicating connection"));
+
+    connection->connectIndicated = TRUE;
+    connection->currentTarget->CBList->connectInd(connection->common.connectionHandle, FALSE, NULL, 0, NULL);
+}
+
+
+OI_STATUS OI_OBEXSRV_AuthenticationResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                            const OI_BYTE *userId,
+                                            OI_UINT8 userIdLen,
+                                            const OI_CHAR *password,
+                                            OI_BOOL readOnly)
+{
+    OI_STATUS status;
+    DISPATCH_ARG darg;
+    OBEXSRV_CONNECTION *connection;
+
+    OI_DBGTRACE(("OI_OBEXSRV_AuthenticationResponse(connectionId = %d, userId =  \"%s\", userIdLen = %d, password = \"%s\", readOnly = %s)",
+                 connectionId, userId ? (OI_CHAR *)userId : "<null>", userIdLen, password ? password : "<null>", readOnly ? "TRUE" : "FALSE"));
+
+    if (!OI_INIT_FLAG_VALUE(OBEX_SRV)) {
+        return OI_STATUS_NOT_INITIALIZED;
+    }
+
+    /*
+     * Check that we are connecting.
+     */
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state != OBEX_CONNECTING)) {
+        OI_DBGPRINT(("Authentication response not expected"));
+        return OI_OBEX_INVALID_OPERATION;
+    }
+
+    if (!connection->unauthorized && !connection->authRequested) {
+        OI_DBGPRINT(("Connection did not required authentication"));
+        return OI_OBEX_INVALID_OPERATION;
+    }
+
+    /*
+     * Password must be a null terminated string.
+     */
+    if (password == NULL) {
+        password = "\0";
+    }
+
+    /*
+     * Readonly is only passed to the client if the connection is authenticated.
+     */
+    connection->common.readOnly = readOnly;
+
+    status = OI_OBEXAUTH_SaveAuthInfo(&connection->common, userId, userIdLen, password);
+    if (OI_SUCCESS(status)) {
+        /*
+         * If authentication succeeds. re-indicate the connection to the
+         * upper layer so that the connection can be accepted.
+         */
+        if (connection->unauthorized) {
+            if (OI_OBEXAUTH_Authenticate(&connection->common) == OI_OK) {
+                connection->unauthorized = FALSE;
+                Dispatch_SetArg(darg, connection);
+                OI_Dispatch_RegisterFunc(ReIndicateConnect, &darg, NULL);
+            } else {
+                if (connection->authTries < MAX_AUTHENTICATION_ATTEMPTS) {
+                    /*
+                     * Accept the connection to allow the authentication to proceed.
+                     */
+                    status = OI_OBEXSRV_AcceptConnect(connectionId, TRUE, OI_OK, NULL);
+                } else {
+                    OI_DBGPRINT(("Reached maximum number of authentication attempts"));
+                    status = OI_OBEX_ACCESS_DENIED;
+                }
+            }
+        } else {
+            /*
+             * Re-indicate the connection so the upperlayer can call OI_OBEXSRV_AcceptConnect to
+             * accept or reject the connect request. We do this for consistency with the case of no
+             * authentication.
+             */
+            Dispatch_SetArg(darg, connection);
+            OI_Dispatch_RegisterFunc(ReIndicateConnect, &darg, NULL);
+        }
+    }
+
+    /*
+     * Reset the OBEX connection if we get an error.
+     */
+    if (!OI_SUCCESS(status)) {
+
+        OI_STATUS connectStatus;
+
+        OI_SLOG_ERROR(status, ("OI_OBEXSRV_AuthenticationResponse error"));
+
+        connectStatus = acceptConnect(connectionId, NULL, FALSE, status, NULL);
+        if (!OI_SUCCESS(connectStatus)) {
+            OI_SLOG_ERROR(connectStatus, ("OI_OBEXSRV_AuthenticationResponse: Failure to send error reponse"));
+        }
+        SetState(connection, LOWER_LAYER_CONNECTED);
+        OI_OBEXAUTH_Reset(&connection->common);
+    }
+
+    return status;
+
+}
+
+/**
+ * Given two (possibly null) byteseq pointers that represent OBEX targets,
+ * determine if they match. Two byteseqs match if they both have the same data,
+ * or if both are NULL or have a NULL data pointer
+ */
+
+static OI_BOOL MatchTarget(const OI_OBEX_BYTESEQ *t1,
+                           const OI_OBEX_BYTESEQ *t2)
+{
+    if (t1 && t2 && (t1->len == t2->len)) {
+        return (OI_MemCmp(t1->data, t2->data, t1->len) == 0);
+    }
+
+    return ((t1 == NULL || t1->len == 0) && (t2 == NULL || t2->len == 0));
+}
+
+
+/**
+ * Given a server connection block and the target header from the client (if
+ * present), determine if a matching connection target can be found. If so, set
+ * the currentTarget field, otherwise return an error.
+ */
+
+static OI_STATUS FindTarget(OBEX_SERVER *server,
+                            const OI_OBEX_BYTESEQ *clientTarget,
+                            OBEXSRV_TARGET_INFO **foundTarget)
+{
+    OBEXSRV_TARGET_INFO *target;
+
+    for (target = &server->targetInfo; target != NULL; target = target->next) {
+        if (MatchTarget(clientTarget, &target->target)) {
+            *foundTarget = target;
+            return OI_OK;
+        }
+    }
+    return OI_OBEX_SERVICE_UNAVAILABLE;
+}
+
+
+/**
+ * Handle an OBEX connect request.
+ */
+
+static OI_STATUS ConnectCommand(OBEXSRV_CONNECTION *connection,
+                                OI_BYTE_STREAM *rcvPacket,
+                                OI_UINT8 cmdCode)
+{
+    OI_BYTE *userIdRemote = NULL;
+    OI_UINT8 userIdRemoteLen = 0;
+    OI_OBEX_HEADER_LIST headers = { NULL, 0 };
+    OI_OBEX_HEADER *target;
+    OI_OBEX_HEADER *authChallenge = NULL;
+    OI_OBEX_HEADER *authResponse = NULL;
+    OI_STATUS status;
+    OI_STATUS connectStatus;
+    OI_UINT8 version = 0;
+    OI_UINT8 flags = 0;
+    OI_BOOL havePassword;
+    OI_UINT16 maxSendPktLen = 0;
+
+    /*
+     * Reject a connect command if we are already connected.
+     */
+    if (connection->state != LOWER_LAYER_CONNECTED) {
+        status = OI_OBEX_SERVICE_UNAVAILABLE;
+        goto ConnectError;
+    }
+
+    ByteStream_GetUINT8_Checked(*rcvPacket, version);
+    /*
+     * Due to a misreading on the specification some implementations (including
+     * earlier versions of BM3) send the OBEX spec version number instead of the
+     * OBEX protocol version number. For interoperability we will only check the
+     * major version number.
+     */
+    if (OI_OBEX_MAJOR_VERSION_NUMBER(version) != OI_OBEX_MAJOR_VERSION) {
+        status = OI_OBEX_UNSUPPORTED_VERSION;
+        OI_SLOG_ERROR(status, ("OBEX Server connect - version mismatch %d.%d", OI_OBEX_MAJOR_VERSION_NUMBER(version), OI_OBEX_MINOR_VERSION_NUMBER(version)));
+        goto ConnectError;
+    }
+    OI_DBGPRINT2(("OBEX Server connect - version %d.%d", OI_OBEX_MAJOR_VERSION_NUMBER(version), OI_OBEX_MINOR_VERSION_NUMBER(version)));
+
+    ByteStream_GetUINT8_Checked(*rcvPacket, flags);
+    if (flags != 0) {
+        status = OI_OBEX_COMMAND_ERROR;
+        goto ConnectError;
+    }
+    ByteStream_GetUINT16_Checked(*rcvPacket, maxSendPktLen, OI_OBEX_BO);
+    if (ByteStream_Error(*rcvPacket)) {
+        status = OI_OBEX_INCOMPLETE_PACKET;
+        goto ConnectError;
+    }
+
+    OI_DBGPRINT2(("OBEX Server MaxSendPktLen was: %d, now %d", connection->common.maxSendPktLen, OI_MIN(maxSendPktLen, connection->common.maxSendPktLen)));
+    connection->common.maxSendPktLen = OI_MIN(maxSendPktLen, connection->common.maxSendPktLen);
+
+    /*
+     * The OBEX specification defines a minimum packet length. Reject
+     * connections that do not conform to the specification.
+     */
+    if (connection->common.maxSendPktLen < OI_OBEX_MIN_PACKET_SIZE) {
+        status = OI_OBEX_VALUE_NOT_ACCEPTABLE;
+        OI_SLOG_ERROR(status, ("OBEX Server connect - packet size too small %d", connection->common.maxSendPktLen));
+        goto ConnectError;
+    }
+
+    OI_DBGPRINT2(("OBEX Server connect - requested packet len = %d", connection->common.maxSendPktLen));
+    status = OI_OBEXCOMMON_ParseHeaderList(&connection->common, &headers, rcvPacket);
+    if (!OI_SUCCESS(status)) {
+        goto ConnectError;
+    }
+
+    /*
+     * Cache headers before invoking any callbacks.
+     */
+    connection->common.pRawHeaders = &headers;
+
+    /*
+     * If the client has specified a target check that the server supports the
+     * target. For the purposes of the comparison, NULL is a valid target and
+     * is valid if the server supports the NULL target.
+     */
+    target = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_TARGET);
+    status = FindTarget(connection->obexServer, target ? &target->val.target : NULL, &connection->currentTarget);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("Unable to find OBEX target %@", target ? target->val.target.data : NULL, target ? target->val.target.len : 0));
+        goto ConnectError;
+    }
+    /*
+     * We need to know if the client specified a target so we know whether to
+     * use a connection id subsequent response packets.
+     */
+    connection->clientSpecifiedTarget = (target != NULL);
+    /*
+     * Authentication is required if the server requires authentication or if
+     * the client included an authentication challenge in the connection
+     * request.
+     *
+     * Check if we received authentication challenge from the client
+     */
+    authChallenge = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_AUTHENTICATION_CHALLENGE);
+
+    if (authChallenge != NULL) {
+        OI_DBGPRINT(("OBEX server received authentication challenge"));
+
+        /*
+         * If this this is the first authentication attempt we need to
+         * allocate memory to manage the authentication state information.
+         */
+        if (connection->common.authentication == NULL) {
+            connection->common.authentication = OI_Calloc(sizeof(OBEX_AUTHENTICATION));
+            if (connection->common.authentication == NULL) {
+                status = OI_STATUS_NO_RESOURCES;
+                OI_SLOG_ERROR(status, ("OBEX server could not allocate authentication state"));
+                goto ConnectError;
+            }
+        }
+
+        OI_OBEXAUTH_SaveChallenge(&connection->common, authChallenge);
+
+        connection->authRequested = TRUE;
+
+    } else {
+        connection->authRequested = FALSE;
+    }
+
+    if (connection->currentTarget->authRequired) {
+        connection->common.authenticating = TRUE;
+        /*
+         * Until we know better assume that the connection is not authorized.
+         */
+        connection->unauthorized = TRUE;
+        /*
+         * If this this is the first authentication attempt we need to
+         * allocate memory to manage the authentication state information.
+         */
+        if (connection->common.authentication == NULL) {
+            connection->common.authentication = OI_Calloc(sizeof(OBEX_AUTHENTICATION));
+            if (connection->common.authentication == NULL) {
+                status = OI_STATUS_NO_RESOURCES;
+                OI_SLOG_ERROR(status, ("OBEX server could not allocate authentication state"));
+                goto ConnectError;
+            }
+        }
+
+        if (connection->currentTarget->authRequired == OI_OBEXSRV_AUTH_USERID_AND_PASSWORD) {
+            connection->common.authentication->userIdRequired = TRUE;
+        }
+
+        /*
+         * We count the number of times authentication has been attempted on to
+         * establish this connection. Reject the connection request is there are
+         * too many failed attempts.
+         */
+        if (connection->authTries >= MAX_AUTHENTICATION_ATTEMPTS) {
+            OI_DBGPRINT(("Reached maximum number of authentication attempts"));
+            OI_OBEXAUTH_Reset(&connection->common);
+            status = OI_OBEX_ACCESS_DENIED;
+            goto ConnectError;
+        }
+
+        authResponse = OI_OBEX_FindHeader(&headers, OI_OBEX_HDR_AUTHENTICATION_RESPONSE);
+        if (authResponse != NULL) {
+            OI_OBEXAUTH_SaveResponse(&connection->common, authResponse);
+
+            userIdRemoteLen = connection->common.authentication->userIdRemoteLen;
+            if (userIdRemoteLen > 0) {
+                userIdRemote = &connection->common.authentication->userIdRemote[0];
+                OI_DBGPRINT2(("Connection includes user id %s (%d)", userIdRemote, userIdRemoteLen));
+            }
+            /*
+             * Does the server require a user id as well as a password?
+             */
+            if (connection->common.authentication->userIdRequired && (userIdRemote == NULL)) {
+                /*
+                 * Reject the connection attempt.
+                 */
+                OI_DBGPRINT(("Server requires user id to authenticate"));
+                OI_OBEXAUTH_Reset(&connection->common);
+                status = OI_OBEX_ACCESS_DENIED;
+                goto ConnectError;
+            }
+        }
+    } else {
+        /*
+         * If the connection does not require authentication then it is
+         * implicitly authorized.
+         */
+        connection->common.authenticating = FALSE;
+        connection->unauthorized = FALSE;
+    }
+    /*
+     * No longer need the received headers.
+     */
+    OI_FreeIf(&headers.list);
+    /*
+     * We are connecting.
+     */
+    SetState(connection, OBEX_CONNECTING);
+    if (connection->unauthorized) {
+        /*
+         * Check if we have all the information we need to authenticate.
+         */
+        havePassword = (authResponse != NULL);
+        if (!havePassword) {
+            /*
+             * If this is the first connect request and the upper layer provides an authentication
+             * indication call it now.
+             */
+            if ((connection->authTries == 0) && connection->currentTarget->CBList->authInd) {
+                OI_DBGPRINT(("Indicate auth"));
+                connection->currentTarget->CBList->authInd(connection->common.connectionHandle, &connection->clientBdAddr);
+                status = OI_OK;
+            } else {
+                /*
+                 * Continue the connection process to get all the authentication information.
+                 */
+                status = OI_OBEXSRV_AcceptConnect(connection->common.connectionHandle, TRUE, OI_OK, NULL);
+            }
+            if (OI_SUCCESS(status)) {
+                return status;
+            } else {
+                OI_SLOG_ERROR(status, ("OBEX server could not accept connection"));
+                goto ConnectError;
+            }
+        }
+    }
+    ++connection->authTries;
+    /*
+     * Let application know that a connect request has been received. If
+     * unauthorized is TRUE the upper layer must call back with a password.
+     */
+    connection->connectIndicated = TRUE;
+    {
+        OI_OBEX_REALM *pRealm = NULL;
+
+        if ((NULL != connection->common.authentication) && (connection->common.authentication->realm.len > 0)) {
+            pRealm = &connection->common.authentication->realm;
+        }
+        connection->currentTarget->CBList->connectInd(connection->common.connectionHandle,
+                                                      connection->unauthorized | connection->authRequested,
+                                                      userIdRemote,
+                                                      userIdRemoteLen,
+                                                      pRealm);
+    }
+    connection->common.pRawHeaders = NULL;
+    return OI_OK;
+
+ConnectError:
+
+    OI_SLOG_ERROR(status, ("ConnectCommand error"));
+
+    connectStatus = acceptConnect(connection->common.connectionHandle, NULL, FALSE, status, NULL);
+    if (!OI_SUCCESS(connectStatus)) {
+        OI_SLOG_ERROR(connectStatus, ("OBEX server failed to accept connection"));
+    }
+    OI_FreeIf(&connection->common.authentication);
+    OI_FreeIf(&headers.list);
+    connection->common.pRawHeaders = NULL;
+    return status;
+}
+
+
+OI_STATUS OI_OBEXSRV_AuthAccept(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                const OI_OBEX_REALM          *realm,
+                                OI_BOOL                      accept)
+{
+    OBEXSRV_CONNECTION *connection;
+    OI_STATUS status;
+
+    OI_DBGTRACE(("OI_OBEXSRV_AuthAccept (connectionHandle = %d, accept = %d)", connectionId, accept));
+
+    connection = LookupConnection(connectionId);
+    if ((connection == NULL) || (connection->state != OBEX_CONNECTING)) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+    if (realm && (realm->len > 254)) {
+        OI_DBGPRINT(("Maximum length of realm string is 254 bytes"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    status = acceptConnect(connectionId, realm, accept, OI_OK, NULL);
+    if (OI_SUCCESS(status)) {
+        ++connection->authTries;
+    } else {
+        OI_SLOG_ERROR(status, ("OBEX server failed to accept connection"));
+    }
+    return status;
+}
+
+
+/**
+ * Returns the current target associated with an OI_OBEXSRV_CONNECTION_HANDLE
+ */
+
+OI_STATUS OI_OBEXSRV_GetTarget(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle,
+                               OI_OBEX_BYTESEQ *target)
+{
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionHandle);
+
+    OI_DBGTRACE(("OI_OBEXSRV_GetTarget (connectionHandle = %d, <*target = %x>)\n",
+                 connectionHandle, target));
+
+    if (connection == NULL) {
+        OI_DBGPRINT(("No connection for handle %x", connectionHandle));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    *target = connection->currentTarget->target;
+    return OI_OK;
+}
+
+
+OI_OBEX_SERVER_HANDLE OI_OBEXSRV_GetServerHandle(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle)
+{
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionHandle);
+
+    if (connection) {
+        return connection->obexServer->handle;
+    } else {
+        return NULL;
+    }
+}
+
+
+/**
+ * Returns the BD_ADDR associated with an OI_OBEXSRV_CONNECTION_HANDLE
+ */
+
+OI_STATUS OI_OBEXSRV_GetClientAddr(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle,
+                                   OI_BD_ADDR *pBdAddr)
+{
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionHandle);
+
+    OI_DBGPRINT2(("OI_OBEXSRV_GetClientAddr (connectionHandle = %d, <*pBdAddr = %x>)\n",
+                 connectionHandle, pBdAddr));
+
+    if (connection == NULL) {
+        OI_SLOG_ERROR(OI_OBEX_NOT_CONNECTED, ("No connection for handle %x", connectionHandle));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    *pBdAddr = connection->clientBdAddr;
+    return OI_OK;
+}
+
+
+/*
+ * Data received from an OBEX client.
+ */
+static void LowerRecvDataInd(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                             OI_BYTE *dataBuf,
+                             OI_UINT16 dataLen)
+{
+    OBEXSRV_CONNECTION *connection = (OBEXSRV_CONNECTION*)lowerConnection->context;
+    OI_STATUS status;
+    OI_UINT8 cmdCode;
+    OI_BYTE_STREAM rcvPacket;
+
+    if (connection == NULL) {
+        OI_SLOG_ERROR(OI_OBEX_NOT_CONNECTED, ("OBEX received data for unknown connection"));
+        return;
+    }
+
+    OI_DBGPRINT2(("OBEX server received data"));
+
+    /* We already issued a disconnect, nothing to do */
+    if (connection->state == OBEX_DISCONNECT_COMPLETING) {
+        OI_SLOG_ERROR(OI_OBEX_NOT_CONNECTED, ("Received command after server issued a disconnect request"));
+        return;
+    }
+
+    /*
+     * The client should not be sending any OBEX commands after issuing a disconnect. If we get
+     * spurious commands we will force a disconnect of the underlying lower layer connection and let
+     * the badly behaving remote client deal with the consequences.
+     */
+    if (connection->state == OBEX_DISCONNECTING) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_STATE, ("Received command after a disconnect"));
+        SetState(connection, OBEX_DISCONNECT_COMPLETING);
+        status = connection->common.lowerConnection->ifc->disconnect(connection->common.lowerConnection);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Lower layer disconnect failed"));
+            ServerDisconnect(connection, status);
+        }
+        return;
+    }
+
+
+    ByteStream_Init(rcvPacket, dataBuf, dataLen);
+    ByteStream_Open(rcvPacket, BYTESTREAM_READ);
+    /*
+     * Get the OBEX response code and skip over the packet length.
+     */
+    ByteStream_GetUINT8(rcvPacket, cmdCode);
+    ByteStream_Skip(rcvPacket, sizeof(OI_UINT16));
+
+    switch (OI_OBEX_FINAL(cmdCode)) {
+    case OI_OBEX_FINAL(OI_OBEX_CMD_CONNECT):
+        status = ConnectCommand(connection, &rcvPacket, cmdCode);
+        break;
+    case OI_OBEX_FINAL(OI_OBEX_CMD_DISCONNECT):
+        OI_DBGPRINT(("OBEX server received disconnect request"));
+        /*
+         * Acknowledge the disconnect request. The disconnect will complete
+         * when the lower layer indicates that the response has been sent.
+         */
+        status = OI_OBEXCOMMON_SendOk(&connection->common);
+        if (OI_SUCCESS(status)) {
+            SetState(connection, OBEX_DISCONNECTING);
+        } else {
+            /*
+             * Even if we are unable to respond to the disconnect request we
+             * need to act on it.
+             */
+            OI_SLOG_ERROR(status, ("OI_OBEXCOMMON_SendOk failed"));
+            SetState(connection, OBEX_DISCONNECT_COMPLETING);
+            status = connection->common.lowerConnection->ifc->disconnect(connection->common.lowerConnection);
+            if (!OI_SUCCESS(status)) {
+                OI_SLOG_ERROR(status, ("Lower layer disconnect failed"));
+                ServerDisconnect(connection, status);
+            }
+        }
+        break;
+    case OI_OBEX_FINAL(OI_OBEX_CMD_PUT):
+        OI_DBGPRINT2(("PUT"));
+        status = PutCommand(connection, &rcvPacket, OI_OBEX_IS_FINAL(cmdCode));
+        break;
+    case OI_OBEX_FINAL(OI_OBEX_CMD_GET):
+        OI_DBGPRINT2(("GET"));
+        status = GetCommand(connection, &rcvPacket, OI_OBEX_IS_FINAL(cmdCode));
+        break;
+    case OI_OBEX_FINAL(OI_OBEX_CMD_SET_PATH):
+        OI_DBGPRINT2(("SETPATH"));
+        status = SetPathCommand(connection, &rcvPacket);
+        break;
+    case OI_OBEX_FINAL(OI_OBEX_CMD_ACTION):
+        OI_DBGPRINT2(("ACTION"));
+        status = ActionCommand(connection, &rcvPacket);
+        break;
+    case OI_OBEX_FINAL(OI_OBEX_CMD_SESSION):
+        OI_DBGPRINT2(("SESSION"));
+        status = SessionCommand(connection, &rcvPacket);
+        break;
+    case OI_OBEX_FINAL(OI_OBEX_CMD_ABORT):
+        OI_DBGPRINT2(("ABORT"));
+        status = handleAbortCommand(connection, &rcvPacket);
+        break;
+    default:
+        status = OI_OBEX_BAD_REQUEST;
+        ErrorResponse(connection, status);
+    }
+
+    if (!OI_SUCCESS(status)) {
+        OI_DBGPRINT(("OBEX request error %d", status));
+    }
+}
+
+
+static void LowerConnectCfm(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                            OI_UINT16 recvMtu,
+                            OI_UINT16 sendMtu,
+                            OI_STATUS result)
+{
+    OBEXSRV_CONNECTION *connection = (OBEXSRV_CONNECTION*)lowerConnection->context;
+    DISPATCH_ARG darg;
+    OI_INTERVAL timeout;
+
+    OI_DBGTRACE(("LowerConnectCfm %d recvMtu:%d sendMtu:%d", result, recvMtu, sendMtu));
+
+    if (connection == NULL) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_STATE, ("Null connection handle!"));
+        return;
+    }
+
+    if (OI_SUCCESS(result)) {
+        OI_DBGPRINT(("OBEX server lower layer connection confirmed"));
+        /*
+         * Maximum OBEX packet size depends on the size of the lower layer MTU
+         */
+        connection->common.maxRecvPktLen = OI_MIN(recvMtu, connection->common.maxRecvPktLen);
+        connection->common.maxSendPktLen = sendMtu;
+        OI_DBGPRINT(("maxRecvPktLen = %d, maxSendPktLen = %d", connection->common.maxRecvPktLen, connection->common.maxSendPktLen));
+
+        /*
+         * SRM is supported if it was enabled when the server was registered and the lower protocol
+         * for the connection is OBEX/L2CAP
+         */
+        if ((connection->obexServer->srm & OI_OBEX_SRM_SUPPORTED) &&
+            (connection->common.lowerConnection->ifc->getProtocol(
+            connection->common.lowerConnection) == OI_OBEX_LOWER_L2CAP)) {
+            connection->common.srm = OI_OBEX_SRM_SUPPORTED;
+        } else {
+            connection->common.srm &= ~OI_OBEX_SRM_SUPPORTED;
+        }
+        /*
+         * Finalize the connection. Most of the intialization was performed in
+         * LowerConnectInd() when the connection was indicated.
+         */
+        SetState(connection, LOWER_LAYER_CONNECTED);
+        /*
+         * If there is an existing timeout cancel it.
+         */
+        if (0 != connection->connectTimeout) {
+            OI_Dispatch_CancelFunc(connection->connectTimeout);
+        }
+        /*
+         * Allow for longer timeout for password entry if authentication is required.
+         */
+        timeout = (connection->obexServer->targetInfo.authRequired) ? OI_CONFIG_TABLE_GET(OBEX_SRV)->authTimeout : OI_CONFIG_TABLE_GET(OBEX_SRV)->connectTimeout;
+
+        Dispatch_SetArg(darg, connection->common.connectionHandle);
+        OI_Dispatch_RegisterTimedFunc(ConnectTimeout, &darg, timeout, &connection->connectTimeout);
+
+    } else {
+        /*
+         * Free any dynamically allocated memory and release the connection
+         * entry.
+         */
+        OI_SLOG_ERROR(result, ("OBEX server lower layer connection failed"));
+        /*
+         * Unlink the connection from the server and release the handle
+         */
+        OI_List_Del(&connection->link);
+        OI_HANDLE_Free(connection->common.connectionHandle);
+        OI_Free(connection);
+    }
+}
+
+
+/**
+ * Called by the lower layer when a client attempts to establish a connection to a registered OBEX
+ * server. We have to either accept or reject the request.
+ */
+
+static void LowerConnectInd(OI_OBEX_LOWER_SERVER lowerServer,
+                            OI_OBEX_LOWER_CONNECTION lowerConnection,
+                            OI_BD_ADDR *addr)
+{
+    OBEX_SERVER *server = (OBEX_SERVER*)lowerServer->context;
+    OBEXSRV_CONNECTION *connection;
+    OI_STATUS status;
+
+    OI_DBGTRACE(("LowerConnectInd %:", addr));
+
+
+    connection = OI_Calloc(sizeof(*connection));
+    if (!connection) {
+        OI_SLOG_ERROR(OI_STATUS_NO_RESOURCES, ("Failed to accepting connection from %:", addr));
+        goto RejectConnection;
+    }
+    /*
+     * Allocate a connection handle and associate it with the connection record
+     */
+    connection->common.connectionHandle = OI_HANDLE_Alloc(ObexSrvConnectionHandleType, connection);
+    if (!connection->common.connectionHandle) {
+        OI_SLOG_ERROR(OI_STATUS_NO_RESOURCES, ("Failed to accepting connection from %:", addr));
+        goto RejectConnection;
+    }
+    /*
+     * Save connecting device's bdaddr and the lower layer connection
+     */
+    connection->clientBdAddr = *addr;
+    connection->common.lowerConnection = lowerConnection;
+    connection->obexServer = server;
+    /*
+     * Inherit SRM flags from the server registration
+     */
+    connection->common.srm = server->srm;
+    /*
+     * Until we negotiate maximum  packet size for sending on this connection
+     * use the default minimum packet sizes.
+     */
+    connection->common.maxSendPktLen = OI_OBEX_MIN_PACKET_SIZE;
+    /*
+     * The maximum packet size we can receive is specified by a configuration
+     * parameter.
+     */
+    connection->common.maxRecvPktLen = OI_CONFIG_TABLE_GET(OBEX_SRV)->maxPktLen;
+    /*
+     * Accept the link request.
+     */
+    connection->state = LOWER_LAYER_CONNECTING;
+    status = lowerServer->ifc->accept(lowerConnection, TRUE);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("OBEX server error accepting link request from %:", addr));
+        goto RejectConnection;
+    }
+    /*
+     * Associate this OBEX connection with the lower connection.
+     */
+    lowerConnection->context = connection;
+    /*
+     * Add the connection to the server's connection list
+     */
+    OI_List_Add(&connection->link, &server->connectionList);
+    return;
+
+
+RejectConnection:
+
+    if (connection) {
+        if (connection->common.connectionHandle) {
+            OI_HANDLE_Free(connection->common.connectionHandle);
+        }
+        OI_Free(connection);
+    }
+    /*
+     * Reject the connection request.
+     */
+    OI_DBGPRINT(("OBEX server rejecting link request from %:", addr));
+    (void) lowerConnection->ifc->accept(lowerConnection, FALSE);
+}
+
+
+OI_STATUS OI_OBEXSRV_ConfirmSetpath(OI_OBEXSRV_CONNECTION_HANDLE    connectionId,
+                                    OI_STATUS                       status,
+                                    const OI_OBEX_HEADER_LIST       *optHeaders)
+{
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+    OI_DBGTRACE(("OI_OBEXSRV_ConfirmSetpath (connectionId = %d, status = %d)\n",
+                 connectionId, status));
+
+    if ((connection == NULL) || (connection->state != SETTING_PATH)) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+    SetState(connection, OBEX_CONNECTED);
+    if (OI_SUCCESS(status)) {
+        status = sendSimpleWithHeaders(&connection->common, OI_OBEX_FINAL(OI_OBEX_RSP_OK), optHeaders);
+    } else {
+        ErrorResponse(connection, status);
+        status = OI_OK;
+    }
+    return status;
+}
+
+
+OI_UINT16 OI_OBEXSRV_OptimalBodyHeaderSize(OI_OBEXSRV_CONNECTION_HANDLE connectionId)
+{
+    OI_UINT16   optimalSize;
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+    /*
+     * We don't know the packet length until we are connected.
+     */
+    if ((connection == NULL) || (connection->state < OBEX_CONNECTING)) {
+        optimalSize = 0;
+    } else {
+        optimalSize = connection->common.maxSendPktLen - OI_OBEX_BODY_PKT_OVERHEAD;
+    }
+    OI_DBGPRINT2(("OI_OBEXSRV_OptimalBodyHeaderSize (connectionId %d) is %d\n", connectionId, optimalSize));
+    return optimalSize;
+}
+
+
+/**
+ * Registers the OBEX server to accept put and/or get requests from OBEX
+ * clients.
+ */
+
+OI_STATUS OI_OBEXSRV_RegisterServer(const OI_OBEX_BYTESEQ *target,
+                                    const OI_OBEXSRV_CB_LIST *CBList,
+                                    OI_OBEXSRV_AUTHENTICATION authentication,
+                                    OI_OBEX_CONNECTION_OPTIONS *connectOptions,
+                                    OI_OBEX_LOWER_PROTOCOL *lowerProtocolList,
+                                    OI_UINT8 numProtocols,
+                                    const OI_CONNECT_POLICY *policy,
+                                    OI_OBEX_SERVER_HANDLE *serverHandle)
+{
+    OI_UINT i;
+    OI_STATUS status = OI_STATUS_INVALID_PARAMETERS;
+    OBEX_SERVER *server = NULL;
+    OI_UINT numRegistered = 0;
+
+    OI_ARGCHECK(policy);
+    OI_ARGCHECK(CBList);
+    OI_ARGCHECK(lowerProtocolList);
+    OI_ARGCHECK(serverHandle);
+    OI_ARGCHECK(numProtocols > 0);
+
+    OI_DBGTRACE(("OI_OBEXSRV_RegisterServer target:%x authentication:%s", target, OI_OBEXSRV_AuthenticationText(authentication)));
+
+    if ((CBList == NULL) || ((target != NULL) && (target->data == NULL))) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    OI_DBGPRINT2(("Target: %@", target ? target->data : NULL, target ? target->len : 0));
+
+    server = OI_Calloc(sizeof(OBEX_SERVER));
+    if (server == NULL) {
+        status = OI_STATUS_NO_RESOURCES;
+        goto RegistrationFailed;
+    }
+    server->handle = OI_HANDLE_Alloc(ObexServerHandleType, server);
+    if (!server->handle) {
+        status = OI_STATUS_NO_RESOURCES;
+        goto RegistrationFailed;
+    }
+    OI_List_DynamicInit(&server->connectionList);
+
+    server->lowerProtocolList = OI_Calloc(sizeof(OI_OBEX_LOWER_SERVER) * (numProtocols + 1));
+
+    if (server->lowerProtocolList == NULL) {
+        status = OI_STATUS_NO_RESOURCES;
+        goto RegistrationFailed;
+    }
+
+    /*
+     * Is the upper layer server requesting SRM?
+     */
+    if (connectOptions && connectOptions->enableSRM) {
+        server->srm = OI_OBEX_SRM_SUPPORTED;
+    }
+#ifdef OI_TEST_HARNESS
+    OI_OBEX_TestInit();
+    if (OI_ObexTest.disableSRM) {
+        server->srm &= ~OI_OBEX_SRM_SUPPORTED;
+    }
+#endif
+    /*
+     * Registration with one or more lower protocols
+     */
+    for (i = 0; i < numProtocols; ++i) {
+        /*
+         * Register the server with the lower layer handler.
+         */
+        status = OI_OBEX_LOWER_RegisterServer(&lowerCallbacks,
+                                              OI_CONFIG_TABLE_GET(OBEX_SRV)->maxPktLen,
+                                              policy,
+                                              &lowerProtocolList[i],
+                                              &server->lowerProtocolList[i]);
+
+
+        if (OI_SUCCESS(status)) {
+            /*
+             * Store the OBEX server connection struct in the lower layer server handle.
+             */
+            server->lowerProtocolList[i]->context = server;
+            ++numRegistered;
+        } else {
+            lowerProtocolList[i].protocol = OI_OBEX_LOWER_NONE;
+        }
+    }
+    /*
+     * Check that we successfully registered at least one lower layer protocol.
+     */
+    if (numRegistered == 0) {
+        status = OI_STATUS_NO_RESOURCES;
+        OI_SLOG_ERROR(status, ("Failed to register lower layer protocol"));
+        goto RegistrationFailed;
+    }
+
+    if (target != NULL) {
+        server->targetInfo.target.data = target->data;
+        server->targetInfo.target.len = target->len;
+    }
+
+    server->targetInfo.CBList = CBList;
+    server->targetInfo.authRequired = authentication;
+
+    OI_INIT_FLAG_INCREMENT(OBEX_SRV);
+
+    *serverHandle = server->handle;
+
+    return OI_OK;
+
+RegistrationFailed:
+
+    OI_SLOG_ERROR(status, ("OI_OBEXSRV_RegisterServer error"));
+
+    if (server) {
+
+        if (server->lowerProtocolList) {
+            /*
+             * Deregister any lower servers that were registered.
+             */
+            for (i = 0; i < numProtocols; ++i) {
+                if (server->lowerProtocolList[i]) {
+                    server->lowerProtocolList[i]->ifc->deregServer(server->lowerProtocolList[i]);
+                }
+            }
+            OI_Free(server->lowerProtocolList);
+        }
+
+        if (server->handle) {
+            OI_HANDLE_Free(server->handle);
+        }
+        OI_Free(server);
+    }
+    return status;
+}
+
+
+/**
+ * This function registers an additional target on an existing OBEX server.
+ */
+OI_STATUS OI_OBEXSRV_RegisterSecondaryTarget(const OI_OBEX_BYTESEQ *target,
+                                             const OI_OBEXSRV_CB_LIST *CBList,
+                                             OI_OBEXSRV_AUTHENTICATION authentication,
+                                             OI_OBEX_SERVER_HANDLE serverHandle)
+{
+    OBEX_SERVER *server = (OBEX_SERVER*)OI_HANDLE_Deref(serverHandle);
+    OBEXSRV_TARGET_INFO *targetInfo;
+
+    OI_DBGTRACE(("OI_OBEXSRV_RegisterSecondaryTarget target:%x authentication:%s", target, OI_OBEXSRV_AuthenticationText(authentication)));
+
+    OI_ARGCHECK(target);
+    OI_ARGCHECK(CBList);
+
+    if (server == NULL) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+
+    OI_DBGPRINT2(("Target: %@", target ? target->data : NULL, target ? target->len : 0));
+
+    if (FindTarget(server, target, &targetInfo) == OI_OK) {
+        return OI_STATUS_ALREADY_REGISTERED;
+    }
+    targetInfo = OI_Calloc(sizeof(*targetInfo));
+    if (targetInfo == NULL) {
+        return OI_STATUS_NO_RESOURCES;
+    }
+    targetInfo->target.data = target->data;
+    targetInfo->target.len = target->len;
+
+    targetInfo->CBList = CBList;
+    targetInfo->authRequired = authentication;
+    targetInfo->next = server->targetInfo.next;
+    server->targetInfo.next = targetInfo;
+
+    return OI_OK;
+}
+
+
+/*
+ * Forcibly sever the connection to an OBEX client.
+ */
+OI_STATUS OI_OBEXSRV_ForceDisconnect(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle)
+{
+    OBEXSRV_CONNECTION *connection;
+
+    OI_DBGTRACE(("OI_OBEXSRV_ForceDisconnect"));
+
+    connection = LookupConnection(connectionHandle);
+    if (connection == NULL) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+    if (connection->state == DISCONNECTED) {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    /*
+     * This will let us report the reason for the disconnect in any callbacks
+     * that are pending.
+     */
+    connection->forcedDisconnect = TRUE;
+
+    SetState(connection, OBEX_DISCONNECT_COMPLETING);
+    return connection->common.lowerConnection->ifc->disconnect(connection->common.lowerConnection);
+}
+
+
+/*
+ * Deregisters the OBEX server so that it will no longer accept put and/or get
+ * requests from OBEX clients. All targets for the service are deregistered.
+ *
+ * The server cannot be deregistered if there is a client connected. The
+ * application must first force a disconnect and then deregister the server.
+ */
+
+OI_STATUS OI_OBEXSRV_DeregisterServer(OI_OBEX_SERVER_HANDLE serverHandle)
+{
+    OBEX_SERVER *server = (OBEX_SERVER*)OI_HANDLE_Deref(serverHandle);
+    OI_STATUS status = OI_OK;
+    OI_OBEX_LOWER_SERVER *list;
+    OBEXSRV_TARGET_INFO *target;
+
+    OI_DBGTRACE(("OI_OBEXSRV_DeregisterServer handle:%x", serverHandle));
+
+    if (server == NULL) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+    /*
+     * Check there are no connections using this server
+     */
+    if (!OI_List_IsEmpty(&server->connectionList)) {
+        status = OI_STATUS_STILL_CONNECTED;
+        OI_SLOG_ERROR(status, ("OI_OBEXSRV_DeregisterServer failed"));
+        return status;
+    }
+    /*
+     * Deregister all the lower protocols for this OBEX server
+     */
+    for (list = server->lowerProtocolList; *list != NULL; ++list) {
+        status = (*list)->ifc->deregServer(*list);
+        if (!OI_SUCCESS(status)){
+            OI_SLOG_ERROR(status, ("Lower layer deregister failed"));
+        }
+    }
+    OI_Free(server->lowerProtocolList);
+    /*
+     * Free all secondary targets associated with this server
+     */
+    target = server->targetInfo.next;
+    while (target != NULL) {
+        OBEXSRV_TARGET_INFO *goner;
+        goner = target;
+        target = target->next;
+        OI_Free(goner);
+    }
+    OI_HANDLE_Free(serverHandle);
+    OI_Free(server);
+    OI_INIT_FLAG_DECREMENT(OBEX_SRV);
+    return status;
+}
+
+
+OI_STATUS OI_OBEXSRV_GetLowerProtocolInfo(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle,
+                                          OI_OBEX_LOWER_PROTOCOL *lowerProtocol)
+{
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionHandle);
+
+    OI_ARGCHECK(lowerProtocol);
+
+    if ((connection == NULL) || (connection->state < LOWER_LAYER_CONNECTED)) {
+        return OI_STATUS_NOT_CONNECTED;
+    } else {
+        *lowerProtocol = connection->common.lowerConnection->server->lowerProtocol;
+        return OI_OK;
+    }
+}
+
+
+OI_BOOL OI_OBEXSRV_IsServerBusy(OI_OBEX_SERVER_HANDLE serverHandle)
+{
+    OBEX_SERVER *server = (OBEX_SERVER*)OI_HANDLE_Deref(serverHandle);
+
+    if (server == NULL) {
+        OI_DBGTRACE(("OI_OBEXSRV_IsServerBusy invalid server handle"));
+        return FALSE;
+    } else {
+        OI_DBGTRACE(("OI_OBEXSRV_IsServerBusy %d", !OI_List_IsEmpty(&server->connectionList)));
+        return !OI_List_IsEmpty(&server->connectionList);
+    }
+}
+
+
+void* OI_OBEXSRV_GetConnectionContext(OI_OBEXSRV_CONNECTION_HANDLE connectionId)
+{
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+
+    if (connection == NULL) {
+        OI_DBGPRINT2(("OI_OBEXSRV_GetConnectionContext invalid connection handle"));
+        return NULL;
+    } else {
+        OI_DBGPRINT2(("OI_OBEXSRV_GetConnectionContext connectionId:%d context:%x", connectionId, connection->context));
+        return connection->context;
+    }
+}
+
+OI_STATUS OI_OBEXSRV_SetConnectionContext(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                          void *context)
+{
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+    if (connection == NULL) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("OI_OBEXSRV_SetConnectionContext invalid connection handle"));
+        return OI_STATUS_INVALID_HANDLE;
+    } else {
+        OI_DBGPRINT2(("OI_OBEXSRV_SetConnectionContext connectionId:%d context:%x", connectionId, context));
+        connection->context = context;
+        return OI_OK;
+    }
+}
+
+
+OI_STATUS OI_OBEXSRV_SetServerContext(OI_OBEX_SERVER_HANDLE serverHandle,
+                                      void *context)
+{
+    OBEX_SERVER *server = (OBEX_SERVER*)OI_HANDLE_Deref(serverHandle);
+
+    if (server) {
+        OI_DBGPRINT2(("OI_OBEXSRV_SetServerContext serverHandle:%d context:%x", serverHandle, context));
+        server->context = context;
+        return OI_OK;
+    } else {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("OI_OBEXSRV_SetServerContext invalid server handle"));
+        return OI_STATUS_INVALID_HANDLE;
+    }
+
+}
+
+
+void* OI_OBEXSRV_GetServerContext(OI_OBEX_SERVER_HANDLE serverHandle)
+{
+    OBEX_SERVER *server = (OBEX_SERVER*)OI_HANDLE_Deref(serverHandle);
+
+    OI_DBGPRINT2(("OI_OBEXSRV_GetServerContext"));
+
+    if (server) {
+        OI_DBGPRINT2(("OI_OBEXSRV_GetServerContext serverHandle:%d context:%x", serverHandle, server->context));
+        return server->context;
+    } else {
+        OI_DBGPRINT2(("OI_OBEXSRV_GetServerContext invalid server handle"));
+        return NULL;
+    }
+}
+
+
+OI_UINT OI_OBEXSRV_GetNumConnections(OI_OBEX_SERVER_HANDLE serverHandle)
+{
+    OBEX_SERVER *server = (OBEX_SERVER*)OI_HANDLE_Deref(serverHandle);
+    if (server) {
+        return OI_List_CountElements(&server->connectionList);
+    } else {
+        return 0;
+    }
+}
+
+
+OI_STATUS OI_OBEXSRV_GetL2capCID(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                 OI_L2CAP_CID *cid)
+{
+    OI_STATUS status = OI_STATUS_NOT_FOUND;
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+    OI_ARGCHECK(cid != NULL);
+
+    if (connection) {
+        switch (connection->state) {
+        case DISCONNECTED:
+        case LOWER_LAYER_CONNECTING:
+        case OBEX_DISCONNECTING:
+        case OBEX_DISCONNECT_COMPLETING:
+            status = OI_STATUS_NOT_CONNECTED;
+            break;
+        default:
+            *cid = connection->common.lowerConnection->ifc->getCID(connection->common.lowerConnection);
+            status = OI_OK;
+            break;
+        }
+    }
+    return status;
+}
+
+
+OI_STATUS OI_OBEXSRV_GetRawHeaderList(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                      OI_OBEX_HEADER_LIST          **pRawHeaderList)
+{
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+    OI_ARGCHECK(pRawHeaderList);
+
+    if (connection == NULL) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+
+    *pRawHeaderList = connection->common.pRawHeaders;
+
+    return OI_OK;
+}
+
+
+static void dispatchedAbortCommand(DISPATCH_ARG *darg)
+{
+    OI_OBEXSRV_CONNECTION_HANDLE connectionHandle = Dispatch_GetArg(darg, OI_OBEXSRV_CONNECTION_HANDLE);
+    OBEXSRV_CONNECTION *connection = LookupConnection(connectionHandle);
+
+    if (connection) {
+        connection->abortPending = FALSE;       /* Unblock bulk confirms */
+        AbortOperation(connection);
+    } else {
+        OI_SLOG_ERROR(OI_OBEX_NOT_CONNECTED, ("dispatchedAbortCommand"));
+    }
+}
+
+
+OI_STATUS OI_OBEXSRV_AbortResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                   OI_OBEX_HEADER_LIST          *rspHeaders,
+                                   OI_STATUS                    rspStatus)
+{
+    OI_STATUS           status = OI_OK;
+    OBEXSRV_CONNECTION  *connection = LookupConnection(connectionId);
+
+    if (connection == NULL) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+    if (!connection->abortResponsePending) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+
+    /*
+     *  We have been waiting for this.
+     */
+    connection->abortResponsePending = FALSE;           /* No longer waiting for response */
+    if (rspHeaders) {
+        /*
+         *  Application wants optional headers sent with the abort response.
+         *  Build the abort response packet for later use by the abort handler
+         */
+        OI_BYTE_STREAM  pkt;
+
+        OI_OBEXCOMMON_InitPacket(&connection->common, OI_OBEX_FINAL(rspStatus), &pkt);
+        status = OI_OBEXCOMMON_MarshalPacketMbuf(&connection->common, &pkt, NULL, 0, rspHeaders, &connection->abortMbuf);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("OI_OBEXCOMMON_MarshalPacketMbuf"));
+        }
+    } else {
+        /*
+         *  Build simple response, no headers
+         */
+        OI_BYTE cmdBuf[3];
+
+        cmdBuf[0] = OI_OBEX_FINAL(rspStatus);
+        cmdBuf[1] = 0;
+        cmdBuf[2] = sizeof(cmdBuf);
+        connection->abortMbuf = OI_MBUF_Wrap(cmdBuf, sizeof(cmdBuf), MBUF_COPY);
+    }
+
+    if (OI_SUCCESS(status)) {
+        /*
+         *  Now we want to actually process the abort command, but that needs to
+         *  run on dispatcher thread because we may be calling other application callbacks
+         *  in the course of executing abort.
+         */
+        DISPATCH_ARG darg;
+
+        Dispatch_SetArg(darg, connection->common.connectionHandle);
+        status = OI_Dispatch_RegisterFunc(dispatchedAbortCommand, &darg, NULL);
+    }
+    return status;
+}
+/*****************************************************************************/
diff --git a/obex_profiles/profiles/obex/obextest.c b/obex_profiles/profiles/obex/obextest.c
new file mode 100644
index 0000000..8b83596
--- /dev/null
+++ b/obex_profiles/profiles/obex/obextest.c
@@ -0,0 +1,136 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+Test harness support for OBEX
+*/
+
+#define __OI_MODULE__ OI_MODULE_OBEX_SRV
+
+#include "oi_obextest.h"
+#include "oi_debug.h"
+#include "oi_test.h"
+#include "oi_utils.h"
+
+
+#ifdef OI_TEST_HARNESS
+
+OI_OBEX_TEST_GLOBALS OI_ObexTest;
+
+
+static OI_STATUS ObexTest(const OI_CHAR *cmd)
+{
+    static const OI_CHAR cmdOpts[] = "SRM|L2CAP|FRAME_SZ|ABORT|ERROR_RSP";
+    static const OI_CHAR tf[] = "T|F";
+    static const OI_CHAR ignore[] = "ignore";
+    const OI_CHAR *args;
+    OI_INT index;
+    OI_BOOL inputOk = FALSE;
+
+    args = OI_ScanAlt(cmd, cmdOpts, &index);
+    switch (index) {
+        case 0:
+            if (OI_ScanAlt(args, tf, &index) != args) {
+                inputOk = TRUE;
+                OI_ObexTest.disableSRM = (index == 1);
+                OI_ObexTest.ignoreSRM = FALSE;
+                OI_Printf("SRM %s\n", OI_ObexTest.disableSRM ? "disabled" : "enabled");
+                break;
+            }
+            if (OI_ScanAlt(args, ignore, &index) != args) {
+                inputOk = TRUE;
+                OI_ObexTest.ignoreSRM = TRUE;
+                OI_Printf("SRM will be ignored (incorrect behavior)\n");
+            }
+            break;
+        case 1:
+            if (OI_ScanAlt(args, tf, &index) != args) {
+                inputOk = TRUE;
+                OI_ObexTest.disableL2CAP = (index == 1);
+                OI_Printf("OBEX/L2CAP %s\n", OI_ObexTest.disableL2CAP ? "disabled" : "enabled");
+            }
+            break;
+        case 2:
+            if (OI_ScanUInt(args, &OI_ObexTest.frameSize) != args) {
+                inputOk = TRUE;
+                OI_Printf("Max RFCOMM frame size is %d\n", OI_ObexTest.frameSize);
+            }
+            break;
+        case 3:
+            if (OI_ScanAlt(args, tf, &index) != args) {
+                inputOk = TRUE;
+                OI_ObexTest.fastAbort = (index == 0);
+                OI_Printf("OBEX PUT fast abort %s\n", OI_ObexTest.fastAbort ? "enabled" : "disabled");
+            }
+            break;
+        case 4:
+            if (OI_ScanAlt(args, tf, &index) != args) {
+                inputOk = TRUE;
+                OI_ObexTest.SendErrorRsp = (index == 0);
+            }
+            break;
+    }
+
+    if (!inputOk) {
+        OI_Printf("\nUsage: %s\n", cmdOpts);
+        OI_Printf("  SRM T|F|ignore    (enable, disable or ignore Single Response Mode)\n");
+        OI_Printf("  L2CAP T|F  (enable or disable OBEX over L2CAP)\n");
+        OI_Printf("  FRAME_SZ N (set maximum RFCOMM frames size)\n");
+        OI_Printf("  ABORT T|F (send an abort before receiving a put response)\n");
+        OI_Printf("  ERROR_RSP T|F (send an error in a put/get response)\n");
+    }
+    return OI_OK;
+}
+
+
+void OI_OBEX_TestInit(void)
+{
+    static OI_BOOL registered = FALSE;
+
+    if (!registered) {
+        OI_STATUS status;
+
+        registered = TRUE;
+        OI_ObexTest.disableSRM = FALSE;
+        OI_ObexTest.disableL2CAP = FALSE;
+        OI_ObexTest.fastAbort = FALSE;
+        OI_ObexTest.SendErrorRsp = FALSE;
+
+        status = OI_TEST_RegisterHandler(ObexTest, "obex");
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("OI_TEST_RegisterHandler (obex) failed"));
+        }
+    }
+}
+
+#endif
diff --git a/obex_profiles/profiles/obex/oi_obex_lower.h b/obex_profiles/profiles/obex/oi_obex_lower.h
new file mode 100644
index 0000000..3b2fa74
--- /dev/null
+++ b/obex_profiles/profiles/obex/oi_obex_lower.h
@@ -0,0 +1,293 @@
+#ifndef _OI_OBEX_LOWER_H
+#define _OI_OBEX_LOWER_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "oi_bt_spec.h"
+#include "oi_obex.h"
+#include "oi_stddefs.h"
+#include "oi_mbuf.h"
+#include "oi_status.h"
+#include "oi_connect_policy.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _OI_OBEX_LOWER_SERVER *OI_OBEX_LOWER_SERVER;
+
+typedef struct _OI_OBEX_LOWER_CONNECTION *OI_OBEX_LOWER_CONNECTION;
+
+
+/*
+ * OBEX APIs called by the lower layer interface
+ */
+
+
+/**
+ * This function is called by the lower layer to confirm a connection.
+ *
+ * @param lowerConnection  The handle for this connection.
+ *
+ * @param recvMtu           Lower layer imposed on maximum OBEX packet we can receive.
+ *
+ * @param sendMtu           Lower layer imposed on maximum OBEX packet we can send.
+ *
+ * @param result
+ */
+typedef void (*OI_OBEX_LOWER_CONNECT_CFM)(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                          OI_UINT16 recvMtu,
+                                          OI_UINT16 sendMtu,
+                                          OI_STATUS result);
+
+
+/**
+ * This function is called by the lower layer to indicate an incoming connect request.
+ *
+ * @param serverHandle      The server handle for the lower server.
+ *
+ * @param lowerConnection   The handle for this connection.
+ *
+ * @param addr              The Bluetooth device address of the remote device making the
+ *                          connection.
+ */
+typedef void (*OI_OBEX_LOWER_CONNECT_IND)(OI_OBEX_LOWER_SERVER serverHandle,
+                                          OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                          OI_BD_ADDR *addr);
+
+
+/**
+ * This function is called by the lower layer to indicate a disconnect
+ *
+ * @param lowerConnection  The handle for the connection that is going away.
+ *
+ * @param reason            Status code indicating the reason for the disconnection.
+ */
+typedef void (*OI_OBEX_LOWER_DISCONNECT_IND)(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                             OI_STATUS reason);
+
+
+/**
+ * This function is called by the lower layer to confirm completion of a write.
+ *
+ * @param lowerConnection  The handle for the connection for which a write has completed.
+ *
+ * @param mbuf              Pointer to the MBUF that is no longer in use by the lower layer.
+ *
+ * @param queueFull         If FALSE another write can be issued, if TRUE, subsequent calls to write will fail.
+ *
+ * @param result            OI_OK if the write completed succesfully.
+ *                          Other status codes indicate the reason that the write failed.
+ */
+typedef void (*OI_OBEX_LOWER_WRITE_CFM)(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                        OI_MBUF *mbuf,
+                                        OI_BOOL queueFull,
+                                        OI_STATUS result);
+
+
+/**
+ * This function is called by the lower layer to indicate data has been received.
+ *
+ * @param lowerConnection  The handle for the connection on which data has been received.
+ *
+ * @param dataBuf           Pointer to a lower layer buffer containing the received data.
+ *
+ * @param dataLen           The length of the received data.
+ */
+typedef void (*OI_OBEX_LOWER_RECV_DATA_IND)(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                            OI_BYTE *dataBuf,
+                                            OI_UINT16 dataLen);
+
+
+
+/**
+ * Callback functions passed in by OBEX client or SERVER
+ */
+typedef struct {
+    OI_OBEX_LOWER_CONNECT_CFM    connectCfm;
+    OI_OBEX_LOWER_CONNECT_IND    connectInd;
+    OI_OBEX_LOWER_DISCONNECT_IND disconnectInd;
+    OI_OBEX_LOWER_WRITE_CFM      writeCfm;
+    OI_OBEX_LOWER_RECV_DATA_IND  recvDataInd;
+} OI_OBEX_LOWER_CALLBACKS;
+
+
+/*
+ * Lower layer abstract interface function prototypes
+ */
+
+typedef OI_STATUS (*OI_OBEX_LOWER_REGISTER_SERVER)(OI_OBEX_LOWER_SERVER serverHandle,
+                                                   OI_UINT16 mtu,
+                                                   const OI_CONNECT_POLICY *policy,
+                                                   OI_OBEX_LOWER_PROTOCOL* lowerProtocol,
+                                                   btsock_interface_t *socket_interface);
+
+typedef OI_STATUS (*OI_OBEX_LOWER_DEREGISTER_SERVER)(OI_OBEX_LOWER_SERVER serverHandle);
+
+
+typedef OI_STATUS (*OI_OBEX_LOWER_CONNECT)(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                           OI_BD_ADDR *addr,
+                                           OI_OBEX_LOWER_PROTOCOL *serverIdentifier,
+                                           OI_UINT16 mtu,
+                                           const OI_CONNECT_POLICY *policy,
+                                           btsock_interface_t *socket_interface);
+
+
+typedef OI_STATUS (*OI_OBEX_LOWER_ACCEPT)(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                          OI_BOOL accept);
+
+
+typedef OI_STATUS (*OI_OBEX_LOWER_DISCONNECT)(OI_OBEX_LOWER_CONNECTION lowerConnection);
+
+
+/**
+ * Called by OBEX to write data via the lower layer transport
+ */
+typedef OI_STATUS (*OI_OBEX_LOWER_WRITE)(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                         OI_MBUF *mbuf,
+                                         OI_BOOL accleratedCfm,
+                                         OI_BOOL *queueFull);
+
+
+/*
+ * Called by OBEX to turn lower layer flow control on/off
+ */
+typedef void (*OI_OBEX_LOWER_FLOW_CONTROL)(OI_OBEX_LOWER_CONNECTION lowerConnection,
+                                           OI_BOOL flow);
+
+
+/**
+ * Get the protocol id for the lower protocol
+ */
+typedef OI_OBEX_LOWER_PROTOCOL_ID (*OI_OBEX_LOWER_GET_PROTOCOL)(
+                                        OI_OBEX_LOWER_CONNECTION lowerConnection);
+
+
+/**
+ * Get the L2CAP channel for the lower connection
+ */
+typedef OI_L2CAP_CID (*OI_OBEX_LOWER_GET_CID)(OI_OBEX_LOWER_CONNECTION lowerConnection);
+
+
+/*
+ * Abstract interface to a lower layer OBEX transport
+ */
+typedef struct {
+
+    OI_OBEX_LOWER_REGISTER_SERVER   regServer;   /**< Registers the lower layer transport */
+    OI_OBEX_LOWER_DEREGISTER_SERVER deregServer; /**< Deregisters the lower layer transport */
+    OI_OBEX_LOWER_CONNECT           connect;     /**< Connects to a remote OBEX server over a lower layer transport */
+    OI_OBEX_LOWER_ACCEPT            accept;      /**< Accepts an inbound connection from a remote OBEX server */
+    OI_OBEX_LOWER_DISCONNECT        disconnect;  /**< Disconnects a lower layer transport */
+    OI_OBEX_LOWER_WRITE             write;       /**< Writes data to a remote OBEX server over a lower layer transport */
+    OI_OBEX_LOWER_GET_PROTOCOL      getProtocol; /**< Returns the protocol id for this lower interface */
+    OI_OBEX_LOWER_FLOW_CONTROL      flowControl; /**< Turns lower layer flow control on/off */
+    OI_OBEX_LOWER_GET_CID           getCID;      /**< Get the L2CAP CID for the lower protocol */
+
+} OI_OBEX_LOWER_INTERFACE;
+
+
+/*
+ * Connection information that is specific and private to the lower layer.
+ */
+struct _LOWER_CONNECTION_PRIVATE;
+
+
+struct _OI_OBEX_LOWER_CONNECTION {
+    void *context;
+    OI_OBEX_LOWER_SERVER server;              /* server handle if there is one */
+    const OI_OBEX_LOWER_INTERFACE *ifc;
+    const OI_OBEX_LOWER_CALLBACKS *callbacks;
+    struct _LOWER_CONNECTION_PRIVATE *lowerPrivate;
+    void *lowerHandle;
+};
+
+
+/*
+ * Server information that is specific and private to the lower layer.
+ */
+struct _LOWER_SERVER_PRIVATE;
+
+
+struct _OI_OBEX_LOWER_SERVER {
+    void *context;
+    const OI_OBEX_LOWER_INTERFACE *ifc;
+    const OI_OBEX_LOWER_CALLBACKS *callbacks;
+    const OI_CONNECT_POLICY *policy;
+    OI_UINT16 mtu;
+    OI_OBEX_LOWER_PROTOCOL lowerProtocol;
+    struct _LOWER_SERVER_PRIVATE* lowerPrivate;
+};
+
+
+
+/**
+ * Registers an OBEX server on a specified lower layer protocol. An OBEX server can be registered on
+ * more than one lower layer protocol.
+ */
+OI_STATUS OI_OBEX_LOWER_RegisterServer(const OI_OBEX_LOWER_CALLBACKS *callbacks,
+                                       OI_UINT16 mtu,
+                                       const OI_CONNECT_POLICY *policy,
+                                       OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                                       OI_OBEX_LOWER_SERVER *lowerServer);
+
+
+/**
+ * Establish a connection to a remote OBEX server using a specified lower layer protocol.
+ */
+OI_STATUS OI_OBEX_LOWER_Connect(const OI_OBEX_LOWER_CALLBACKS *callbacks,
+                                OI_BD_ADDR *addr,
+                                OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                                OI_UINT16 mtu,
+                                const OI_CONNECT_POLICY *policy,
+                                OI_OBEX_LOWER_CONNECTION *lowerConnection);
+
+
+
+/**
+ * Returns a pointer to the lower interface function table
+ */
+const OI_OBEX_LOWER_INTERFACE* OI_OBEX_LowerInterface(void);
+
+/**
+ * This function sets the socket interface exposed by stack for communicating with underlying
+ * transport (RFCOMM or L2CAP).
+ *
+ * @param socket_interface  Socket Interface to be used.
+
+ * @return      - Null
+ */
+void OI_OBEX_LOWER_SetSocketInterface(btsock_interface_t *socket_interface);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OI_OBEX_LOWER_H */
diff --git a/obex_profiles/profiles/obex/oi_obexauth.h b/obex_profiles/profiles/obex/oi_obexauth.h
new file mode 100644
index 0000000..f7001cd
--- /dev/null
+++ b/obex_profiles/profiles/obex/oi_obexauth.h
@@ -0,0 +1,114 @@
+#ifndef _OBEXAUTH_H
+#define _OBEXAUTH_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+OBEX authentication support
+*/
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_obexspec.h"
+#include "oi_obexcommon.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/**
+ * Resets OBEX authentication state and frees any dynamically allocated memory.
+ */
+
+void OI_OBEXAUTH_Reset(OBEX_COMMON *common);
+
+
+/**
+ * Saves the password string.
+ */
+
+OI_STATUS OI_OBEXAUTH_SaveAuthInfo(OBEX_COMMON *common,
+                                   const OI_BYTE userId[OI_OBEX_MAX_USERID_LEN],
+                                   OI_UINT8 userIdLen,
+                                   const OI_CHAR *password);
+
+/**
+ * Saves an OBEX authentication challenge digest string.
+ */
+
+OI_STATUS OI_OBEXAUTH_SaveChallenge(OBEX_COMMON *common,
+                                    OI_OBEX_HEADER *challenge);
+
+
+/**
+ * Saves an OBEX authentication response digest string.
+ */
+
+OI_STATUS OI_OBEXAUTH_SaveResponse(OBEX_COMMON *common,
+                                   OI_OBEX_HEADER *response);
+
+
+/**
+ * Generate the authentication response to an previous authentication challenge.
+ */
+
+void OI_OBEXAUTH_ComposeResponse(OBEX_COMMON *common,
+                                 OI_OBEX_HEADER *response);
+
+
+/**
+ * Composes an authentication challenge header.
+ */
+
+void OI_OBEXAUTH_ComposeChallenge(const OI_CHAR* privateKey,
+                                  const OI_OBEX_REALM* realm,
+                                  OBEX_COMMON *common,
+                                  OI_OBEX_HEADER *challenge);
+
+
+/**
+ * Checks that correct response was received to an OBEX authentication
+ * challenge.
+ */
+
+OI_STATUS OI_OBEXAUTH_Authenticate(OBEX_COMMON *common);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/**@}*/
diff --git a/obex_profiles/profiles/obex/oi_obexcommon.h b/obex_profiles/profiles/obex/oi_obexcommon.h
new file mode 100644
index 0000000..67a970a
--- /dev/null
+++ b/obex_profiles/profiles/obex/oi_obexcommon.h
@@ -0,0 +1,427 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+functions common to OBEX server and client
+*/
+
+#ifndef _OBEXCOMMON_H
+#define _OBEXCOMMON_H
+
+#include "oi_obex.h"
+#include "oi_obexcli.h"
+#include "oi_obexsrv.h"
+#include "oi_obexspec.h"
+#include "oi_obex_lower.h"
+#include "oi_mbuf.h"
+#include "oi_bytestream.h"
+
+/** \addtogroup OBEX_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * size of a small buffer used for composing OBEX packet headers
+ */
+#define OI_OBEX_HDR_BUFSIZE 8
+
+/**
+ * the maximum number of headers passed in to a connect request
+ */
+#define OI_OBEX_MAX_CONNECT_HDRS  4
+
+
+typedef struct {
+    /**
+     * password entered by the user
+     */
+    OI_BYTE password[OI_OBEX_MAX_PASSWORD_LEN];
+    OI_UINT8 passwordLen;
+    /**
+     * user id of client
+     */
+    OI_BYTE userId[OI_OBEX_MAX_USERID_LEN];
+    OI_UINT8 userIdLen;
+    /**
+     * remote user id
+     */
+    OI_BYTE userIdRemote[OI_OBEX_MAX_USERID_LEN];
+    OI_UINT8 userIdRemoteLen;
+    /**
+     * realm
+     */
+    OI_OBEX_REALM realm;
+    /*
+     * indicates if server/client requires a user id in the authentication response.
+     */
+    OI_BOOL userIdRequired;
+    /*
+     * indicates if server/client was requested to provide a user id to establish an authorized connection
+     */
+    OI_BOOL userIdRequested;
+    /**
+     * nonce received in a challenge
+     */
+    OI_BYTE challengeDigest[OI_OBEX_AUTH_DIGEST_LEN];
+    /**
+     * nonce received in a response
+     */
+    OI_BYTE responseDigest[OI_OBEX_AUTH_DIGEST_LEN];
+    /**
+     * This is the buffer for sending an authentication response header. This is the entire
+     * header byte sequence, so we need two bytes for the authentication field tag and length
+     * and two bytes + the maximum user id length for the user id field.
+     */
+    OI_BYTE responseHeader[5 + OI_OBEX_AUTH_DIGEST_LEN + OI_OBEX_MAX_USERID_LEN];
+    /**
+     * This is the buffer for sending an authentication challenge header. This is the entire
+     * header byte sequence, so we need two bytes for the authentication field tag and length.
+     * three bytes for the option field, and 257 bytes for the realm
+     */
+    OI_BYTE challengeHeader[2 + OI_OBEX_AUTH_DIGEST_LEN + 3 + 257];
+
+} OBEX_AUTHENTICATION;
+
+
+typedef struct {
+
+    /**
+     * Pointer to the lower level protocol connection
+     */
+    OI_OBEX_LOWER_CONNECTION lowerConnection;
+    /**
+     * Connection handle exposed to upper layer
+     */
+    OI_OBEX_CONNECTION_HANDLE connectionHandle;
+    /**
+     * mbuf for sending packets.
+     */
+    OI_MBUF *mbuf;
+    /**
+     * Small buffer for composing the packet headers and simple response
+     * packets.
+     */
+    OI_BYTE hdrBuf[OI_OBEX_HDR_BUFSIZE];
+    /**
+     * Are we authenticating connections?
+     */
+    OI_UINT8 authenticating;
+    /**
+     * indicates read-only access is being granted by server.
+     */
+    OI_UINT8 readOnly;
+    /**
+     * maintains state during OBEX authentication
+     */
+    OBEX_AUTHENTICATION *authentication;
+    /**
+     * Single Response mode flags
+     */
+    OI_UINT8 srm;
+    /**
+     * Single response mode parameter for the current operation
+     */
+    OI_UINT8 srmParam;
+    /**
+     * flag indicating if srmp is valid or not
+     */
+    OI_BOOL srmpValid;
+    /**
+     * flag indicating if srmpWait is received from remote device
+     */
+    OI_BOOL srmpWaitReceived;
+    /**
+     * maximum packet size we can receive (based on configuration parameter)
+     */
+    OI_UINT16 maxRecvPktLen;
+    /**
+     * maximum packet size we can send (negotiated at connect time)
+     */
+    OI_UINT16 maxSendPktLen;
+    /**
+     * opcode for the current operation.
+     */
+    OI_UINT8 currentOpcode;
+    /**
+     * body header that had to be segmented because it would not fit in one
+     * packet.
+     */
+    OI_OBEX_HEADER bodySegment;
+    /**
+     * current PUT/GET progress
+     */
+    OI_UINT32 progressBytes;
+    /**
+     * raw received headers, only available during callbacks.
+     */
+    OI_OBEX_HEADER_LIST *pRawHeaders;
+
+} OBEX_COMMON;
+
+
+/**
+ * Type definition for bulk data blocks passed to OI_OBEXCOMMON_SendBulk().
+ */
+typedef struct OBEX_BULK_DATA *OBEX_BULK_DATA_LIST;
+
+
+/**
+ * Structure definition for data blocks passed to OI_OBEXCOMMON_SendBulk().
+ */
+struct OBEX_BULK_DATA {
+    OI_UINT8 *blockBuffer;            /* The bulk data block buffer */
+    OI_UINT32 blockSize;              /* Size of the bulk data block */
+    OI_UINT32 bytesSent;              /* Number of bytes that have been sent */
+    OI_UINT32 bytesConfirmed;         /* Number of bytes that have been confirmed */
+    OBEX_BULK_DATA_LIST next;         /* Forms a linked list of written but no confirmed bulk data blocks */
+    OI_BOOL final;                    /* TRUE if this is the final block for the put transation */
+};
+
+/**
+ * This function initializes and opens a byte stream for composing a generic OBEX packet.
+ *
+ * @param common   pointer to common OBEX connection information
+ *
+ * @param opcode   the OBEX command or response code
+ *
+ * @param pkt      pointer to byte stream to be initialized
+ */
+void OI_OBEXCOMMON_InitPacket(OBEX_COMMON *common,
+                              OI_UINT8 opcode,
+                              OI_BYTE_STREAM *pkt);
+
+
+/**
+ * This function marshals OBEX headers into common->mbuf ready for sending as series
+ * of lower layer packets.
+ *
+ * @param common     pointer to common OBEX connection information
+ *
+ * @param pktHdr     byte stream previously initialized by
+ *                   OI_OBEXCOMMON_InitPacket()
+ *
+ * @param hdrs       OBEX headers to be marshaled.
+ *
+ * @param hdrCount   how many headers.
+ *
+ * @param hdrList    list of headers provided by application.
+ *
+ * @return           OI_OK or OI_STATUS_OUT_OF_MEMORY
+ */
+OI_STATUS OI_OBEXCOMMON_MarshalPacket(OBEX_COMMON *common,
+                                      OI_BYTE_STREAM *pktHdr,
+                                      OI_OBEX_HEADER *hdrs,
+                                      OI_UINT16 hdrCount,
+                                      OI_OBEX_HEADER_LIST const *hdrList);
+
+/**
+ * This function is identical to OI_OBEXCOMMON_MarshalPacket() except that
+ * pointer to marshalled mbuf is returned to caller rather than placed
+ * directly into common->mbuf.
+ *
+ * @param common     pointer to common OBEX connection information
+ *
+ * @param pktHdr     byte stream previously initialized by
+ *                   OI_OBEXCOMMON_InitPacket()
+ *
+ * @param hdrs       OBEX headers to be marshaled.
+ *
+ * @param hdrCount   how many headers.
+ *
+ * @param hdrList    list of headers provided by application.
+ *
+ * @param mbuf       caller's pointer where this function will return pointer
+ *                   to mbuf containing marshalled packet.  Undefined if return
+ *                   status is not successful.
+ *
+ * @return           OI_OK or OI_STATUS_OUT_OF_MEMORY
+ */
+OI_STATUS OI_OBEXCOMMON_MarshalPacketMbuf(OBEX_COMMON       *common,
+                                          OI_BYTE_STREAM    *pktHdr,
+                                          OI_OBEX_HEADER    *hdrs,
+                                          OI_UINT16         hdrCount,
+                                          OI_OBEX_HEADER_LIST const *hdrList,
+                                          OI_MBUF           **mbuf);
+
+
+
+/**
+ * This function marshals bulk data into one or more OBEX packets depending on whether
+ * single-response mode is enabled or not.
+ *
+ * @param common     A pointer to common OBEX connection information
+ *
+ * @param bulkData   The current the bulk data list to send.
+ *
+ * @param busy       If TRUE indicates that bulk sends cannot be performed now.
+ *
+ * @param final      Returns TRUE if we completely put the final bulk data block
+ */
+OI_STATUS OI_OBEXCOMMON_SendBulk(OBEX_COMMON *common,
+                                 OBEX_BULK_DATA_LIST *bulkData,
+                                 OI_BOOL *busy,
+                                 OI_BOOL *final);
+
+
+/**
+ * Allocate and initialize a linked list of bulk data blocks
+ *
+ * @param numBuffer        The number of bulk data blocks to allocate
+ *
+ * @param bulkDataBuffer   An array of bulk data buffers
+ *
+ * @param bufferLength     An array of lengths for the bulk data buffers
+ *
+ * @param bulkDataHead     Returns the head of the allocated bulk data list
+ *
+ * @param bulkDataTail     Returns the tail of the allocated bulk data list
+ */
+OI_STATUS OI_OBEXCOMMON_AllocBulkData(OI_UINT8 numBuffers,
+                                      OI_UINT8 *bulkDataBuffer[],
+                                      OI_UINT32 bufferLength[],
+                                      OBEX_BULK_DATA_LIST *bulkDataHead,
+                                      OBEX_BULK_DATA_LIST *bulkDataTail);
+
+
+/**
+ * Free a bulk data list
+ */
+void OI_OBEXCOMMON_FreeBulkData(OBEX_BULK_DATA_LIST list);
+
+
+/**
+ * This function marshals segmented body headers.
+ *
+ * @param common     A pointer to common OBEX connection information
+ *
+ */
+OI_STATUS OI_OBEXCOMMON_MarshalBodySegment(OBEX_COMMON *common);
+
+
+/**
+ * Send a simple OBEX packet - just an opcode with no headers
+ *
+ * @param common     A pointer to common OBEX connection information
+ *
+ * @param opcode     The opcode to send
+ */
+
+OI_STATUS OI_OBEXCOMMON_SendSimple(OBEX_COMMON *common,
+                                   OI_UINT8 opcode);
+/**
+ * Send an OBEX OK response packet.
+ *
+ * @param common     A pointer to common OBEX connection information
+ */
+#define OI_OBEXCOMMON_SendOk(common) \
+    OI_OBEXCOMMON_SendSimple((common), OI_OBEX_FINAL(OI_OBEX_RSP_OK))
+
+
+/**
+ * Send an OBEX CONTINUE response packet.
+ *
+ * @param common     A pointer to common OBEX connection information
+ */
+#define OI_OBEXCOMMON_SendContinue(common) \
+    OI_OBEXCOMMON_SendSimple((common), OI_OBEX_FINAL(OI_OBEX_RSP_CONTINUE))
+
+
+/**
+ * Header overhead for a bulk PUT request issued by an OBEX client
+ */
+#define BULK_PUT_HDR_SIZE (sizeof(OI_UINT16) + sizeof(OI_UINT8) + sizeof(OI_UINT16) + sizeof(OI_UINT8))
+
+
+/**
+ * Header overhead for a bulk GET response issued by an OBEX server
+ */
+#define BULK_GET_HDR_SIZE (sizeof(OI_UINT16) + sizeof(OI_UINT8) + sizeof(OI_UINT16) + sizeof(OI_UINT8))
+
+
+/**
+ * Data received from an OBEX server.
+ */
+
+OI_STATUS OI_OBEXCOMMON_ReassemblePacket(OBEX_COMMON *common,
+                                         OI_BYTE *dataBuf,
+                                         OI_UINT16 dataLen);
+
+
+/**
+ * Returns the size in bytes that the headers will occupy in an OBEX packet.
+ */
+OI_UINT16 OI_OBEXCOMMON_HeaderListSize(const OI_OBEX_HEADER_LIST *headers);
+
+
+/**
+ * Get all headers.
+ */
+OI_STATUS OI_OBEXCOMMON_ParseHeaderList(OBEX_COMMON *common,
+                                        OI_OBEX_HEADER_LIST *headers,
+                                        OI_BYTE_STREAM *bs);
+
+/**
+ * Remove a specific header form the header list and free any memory allocated for the header.
+ *
+ * @param headerList    The header list.
+ *
+ * @poaram headerId     The header id of the header to to remove from the header list.
+ */
+OI_STATUS OI_OBEXCOMMON_DeleteHeaderFromList(OI_OBEX_HEADER_LIST *headerList,
+                                             OI_UINT8 headerId);
+
+
+/**
+ * Builds an application paramers header based on a list of elements. The caller
+ * is responsible for calling OI_Free(data->data) when it is finished with this
+ * information. The underlying application parameter entry list data is not
+ * affected by this operation.
+ */
+OI_STATUS OI_OBEXCOMMON_BuildAppParamsHeader(OI_OBEX_BYTESEQ *data,
+                                             const OI_OBEX_APP_PARAM_LIST *params);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OBEXCOMMON_H */
+
diff --git a/obex_profiles/profiles/opp/oi_opp_common.h b/obex_profiles/profiles/opp/oi_opp_common.h
new file mode 100644
index 0000000..d109d4f
--- /dev/null
+++ b/obex_profiles/profiles/opp/oi_opp_common.h
@@ -0,0 +1,71 @@
+#ifndef _OPPCOMMON_H
+#define _OPPCOMMON_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+Object Push Profile common definitions and functions
+*/
+
+#include "oi_status.h"
+#include "oi_obexspec.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * struct for describing a generic OBEX object. The struct may contain a
+ * complete object or partial object data.
+ */
+typedef struct {
+    OI_OBEX_UNICODE name;     /**< Unicode name of the object */
+    OI_OBEX_BYTESEQ type;     /**< NULL-terminated ASCII type for the object */
+    OI_UINT32 objSize;        /**< total size of the object */
+    OI_OBEX_BYTESEQ objData;  /**< object data */
+} OI_OPP_GENERIC_OBJECT;
+
+OI_STATUS OPPCommon_ParseHeaders(OI_OPP_GENERIC_OBJECT *obj,
+                                 OI_OBEX_HEADER_LIST *headers);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OPPCOMMON_H */
+
+/**@}*/
diff --git a/obex_profiles/profiles/opp/oi_opp_test.h b/obex_profiles/profiles/opp/oi_opp_test.h
new file mode 100644
index 0000000..b01ad1d
--- /dev/null
+++ b/obex_profiles/profiles/opp/oi_opp_test.h
@@ -0,0 +1,72 @@
+#ifndef _OPP_TEST_H
+#define _OPP_TEST_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "oi_stddefs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef OI_TEST_HARNESS
+
+/**
+ * OPP Test Names. Used to trigger test behavior for qualification testing.
+ */
+typedef enum {
+    TEST_OPP_NONE = 0,
+    TEST_OPP_MISSING_SERVER_PULL_HEADER
+} OI_OPP_TESTNAME;
+
+/**
+ * Set the current OPP test
+ */
+void OI_OPP_SetTestName(OI_OPP_TESTNAME testname);
+
+/**
+ * Get the current OPP test
+ */
+OI_OPP_TESTNAME OI_OPP_GetTestName(void);
+
+/*
+ * Init the test param
+ */
+OI_STATUS OI_OPP_Test_Init(void);
+
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OPP_TEST_H */
diff --git a/obex_profiles/profiles/opp/opp_client.c b/obex_profiles/profiles/opp/opp_client.c
new file mode 100644
index 0000000..fa5c44e
--- /dev/null
+++ b/obex_profiles/profiles/opp/opp_client.c
@@ -0,0 +1,1426 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+Object Push Client
+*/
+
+#define __OI_MODULE__ OI_MODULE_OPP_CLI
+
+#include "oi_bt_assigned_nos.h"
+#include "oi_memmgr.h"
+#include "oi_obexcli.h"
+#include "oi_opp_client.h"
+#include "oi_opp_common.h"
+#include "oi_dispatch.h"
+
+#include "oi_utils.h"
+#include "oi_debug.h"
+#include "oi_argcheck.h"
+#include "oi_assert.h"
+
+#include "oi_init_flags.h"
+#include "oi_config_table.h"
+#include "oi_bt_profile_config.h"
+
+
+/**
+ * These are the various client connection states.
+ */
+
+typedef enum {
+    CLIENT_STATE_DISCONNECTED,      /**< Initial state */
+    CLIENT_STATE_CONNECTING,        /**< In the process of creating service-level connection */
+    CLIENT_STATE_CONNECTED,         /**< Connected, no operations in progress */
+    CLIENT_STATE_PUSH_PENDING,      /**< Waiting on OFS read open confirm before starting 1st PUT */
+    CLIENT_STATE_PUSHING,           /**< Putting an object */
+    CLIENT_STATE_PULL_PENDING,      /**< From issuing 1st get until OFS write open confirm is called */
+    CLIENT_STATE_PULLING            /**< While getting and OFS writing */
+} OPP_CLIENT_STATE;
+
+
+typedef enum {
+    OPP_NO_ABORT,
+    OPP_ABORT_SENT,
+    OPP_ABORT_CONFIRMED
+} OPP_ABORT_STATE;
+
+/**
+ * Struct for an OPP client connection.
+ */
+
+typedef struct {
+
+    OI_OPP_GENERIC_OBJECT curObj;           /**< Keeps track of received object state */
+    OI_OBEXCLI_CONNECTION_HANDLE id;        /**< The underlying OBEX client connection */
+    OI_OPP_CLIENT_EVENT_CB eventCB;         /**< Callback function to report operation completion */
+    OI_OPP_CLIENT_CANCEL_CFM cancelCfm;     /**< Callback function to report operation cancellation completion */
+    const OI_OPP_OBJSYS_FUNCTIONS *objops;  /**< Interface to an object filing system */
+    OI_OPP_HANDLE handle;                   /**< The handle for object operations */
+    OI_UINT32 maxReadSize;                  /**< Maximum packet read size */
+    DISPATCH_CB_HANDLE pendingClose;        /**< Close operation that has been registered with the dispatcher */
+    OPP_CLIENT_STATE state;                 /**< State of this connection */
+    OPP_ABORT_STATE abortState;
+    OI_BOOL  final;                         /**< Indicates if this is a final packet */
+    OI_BOOL  ofsCfmPending;                 /**< Waiting for Object File System to call our cfm function */
+    OI_BOOL  disconnected;                  /**< Received disconnect indication, waiting to call event callback. */
+    OI_BOOL  nameOverrideEnabled;           /**< Require Name Override <default: FALSE> */
+    OI_BOOL  nameOverridePending;           /**< Required Name Override pending */
+    OI_BOOL  pullStarted;                   /**< Status to be reported on closing an object */
+    OI_STATUS closeStatus;
+
+} OPP_CLIENT;
+
+static void AbortCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId);
+
+static void DeferredPushOpenCfm(OI_OPP_HANDLE handle,
+                               const OI_OBEX_UNICODE *name,
+                               const OI_CHAR *type,
+                               OI_UINT32 size,
+                               OI_BYTE * data,
+                               OI_UINT16 data_len,
+                               OI_STATUS status,
+                               OI_OPP_CONNECTION oppContext);
+
+#define LookupClient(handle)   ((OPP_CLIENT*)OI_OBEXCLI_GetConnectionContext(handle))
+
+
+#define IS_CLIENT_CONNECTED(client)   ((client) && (client->state >= CLIENT_STATE_CONNECTED))
+#define IS_CLIENT_CONNECTING(client)  ((client) && (client->state == CLIENT_STATE_CONNECTING))
+#define IS_CLIENT_IDLE(client)        ((client) && (client->state == CLIENT_STATE_CONNECTED) && (client->abortState == OPP_NO_ABORT))
+
+/**
+ * Connection policy.
+ */
+static const OI_CONNECT_POLICY  connectPolicy =
+{
+    OI_ELEMENT_UUID32(OI_UUID_OBEXObjectPush), /* OI_DATAELEM         serviceUuid          */
+    FALSE,                                     /* OI_BOOL             mustBeMaster         */
+    NULL,                                      /* OI_L2CAP_FLOWSPEC   *flowspec            */
+    0                                          /* OI_UINT8            powerSavingDisables  */
+};
+
+
+#define OI_CASE(a) case a: return(#a);
+
+
+OI_CHAR *OI_OPPClient_eventText(OI_OPP_CLIENT_EVENT event)
+{
+#ifdef OI_DEBUG
+    switch (event) {
+        OI_CASE(OI_OPP_CLIENT_CONNECTED);
+        OI_CASE(OI_OPP_CLIENT_DISCONNECT);
+        OI_CASE(OI_OPP_CLIENT_PUSH_STARTED);
+        OI_CASE(OI_OPP_CLIENT_PULL_STARTED);
+        OI_CASE(OI_OPP_CLIENT_PUSH_PROGRESS);
+        OI_CASE(OI_OPP_CLIENT_PULL_PROGRESS);
+        OI_CASE(OI_OPP_CLIENT_PUSH_COMPLETE);
+        OI_CASE(OI_OPP_CLIENT_PULL_COMPLETE);
+    }
+    return "unknown event";
+#else
+    return "";
+#endif      /* OI_DEBUG */
+}
+
+#ifdef OI_DEBUG
+static OI_CHAR* ClientStateText(OPP_CLIENT_STATE state)
+{
+    switch (state) {
+        OI_CASE(CLIENT_STATE_DISCONNECTED);
+        OI_CASE(CLIENT_STATE_CONNECTING);
+        OI_CASE(CLIENT_STATE_CONNECTED);
+        OI_CASE(CLIENT_STATE_PUSH_PENDING);
+        OI_CASE(CLIENT_STATE_PUSHING);
+        OI_CASE(CLIENT_STATE_PULL_PENDING);
+        OI_CASE(CLIENT_STATE_PULLING);
+    }
+    return "unknown state";
+}
+#else
+#define ClientStateText(state)  ("")
+#endif  /* OI_DEBUG */
+
+
+#define SetState(client, newState) \
+    do { \
+        OI_DBGPRINT(("Client state %s ==> %s", ClientStateText((client)->state), ClientStateText(newState))); \
+        (client)->state = (newState); \
+    } while (0)
+
+
+
+
+/*********************** FORWARD DEFINITIONS ***************************/
+
+static void ClientPutCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                         OI_OBEX_HEADER_LIST *rspHeaders,
+                         OI_STATUS status);
+
+static void ClientBulkPutCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                             OI_UINT8 numBuffers,
+                             OI_UINT8 *bulkDataBuffer[],
+                             OI_UINT32 bufferLen[],
+                             OI_STATUS status);
+
+static void CloseObject(OPP_CLIENT *client,
+                        OI_STATUS status);
+
+
+static void PullWriteCfm(OI_OPP_HANDLE handle,
+                         OI_STATUS status,
+                         OI_OPP_CONNECTION oppContext);
+
+
+
+/******************* END OF FORWARD DEFINITIONS ************************/
+
+
+static void ClientConnectCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                             OI_BOOL readOnly, /* not used for OPP */
+                             OI_STATUS status)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    OI_OPP_CLIENT_EVENT_DATA    evt;
+    OI_OPP_CLIENT_EVENT_CB      cbSv;
+
+    OI_DBGTRACE(("ClientConnectCfm %d, id = %d", status, connectionId));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    OI_ASSERT(connectionId == client->id);
+
+    cbSv = client->eventCB;
+    OI_MemZero(&evt, sizeof(evt));
+    evt.event = OI_OPP_CLIENT_CONNECTED;
+
+    if (OI_SUCCESS(status)) {
+        OI_L2CAP_CID cid;
+        OI_DBGPRINT2(("OPP client connected"));
+        SetState(client, CLIENT_STATE_CONNECTED);
+        /*
+         * Establish the maximum read size for object read operations.
+         */
+        client->maxReadSize = OI_OBEXCLI_OptimalBodyHeaderSize(connectionId);
+        cbSv(connectionId, &evt, OI_OK);
+        /*
+         * Register connection with the AMP policy manager
+         */
+        status = OI_OBEXCLI_GetL2capCID(connectionId, &cid);
+    } else {
+        SetState(client, CLIENT_STATE_DISCONNECTED);
+        cbSv(connectionId, &evt, status);
+        OI_Free(client);
+    }
+}
+
+
+static void ClientDisconnectInd(OI_OBEXCLI_CONNECTION_HANDLE connectionId)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+
+    OI_DBGTRACE(("ClientDisconnectInd, id = %d", connectionId));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    /*
+     * record the disconnect event for subsequent processes
+     */
+    client->disconnected = TRUE;
+
+    /*
+     * If close is already pending, just call it now
+     */
+    if (client->pendingClose) {
+        OI_DBGPRINT2(("Disconnect : calling close immediately"));
+        OI_Dispatch_CallFunc(client->pendingClose);
+        /*
+         * The client object has (hopefully) been freed by the pendingClose().
+         * Disconnect has been handled completely.
+         */
+        return;
+    }
+    if (client->ofsCfmPending) {
+        /*
+         * We're waiting for an OFS confirm callback, just have to keep waiting
+         */
+    } else {
+        /*
+         * Status to be reported to OFS and app depends on whether we're idle or pushing/pulling
+         */
+        CloseObject(client, client->state > CLIENT_STATE_CONNECTED? OI_OBEX_NOT_CONNECTED : OI_OK);
+        OI_Dispatch_CallFunc(client->pendingClose);
+    }
+}
+
+
+static void ClientProgressInd(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                              OI_UINT8 cmd,
+                              OI_UINT32 progress)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    if (client) {
+        OI_OPP_CLIENT_EVENT_DATA evt;
+
+        OI_DBGPRINT(("%s progress %d", cmd == OI_OBEX_CMD_PUT ? "PUT" : "GET", progress));
+
+        OI_MemZero(&evt, sizeof(OI_OPP_CLIENT_EVENT_DATA));
+        evt.event = (cmd == OI_OBEX_CMD_PUT) ? OI_OPP_CLIENT_PUSH_PROGRESS : OI_OPP_CLIENT_PULL_PROGRESS;
+        evt.data.pushProgress.bytesTransferred = progress;
+        client->eventCB(client->id, &evt, OI_OK);
+    }
+}
+
+
+/**
+ * Connect to remote OBEX object push profile server.
+ */
+
+OI_STATUS OI_OPPClient_Connect(OI_BD_ADDR *addr,
+                               OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                               OI_OPP_CLIENT_CONNECTION_HANDLE *connectionId,
+                               OI_OPP_CLIENT_EVENT_CB eventCB,
+                               const OI_OPP_OBJSYS_FUNCTIONS *objectFunctions)
+{
+    static const OI_OBEXCLI_CB_LIST callbacks = {
+        ClientConnectCfm,
+        ClientDisconnectInd,
+        NULL, /* no authentication challenge */
+        ClientProgressInd,
+        ClientBulkPutCfm
+    };
+    OPP_CLIENT *client;
+    OI_STATUS status;
+    OI_OBEX_CONNECTION_OPTIONS connOpts;
+
+    OI_DBGTRACE(("OI_OPPClient_Connect addr:%: %s connectionId:%x", addr, OI_OBEX_LowerProtocolTxt(lowerProtocol), connectionId));
+
+    OI_ARGCHECK(eventCB && objectFunctions);
+    OI_ARGCHECK(objectFunctions->OpenRead);
+    OI_ARGCHECK(objectFunctions->Read);
+    OI_ARGCHECK(objectFunctions->OpenWrite);
+    OI_ARGCHECK(objectFunctions->Write);
+    OI_ARGCHECK(objectFunctions->Close);
+
+    client = OI_Calloc(sizeof(OPP_CLIENT));
+    if (client == NULL) {
+        return OI_STATUS_NO_RESOURCES;
+    }
+    client->eventCB = eventCB;
+    client->objops = objectFunctions;
+    /*
+     * We allow SRM for OPP
+     */
+    connOpts.enableSRM = TRUE;
+    status = OI_OBEXCLI_Connect(addr,
+                                lowerProtocol,
+                                &connOpts,
+                                OI_OBEXCLI_AUTH_NONE,
+                                NULL,
+                                &callbacks,
+                                connectionId,
+                                &connectPolicy);
+
+    if (OI_SUCCESS(status)) {
+        client->id = *connectionId;
+        /*
+         * Associate OPP client connection with the OBEX connection
+         */
+        status = OI_OBEXCLI_SetConnectionContext(client->id, client);
+        OI_ASSERT(OI_SUCCESS(status));
+        SetState(client, CLIENT_STATE_CONNECTING);
+    } else {
+        OI_Free(client);
+        OI_SLOG_ERROR(status, ("OI_OBEXCLI_Connect failed"));
+    }
+    return status;
+}
+
+
+OI_STATUS OI_OPPClient_Disconnect(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    OI_STATUS status;
+
+    OI_DBGTRACE(("OI_OPPClient_Disconnect, id %d", connectionId));
+
+    if (IS_CLIENT_CONNECTING(client)) {
+        OI_DBGPRINT(("Connecting"));
+        return OI_OBEX_CONNECT_IN_PROGRESS;
+    }
+    if (!IS_CLIENT_CONNECTED(client)) {
+        OI_DBGPRINT(("Not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    status = OI_OBEXCLI_Disconnect(client->id, NULL);
+    if (!OI_SUCCESS(status)) {
+        OI_DBGPRINT(("OI_OBEXCLI_Disconnect failed (%d)", status));
+    }
+    return status;
+}
+
+
+static void CloseObjectCB(DISPATCH_ARG *darg)
+{
+    OPP_CLIENT *client = LookupClient(Dispatch_GetArg(darg, OI_OPP_CLIENT_CONNECTION_HANDLE));
+    OI_STATUS status;
+    OI_OPP_CLIENT_EVENT_DATA evt;
+    OPP_CLIENT_STATE snapState;
+
+    if (!client) {
+        OI_LOG_ERROR(("CloseObject - client has gone"));
+        return;
+    }
+
+    snapState = client->state;
+    client->pendingClose = 0;
+    client->nameOverridePending = FALSE;
+
+    /*
+     * Confirm is not pending
+     */
+    client->ofsCfmPending = FALSE;
+
+    /*
+     * Reset state before calling event callback in case the callback function
+     * calls right back into OPP.
+     */
+    client->final = FALSE;
+    if (client->disconnected) {
+        SetState(client, CLIENT_STATE_DISCONNECTED);
+    } else if (client->state > CLIENT_STATE_CONNECTED) {
+        SetState(client, CLIENT_STATE_CONNECTED);
+    }
+    if (client->abortState != OPP_NO_ABORT) {
+        status = OI_OBEX_CLIENT_ABORTED_COMMAND;
+    } else {
+        status = client->closeStatus;
+    }
+
+    switch (snapState) {
+    case CLIENT_STATE_PUSHING:
+        client->objops->Close(client->handle, status, (OI_OPP_CONNECTION) client->id);
+        /* falling through */
+    case CLIENT_STATE_PUSH_PENDING:
+        evt.event = OI_OPP_CLIENT_PUSH_COMPLETE;
+        evt.data.pushComplete.finalSize = client->curObj.objSize;
+        client->eventCB(client->id, &evt, status);
+        break;
+    case CLIENT_STATE_PULLING:
+        client->objops->Close(client->handle, status, (OI_OPP_CONNECTION) client->id);
+        /* falling through */
+    case CLIENT_STATE_PULL_PENDING:
+        evt.event = OI_OPP_CLIENT_PULL_COMPLETE;
+        evt.data.pullComplete.finalSize = client->curObj.objSize;
+        client->eventCB(client->id, &evt, status);
+        break;
+    default:
+        break;
+    }
+    /*
+     * Free any saved header data.
+     */
+    OI_FreeIf(&client->curObj.name.str);
+    client->curObj.name.len = 0;
+    OI_FreeIf(&client->curObj.type.data);
+    client->curObj.type.len = 0;
+    OI_MemZero(&client->curObj, sizeof(OI_OPP_GENERIC_OBJECT));
+    OI_MemZero(&evt, sizeof(OI_OPP_CLIENT_EVENT_DATA));
+    /*
+     * Confirm the abort if there was one
+     */
+    if (client->abortState == OPP_ABORT_CONFIRMED) {
+        SetState(client, CLIENT_STATE_CONNECTED);
+        client->cancelCfm(client->id);
+        client->cancelCfm = NULL;
+        client->abortState = OPP_NO_ABORT;
+    }
+    /*
+     * Report the disconnection and clean up
+     */
+    if (client->disconnected) {
+        OI_OPP_CLIENT_EVENT_DATA evt;
+        OI_MemZero(&evt, sizeof(OI_OPP_CLIENT_EVENT_DATA));
+        evt.event = OI_OPP_CLIENT_DISCONNECT;
+        client->eventCB((OI_OPP_CONNECTION) client->id, &evt, OI_OK);
+        OI_Free(client);
+    }
+}
+
+/*
+ * Put a callback function on the dispatcher to close the object.
+ */
+static void CloseObject(OPP_CLIENT *client,
+                        OI_STATUS status)
+{
+    if (!client->pendingClose) {
+        DISPATCH_ARG darg;
+        OI_DBGPRINT2(("CloseObject"));
+        client->closeStatus = status;
+        Dispatch_SetArg(darg, client->id);
+        (void) OI_Dispatch_RegisterFunc(CloseObjectCB, &darg, &client->pendingClose);
+    }
+}
+
+
+static void PushReadCfm(OI_OPP_HANDLE handle,
+                        OI_BYTE *data,
+                        OI_UINT32 len,
+                        OI_STATUS status,
+                        OI_OPP_CONNECTION oppContext)
+{
+    OPP_CLIENT *client = LookupClient(oppContext);
+    OI_STATUS obexStatus;
+
+    if (!client || (client->state != CLIENT_STATE_PUSHING) || !client->ofsCfmPending) {
+        OI_LOG_ERROR(("Push read confirm called at wrong time"));
+        return;
+    }
+
+    OI_DBGPRINT2(("PushReadCfm %d bytes %d", len, status));
+
+    /*
+     * Confirm is no longer pending
+     */
+    client->ofsCfmPending = FALSE;
+    /*
+     * Check for disconnect or abort that occurred during wait for this confirm.
+     */
+    if (client->disconnected || (client->abortState != OPP_NO_ABORT)) {
+        CloseObject(client, OI_OBEX_NOT_CONNECTED);
+        return;
+    }
+
+    if (status == OI_STATUS_END_OF_FILE) {
+        status = OI_OK;
+        obexStatus = OI_OK;
+    } else {
+        obexStatus = OI_OBEX_CONTINUE;
+    }
+    if (!OI_SUCCESS(status)) {
+        /*
+         * Let obex know the put operation terminated with an error.  The object will be closed
+         * when the ClientBulkPutCfm is called with failed status.
+         */
+        status = OI_OBEXCLI_BulkPut(client->id, 0, NULL, NULL, status);
+    } else {
+        status = OI_OBEXCLI_BulkPut(client->id, 1, &data, &len, obexStatus);
+    }
+    if (!OI_SUCCESS(status)) {
+        OI_DBGPRINT(("PushReadCfm closing object %d", status));
+        CloseObject(client, status);
+    }
+}
+
+
+static void ClientBulkPutCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                             OI_UINT8 numBuffers,
+                             OI_UINT8 *bulkDataBuffer[],
+                             OI_UINT32 bufferLen[],
+                             OI_STATUS status)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+
+    OI_DBGPRINT2(("OPP client bulk put confirm %d", status));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+
+    if (status == OI_OBEX_CONTINUE) {
+        if (client->final) {
+            /*
+             * We should not get a continue response after we have sent the
+             * final packet.
+             */
+            OI_LOG_ERROR(("OBEX incorrect continue reponse"));
+            status = OI_OBEX_INVALID_OPERATION;
+        } else {
+            /*
+             * Set pending first because the confirm may be called from within the OFS function
+             */
+            client->ofsCfmPending = TRUE;
+
+            status = client->objops->Read(client->handle, client->maxReadSize, PushReadCfm, (OI_OPP_CONNECTION) client->id);
+            if (status == OI_STATUS_END_OF_FILE) {
+                PushReadCfm(client->handle, NULL, 0, status, (OI_OPP_CONNECTION) client->id);
+                status = OI_OK;
+            }
+            if (!OI_SUCCESS(status)) {
+                /*
+                 * If OFS returns error, there is no pending confirm callback
+                 */
+                client->ofsCfmPending = FALSE;
+            }
+        }
+        if (!OI_SUCCESS(status)) {
+            /*
+             * Let obex know the put operation terminated with an error.
+             */
+            status = OI_OBEXCLI_BulkPut(client->id, 0, NULL, NULL, status);
+            CloseObject(client, status);
+        }
+    } else {
+        /*
+         * We are either done or got an error. If we have not send an ABORT
+         * we close the object, otherwise we wait for the ABORT confirmation.
+         */
+        if (client->abortState == OPP_NO_ABORT) {
+            /*
+             * We are either done or got an error, in either case we need to close
+             * the object.
+             */
+            client->ofsCfmPending = FALSE;
+            CloseObject(client, status);
+        }
+    }
+}
+
+
+static void ClientPutCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                         OI_OBEX_HEADER_LIST *rspHeaders,
+                         OI_STATUS status)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+
+    OI_DBGPRINT2(("OPP client put confirm %d", status));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    if (status == OI_OBEX_CONTINUE) {
+        if (client->final) {
+            /*
+             * We should not get a continue response after we have sent the
+             * final packet.
+             */
+            OI_LOG_ERROR(("OBEX incorrect continue reponse"));
+            status = OI_OBEX_INVALID_OPERATION;
+        } else {
+            /*
+             * Set pending first because the confirm may be called from within the OFS function
+             */
+            client->ofsCfmPending = TRUE;
+
+            status = client->objops->Read(client->handle, client->maxReadSize, PushReadCfm, (OI_OPP_CONNECTION) client->id);
+            if (status == OI_STATUS_END_OF_FILE) {
+                PushReadCfm(client->handle, NULL, 0, status, (OI_OPP_CONNECTION) client->id);
+                status = OI_OK;
+            }
+            if (!OI_SUCCESS(status)) {
+                /*
+                 * If OFS returns error, there is no pending confirm callback
+                 */
+                client->ofsCfmPending = FALSE;
+            }
+        }
+
+        if (!OI_SUCCESS(status)) {
+            /*
+             * Let obex know the put operation terminated with an error.
+             */
+            OI_OBEXCLI_Put(client->id, NULL, NULL, status);
+            CloseObject(client, status);
+        }
+    } else {
+        /*
+         * We are either done or got an error. If we have not send an ABORT
+         * we close the object, otherwise we wait for the ABORT confirmation.
+         */
+        if (client->abortState == OPP_NO_ABORT) {
+            client->ofsCfmPending = FALSE;
+            CloseObject(client, status);
+        }
+    }
+}
+
+
+static void PushOpenCfm(OI_OPP_HANDLE handle,
+                        const OI_OBEX_UNICODE *name,
+                        const OI_CHAR *type,
+                        OI_UINT32 size,
+                        OI_BYTE * data,
+                        OI_UINT16 data_len,
+                        OI_STATUS status,
+                        OI_OPP_CONNECTION oppContext)
+{
+    OPP_CLIENT *client = LookupClient(oppContext);
+
+    OI_DBGTRACE(("PushOpenCfm %d", status));
+
+    if (!client || (client->state != CLIENT_STATE_PUSH_PENDING) || !client->ofsCfmPending) {
+        OI_LOG_ERROR(("Push open confirm called at wrong time"));
+        return;
+    }
+
+    if (OI_SUCCESS(status)) {
+        OI_OPP_CLIENT_EVENT_DATA evt;
+
+        client->handle = handle;
+        client->curObj.objSize = size;
+        OI_MemZero(&evt, sizeof(OI_OPP_CLIENT_EVENT_DATA));
+        evt.event = OI_OPP_CLIENT_PUSH_STARTED;
+        evt.data.pushStarted.fileName = &client->curObj.name;
+        evt.data.pushStarted.totalBytes = size;
+        client->eventCB(client->id, &evt, OI_OK);
+    } else {
+        DeferredPushOpenCfm(handle, name, type, size, data, data_len, status, oppContext);
+    }
+}
+
+static void StripPath(OI_OBEX_UNICODE *name)
+{
+    OI_INT          i;
+    OI_INT          copyLength;
+    OI_OBEX_UNICODE tmpName;
+
+    if ((name == NULL) || (name->str == NULL)) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS,("StripPath"));
+        return;
+    }
+
+    tmpName = *name;
+    i = (OI_INT) tmpName.len;
+
+    while (--i >= 0) {
+        switch (tmpName.str[i]) {
+            /* There are 3 recognized File System Separators */
+        case ':':  /* Apple */
+        case '/':  /* Linux/Unix */
+        case '\\': /* Microsoft */
+            goto FoundDirSeparator;
+
+        default:
+            break;
+        }
+    }
+
+    return;
+
+FoundDirSeparator:
+    i++;
+    copyLength = (tmpName.len - i) * sizeof(OI_CHAR16);
+    if (copyLength) {
+        name->str = OI_Malloc(copyLength);
+        if (name->str) {
+            OI_MemCopy(name->str, &tmpName.str[i], copyLength);
+            name->len = (tmpName.len - i);
+            OI_DBGPRINT(("Strip Path for OBEX Name header: %?S --> %?S",
+                         tmpName.str, tmpName.len,
+                         name->str, name->len));
+            OI_Free(tmpName.str);
+        } else {
+            /* Malloc Failed.  Restore previous name */
+            OI_SLOG_ERROR(OI_STATUS_OUT_OF_MEMORY,("StripPath"));
+            *name = tmpName;
+        }
+    }
+}
+
+static void PushOpenCfmWithoutOverride(OI_OPP_HANDLE handle,
+                                       const OI_OBEX_UNICODE *name,
+                                       const OI_CHAR *type,
+                                       OI_UINT32 size,
+                                       OI_BYTE * data,
+                                       OI_UINT16 data_len,
+                                       OI_STATUS status,
+                                       OI_OPP_CONNECTION oppContext)
+{
+    OI_OPP_CLIENT_EVENT_DATA evt;
+    OPP_CLIENT *client = LookupClient(oppContext);
+
+    /*
+     * Notify the app that the push is starting.  The transfer will
+     * start immediately, since no NameOverride feedback is expected
+     * from the application.
+     */
+
+    OI_DBGTRACE(("PushOpenCfmWithoutOverride %d", status));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+
+    OI_MemZero(&evt, sizeof(OI_OPP_CLIENT_EVENT_DATA));
+    evt.event = OI_OPP_CLIENT_PUSH_STARTED;
+    evt.data.pushStarted.fileName = &client->curObj.name;
+    evt.data.pushStarted.totalBytes = size;
+    client->eventCB(client->id, &evt, status);
+
+    StripPath(&client->curObj.name);
+
+    /*
+     * Do the actual OpenCfm work.
+     */
+    DeferredPushOpenCfm(handle, &client->curObj.name, type, size, data, data_len,
+        status, oppContext);
+}
+
+static void DeferredPushOpenCfm(OI_OPP_HANDLE handle,
+                                const OI_OBEX_UNICODE *name,
+                                const OI_CHAR *type,
+                                OI_UINT32 size,
+                                OI_BYTE * data,
+                                OI_UINT16 data_len,
+                                OI_STATUS status,
+                                OI_OPP_CONNECTION oppContext)
+{
+    OPP_CLIENT *client = LookupClient(oppContext);
+    OI_UINT16 len;
+    OI_OBEX_HEADER hdrs[3];
+    OI_OBEX_HEADER_LIST hdrList;
+
+    OI_DBGTRACE(("DeferredPushOpenCfm %d", status));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    /*
+     * Confirm is no longer pending
+     */
+    client->ofsCfmPending = FALSE;
+    /*
+     * Check for disconnect or abort that occurred during wait for this confirm.
+     */
+    if (client->disconnected || (client->abortState != OPP_NO_ABORT)) {
+        if (OI_SUCCESS(status)) {
+            /*
+             * OFS reported a successful open, set state to PUSHING to trigger close() callback.
+             */
+            SetState(client, CLIENT_STATE_PUSHING);
+        }
+        CloseObject(client, OI_OBEX_NOT_CONNECTED);
+        return;
+    }
+
+    hdrList.list = hdrs;
+    hdrList.count = 0;
+
+    if (OI_SUCCESS(status) || status == OI_STATUS_END_OF_FILE) {
+        SetState(client, CLIENT_STATE_PUSHING);
+        client->handle = handle;
+        /*
+         * Send the initial object headers.
+         */
+        hdrs[hdrList.count].id = OI_OBEX_HDR_LENGTH;
+        hdrs[hdrList.count].val.length = size;
+        client->curObj.objSize = size;
+        ++hdrList.count;
+        hdrs[hdrList.count].id = OI_OBEX_HDR_NAME;
+        hdrs[hdrList.count].val.name = client->curObj.name;
+        ++hdrList.count;
+        /*
+         * Type header is optional
+         */
+        if (type != NULL) {
+            len = OI_StrLen(type);
+            if ( len > 0 ){
+                hdrs[hdrList.count].id = OI_OBEX_HDR_TYPE;
+                hdrs[hdrList.count].val.type.data = (OI_BYTE*) type;
+                hdrs[hdrList.count].val.type.len = len + 1; /* include null termination */
+                ++hdrList.count;
+            }
+        }
+        /*
+         * Body Header
+         */
+        if (data != NULL && data_len > 0) {
+            hdrs[hdrList.count].id = OI_OBEX_HDR_BODY;
+            hdrs[hdrList.count].val.body.data = (OI_BYTE*) data;
+            hdrs[hdrList.count].val.body.len = data_len;
+            ++hdrList.count;
+        }
+        status = OI_OBEXCLI_Put(client->id, &hdrList, ClientPutCfm,
+            (status == OI_STATUS_END_OF_FILE) ? OI_OK : OI_OBEX_CONTINUE);
+    }
+
+    if (!OI_SUCCESS(status)) {
+        CloseObject(client, status);
+    }
+}
+
+OI_STATUS OI_OPPClient_Push(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                            const OI_OBEX_UNICODE *name,
+                            const OI_CHAR *type)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    OI_STATUS status = OI_OK;
+
+    OI_DBGTRACE(("OI_OPPClient_Push, id %d", connectionId));
+
+    if (!IS_CLIENT_CONNECTED(client)) {
+        OI_DBGPRINT(("OPP client not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    if (!IS_CLIENT_IDLE(client)) {
+        OI_DBGPRINT(("Operation already in progress client state = %s", ClientStateText(client->state)));
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    client->final = FALSE;
+    SetState(client, CLIENT_STATE_PUSH_PENDING);
+
+    /*
+     * Set pending first because the confirm may be called from within the OFS function
+     */
+    client->ofsCfmPending = TRUE;
+
+    /*
+     * Duplicate file name into our mem space
+     */
+    OI_FreeIf(&client->curObj.name.str);
+    client->curObj.name.len = 0;
+    if (name && name->str) {
+        client->curObj.name.str = OI_Malloc(name->len * sizeof(OI_CHAR16));
+        if (client->curObj.name.str) {
+            client->curObj.name.len = name->len;
+            OI_MemCopy(client->curObj.name.str, name->str, name->len * sizeof(OI_CHAR16));
+        }
+    }
+
+    /*
+     * Duplicate type name into our mem space
+     */
+    OI_FreeIf(&client->curObj.type.data);
+    client->curObj.type.len = 0;
+    if (type) {
+        // Preserve the terminating null when allocating/copying
+        OI_UINT typeLen = OI_StrLen(type) + 1;
+        client->curObj.type.data = OI_Malloc(typeLen);
+        if (client->curObj.type.data) {
+            client->curObj.type.len = typeLen;
+            OI_MemCopy(client->curObj.type.data, type, typeLen);
+        }
+    }
+
+    /*
+     * If Name Override Enabaled, wait for App to supply name, otherwise use
+     * same filename for remote naming.
+     */
+    if (client->nameOverrideEnabled) {
+        client->nameOverridePending = TRUE;
+        status = client->objops->OpenRead(name, type, client->maxReadSize,
+            PushOpenCfm, (OI_OPP_CONNECTION) client->id);
+    } else {
+        status = client->objops->OpenRead(name, type, client->maxReadSize,
+            PushOpenCfmWithoutOverride, (OI_OPP_CONNECTION) client->id);
+    }
+
+    if (!OI_SUCCESS(status)) {
+        OI_DBGTRACE(("OI_OPPClient_Push failed: %d", status));
+        /*
+         * If the OFS OpenRead() call failed, there is no pending confirm.
+         * Set
+         */
+        client->ofsCfmPending = FALSE;
+        SetState(client, CLIENT_STATE_CONNECTED);
+    }
+
+    return status;
+}
+
+
+static void PullAbortCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    OI_DBGTRACE(("PullAbortCfm, id %d", connectionId));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+    } else {
+        CloseObject(client, OI_OBEX_OFS_ERROR);
+    }
+}
+
+
+static void GetRcvData(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                       OI_OBEX_HEADER_LIST *rspHeaders,
+                       OI_STATUS rcvStatus)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    OI_STATUS status = rcvStatus;
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    if (OI_SUCCESS(rcvStatus) || (rcvStatus == OI_OBEX_CONTINUE)) {
+        client->final = (rcvStatus == OI_OK);
+        status = OPPCommon_ParseHeaders(&client->curObj, rspHeaders);
+        if (OI_SUCCESS(status)) {
+            client->ofsCfmPending = TRUE;
+            status = client->objops->Write(client->handle,
+                                           client->curObj.objData.data,
+                                           client->curObj.objData.len,
+                                           PullWriteCfm,
+                                           (OI_OPP_CONNECTION) client->id);
+
+            client->curObj.objData.data = NULL;
+            client->curObj.objData.len = 0;
+            if (!OI_SUCCESS(status)) {
+                client->ofsCfmPending = FALSE;
+            }
+        }
+    }
+    if (!OI_SUCCESS(status)) {
+        CloseObject(client, status);
+    }
+}
+
+
+static void PullWriteCfm(OI_OPP_HANDLE handle,
+                         OI_STATUS status,
+                         OI_OPP_CONNECTION oppContext)
+{
+    OPP_CLIENT *client = LookupClient(oppContext);
+
+    if (!client || (client->state != CLIENT_STATE_PULLING) || !client->ofsCfmPending) {
+        OI_LOG_ERROR(("Pull write confirm called at wrong time"));
+        return;
+    }
+
+    OI_DBGPRINT2(("PullWriteCfm %d\n", status));
+
+    /*
+     * Confirm is no longer pending
+     */
+    client->ofsCfmPending = FALSE;
+    /*
+     * Check for disconnect or abort that occurred during wait for this confirm.
+     */
+    if (client->disconnected || (client->abortState != OPP_NO_ABORT)) {
+        CloseObject(client, OI_OBEX_NOT_CONNECTED);
+        return;
+    }
+    /*
+     * If we had not received the final packet call for more.
+     */
+    if (!client->final) {
+        if (!OI_SUCCESS(status)) {
+            /*
+             * Let OBEX know we are terminating the GET because of an error.
+             */
+            status = OI_OBEXCLI_Abort(client->id, PullAbortCfm);
+        } else {
+            status = OI_OBEXCLI_Get(client->id, NULL, GetRcvData, TRUE);
+        }
+    }
+    /*
+     * On error or when we are done pulling, close the object.
+     */
+    if (client->final || !OI_SUCCESS(status)) {
+        CloseObject(client, status);
+    }
+}
+
+
+/*
+ * Return first body header.
+ */
+static void FirstBodyHeader(DISPATCH_ARG *darg)
+{
+    OPP_CLIENT *client = LookupClient(Dispatch_GetArg(darg, OI_OPP_CLIENT_CONNECTION_HANDLE));
+    OI_STATUS status;
+
+    if (!client) {
+        OI_LOG_ERROR(("FirstBodyHeader - client has gone"));
+        return;
+    }
+    /*
+     * Set pending first because the confirm may be called from within the OFS function
+     */
+    client->ofsCfmPending = TRUE;
+
+    status = client->objops->Write(client->handle,
+                                   client->curObj.objData.data,
+                                   client->curObj.objData.len,
+                                   PullWriteCfm,
+                                   (OI_OPP_CONNECTION) client->id);
+    if (!OI_SUCCESS(status)) {
+        /*
+         * If OFS returns error, there is no pending confirm callback
+         */
+        client->ofsCfmPending = FALSE;
+    }
+
+    client->curObj.objData.data = NULL;
+    client->curObj.objData.len = 0;
+    if (!OI_SUCCESS(status)) {
+        CloseObject(client, status);
+    }
+}
+
+
+static void PullOpenCfm(OI_OPP_HANDLE handle,
+                        OI_STATUS status,
+                        OI_OPP_CONNECTION oppContext)
+{
+    OPP_CLIENT *client = LookupClient(oppContext);
+
+    if (!client || (client->state != CLIENT_STATE_PULL_PENDING) || !client->ofsCfmPending) {
+        OI_LOG_ERROR(("Pull open confirm called at wrong time"));
+        return;
+    }
+
+    OI_DBGPRINT2(("PullOpenCfm %d",status));
+
+    /*
+     * Confirm is no longer pending
+     */
+    client->ofsCfmPending = FALSE;
+    /*
+     * Check for disconnect or abort that occurred during wait for this confirm.
+     */
+    if (client->disconnected || (client->abortState != OPP_NO_ABORT)) {
+        if (OI_SUCCESS(status)) {
+            /*
+             * OFS reported a successful open, set state to PULLING to trigger close() callback.
+             */
+            SetState(client, CLIENT_STATE_PULLING);
+        }
+        CloseObject(client, OI_OBEX_NOT_CONNECTED);
+        return;
+    }
+
+    if (!OI_SUCCESS(status)) {
+        /*
+         * If the operation is not complete, let OBEX know we are terminating
+         * the GET because of an error.
+         */
+        if (!client->final) {
+            status = OI_OBEXCLI_Abort(client->id, PullAbortCfm);
+            if (!OI_SUCCESS(status)) {
+                /*
+                 * The abort failed, close the object terminating the current operation
+                 */
+                CloseObject(client, status);
+            }
+        } else {
+            /*
+             * On error when we are done pulling, close the object.
+             */
+            CloseObject(client, status);
+        }
+    } else {
+        DISPATCH_ARG darg;
+        SetState(client, CLIENT_STATE_PULLING);
+        client->handle = handle;
+        Dispatch_SetArg(darg, client->id);
+        (void) OI_Dispatch_RegisterFunc(FirstBodyHeader, &darg, NULL);
+    }
+}
+
+/*
+ * Confirm or Override the default name
+ */
+static OI_STATUS NameOverride(OPP_CLIENT            *client,
+                              const OI_OBEX_UNICODE *name)
+{
+    OI_OBEX_UNICODE tmpName = {0,NULL};
+    OI_STATUS       status = OI_OK;
+
+    switch (client->state) {
+    case CLIENT_STATE_PULL_PENDING:
+        status = client->objops->OpenWrite(name ? name : &client->curObj.name,
+                                           (OI_CHAR*) client->curObj.type.data,
+                                           client->curObj.objSize,
+                                           PullOpenCfm,
+                                           (OI_OPP_CONNECTION) client->id);
+        if (!OI_SUCCESS(status)) {
+            /*
+             * If OFS returns error, there is no pending confirm callback
+             */
+            client->ofsCfmPending = FALSE;
+        }
+        break;
+
+    case CLIENT_STATE_PUSH_PENDING:
+        /*
+         * On PUSH, if name is supplied, Save name for remote naming
+         * purposes only. Open original file specified for reading.
+         */
+        if (name && name->str && name->str[0]) {
+            /*
+             * Preserve Original File Name
+             */
+            tmpName.str = client->curObj.name.str;
+            tmpName.len = client->curObj.name.len;
+            client->curObj.name.str = OI_Malloc(name->len * sizeof(OI_CHAR16));
+            if (client->curObj.name.str) {
+                /*
+                 * Copy New File Name
+                 */
+                client->curObj.name.len = name->len;
+                OI_MemCopy(client->curObj.name.str, name->str, name->len * sizeof(OI_CHAR16));
+                OI_FreeIf(&tmpName.str);
+            } else {
+                /*
+                 * Malloc Failure: Use original name
+                 */
+                name = NULL;
+                client->curObj.name.str = tmpName.str;
+                tmpName.str = NULL;
+            }
+        } else {
+            StripPath(&client->curObj.name);
+        }
+
+        DeferredPushOpenCfm(client->handle,
+                            &client->curObj.name,
+                            (OI_CHAR *) client->curObj.type.data,
+                            client->curObj.objSize,
+                            NULL,
+                            0,
+                            OI_OK,
+                            client->id);
+
+        break;
+
+    default:
+        status = OI_STATUS_INVALID_STATE;
+        break;
+    }
+    return status;
+}
+
+static void GetRcv(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                   OI_OBEX_HEADER_LIST *rspHeaders,
+                   OI_STATUS rcvStatus)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    OI_STATUS status = rcvStatus;
+
+    OI_DBGTRACE(("GetRcv %d", rcvStatus));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+
+    if (OI_SUCCESS(rcvStatus) || (rcvStatus == OI_OBEX_CONTINUE)) {
+        client->final = (rcvStatus == OI_OK);
+        status = OPPCommon_ParseHeaders(&client->curObj, rspHeaders);
+        /*
+         * Wait until we have seen a body header before attempting to open the
+         * object.
+         */
+        if (client->final || (client->curObj.objData.data != NULL)) {
+
+            /* The IrMC OBEX spec and Bluetooth OPP spec disagree on whether
+             * the NAME header is required or not.  In the name of greatest
+             * compatibility, a NULL file name will be passed to the
+             * application for the application to deal with the issue.
+             */
+            if (client->curObj.name.str == NULL || client->curObj.name.len == 0 || client->curObj.name.str[0] == '\0') {
+                OI_LOG_ERROR(("Remote device failed to provide mandatory NAME header.\n"));
+            }
+
+            /*
+             * Set pending first because the confirm may be called from within the OFS function
+             */
+            client->ofsCfmPending = TRUE;
+
+            if (client->nameOverrideEnabled) {
+                client->nameOverridePending = TRUE;
+            } else {
+                /*
+                 * Use existing curObj name
+                 */
+                OI_DBGPRINT2(("internal NameOverride"));
+                status = NameOverride(client, NULL);
+            }
+
+            /*
+             * PULL_STARTED event must be sent after setting up for Name
+             * Overriding, because it may be invoked from callback
+             */
+            if (client->pullStarted == FALSE) {
+                OI_OPP_CLIENT_EVENT_DATA evt;
+
+                client->pullStarted = TRUE;
+                OI_MemZero(&evt, sizeof(OI_OPP_CLIENT_EVENT_DATA));
+                evt.event = OI_OPP_CLIENT_PULL_STARTED;
+                evt.data.pullStarted.fileName = &client->curObj.name;
+                evt.data.pullStarted.totalBytes = client->curObj.objSize;
+                /*
+                 * Alert App that Transfer Starting. App must call OI_OPPClient_NameOverride
+                 * if Name Overriding has been Enabled.
+                 */
+                client->eventCB(client->id, &evt, OI_OK);
+            }
+        } else {
+            status = OI_OBEXCLI_Get(client->id, NULL, GetRcv, TRUE);
+        }
+    }
+    if (!OI_SUCCESS(status)) {
+        CloseObject(client, status);
+    }
+}
+
+/*
+ * Confirm or Override the default name
+ */
+OI_STATUS OI_OPPClient_NameOverride(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                                    const OI_OBEX_UNICODE          *name)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    OI_STATUS status = OI_STATUS_INVALID_STATE;
+
+    OI_DBGTRACE(("OI_OPPClient_NameOverride"));
+    if (!IS_CLIENT_CONNECTED(client)) {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    if (client->nameOverridePending) {
+        client->nameOverridePending = FALSE;
+        status = NameOverride(client, name);
+    }
+    return status;
+}
+
+/*
+ * Pull the default object.
+ */
+
+OI_STATUS OI_OPPClient_Pull(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    static const OI_CHAR typeName[] = OI_OBEX_VCARD_TYPE;
+    OI_STATUS status;
+    OI_OBEX_HEADER hdr;
+    OI_OBEX_HEADER_LIST hdrList;
+
+    OI_DBGTRACE(("OI_OPPClient_Pull, id %d", connectionId));
+
+    if (!IS_CLIENT_CONNECTED(client)) {
+        OI_DBGPRINT(("OPP client not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    if (!IS_CLIENT_IDLE(client)) {
+        OI_DBGPRINT(("Operation already in progress client state = %s", ClientStateText(client->state)));
+        return OI_OBEX_OPERATION_IN_PROGRESS;
+    }
+    client->final = FALSE;
+    client->pullStarted = FALSE;
+    SetState(client, CLIENT_STATE_PULL_PENDING);
+
+    /*
+     * There is only one header required for pulling the default object. A type
+     * header initialized to the vcard type string.
+     */
+    hdr.id = OI_OBEX_HDR_TYPE;
+    hdr.val.type.data = (OI_BYTE*) typeName;
+    hdr.val.type.len = OI_ARRAYSIZE(typeName);
+
+    hdrList.list = &hdr;
+    hdrList.count = 1;
+    status = OI_OBEXCLI_Get(client->id, &hdrList, GetRcv, TRUE);
+
+    if (!OI_SUCCESS(status)) {
+        SetState(client, CLIENT_STATE_CONNECTED);
+    }
+    return status;
+}
+
+
+
+static void AbortCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+
+    OI_DBGPRINT(("AbortCfm connectionId:%#x", connectionId));
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    if (client->abortState != OPP_ABORT_SENT) {
+        OI_DBGPRINT(("Did not expect AbortCfm callback"));
+        return;
+    }
+    client->abortState = OPP_ABORT_CONFIRMED;
+    CloseObject(client, OI_OBEX_CLIENT_ABORTED_COMMAND);
+    OI_Dispatch_CallFunc(client->pendingClose);
+}
+
+
+OI_STATUS OI_OPPClient_Cancel(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                              OI_OPP_CLIENT_CANCEL_CFM cancelCfm)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+    OI_STATUS status;
+
+    OI_DBGTRACE(("OI_OPPClient_Cancel connectionId:%#x", connectionId));
+
+    if (!IS_CLIENT_CONNECTED(client)) {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    if (IS_CLIENT_IDLE(client)) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+
+    OI_DBGPRINT(("OI_OPPClient_Cancel, state %s", ClientStateText(client->state)));
+
+    status = OI_OBEXCLI_Abort(client->id, AbortCfm);
+    if (OI_SUCCESS(status)) {
+        client->abortState = OPP_ABORT_SENT;
+        client->cancelCfm = cancelCfm;
+    } else {
+        /*
+         * Abort attempt resulted in some error.
+         */
+        OI_SLOG_ERROR(status, ("OI_OBEXCLI_Abort failed"));
+        CloseObject(client, OI_OBEX_CLIENT_ABORTED_COMMAND);
+    }
+    return status;
+}
+
+OI_STATUS OI_OPPClient_EnableNameOverride(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                                          OI_BOOL                         nameOverrideEnabled)
+{
+    OPP_CLIENT *client = LookupClient(connectionId);
+
+    OI_DBGTRACE(("OI_OPPClient_EnableNameOverride: %d", nameOverrideEnabled));
+    if (IS_CLIENT_CONNECTED(client)) {
+        client->nameOverrideEnabled = (OI_UINT8)(nameOverrideEnabled ? TRUE : FALSE);
+        return OI_OK;
+    } else {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+}
diff --git a/obex_profiles/profiles/opp/opp_common.c b/obex_profiles/profiles/opp/opp_common.c
new file mode 100644
index 0000000..87bb2f4
--- /dev/null
+++ b/obex_profiles/profiles/opp/opp_common.c
@@ -0,0 +1,196 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+Object Push Profile common functions
+*/
+
+#define __OI_MODULE__ OI_MODULE_OPP_SRV
+
+#include "oi_opp_common.h"
+#include "oi_obexsrv.h"
+#include "oi_memmgr.h"
+#include "oi_debug.h"
+#include "oi_assert.h"
+#include "oi_unicode.h"
+
+
+/**
+ * Check that a file or folder name is a base name. That is, check that the name
+ * does not include relative or absolute path.
+ *
+ * Rejects names that contain "/", backslash, "..", or ":"
+ */
+
+static OI_BOOL IsBaseName(OI_OBEX_UNICODE *name)
+{
+    OI_INT i;
+    OI_CHAR16 *str;
+    OI_UINT16 len;
+    const OI_CHAR16 telecom[] = { 't', 'e', 'l', 'e', 'c', 'o', 'm', '/', 0 };
+
+    if ((name == NULL) || (name->str == NULL)) {
+        /* An empty name is always a base name. */
+        return TRUE;
+    }
+
+    str = name->str;
+    len = name->len;
+
+    /* The path "telecom/" is OK so only check for path characters after it if
+     * it is at the beginning of the NAME header. */
+    if (OI_StrncmpUtf16(str, telecom, OI_ARRAYSIZE(telecom) - 1) == 0) {
+        str += OI_ARRAYSIZE(telecom) - 1;
+        len -= OI_ARRAYSIZE(telecom) - 1;
+    }
+
+    /*
+     * Reject . ..
+     */
+    if (str[0] == (OI_CHAR16) '.') {
+        if ((len == 1) || (str[1] == 0)) {
+            goto NotBase;
+        }
+        if (str[1] == ((OI_CHAR16) '.')  && ((len == 2) || (str[2] == 0))) {
+            goto NotBase;
+        }
+    }
+    /*
+     * Reject : / \
+     */
+    for (i = 0; i < len; ++i) {
+        OI_CHAR16 c = str[i];
+        if ((c == (OI_CHAR16)(':')) || (c == (OI_CHAR16)('/')) || (c == (OI_CHAR16)('\\'))) {
+            goto NotBase;
+        }
+    }
+    return TRUE;
+
+NotBase:
+
+    OI_DBGPRINT2(("Disallowing folder name %S", name->str));
+    return FALSE;
+}
+
+
+
+OI_STATUS OPPCommon_ParseHeaders(OI_OPP_GENERIC_OBJECT *obj,
+                                 OI_OBEX_HEADER_LIST *headers)
+{
+    OI_STATUS status;
+    OI_OBEX_UNICODE *uname;
+    OI_OBEX_BYTESEQ *type;
+    OI_UINT i;
+
+    for (i = 0; i < headers->count; ++i) {
+        switch (headers->list[i].id) {
+            case OI_OBEX_HDR_NAME:
+                if (obj->name.str != NULL) {
+                    /*
+                     * Ignore the duplicate name header.
+                     */
+                    break;
+                }
+                uname = &(headers->list[i].val.name);
+                if (!IsBaseName(uname)) {
+                    status = OI_OBEX_NOT_FOUND;
+                    goto ObjCleanup;
+                }
+                obj->name.str = OI_Malloc(uname->len * sizeof(OI_CHAR16));
+                if (obj->name.str == NULL) {
+                    status = OI_STATUS_OUT_OF_MEMORY;
+                    goto ObjCleanup;
+                }
+                obj->name.len = uname->len;
+                OI_MemCopy(obj->name.str, uname->str, uname->len * sizeof(OI_CHAR16));
+                break;
+            case OI_OBEX_HDR_TYPE:
+                if (obj->type.data != NULL) {
+                    /*
+                     * Ignore the duplicate type header.
+                     */
+                    break;
+                }
+                type = &(headers->list[i].val.type);
+                obj->type.data = OI_Malloc(type->len);
+                if (obj->type.data == NULL) {
+                    status = OI_STATUS_OUT_OF_MEMORY;
+                    goto ObjCleanup;
+                }
+                obj->type.len = type->len;
+                OI_MemCopy(obj->type.data, type->data, type->len);
+                break;
+            case OI_OBEX_HDR_LENGTH:
+                if (obj->objSize != 0) {
+                    /*
+                     * Ignore the bogus length header.
+                     */
+                    break;
+                }
+                type = &(headers->list[i].val.type);
+                obj->objSize = headers->list[i].val.length;
+                if (obj->objSize == 0) {
+                    status = OI_OBEX_VALUE_NOT_ACCEPTABLE;
+                    goto ObjCleanup;
+                }
+                break;
+            case OI_OBEX_HDR_BODY:
+                obj->objData = headers->list[i].val.body;
+                break;
+            case OI_OBEX_HDR_END_OF_BODY:
+                obj->objData = headers->list[i].val.body;
+                /*
+                 * The Sony/Ericcsson T68i does not provide the mandatory length
+                 * header so we have to figure out the length of the object from
+                 * the body header.
+                 */
+                if (obj->objSize == 0) {
+                    obj->objSize = obj->objData.len;
+                }
+                break;
+            default:
+                /* Other headers are ignored. */
+                break;
+        }
+    }
+
+    return OI_OK;
+
+ObjCleanup:
+
+    OI_FreeIf(&obj->name.str);
+    OI_FreeIf(&obj->type.data);
+
+    return status;
+}
+
diff --git a/obex_profiles/profiles/opp/opp_server.c b/obex_profiles/profiles/opp/opp_server.c
new file mode 100644
index 0000000..9e15d1e
--- /dev/null
+++ b/obex_profiles/profiles/opp/opp_server.c
@@ -0,0 +1,1578 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+Object Push Profile server
+*/
+
+#define __OI_MODULE__ OI_MODULE_OPP_SRV
+#include "oi_opp_server.h"
+#include "oi_opp_common.h"
+#include "oi_obexspec.h"
+#include "oi_obexsrv.h"
+#include "oi_argcheck.h"
+#include "oi_utils.h"
+#include "oi_memmgr.h"
+#include "oi_dispatch.h"
+#include "oi_debug.h"
+#include "oi_assert.h"
+#include "oi_bt_assigned_nos.h"
+#include "oi_sdpdb.h"
+#include "oi_sdp_utils.h"
+#include "oi_std_utils.h"
+#include "oi_opp_test.h"
+
+#include "oi_init_flags.h"
+#include "oi_config_table.h"
+#include "oi_bt_profile_config.h"
+
+/*
+ * Service class ID list
+ */
+
+static const OI_DATAELEM ServiceClassIDList[] = {
+    OI_ELEMENT_UUID32(OI_UUID_OBEXObjectPush)
+};
+
+/*
+ * Profile descriptor list
+ */
+
+static const OI_DATAELEM Profile0[] = {
+    OI_ELEMENT_UUID32(OI_UUID_OBEXObjectPush),
+#ifdef OI_OBEX_OVER_L2CAP
+    OI_ELEMENT_UINT16(0x0102) /* version 1.2 */
+#else
+    OI_ELEMENT_UINT16(0x0100) /* version 1.0 */
+#endif
+};
+
+static const OI_DATAELEM ProfileDescriptorList[] = {
+    OI_ELEMENT_SEQ(Profile0)
+};
+
+/*
+ * SDP Attribute lists
+ */
+
+static const OI_SDPDB_ATTRIBUTE ServiceDescription[] = {
+    { OI_ATTRID_ServiceClassIDList,             OI_ELEMENT_SEQ(ServiceClassIDList) },
+    { OI_ATTRID_BluetoothProfileDescriptorList, OI_ELEMENT_SEQ(ProfileDescriptorList) }
+};
+
+
+
+/*
+ * Note that the order of these states is important.
+ */
+typedef enum {
+    OPP_SERVER_DISCONNECTED = 0, /* doing nothing right now */
+    OPP_SERVER_CONNECTING   = 1, /* server has indicated a connection */
+    OPP_SERVER_CONNECTED    = 2, /* server is connected */
+    OPP_PULL_PENDING        = 3, /* pull has been requested */
+    OPP_CLIENT_PULLING      = 4, /* pull is in progress  */
+    OPP_PUSH_PENDING        = 5, /* push has been requested */
+    OPP_CLIENT_PUSHING      = 6  /* push is in progress  */
+} OPP_SERVER_STATE;
+
+
+/*
+ * Struct for an OBEX OPP server
+ */
+typedef struct {
+
+    OI_OBEX_SERVER_HANDLE serverHandle;
+
+    const OI_OPP_OBJSYS_FUNCTIONS *objops;
+    const OI_OPP_SERVER_CALLBACKS *callbacks;
+
+    OI_UINT32 srecHandle;
+
+    OI_OPP_SERVER_OBJECT_FORMATS supportedFormats;  /**< Supported formats as a bit vector.*/
+
+    OI_UINT8 numAttributes;
+    OI_SDPDB_ATTRIBUTE sdpAttributes[3]; /**< Supported format and Protocol Descriptor list */
+
+} OPP_SERVER;
+
+
+/*
+ * Struct for an OPP connection.
+ */
+typedef struct {
+
+    OPP_SERVER_STATE state;
+    OPP_SERVER *server;      /* Pointer to server for this connection */
+
+    OI_OPP_HANDLE ofsHandle; /* Object file store handle for current operation */
+
+    OI_UINT32 maxReadSize;
+
+    OI_OPP_GENERIC_OBJECT rcvObj;
+
+    OI_OBEXSRV_CONNECTION_HANDLE obexHandle; /* Handle for underlying OBEX connection */
+
+    DISPATCH_CB_HANDLE closeCB;
+
+    OI_BOOL   final;
+    OI_BOOL   allowPush;
+    OI_BOOL   allowPull;
+    OI_BOOL   ofsAcceptPending;       /**< Waiting for application to accept/reject incoming PUT */
+    OI_BOOL   ofsCfmPending;          /**< Waiting for Object File System to call our cfm function */
+    OI_BOOL   deferredPPError;        /**< Push/Pull error occurred while awaiting OFS cfm. */
+    OI_STATUS deferredErrorStatus;    /**< The specific error whose handling has been deferred */
+
+} OPPSRV_CONNECTION;
+
+
+
+#define LookupConnection(handle)   ((OPPSRV_CONNECTION*)OI_OBEXSRV_GetConnectionContext(handle))
+#define LookupServer(handle)       ((OPP_SERVER*)OI_OBEXSRV_GetServerContext(handle))
+
+
+
+/**
+ * Connection policy.
+ */
+static const OI_CONNECT_POLICY  connectPolicy =
+{
+    OI_ELEMENT_UUID32(OI_UUID_OBEXObjectPush), /* OI_DATAELEM         serviceUuid         */
+    FALSE,                                     /* OI_BOOL             mustBeMaster        */
+    NULL,                                      /* OI_L2CAP_FLOWSPEC   *flowspec           */
+    0                                          /* OI_UINT8            powerSavingDisables */
+};
+
+#define    OI_CASE(a) case a: return(#a) ;
+
+OI_CHAR  *OI_OPPServer_eventText(OI_OPP_SERVER_EVENT event)
+{
+#ifdef OI_DEBUG
+    switch (event) {
+        OI_CASE(OI_OPP_SERVER_EVENT_PUSH);
+        OI_CASE(OI_OPP_SERVER_EVENT_PULL);
+        OI_CASE(OI_OPP_SERVER_EVENT_PUSH_PROGRESS);
+        OI_CASE(OI_OPP_SERVER_EVENT_PULL_PROGRESS);
+        OI_CASE(OI_OPP_SERVER_EVENT_PUSH_COMPLETE);
+        OI_CASE(OI_OPP_SERVER_EVENT_PULL_COMPLETE);
+    }
+    return "unknown event";
+#else
+    return "";
+#endif      /* OI_DEBUG */
+}
+
+
+#ifdef OI_DEBUG
+static OI_CHAR* ServerStateText(OPP_SERVER_STATE state)
+{
+    switch (state) {
+        OI_CASE(OPP_SERVER_DISCONNECTED);
+        OI_CASE(OPP_SERVER_CONNECTING);
+        OI_CASE(OPP_SERVER_CONNECTED);
+        OI_CASE(OPP_PULL_PENDING);
+        OI_CASE(OPP_CLIENT_PULLING);
+        OI_CASE(OPP_PUSH_PENDING);
+        OI_CASE(OPP_CLIENT_PUSHING);
+    }
+    return("unknown state");
+
+}
+
+#else
+
+#define ServerStateText(state)  ("")
+
+#endif  /* OI_DEBUG */
+
+
+#define SetState(cn, newState) \
+    do { \
+        OI_DBGTRACE(("OPP Server state %s ==> %s", ServerStateText((cn)->state), ServerStateText(newState))); \
+        (cn)->state = (newState); \
+    } while (0)
+
+
+/*
+ * Tries to figure out the type of the object being pushed from the suffix on the
+ * name.
+ */
+
+static OI_CHAR* ObjTypeFromSuffix(OI_OBEX_UNICODE *name)
+{
+    OI_CHAR suffix[5];
+    OI_UINT len;
+    OI_INT i;
+
+    /*
+     * The spec says that a OBEX name should be a null terminated but we
+     * are a little more paranoid.
+     */
+    for (len = name->len; len > 0; --len) {
+        if (name->str[len - 1] != 0) {
+            break;
+        }
+    }
+    /*
+     * A suffixed name must be at least 5 characters long (e.g. x.vcf).
+     */
+    if (len >= 5) {
+        /*
+         * Convert suffix (including '.') to ascii.
+         */
+        for (i = 0; i < 4; ++i) {
+            suffix[i] = (OI_CHAR) (name->str[len - 4 + i] & 0xFF);
+        }
+        suffix[i] = 0;
+        OI_DBGPRINT2(("ObjecTypeFromSuffix %s", suffix));
+        if (OI_Strcmp(suffix, OI_OBEX_VCARD_SUFFIX) == 0) {
+            return OI_OBEX_VCARD_TYPE;
+        }
+        if (OI_Strcmp(suffix, OI_OBEX_VCALENDAR_SUFFIX) == 0) {
+            return OI_OBEX_VCALENDAR_TYPE;
+        }
+        if (OI_Strcmp(suffix, OI_OBEX_VNOTE_SUFFIX) == 0) {
+            return OI_OBEX_VNOTE_TYPE;
+        }
+        if (OI_Strcmp(suffix, OI_OBEX_VMESSAGESUFFIX) == 0) {
+            return OI_OBEX_VMESSAGE_TYPE;
+        }
+        if (OI_Strcmp(suffix, OI_OBEX_ICALENDAR_SUFFIX) == 0) {
+            return OI_OBEX_ICALENDAR_TYPE;
+        }
+    }
+    return "";
+}
+
+
+/*
+ * Brute force check for supported format type.
+ */
+static OI_BOOL IsSupportedType(OI_CHAR *type,
+                               OI_UINT typeLen,
+                               OI_OPP_SERVER_OBJECT_FORMATS formats)
+{
+    if (formats == OI_OPP_SERVER_OBJ_FORMAT_ANY) {
+        return TRUE;
+    }
+    if (OI_StrncmpInsensitive(type, OI_OBEX_VCARD_TYPE, (OI_UINT16)typeLen) == 0) {
+        return formats & (OI_OPP_SERVER_OBJ_FORMAT_VCARD_2_1 | OI_OPP_SERVER_OBJ_FORMAT_VCARD_3_0);
+    }
+    if (OI_StrncmpInsensitive(type, OI_OBEX_VCALENDAR_TYPE, (OI_UINT16)typeLen) == 0) {
+        return (formats & OI_OPP_SERVER_OBJ_FORMAT_VCAL_1_0);
+    }
+    if (OI_StrncmpInsensitive(type, OI_OBEX_ICALENDAR_TYPE, (OI_UINT16)typeLen) == 0) {
+        return (formats & OI_OPP_SERVER_OBJ_FORMAT_ICAL_2_0);
+    }
+    if (OI_StrncmpInsensitive(type, OI_OBEX_VNOTE_TYPE, (OI_UINT16)typeLen) == 0) {
+        return (formats & OI_OPP_SERVER_OBJ_FORMAT_VNOTE);
+    }
+    if (OI_StrncmpInsensitive(type, OI_OBEX_VMESSAGE_TYPE, (OI_UINT16)typeLen) == 0) {
+        return (formats & OI_OPP_SERVER_OBJ_FORMAT_VMESSAGE);
+    }
+    return FALSE;
+}
+
+
+static void ObjectClose(OPPSRV_CONNECTION *connection,
+                        OI_BOOL disconnected,
+                        OI_STATUS status)
+{
+    OI_OPP_SERVER_EVENT_DATA eventData;
+    OPP_SERVER_STATE snapState;
+    OI_OPP_SERVER_EVENT_IND eventInd;
+
+    snapState = connection->state;
+
+    switch (snapState) {
+        case OPP_PULL_PENDING:
+        case OPP_CLIENT_PULLING:
+            eventData.event = OI_OPP_SERVER_EVENT_PULL_COMPLETE;
+            eventData.data.pullComplete.finalSize = connection->rcvObj.objSize;
+            eventData.data.pullComplete.status = status;
+            eventInd = connection->server->callbacks->eventInd;
+            break;
+        case OPP_PUSH_PENDING:
+        case OPP_CLIENT_PUSHING:
+            eventData.event = OI_OPP_SERVER_EVENT_PUSH_COMPLETE;
+            eventData.data.pushComplete.finalSize = connection->rcvObj.objSize;
+            eventData.data.pushComplete.status = status;
+            eventInd = connection->server->callbacks->eventInd;
+            break;
+        default:
+            eventInd = NULL;
+            break;
+    }
+    /*
+     * Free any saved header data.
+     */
+    OI_FreeIf(&connection->rcvObj.name.str);
+    OI_FreeIf(&connection->rcvObj.type.data);
+    OI_MemZero(&connection->rcvObj, sizeof(OI_OPP_GENERIC_OBJECT));
+    if (disconnected) {
+        /*
+         * Break association between the handle and the OPP connection
+         */
+        OI_OBEXSRV_SetConnectionContext(connection->obexHandle, NULL);
+    } else {
+        /*
+         * Make connection available for other operations.
+         */
+        SetState(connection, OPP_SERVER_CONNECTED);
+    }
+    /*
+     * If there is an open object, close the object and clear OFS state.
+     */
+    if (connection->ofsHandle) {
+        OI_DBGTRACE(("objops->close %d", status));
+        connection->server->objops->Close(connection->ofsHandle, status, connection->obexHandle);
+        connection->ofsHandle = NULL;
+    }
+    connection->ofsAcceptPending = FALSE;
+    connection->ofsCfmPending = FALSE;
+
+    /*
+     * If applicable indicate the PULL/PUSH completion event now.
+     */
+    if (eventInd != NULL) {
+        eventInd(connection->obexHandle, &eventData);
+    }
+    /*
+     * If we disconnected call the disconnect indication now
+     */
+    if (disconnected) {
+        if (connection->server->callbacks->disconnectInd != NULL) {
+            connection->server->callbacks->disconnectInd(connection->obexHandle);
+        }
+        OI_Free(connection);
+    }
+}
+
+
+static void DeferredObjectClose(DISPATCH_ARG *darg)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(Dispatch_GetArg(darg, OI_OBEXSRV_CONNECTION_HANDLE));
+    if (connection == NULL) {
+        OI_LOG_ERROR(("DeferredObjectClose - connection has gone"));
+    } else {
+        connection->closeCB = 0;
+        ObjectClose(connection, FALSE, connection->deferredErrorStatus);
+    }
+
+}
+
+
+static void SetupDeferredObjectClose(OPPSRV_CONNECTION *connection,
+                                     OI_STATUS status)
+{
+    DISPATCH_ARG darg;
+
+    /*
+     * There can only be one object open at any one time, so there can only be one object close
+     * pending at any one time.
+     */
+    OI_ASSERT(!connection->closeCB);
+
+    OI_DBGPRINTSTR(("SetupDeferredObjectClose"));
+    /*
+     * OBEX returns a CLEANUP status when the operation is complete
+     */
+    if (status == OI_OBEX_CLEANUP) {
+        status = OI_OK;
+    }
+    /*
+     * We cannot call back into the application on this thread so we must complete the object close on
+     * the dispatch thread.
+     */
+
+    connection->deferredErrorStatus = status;
+    Dispatch_SetArg(darg, connection->obexHandle);
+    OI_Dispatch_RegisterFunc(DeferredObjectClose, &darg, &connection->closeCB);
+}
+
+/*
+ * Invoke DeferredObjectClose() if it's queued, and return error code if caller
+ * should abort.
+ */
+static OI_STATUS CheckDeferredObjectClose(OPPSRV_CONNECTION *connection)
+{
+    if (!connection) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+    if (connection->closeCB) {
+        OI_DBGPRINTSTR(("Deferred close is queued - calling close immediately"));
+        OI_Dispatch_CallFunc(connection->closeCB);
+    }
+    return OI_OK;
+}
+
+
+static void PushWriteCfm(OI_OPP_HANDLE handle,
+                         OI_STATUS status,
+                         OI_OPP_CONNECTION oppContext)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(oppContext);
+    OI_STATUS retVal;
+
+    OI_DBGTRACE(("PushWriteCfm %d", status));
+
+    /*
+     * First check we are expecting this call.
+     */
+    if (!connection) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    if ((connection->state != OPP_CLIENT_PUSHING) || !connection->ofsCfmPending) {
+        OI_LOG_ERROR(("Push write confirm called at wrong time"));
+        return;
+    }
+    /*
+     * Confirm is no longer pending
+     */
+    connection->ofsCfmPending = FALSE;
+    if (OI_SUCCESS(status)) {
+        /*
+         * Report continue or done to client.
+         */
+        status = OI_OBEXSRV_PutResponse(connection->obexHandle, NULL, connection->final ? OI_OK : OI_OBEX_CONTINUE);
+        if (!OI_SUCCESS(status)) {
+            OI_LOG_ERROR(("OI_OBEXSRV_PutResponse failed %d", status));
+        }
+    } else {
+        /*
+         * Report error to client.
+         */
+        retVal = OI_OBEXSRV_PutResponse(connection->obexHandle, NULL, status);
+        if (!OI_SUCCESS(retVal)) {
+            OI_LOG_ERROR(("OI_OBEXSRV_PutResponse failed %d", retVal));
+        }
+    }
+    if (!OI_SUCCESS(status)) {
+        SetupDeferredObjectClose(connection, status);
+    }
+}
+
+
+/*
+ * Return first body header.
+ */
+static void FirstBodyHeader(DISPATCH_ARG *darg)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(Dispatch_GetArg(darg, OI_OPP_SERVER_CONNECTION_HANDLE));
+    OI_STATUS status;
+
+    if (!connection) {
+        return;
+    }
+
+    connection->ofsCfmPending = TRUE;
+    status = connection->server->objops->Write(connection->ofsHandle,
+                                               connection->rcvObj.objData.data,
+                                               connection->rcvObj.objData.len,
+                                               PushWriteCfm,
+                                               connection->obexHandle);
+    connection->rcvObj.objData.data = NULL;
+    connection->rcvObj.objData.len = 0;
+    if (!OI_SUCCESS(status)) {
+        OI_STATUS   retVal;
+
+        OI_LOG_ERROR(("OFS Write() failed %d", status));
+
+        connection->ofsCfmPending = FALSE;
+        /*
+         * Report error to client.
+         */
+        retVal = OI_OBEXSRV_PutResponse(connection->obexHandle, NULL, status);
+        if (!OI_SUCCESS(retVal)) {
+            OI_SLOG_ERROR(retVal, ("OI_OBEXSRV_PutResponse failed"));
+        }
+        SetupDeferredObjectClose(connection, status);
+    }
+}
+
+
+static void PushOpenCfm(OI_OPP_HANDLE handle,
+                        OI_STATUS status,
+                        OI_OPP_CONNECTION oppContext)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(oppContext);
+
+    OI_DBGTRACE(("PushOpenCfm %d", status));
+
+    /*
+     * First check we are expecting this call.
+     */
+    if (!connection) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    if ((connection->state != OPP_PUSH_PENDING) || !connection->ofsCfmPending) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_STATE, ("Push open confirm called at wrong time"));
+        return;
+    }
+    /*
+     * Confirm is no longer pending
+     */
+    connection->ofsCfmPending = FALSE;
+    /*
+     * If OFS open was successful, we must eventuall call the object close() method.
+     * If OFS open failed, we must NOT call the object close() method.
+     * Handle is the trigger to call close() or not.
+     */
+    connection->ofsHandle = OI_SUCCESS(status) ? handle : NULL;
+    if (OI_SUCCESS(status)) {
+        DISPATCH_ARG darg;
+        connection->ofsHandle = handle;
+        SetState(connection, OPP_CLIENT_PUSHING);
+        Dispatch_SetArg(darg, connection->obexHandle);
+        (void) OI_Dispatch_RegisterFunc(FirstBodyHeader, &darg, NULL);
+    } else {
+        OI_OBEXSRV_PutResponse(connection->obexHandle, NULL, status);
+        SetupDeferredObjectClose(connection, status);
+    }
+}
+
+
+static OI_STATUS ObjPushInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                            OI_OBEX_HEADER_LIST *cmdHeaders,
+                            OI_STATUS obexStatus)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(connectionId);
+    OI_UINT typeLen;
+    OI_CHAR *objType;
+    OI_STATUS status = obexStatus;
+    static int count = 0;
+
+    OI_DBGTRACE(("ObjPushInd %d", obexStatus));
+
+    /*
+     * Check for an outstanding close operation.
+     */
+    status = CheckDeferredObjectClose(connection);
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+    /*
+     * If an OFS confirm is pending, status must indicate a disconnect event.  Normally,
+     *   there cannot be a push indication until we have responded to the previous push
+     *   indication, disconnect is the exception.
+     */
+    if (connection->ofsCfmPending) {
+        if (OI_OBEX_NOT_CONNECTED == obexStatus) {
+            /*
+             * Ignore this error - we are depending on Obex to call our disconnect indication.
+             */
+            OI_DBGTRACE(("ObjPushInd while ofsCfmPending, ignoring status %d\n", obexStatus));
+            return OI_OK;
+        }
+        /*
+         * This can happen when a remote device sends a command before
+         * we've replied to the previous command.  Defer error handling
+         * until OFS finishes.
+         */
+        OI_DBGTRACE(("Deferring error handling (%d) until OFS cfm completed", obexStatus));
+
+        connection->deferredPPError = TRUE;
+        connection->deferredErrorStatus = obexStatus;
+
+        /*
+         * If OBEX passed us an OI_OK status, inform it that an error occurred.
+         * Otherwise, OBEX knows about the error already and we're OI_OK.
+         */
+        return (OI_SUCCESS(obexStatus) ? OI_STATUS_INTERNAL_ERROR : OI_OK);
+    }
+
+    /*
+     * If OBEX reported an error the PUSH operation has been terminated so
+     * all we need to do to cleanup is close the object. We return OI_OK
+     * because OBEX knows about the error.
+     */
+    if (!OI_SUCCESS(obexStatus) && (obexStatus != OI_OBEX_CONTINUE)) {
+        SetupDeferredObjectClose(connection, obexStatus);
+        return OI_OK;
+    }
+
+    /*
+     * Check that the server is allowing PUSH on this connection.
+     */
+    if (!connection->allowPush) {
+        OI_DBGPRINTSTR(("OPP server ObjPushInd - server disallows push"));
+        return OI_OBEX_ACCESS_DENIED;
+    }
+
+    if (cmdHeaders == NULL) {
+        status = OI_OBEX_REQUIRED_HEADER_NOT_FOUND;
+        goto ObjPushError;
+    }
+
+    if (connection->state == OPP_SERVER_CONNECTED) {
+        SetState(connection, OPP_PUSH_PENDING);
+    }
+
+    if ((connection->state != OPP_CLIENT_PUSHING) && (connection->state != OPP_PUSH_PENDING)) {
+        return OI_OBEX_SERVICE_UNAVAILABLE;
+    }
+
+    if (obexStatus == OI_OBEX_CONTINUE) {
+        connection->final = FALSE;
+    } else {
+        connection->final = TRUE;
+    }
+
+    status = OPPCommon_ParseHeaders(&connection->rcvObj, cmdHeaders);
+    if (!OI_SUCCESS(status)) {
+        goto ObjPushError;
+    }
+
+    if (connection->state == OPP_PUSH_PENDING) {
+        /*
+         * Wait until we have seen a body header before attempting to open the
+         * object. This ensures that we have all the other headers we need.
+         */
+        if (connection->final || (connection->rcvObj.objData.data != NULL)) {
+            /*
+             * Name is mandatory.
+             */
+            if (connection->rcvObj.name.str == NULL) {
+                status = OI_OBEX_ACCESS_DENIED;
+                goto ObjPushError;
+            }
+            /*
+             * Some broken implementations do not provide a type header. So we
+             * try to figure out the type from the suffix on the object name.
+             *
+             * Some broken implementations do not null terminate the type string
+             * so we need the size too.
+             */
+            if (connection->rcvObj.type.data == NULL) {
+                objType = ObjTypeFromSuffix(&connection->rcvObj.name);
+                typeLen = OI_StrLen(objType);
+            } else {
+                objType = (OI_CHAR*) connection->rcvObj.type.data;
+                typeLen = connection->rcvObj.type.len;
+            }
+            /*
+             * Check we support this object type.
+             */
+            if (!IsSupportedType(objType, typeLen, connection->server->supportedFormats)) {
+                status = OI_OBEX_UNSUPPORTED_MEDIA_TYPE;
+                goto ObjPushError;
+            }
+            /*
+             * Try and open the object.
+             */
+            if (connection->server->callbacks->eventInd == NULL) {
+                connection->ofsCfmPending = TRUE;
+                status = connection->server->objops->OpenWrite(&connection->rcvObj.name,
+                                                               objType,
+                                                               connection->rcvObj.objSize,
+                                                               PushOpenCfm,
+                                                               connection->obexHandle);
+                if (!OI_SUCCESS(status)) {
+                    connection->ofsCfmPending = FALSE;
+                }
+            } else {
+                OI_OPP_SERVER_EVENT_DATA eventData;
+                eventData.event = OI_OPP_SERVER_EVENT_PUSH;
+                eventData.data.push.localName = &connection->rcvObj.name;
+                eventData.data.push.totalSize = connection->rcvObj.objSize;
+                eventData.data.push.objType = objType;
+                connection->ofsAcceptPending = TRUE;
+                connection->server->callbacks->eventInd(connection->obexHandle, &eventData);
+                status = OI_OK;
+            }
+        } else {
+            /*
+             * Get more data from the client.
+             */
+            status = OI_OBEXSRV_PutResponse(connectionId, NULL, obexStatus);
+        }
+    } else {
+        /*
+         * Write data to the object
+         */
+        connection->ofsCfmPending = TRUE;
+        status = connection->server->objops->Write(connection->ofsHandle,
+                                                   connection->rcvObj.objData.data,
+                                                   connection->rcvObj.objData.len,
+                                                   PushWriteCfm,
+                                                   connection->obexHandle);
+        if (!OI_SUCCESS(status)) {
+            connection->ofsCfmPending = FALSE;
+        }
+        connection->rcvObj.objData.data = NULL;
+        connection->rcvObj.objData.len = 0;
+    }
+
+    if (!OI_SUCCESS(status)) {
+        goto ObjPushError;
+    }
+
+    return OI_OK;
+
+ObjPushError:
+
+    OI_DBGTRACE(("OPP server object push failed %d", status));
+    SetupDeferredObjectClose(connection, status);
+    return status;
+}
+
+
+static void PullOpenCfm(OI_OPP_HANDLE handle,
+                        const OI_OBEX_UNICODE *name,
+                        const OI_CHAR *type,
+                        OI_UINT32 size,
+                        OI_BYTE * data,
+                        OI_UINT16 data_len,
+                        OI_STATUS status,
+                        OI_OPP_CONNECTION oppContext)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(oppContext);
+    OI_OBEX_HEADER hdrs[3];
+    OI_OBEX_HEADER_LIST hdrList;
+
+    OI_DBGTRACE(("PullOpenCfm %d", status));
+
+    /*
+     * First check we are expecting this call.
+     */
+    if (!connection) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    if ((connection->state != OPP_PULL_PENDING) || !connection->ofsCfmPending) {
+        OI_LOG_ERROR(("Pull open confirm called at wrong time"));
+        return;
+    }
+    /*
+     * Confirm is no longer pending
+     */
+    connection->ofsCfmPending = FALSE;
+    /*
+     * If OFS open was successful, we must eventuall call the object close() method.
+     * If OFS open failed, we must NOT call the object close() method.
+     * Handle is the trigger to call close() or not.
+     */
+    connection->ofsHandle = OI_SUCCESS(status) ? handle :NULL;
+    /*
+     * If push/pull error occurred while awaiting the cfm, fail the current operation
+     */
+    if (connection->deferredPPError) {
+        connection->deferredPPError = FALSE;
+        status = connection->deferredErrorStatus;
+    }
+    /*
+     * Now finally comes the 'normal' handling of the confirm
+     */
+    if (!OI_SUCCESS(status)) {
+        /*
+         * Reject the pull request by reporting an error status to the client.
+         */
+        (void) OI_OBEXSRV_GetResponse(connection->obexHandle, NULL, status);
+    } else {
+        if (connection->server->callbacks->eventInd) {
+            OI_OPP_SERVER_EVENT_DATA eventData;
+            eventData.event = OI_OPP_SERVER_EVENT_PULL;
+            eventData.data.pull.localName = name;
+            eventData.data.pull.totalSize = size;
+            eventData.data.pull.objType = type;
+            connection->rcvObj.objSize = size;
+            connection->server->callbacks->eventInd(connection->obexHandle, &eventData);
+        }
+
+        /*
+         * Send the basic info for the default object to the client.
+         */
+        hdrList.count = 0;
+        hdrList.list = hdrs;
+
+        hdrs[hdrList.count].id = OI_OBEX_HDR_LENGTH;
+        hdrs[hdrList.count].val.length = size;
+        ++hdrList.count;
+        #ifdef OI_TEST_HARNESS
+            if (TEST_OPP_MISSING_SERVER_PULL_HEADER != OI_OPP_GetTestName()) {
+                hdrs[hdrList.count].id = OI_OBEX_HDR_NAME;
+                hdrs[hdrList.count].val.name = *name;
+                ++hdrList.count;
+            }
+        #else
+            hdrs[hdrList.count].id = OI_OBEX_HDR_NAME;
+            hdrs[hdrList.count].val.name = *name;
+            ++hdrList.count;
+        #endif
+        hdrs[hdrList.count].id = OI_OBEX_HDR_TYPE;
+        hdrs[hdrList.count].val.type.data = (OI_BYTE*) type;
+        hdrs[hdrList.count].val.type.len = OI_StrLen(type) + 1; /* include nul terminator */
+        ++hdrList.count;
+
+        status = OI_OBEXSRV_GetResponse(connection->obexHandle, &hdrList, OI_OBEX_CONTINUE);
+    }
+
+    if (OI_SUCCESS(status)) {
+        SetState(connection, OPP_CLIENT_PULLING);
+    } else {
+        SetupDeferredObjectClose(connection, status);
+    }
+}
+
+
+/*
+ * Called when to confirm read of data from an object. Passes in the data read
+ * from the object.
+ */
+
+static void PullReadCfm(OI_OPP_HANDLE handle,
+                        OI_BYTE *data,
+                        OI_UINT32 len,
+                        OI_STATUS status,
+                        OI_OPP_CONNECTION oppContext)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(oppContext);
+    OI_STATUS obexStatus;
+    OI_OBEX_HEADER bodyHdr;
+    OI_OBEX_HEADER_LIST hdrList;
+
+    OI_DBGTRACE(("PullReadCfm %d", status));
+
+    /*
+     * First check we are expecting this call.
+     */
+    if (!connection) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Invalid connection handle"));
+        return;
+    }
+    if ((connection->state != OPP_CLIENT_PULLING) || !connection->ofsCfmPending) {
+        OI_LOG_ERROR(("Pull read confirm called at wrong time"));
+        return;
+    }
+    /*
+     * Confirm is no longer pending
+     */
+    connection->ofsCfmPending = FALSE;
+    if (!OI_SUCCESS(status) && (status != OI_STATUS_END_OF_FILE)) {
+        /*
+         * Report error to client.
+         */
+        OI_OBEXSRV_GetResponse(connection->obexHandle, NULL, status);
+    } else {
+        /*
+         * Send the next body header.
+         */
+        if (status == OI_STATUS_END_OF_FILE) {
+            obexStatus = OI_OK;
+            bodyHdr.id = OI_OBEX_HDR_END_OF_BODY;
+        } else {
+            obexStatus = OI_OBEX_CONTINUE;
+            bodyHdr.id = OI_OBEX_HDR_BODY;
+        }
+        bodyHdr.val.body.len = (OI_UINT16) len;
+        bodyHdr.val.body.data = data;
+        hdrList.count = 1;
+        hdrList.list = &bodyHdr;
+        /*
+         * Send the GET command response to client.
+         */
+        status = OI_OBEXSRV_GetResponse(connection->obexHandle, &hdrList, obexStatus);
+    }
+    /*
+     * Close the object if there was an error
+     */
+    if (!OI_SUCCESS(status)) {
+        SetupDeferredObjectClose(connection, status);
+    }
+}
+
+
+/*
+ * The only object that can be PULLED is the default object - the owner's
+ * business card.
+ */
+static OI_STATUS ObjPullInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                            OI_OBEX_HEADER_LIST *cmdHeaders,
+                            OI_STATUS obexStatus)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(connectionId);
+    OI_STATUS status = OI_OK;
+    OI_INT i;
+
+    OI_DBGTRACE(("ObjPullInd %d", obexStatus));
+
+    /*
+     * Check for an outstanding close operation.
+     */
+    status = CheckDeferredObjectClose(connection);
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+    /*
+     * If OBEX reported an error the PULL operation has been terminated so
+     * all we need to do to cleanup is close the object. We return OI_OK
+     * because OBEX already knows about the error.
+     */
+    if (!OI_SUCCESS(obexStatus) && (obexStatus != OI_OBEX_CONTINUE)) {
+        if (connection->ofsCfmPending) {
+            /*
+             * We are waiting for OFS cfm callback so cannot close the object yet. Record the fact
+             * the a push/pull error occurred and the object close will be handled by the ofs cfm
+             * callback. The only error we expect while awaiting OFS cfm is DISCONNECT anything
+             * else is an internal error.
+             */
+            if (obexStatus != OI_OBEX_NOT_CONNECTED) {
+                OI_LOG_ERROR(("Internal error, ObjPullInd (%d) while awaiting OFS cfm", obexStatus));
+            }
+            OI_DBGTRACE(("Deferring error handling (%d) until OFS cfm completed", obexStatus));
+            connection->deferredPPError = TRUE;
+            connection->deferredErrorStatus = obexStatus;
+        } else {
+            SetupDeferredObjectClose(connection, obexStatus);
+        }
+        return OI_OK;
+    }
+
+    /*
+     * In the absence of push/pull errors, there should never be a OFS cfm outstanding.
+     */
+    OI_ASSERT(!connection->ofsCfmPending);
+    if (connection->ofsCfmPending) {
+        OI_LOG_ERROR(("Internal error, ObjPullInd (%d) while awaiting OFS cfm", obexStatus));
+        connection->deferredPPError = TRUE;
+        connection->deferredErrorStatus = OI_OBEX_ACCESS_DENIED;
+        return OI_OBEX_ACCESS_DENIED;
+    }
+
+    /*
+     * Check that the server is allowing PULL on this connection.
+     */
+    if (!connection->allowPull) {
+        OI_DBGPRINTSTR(("OPP server ObjPullInd - server disallows pull"));
+        return OI_OBEX_ACCESS_DENIED;
+    }
+
+    /*
+     * If the PULL operation is now complete close the object.
+     */
+    if (obexStatus == OI_OK) {
+        goto ObjPullComplete;
+    }
+
+    OI_ASSERT(obexStatus == OI_OBEX_CONTINUE);
+
+    if (connection->state == OPP_SERVER_CONNECTED) {
+        OI_BD_ADDR addr;
+        OI_OBEX_BYTESEQ *type = NULL;
+
+        status = OI_OBEXSRV_GetClientAddr(connectionId, &addr);
+        if (!OI_SUCCESS(status)) {
+            goto ObjPullComplete;
+        }
+
+        OI_DBGTRACE(("OPP server pull request from %:", &addr));
+
+        /*
+         * Starting a PULL operation - parse the headers
+         */
+        for (i = 0; i < cmdHeaders->count; ++i) {
+            OI_OBEX_HEADER *tmpHdr = cmdHeaders->list + i;
+            switch (tmpHdr->id) {
+                case OI_OBEX_HDR_NAME:
+                    /*
+                     * Section 4.3.2 of Bluetooth OPP spec says that the name
+                     * header must NOT be used for object pull, but the example
+                     * in section 8.4.1 of the IrDA OBEX spec (version 1.2)
+                     * shows the use of an empty name header. So we will allow
+                     * an empty name header...
+                     */
+                    if (tmpHdr->val.name.len != 0) {
+                        status = OI_OBEX_ACCESS_DENIED;
+                        OI_LOG_ERROR(("Name header not allowed for object pull"));
+                        goto ObjPullComplete;
+                    }
+                    break;
+                case OI_OBEX_HDR_TYPE:
+                    type = &(tmpHdr->val.type);
+                    break;
+                default:
+                    /* Ignore other headers. */
+                    break;
+            }
+        }
+        if ((type == NULL) || (type->len == 0)) {
+            OI_DBGPRINTSTR(("Object pull no type header"));
+            status = OI_OBEX_ACCESS_DENIED;
+            goto ObjPullComplete;
+        }
+        /*
+         * vcard is the only object type allowed for object pull.
+         * Some broken implementations do not null terminate the type string
+         * so we perform string comparison without considering the string terminator.
+         */
+        if (0 != OI_StrncmpInsensitive( OI_OBEX_VCARD_TYPE,
+                                        (OI_CHAR*) type->data,
+                                        (OI_UINT16) OI_StrLen(OI_OBEX_VCARD_TYPE))) {
+            status = OI_OBEX_NOT_FOUND;
+            goto ObjPullComplete;
+        }
+
+        /*
+         * Try to open the default object.  Specify the default object explicitly, type->data from
+         * opp client may not be null terminted (contrary to spec).
+         */
+        SetState(connection, OPP_PULL_PENDING);
+        connection->ofsCfmPending = TRUE;
+        status = connection->server->objops->OpenRead(NULL, (OI_CHAR*) OI_OBEX_VCARD_TYPE,
+            connection->maxReadSize, PullOpenCfm, (OI_OPP_CONNECTION) connection->obexHandle);
+        if (!OI_SUCCESS(status)) {
+            connection->ofsCfmPending = FALSE;
+            goto ObjPullComplete;
+        }
+    } else {
+        if (connection->state != OPP_CLIENT_PULLING) {
+            return OI_OBEX_SERVICE_UNAVAILABLE;
+        }
+        /*
+         * Read from the default object.
+         */
+        connection->ofsCfmPending = TRUE;
+
+        status = connection->server->objops->Read(connection->ofsHandle, connection->maxReadSize, PullReadCfm, (OI_OPP_CONNECTION) connection->obexHandle);
+        if (status == OI_STATUS_END_OF_FILE) {
+            PullReadCfm(connection->ofsHandle, NULL, 0, status, (OI_OPP_CONNECTION) connection->obexHandle);
+            status = OI_OK;
+        }
+        if (!OI_SUCCESS(status)) {
+            connection->ofsCfmPending = FALSE;
+            OI_DBGTRACE(("read from default object returned %d", status));
+            goto ObjPullComplete;
+        }
+    }
+
+    return OI_OK;
+
+
+ObjPullComplete:
+
+    SetupDeferredObjectClose(connection, status);
+    return status;
+}
+
+
+OI_STATUS OI_OPP_AcceptConnect(OI_OPP_SERVER_CONNECTION_HANDLE connectionId,
+                               OI_BOOL allowPush,
+                               OI_BOOL allowPull)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(connectionId);
+    OI_STATUS status;
+    OI_BOOL accept = allowPush || allowPull;
+
+    OI_DBGTRACE(("OI_OPP_AcceptConnect allowPush:%d allowPull:%d", allowPush, allowPull));
+
+    if (!connection) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+    if ((connection->state != OPP_SERVER_CONNECTING) || (connectionId != connection->obexHandle)) {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+    /*
+     * If PUSH is allowed we need to be able to write the object
+     */
+    if (allowPush && !connection->server->objops->OpenWrite) {
+        status = OI_STATUS_INVALID_PARAMETERS;
+        goto RejectConnection;
+    }
+    /*
+     * If PULL is allowed we need to be able to read the object
+     */
+    if (allowPull && !connection->server->objops->OpenRead) {
+        status = OI_STATUS_INVALID_PARAMETERS;
+        goto RejectConnection;
+    }
+
+    status = OI_OBEXSRV_AcceptConnect(connection->obexHandle, accept, accept ? OI_OK : OI_OBEX_ACCESS_DENIED, NULL);
+    if (accept && OI_SUCCESS(status)) {
+        /*
+         * Save access rights.
+         */
+        connection->allowPush = allowPush;
+        connection->allowPull = allowPull;
+        /*
+         * Establish the maximum read size for object read operations.
+         */
+        connection->maxReadSize = OI_OBEXSRV_OptimalBodyHeaderSize(connection->obexHandle);
+        /*
+         * Server is connected.
+         */
+        SetState(connection, OPP_SERVER_CONNECTED);
+    } else {
+        /*
+         * Dissociate OPP connection from the OBEX connection handle
+         */
+        OI_OBEXSRV_SetConnectionContext(connectionId, NULL);
+        OI_Free(connection);
+    }
+    return status;
+
+RejectConnection:
+
+    OI_OBEXSRV_AcceptConnect(connection->obexHandle, FALSE, OI_OBEX_ACCESS_DENIED, NULL);
+    OI_OBEXSRV_SetConnectionContext(connectionId, NULL);
+    OI_Free(connection);
+    return status;
+}
+
+
+OI_STATUS OI_OPPServer_ForceDisconnect(OI_OPP_SERVER_CONNECTION_HANDLE connectionId)
+{
+
+    OPPSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+    if (!connection) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+
+    OI_DBGTRACE(("OI_OPPServer_ForceDisconnect connectionId:%#x %s", connectionId, ServerStateText(connection->state)));
+
+    if (connection->state < OPP_SERVER_CONNECTED) {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    return OI_OBEXSRV_ForceDisconnect(connection->obexHandle);
+}
+
+
+static void ServerConnectInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                             OI_BOOL                      unauthorized,
+                             OI_BYTE                      *userId,
+                             OI_UINT8                     userIdLen,
+                             OI_OBEX_REALM                *realm)
+
+{
+    OI_OBEX_SERVER_HANDLE serverHandle = OI_OBEXSRV_GetServerHandle(connectionId);
+    OPPSRV_CONNECTION *connection = NULL;
+    OI_STATUS status = OI_OK;
+    OPP_SERVER *server = LookupServer(serverHandle);
+    OI_BD_ADDR clientAddr;
+
+    OI_ASSERT(serverHandle);
+
+    OI_DBGTRACE(("ServerConnectInd"));
+
+    if (!server) {
+        status = OI_OBEX_INTERNAL_SERVER_ERROR;
+        OI_SLOG_ERROR(status, ("Server not found for connection"));
+        goto RejectConnection;
+    }
+    /*
+     * OPP does not permit OBEX authentication.
+     */
+    if (unauthorized) {
+        status = OI_OBEX_INVALID_OPERATION;
+        goto RejectConnection;
+    }
+    /*
+     * Allocate a connection
+     */
+    connection = OI_Calloc(sizeof(*connection));
+    if (!connection) {
+        status = OI_STATUS_NO_RESOURCES;
+        goto RejectConnection;
+    }
+    /*
+     * Associate OPP connection with the OPP server and underlying OBEX connection
+     */
+    OI_OBEXSRV_SetConnectionContext(connectionId, connection);
+    connection->obexHandle = connectionId;
+    connection->server = server;
+    SetState(connection, OPP_SERVER_CONNECTING);
+    /*
+     * If the application wants to know about connection indications
+     * call the connect indication callback, otherwise simply accept the
+     * connection.
+     */
+    status = OI_OBEXSRV_GetClientAddr(connectionId, &clientAddr);
+    if (OI_SUCCESS(status)) {
+        OI_L2CAP_CID cid;
+        /*
+         * Register OPP connection with the AMP policy manager
+         */
+        status = OI_OBEXSRV_GetL2capCID(connectionId, &cid);
+
+        if (server->callbacks->connectInd) {
+            /*
+             * Pass address of connecting client to application.
+             */
+            server->callbacks->connectInd(&clientAddr, connectionId);
+        } else {
+            status = OI_OPP_AcceptConnect(connectionId, TRUE, TRUE);
+            if (!OI_SUCCESS(status)) {
+                goto RejectConnection;
+            }
+        }
+    } else {
+        goto RejectConnection;
+    }
+    return;
+
+RejectConnection:
+
+    if (connection) {
+        /*
+         * Dissociate OPP connection from the OBEX connection handle
+         */
+        OI_OBEXSRV_SetConnectionContext(connectionId, NULL);
+        OI_Free(connection);
+    }
+    (void) OI_OBEXSRV_AcceptConnect(connectionId, FALSE, status, NULL);
+}
+
+
+static void ServerDisconnectInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+    OI_DBGTRACE(("ServerDisconnectInd connectionId:%#x", connectionId));
+
+    if (!connection) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_HANDLE, ("Disconnect for invalid handle"));
+        return;
+    }
+    /*
+     * If close is already pending on the dispatcher cancel it.
+     */
+    if (connection->closeCB) {
+        OI_Dispatch_CancelFunc(connection->closeCB);
+    }
+    /*
+     * Status to be reported to OFS and app depends on whether we're idle or pushing/pulling
+     */
+    ObjectClose(connection, TRUE, connection->state > OPP_SERVER_CONNECTED? OI_OBEX_NOT_CONNECTED : OI_OK);
+}
+
+
+
+#define MAX_OPP_FORMAT   8
+
+
+static OI_STATUS InitFormatsAttribute(OI_UINT32 formats,
+                                      OI_SDPDB_ATTRIBUTE *supportedFormats)
+{
+    OI_DATAELEM *formatList = NULL;
+    OI_UINT i;
+    OI_UINT numFormats;
+
+    /*
+     * Formats are specified as a bit vector that identifies the supported
+     * object formats.
+     */
+    if (formats == OI_OPP_SERVER_OBJ_FORMAT_ANY) {
+        numFormats = 1;
+        formatList = OI_Malloc(sizeof(OI_DATAELEM));
+        if (formatList == NULL) {
+            return OI_STATUS_OUT_OF_MEMORY;
+        }
+        OI_SET_UINT_ELEMENT(formatList[0], (OI_UINT8) 0xFF);
+    } else {
+        /*
+         * Count how many formats have been specified.
+         */
+        numFormats = 0;
+        for (i = 0; i < MAX_OPP_FORMAT; ++i) {
+            if (formats & (1 << i)) {
+                ++numFormats;
+            }
+        }
+        if (numFormats > 0) {
+            formatList = OI_Malloc(numFormats * sizeof(OI_DATAELEM));
+            if (formatList == NULL) {
+                return OI_STATUS_OUT_OF_MEMORY;
+            }
+            /*
+             * Supported formats are numbered in the range 1 .. MAX_OPP_FORMAT
+             * (in the Bluetooth Specification 1.1 OPP spec this is 1..6)
+             */
+            numFormats = 0;
+            for (i = 0; i < MAX_OPP_FORMAT; ++i) {
+                if (formats & (1 << i)) {
+                    OI_SET_UINT_ELEMENT(formatList[numFormats], (OI_UINT8) (i + 1));
+                    ++numFormats;
+                }
+            }
+        }
+    }
+    /*
+     * Initialize attribute with the formats element list.
+     */
+    if (numFormats == 0) {
+        OI_SET_EMPTY_LIST_ELEMENT(supportedFormats->Element, OI_DATAELEM_SEQ);
+    } else {
+        OI_SET_LIST_ELEMENT(supportedFormats->Element, OI_DATAELEM_SEQ, formatList[0], numFormats);
+    }
+    supportedFormats->Id = OI_ATTRID_SupportedFormatsList;
+    return OI_OK;
+}
+
+
+static void ServerProgressInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                              OI_UINT8 cmd,
+                              OI_UINT32 progress)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(connectionId);
+    if (connection != NULL) {
+        OI_OPP_SERVER_EVENT_DATA eventData;
+
+        OI_DBGTRACE(("%s progress %d", cmd == OI_OBEX_CMD_PUT ? "PUT" : "GET", progress));
+
+        if (connection->server->callbacks->eventInd) {
+            eventData.event = (cmd == OI_OBEX_CMD_PUT) ? OI_OPP_SERVER_EVENT_PUSH_PROGRESS : OI_OPP_SERVER_EVENT_PULL_PROGRESS;
+            eventData.data.pushProgress.bytesTransferred = progress;
+            connection->server->callbacks->eventInd(connectionId, &eventData);
+        }
+    }
+}
+
+
+OI_STATUS OI_OPPServer_Register(const OI_OPP_SERVER_CALLBACKS *callbacks,
+                                const OI_OPP_OBJSYS_FUNCTIONS *objectOperations,
+                                OI_OPP_SERVER_OBJECT_FORMATS   supportedFormats,
+                                const OI_SDP_STRINGS          *strings,
+                                OI_OPP_SERVER_HANDLE          *serverInstance)
+{
+    static const OI_OBEXSRV_CB_LIST CBList = {
+        ServerConnectInd,
+        ServerDisconnectInd,
+        ObjPullInd,
+        ObjPushInd,
+        NULL,   /* no setpath */
+        NULL,   /* no bulk get indication */
+        NULL,   /* No action commands */
+        ServerProgressInd,
+        NULL,
+        NULL
+    };
+    OI_STATUS status;
+    OI_SDPDB_SERVICE_RECORD srec;
+    OPP_SERVER *server;
+    OI_OBEX_CONNECTION_OPTIONS connOpts;
+    OI_OBEX_LOWER_PROTOCOL lowerProtocol[2];
+    OI_UINT numProtocols = 0;
+
+    OI_DBGTRACE(("OI_OPPServer_Register"));
+
+    OI_ARGCHECK(callbacks);
+    /*
+     * connectInd and disconnectInd must be both NULL or both non-NULL
+     */
+    OI_ARGCHECK((callbacks->connectInd == NULL) == (callbacks->disconnectInd == NULL));
+
+    server = OI_Calloc(sizeof(OPP_SERVER));
+    if (server == NULL) {
+        status = OI_STATUS_NO_RESOURCES;
+        goto ErrorExit;
+    }
+
+    if (objectOperations->OpenRead) {
+        OI_ARGCHECK(objectOperations->Read);
+    }
+    if (objectOperations->OpenWrite) {
+        OI_ARGCHECK(objectOperations->Write);
+    }
+    OI_ARGCHECK(objectOperations->Close);
+
+    /*
+     * Store connect and disconnect indication callbacks.
+     */
+    server->callbacks = callbacks;
+    server->objops = objectOperations;
+
+    /*
+     * Try and get the preferred OPP channel number.
+     */
+    lowerProtocol[numProtocols].protocol = OI_OBEX_LOWER_RFCOMM;
+    lowerProtocol[numProtocols].svcId.rfcommChannel = OI_CONFIG_TABLE_GET(OPP_SRV)->rfcomm_channel_pref;
+    ++numProtocols;
+    lowerProtocol[numProtocols].protocol = OI_OBEX_LOWER_L2CAP;
+    lowerProtocol[numProtocols].svcId.l2capPSM = OI_CONFIG_TABLE_GET(OPP_SRV)->l2cap_psm_pref;
+    ++numProtocols;
+    OI_DBGTRACE(("Listening on %d RFCOMM SCN, and %d L2CAP PSM",
+        OI_CONFIG_TABLE_GET(OPP_SRV)->rfcomm_channel_pref,
+        OI_CONFIG_TABLE_GET(OPP_SRV)->l2cap_psm_pref));
+
+    /*
+     * We allow SRM for OPP
+     */
+    connOpts.enableSRM = TRUE;
+    status = OI_OBEXSRV_RegisterServer(NULL, &CBList, OI_OBEXSRV_AUTH_NONE, &connOpts,
+        lowerProtocol, numProtocols, &connectPolicy, &server->serverHandle);
+    if (!OI_SUCCESS(status)) {
+        goto ErrorExit;
+    }
+
+    /*
+     * Register service record
+     */
+    srec.Attributes = ServiceDescription;
+    srec.NumAttributes = OI_ARRAYSIZE(ServiceDescription);
+    srec.Strings = strings->attrs;
+    srec.NumStrings = strings->num;
+
+    /*
+     * Initialize supported formats attribute list.
+     */
+    OI_ASSERT(server->numAttributes < OI_ARRAYSIZE(server->sdpAttributes));
+    server->supportedFormats = supportedFormats;
+    status = InitFormatsAttribute(supportedFormats, &server->sdpAttributes[server->numAttributes]);
+    ++server->numAttributes;
+    if (!OI_SUCCESS(status)) {
+        goto ErrorExit;
+    }
+
+    OI_DBGTRACE(("Registered Object Push Profile"));
+
+    OI_INIT_FLAG_INCREMENT(OPP_SRV);
+    /*
+     * Associated FTP server with the OBEX server
+     */
+    OI_OBEXSRV_SetServerContext(server->serverHandle, server);
+    /*
+     * Return the server instance handle to the caller
+     */
+    *serverInstance = server->serverHandle;
+
+    return OI_OK;
+
+ErrorExit:
+
+    OI_LOG_ERROR(("OI_OPPServer_Register failed %d", status));
+
+    if (server) {
+        if (server->serverHandle) {
+            (void) OI_OBEXSRV_DeregisterServer(server->serverHandle);
+        }
+        OI_Free(server);
+    }
+
+    return status;
+}
+
+
+OI_STATUS OI_OPPServer_Deregister(OI_OPP_SERVER_HANDLE serverInstance)
+{
+    OPP_SERVER *server = LookupServer(serverInstance);
+    OI_STATUS status;
+
+    OI_DBGTRACE(("OI_OPPServer_Deregister"));
+
+    if (!OI_INIT_FLAG_VALUE(OPP_SRV)) {
+        return OI_STATUS_NOT_REGISTERED;
+    }
+    if (!server) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+    status = OI_OBEXSRV_DeregisterServer(server->serverHandle);
+    if (!OI_SUCCESS(status)) {
+        OI_LOG_ERROR(("Error deregistering OPP server %d", status));
+    } else {
+        OI_Free(server);
+        OI_INIT_FLAG_DECREMENT(OPP_SRV);
+    }
+    return status;
+}
+
+
+OI_STATUS OI_OPPServer_GetServiceRecord(OI_OPP_SERVER_HANDLE serverInstance,
+                                        OI_UINT32 *handle)
+{
+    OPP_SERVER *server = LookupServer(serverInstance);
+
+    OI_CHECK_INIT(OPP_SRV);
+
+    if (!server) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+    *handle = server->srecHandle;
+    return OI_OK;
+}
+
+
+OI_STATUS OI_OPPServer_AcceptPush(OI_OPP_SERVER_CONNECTION_HANDLE connectionId,
+                                  OI_OBEX_UNICODE                *objname,
+                                  OI_BOOL                         accept)
+{
+    OPPSRV_CONNECTION *connection = LookupConnection(connectionId);
+
+    if (!connection) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+    if (connection->state != OPP_PUSH_PENDING) {
+        return OI_STATUS_INVALID_STATE;
+    }
+    if (!connection->ofsAcceptPending) {
+        return OI_STATUS_INVALID_STATE;
+    }
+    connection->ofsAcceptPending = FALSE;
+    if (accept) {
+        OI_STATUS status;
+        connection->ofsCfmPending = TRUE;
+        if (objname) {
+            status = connection->server->objops->OpenWrite(objname,
+                                                           (OI_CHAR*) connection->rcvObj.type.data,
+                                                           connection->rcvObj.objSize,
+                                                           PushOpenCfm,
+                                                           connection->obexHandle);
+        } else {
+            status = connection->server->objops->OpenWrite(&connection->rcvObj.name,
+                                                           (OI_CHAR*) connection->rcvObj.type.data,
+                                                           connection->rcvObj.objSize,
+                                                           PushOpenCfm,
+                                                           connection->obexHandle);
+        }
+        if (!OI_SUCCESS(status)) {
+            /*
+             * If file could not be opened, return failure to remote device,
+             * and cleanup state. This mimics the behavior of a reject.
+             */
+            connection->ofsCfmPending = FALSE;
+            SetState(connection, OPP_SERVER_CONNECTED);
+            OI_FreeIf(&connection->rcvObj.name.str);
+            OI_FreeIf(&connection->rcvObj.type.data);
+            OI_MemZero(&connection->rcvObj, sizeof(OI_OPP_GENERIC_OBJECT));
+            OI_OBEXSRV_PutResponse(connectionId, NULL, OI_OBEX_ACCESS_DENIED);
+        }
+        return status;
+    } else {
+        connection->ofsCfmPending = FALSE;
+        SetState(connection, OPP_SERVER_CONNECTED);
+        OI_FreeIf(&connection->rcvObj.name.str);
+        OI_FreeIf(&connection->rcvObj.type.data);
+        OI_MemZero(&connection->rcvObj, sizeof(OI_OPP_GENERIC_OBJECT));
+        return OI_OBEXSRV_PutResponse(connectionId, NULL, OI_OBEX_ACCESS_DENIED);
+    }
+}
diff --git a/obex_profiles/profiles/pbap/oi_pbap_private.h b/obex_profiles/profiles/pbap/oi_pbap_private.h
new file mode 100644
index 0000000..09fc105
--- /dev/null
+++ b/obex_profiles/profiles/pbap/oi_pbap_private.h
@@ -0,0 +1,89 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+*/
+
+/** \addtogroup PBAP_Internal */
+/**@{*/
+
+#ifndef _OI_PBAP_PRIVATE_H
+#define _OI_PBAP_PRIVATE_H
+
+
+
+/* Application Parameter sizes */
+#define OI_PBAP_APP_PARAM_HEADER_SIZE           (sizeof(OI_UINT8) + sizeof(OI_UINT8))
+#define OI_PBAP_APP_PARAM_ORDER_SIZE            (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT8))
+#define OI_PBAP_APP_PARAM_SEARCHVALUE_SIZE(l)   (OI_PBAP_APP_PARAM_HEADER_SIZE + (l))
+#define OI_PBAP_APP_PARAM_SEARCHATTRIBUTE_SIZE  (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT8))
+#define OI_PBAP_APP_PARAM_MAXLISTCOUNT_SIZE     (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT16))
+#define OI_PBAP_APP_PARAM_LISTSTARTOFFSET_SIZE  (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT16))
+#define OI_PBAP_APP_PARAM_FILTER_SIZE           (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT64))
+#define OI_PBAP_APP_PARAM_FORMAT_SIZE           (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT8))
+#define OI_PBAP_APP_PARAM_PHONBOOKSIZE_SIZE     (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT16))
+#define OI_PBAP_APP_PARAM_NEWMISSEDCALLS_SIZE   (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT8))
+#define OI_PBAP_APP_PARAM_SUPP_FEATURE_SIZE     (OI_PBAP_APP_PARAM_HEADER_SIZE + sizeof(OI_UINT32))
+
+#define OI_PBAP_MAX_PBAP_PATH_SIZE 32
+
+
+extern const OI_CHAR16 OI_PBAP_usim1[];
+extern const OI_CHAR16 OI_PBAP_utelecom[];
+extern const OI_CHAR16 OI_PBAP_vcf[];
+extern const OI_CHAR16 * OI_PBAP_upbdirs[];
+extern const OI_UINT16 OI_PBAP_upbdirsizes[];
+
+
+#ifdef OI_DEBUG
+/**
+ * OI_PBAP_DumpObexHeaders()
+ *
+ * Helper debug function for nicely displaying OBEX headers relevant to PBAP.
+ */
+extern void OI_PBAP_DumpObexHeaders(const OI_OBEX_HEADER_LIST *hdrList);
+
+#else
+
+/**
+ * The following macro is a placeholder when building non-debug mode code.
+ */
+#define OI_PBAP_DumpObexHeaders(p) do {} while(0)
+
+#endif
+
+
+
+
+
+#endif
+/**@}*/
diff --git a/obex_profiles/profiles/pbap/pbap_client.c b/obex_profiles/profiles/pbap/pbap_client.c
new file mode 100644
index 0000000..b9d81e8
--- /dev/null
+++ b/obex_profiles/profiles/pbap/pbap_client.c
@@ -0,0 +1,1868 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ * @internal
+ * Phone Book Access Profile client
+ */
+
+#define __OI_MODULE__ OI_MODULE_PBAP_CLI
+
+#include "oi_bt_assigned_nos.h"
+#include "oi_pbap_client.h"
+#include "oi_dispatch.h"
+#include "oi_std_utils.h"
+#include "oi_memmgr.h"
+#include "oi_pbap_sys.h"
+#include "oi_obexcli.h"
+#include "oi_argcheck.h"
+#include "oi_assert.h"
+#include "oi_sdpdb.h"
+#include "oi_sdp_utils.h"
+#include "oi_bytestream.h"
+#include "oi_unicode.h"
+
+#include "oi_debug.h"
+
+#include "oi_init_flags.h"
+#include "oi_config_table.h"
+#include "oi_bt_profile_config.h"
+
+#include "oi_pbap_private.h"
+
+
+/**
+ * These are the various client connection states.
+ */
+typedef enum {
+    CLIENT_STATE_DISCONNECTED,
+    CLIENT_STATE_AUTHENTICATING,
+    CLIENT_STATE_CONNECTED,
+    CLIENT_STATE_PULLING_VCARD,
+    CLIENT_STATE_PULLING_PHONEBOOK,
+    CLIENT_STATE_PULLING_PHONEBOOK_SIZE,
+    CLIENT_STATE_PULLING_VCARD_LISTING,
+    CLIENT_STATE_ABORTING
+} PBAP_CLIENT_STATE;
+
+
+/****************************************************************
+ *
+ * Service record
+ *
+ ****************************************************************/
+
+static OI_UINT32 srecHandle;
+
+/** service class ID list */
+static const OI_DATAELEM ServiceClassIDList[] = {
+    OI_ELEMENT_UUID32(OI_UUID_PhonebookAccessClient)
+};
+
+/* profile descriptor list */
+static const OI_DATAELEM Profile0[] = {
+    OI_ELEMENT_UUID32(OI_UUID_PhonebookAccess),
+    OI_ELEMENT_UINT16(0x0100) //version 1.0
+};
+
+static const OI_DATAELEM ProfileDescriptorList[] = {
+    OI_ELEMENT_SEQ(Profile0)
+};
+
+/** SDP attribute lists */
+static const OI_SDPDB_ATTRIBUTE ServiceDescription[] = {
+    { OI_ATTRID_ServiceClassIDList,                   OI_ELEMENT_SEQ(ServiceClassIDList) },
+    { OI_ATTRID_BluetoothProfileDescriptorList,       OI_ELEMENT_SEQ(ProfileDescriptorList) }
+};
+
+
+typedef struct _PBAP_CLIENT PBAP_CLIENT;
+
+/* Stucture for tracking the currently selected path and destination path. */
+typedef void(*PBAP_SET_PATH_DONE)(PBAP_CLIENT *client, OI_STATUS status);
+
+typedef struct {
+    OI_PBAP_REPOSITORY currRepo;
+    OI_PBAP_PHONEBOOK currPb;
+    OI_BOOL inTelecom;
+    OI_PBAP_REPOSITORY destRepo;
+    OI_PBAP_PHONEBOOK destPb;
+    PBAP_SET_PATH_DONE SetPathDone;
+} PBAP_PATH_STATE;
+
+/* Get request parameters. */
+typedef struct {
+    OI_PBAP_REPOSITORY repo;                            /**< Repository containing desired information */
+    OI_PBAP_PHONEBOOK pb;                               /**< Phonebook containing desired information */
+    OI_UINT32 entry;                                    /**< Desired Phonebook entry (if applicable) */
+    const OI_CHAR *type;                                /**< Type of get request. */
+    OI_UINT16 typeLen;                                  /**< Length of Type string. */
+    OI_BYTE *appParam;                                  /**< Byte array of the application paramters */
+    OI_UINT16 appParamLen;                              /**< Length of the application parameter byte array */
+    OI_CHAR16 pathStr[OI_PBAP_MAX_PBAP_PATH_SIZE];      /**< Unicode pathname of desired object */
+    OI_UINT16 pathStrLen;                               /**< Length of the pathname */
+    union {
+        OI_PBAP_CLIENT_PULL_PHONEBOOK_CB pullPb;        /**< Pull phonebook callback */
+        OI_PBAP_CLIENT_GET_PHONEBOOK_SIZE_CB getSize;   /**< Pull phonebook size callback */
+        OI_PBAP_CLIENT_PULL_VCARD_LISTING_CB pullList;  /**< Pull listing callback */
+        OI_PBAP_CLIENT_PULL_VCARD_ENTRY_CB pullVCard;   /**< Pull vCard Entry callback */
+        OI_PBAP_CLIENT_SETPATH_CB setPath;              /**< Set Path callback */
+    } cb;
+    struct {
+        OI_UINT16 phonebookSize;                        /**< Total number of entries in the phonebook */
+        OI_UINT8  newMissedCalls;                       /**< Number of newly missed calls */
+    } results;
+
+} PBAP_GET_REQ;
+
+/**
+ * Struct for an PBAP client connection.
+ */
+struct _PBAP_CLIENT {
+    OI_OBEXCLI_CONNECTION_HANDLE id;                   /**< The underlying OBEX client connection */
+    PBAP_CLIENT_STATE state;                           /**< state of this pbap conntection */
+
+    PBAP_PATH_STATE pathState;                         /**< Which path is currently set */
+
+    OI_PBAP_CONNECTION_CFM connectionCfm;              /**< Connect complete callback */
+    OI_PBAP_DISCONNECTION_IND disconnectInd;           /**< Disconnect indication callback */
+    OI_PBAP_CLIENT_AUTHENTICATION_CB authenticationCB; /**< Callback function to get authentication information */
+    OI_PBAP_ABORT_CFM abortCfm;                        /**< Abort complete callback */
+
+    const OI_PBAP_CLIENT_FILESYS_FUNCTIONS *fops;      /**< File operations required by the client */
+    OI_PBAP_HANDLE fh;                                 /**< File handle for use with file operations */
+    OI_BOOL fileOpen;                                  /**< Boolean indicating if file is opened */
+
+    DISPATCH_CB_HANDLE dispatchHandle;                 /**< Set repository/phonebook complete has been registered with the dispatcher */
+
+    PBAP_GET_REQ req;                                  /**< GET request info */
+    OI_BOOL disconnected;
+    OI_BOOL final;
+    OI_BOOL fileOpCfmPending;
+};
+
+/**
+ * Connection policy.
+ */
+static const OI_CONNECT_POLICY  connectPolicy =
+{
+    OI_ELEMENT_UUID32(OI_UUID_PhonebookAccessClient),     /* OI_DATAELEM         serviceUuid           */
+    FALSE,                              /* OI_BOOL             mustBeMaster          */
+    NULL,                               /* OI_L2CAP_FLOWSPEC   *flowspec;            */
+    0                                   /* OI_UINT8            powerSavingDisables ; */
+};
+
+#define IS_CLIENT_CONNECTED (OI_INIT_FLAG_VALUE(PBAP_CLI) && (client) && (client->state >= CLIENT_STATE_CONNECTED))
+
+/**
+ * Helper macro to get the Bip Client pointer from the OBEX connection handle
+ */
+#define PbapClient(c) ((PBAP_CLIENT*)OI_OBEXCLI_GetConnectionContext((OI_OBEXCLI_CONNECTION_HANDLE)(c)))
+
+
+#if defined(OI_DEBUG)
+/**
+ * ClientStateText()
+ *
+ * Helper function to convert the state to a human readable string for printing.
+ */
+static const OI_CHAR *ClientStateText(PBAP_CLIENT_STATE state)
+{
+    switch (state) {
+    case CLIENT_STATE_DISCONNECTED:           return "CLIENT_STATE_DISCONNECTED";
+    case CLIENT_STATE_AUTHENTICATING:         return "CLIENT_STATE_AUTHENTICATING";
+    case CLIENT_STATE_CONNECTED:              return "CLIENT_STATE_CONNECTED";
+    case CLIENT_STATE_PULLING_VCARD:          return "CLIENT_STATE_PULLING_VCARD";
+    case CLIENT_STATE_PULLING_PHONEBOOK:      return "CLIENT_STATE_PULLING_PHONEBOOK";
+    case CLIENT_STATE_PULLING_PHONEBOOK_SIZE: return "CLIENT_STATE_PULLING_PHONEBOOK_SIZE";
+    case CLIENT_STATE_PULLING_VCARD_LISTING:  return "CLIENT_STATE_PULLING_VCARD_LISTING";
+    case CLIENT_STATE_ABORTING:               return "CLIENT_STATE_ABORTING";
+    }
+    return "<unknown state>";
+}
+
+/**
+ * setState()
+ *
+ * Helper macro for setting the state.  (Written as a macro so that the
+ * OI_DBPRINT() reports the line in the function where the state changed
+ * rather than the line in setState().
+ */
+#define setState(_client, _newState)                    \
+    do {                                                \
+        OI_DBG_PRINT1(("PBAP Client state %s ==> %s\n",      \
+                     ClientStateText((_client)->state), \
+                     ClientStateText(_newState)));      \
+        (_client)->state = (_newState);                 \
+    } while (0)
+#else
+/**
+ * ClientStateText()
+ *
+ * Empty definition of above incase it is used by non-debug code.
+ */
+#define ClientStateText(state) ""
+
+/**
+ * setState()
+ *
+ * Non-debug version of the setState() macro.
+ */
+#define setState(_client, _newState)            \
+    do {                                        \
+        (_client)->state = (_newState);         \
+    } while (0);
+#endif
+
+/**
+ * VALIDATE_CFM_STATE()
+ *
+ * This macro validates that a confirm callback is pending and that we are in
+ * the correct state for this confirm.
+ */
+#define VALIDATE_CFM_STATE(_fn, _client, _state_test)                   \
+    do {                                                                \
+        if (!OI_INIT_FLAG_VALUE(PBAP_CLI) ||                            \
+            !(_client) ||                                               \
+            !(_state_test) ||                                           \
+            !(_client)->fileOpCfmPending) {                             \
+            OI_SLOG_ERROR(OI_STATUS_NONE,                               \
+                          ("%s() called at wrong time (state %s valid? %d; confirm pending? %d)", \
+                           (_fn), ClientStateText((_client)->state),    \
+                           (_state_test),                               \
+                           ((_client)->fileOpCfmPending)));             \
+            return;                                                     \
+        }                                                               \
+        (_client)->fileOpCfmPending = FALSE;                            \
+        if ((_client)->disconnected) {                                  \
+            OI_DBG_PRINT2(("Closing file %x\n", (_client)->fh));     \
+            FileClose((_client), OI_OBEX_NOT_CONNECTED);                \
+            return;                                                     \
+        }                                                               \
+    } while (0)
+
+
+/***********************************************************************
+ *
+ * Deferred close
+ *
+ ***********************************************************************/
+
+typedef struct {
+    PBAP_CLIENT *client;
+    OI_STATUS status;
+} CLOSE_INFO;
+
+/**
+ * FileCloseCB()
+ *
+ * This Dispatcher callback closes any open file handles related to the most
+ * recent action and performs the final clean up steps for that action.
+ */
+static void FileCloseCB(DISPATCH_ARG *darg)
+{
+    CLOSE_INFO *info = Dispatch_GetPointerFromArg(darg, CLOSE_INFO);
+    PBAP_CLIENT *client;
+    PBAP_CLIENT_STATE snapState;
+
+    OI_TRACE_USER(("FileCloseCB(<*darg = %x>)", darg));
+    OI_DBG_PRINT2(("darg => status: %d\n", info->status));
+
+    client = info->client;
+    snapState = client->state;
+
+    client->dispatchHandle = 0;
+
+    if (client->disconnected) {
+        setState(client, CLIENT_STATE_DISCONNECTED);
+    } else  {
+        setState(client, CLIENT_STATE_CONNECTED);
+    }
+
+    OI_FreeIf(&client->req.appParam);
+
+    if (client->fileOpen) {
+        OI_PBAP_HANDLE handle = client->fh;
+
+        client->fh = 0;
+        OI_TRACE_USER(("Calling close(<*handle = %x>, id = %d, status = %d)",
+                          handle, (OI_PBAP_CONNECTION)client->id, info->status));
+        client->fops->close(handle, (OI_PBAP_CONNECTION)client->id, info->status);
+        client->fileOpen = FALSE;
+    }
+
+    switch (snapState) {
+    case CLIENT_STATE_PULLING_VCARD:
+        client->req.cb.pullVCard(client->id, info->status);
+        break;
+
+    case CLIENT_STATE_PULLING_PHONEBOOK:
+        client->req.cb.pullPb(client->id, client->req.results.newMissedCalls, info->status);
+        break;
+
+    case CLIENT_STATE_PULLING_PHONEBOOK_SIZE:
+        client->req.cb.getSize(client->id, client->req.results.phonebookSize, info->status);
+        break;
+
+    case CLIENT_STATE_PULLING_VCARD_LISTING:
+        client->req.cb.pullList(client->id, client->req.results.newMissedCalls, info->status);
+        break;
+
+    default:
+        break;
+    }
+
+    /* If disconnected, tell the application and re-initialize ourselves */
+    if (client->disconnected) {
+        OI_PBAP_CONNECTION id = (OI_PBAP_CONNECTION)client->id;
+        OI_PBAP_DISCONNECTION_IND disconnectInd = client->disconnectInd;
+
+        OI_Free(client);
+
+        disconnectInd(id);
+
+        OI_INIT_FLAG_PUT_FLAG(FALSE, PBAP_CLI);
+    }
+}
+
+/**
+ * FileClose()
+ *
+ * Sets up to close the open file handle and clean up from the operation on
+ * the Dispatcher when it is safe to do so.
+ */
+static void FileClose(PBAP_CLIENT *client, OI_STATUS status)
+{
+    DISPATCH_ARG darg;
+    CLOSE_INFO info;
+
+    OI_TRACE_USER(("FileClose(<*client = %x>, status = %d)", client, status));
+
+    info.client = client;
+    info.status = status;
+
+    Dispatch_SetArg(darg, info);
+    (void) OI_Dispatch_RegisterFunc(FileCloseCB, &darg, &client->dispatchHandle);
+}
+
+
+/************************************************************************
+ *
+ * PBAP path utility functions
+ *
+ ************************************************************************/
+
+/**
+ * BuildRepoPathName()
+ *
+ * This function builds the base part of a full path name to some PBAP entity
+ * from the root directory if the current directory is the root directory.
+ * Otherwise it returns an empty string.  It depends on *buf having ample room
+ * for "SIM1/telecom".
+ */
+static OI_INT BuildRepoPathName(PBAP_PATH_STATE *pstate,
+                                OI_PBAP_REPOSITORY repo,
+                                OI_CHAR16 *buf)
+{
+    OI_INT len = 0;
+    OI_INT plen;
+
+    OI_TRACE_USER(("BuildRepoPathName(<*pstate = %x>, repo = %d, <*buf = %x>)",
+                          pstate, repo, buf));
+
+    if ((pstate->currRepo == OI_PBAP_LOCAL_REPOSITORY) && (repo == OI_PBAP_SIM1_REPOSITORY)) {
+        plen = OI_StrLenUtf16(OI_PBAP_usim1) + 1;  /* Count the nul terminator too. */
+        OI_MemCopy(buf, OI_PBAP_usim1, plen * sizeof(OI_CHAR16));
+        len += plen;
+    }
+
+    if (!pstate->inTelecom) {
+        if (len > 0) {
+            buf[len - 1] = '/';
+        }
+
+        plen = OI_StrLenUtf16(OI_PBAP_utelecom) + 1;  /* Count the nul terminator too. */
+        OI_MemCopy(&buf[len], OI_PBAP_utelecom, plen * sizeof(OI_CHAR16));
+        len += plen;
+    }
+
+    OI_DBG_PRINT2(("Path = \"%s\"", buf, len));
+
+    return len;
+}
+
+/**
+ * BuildPbDirPathName()
+ *
+ * This function builds the full path name to a phonebook directory starting
+ * from the current directory.  It depends on *buf having ample room for
+ * "SIM1/telecom/ich".
+ */
+static OI_INT BuildPbDirPathName(PBAP_PATH_STATE *pstate,
+                                 OI_PBAP_REPOSITORY repo,
+                                 OI_PBAP_PHONEBOOK pb,
+                                 OI_CHAR16 *buf)
+{
+    OI_INT len = 0;
+
+    OI_TRACE_USER(("BuildPbDirPathName(<*pstate = %x>, repo = %d, pb = %d, <*buf = %x>)",
+                          pstate, repo, pb, buf));
+
+    if (pstate->currPb == OI_PBAP_INVALID_PHONEBOOK) {
+        len += BuildRepoPathName(pstate, repo, buf);
+
+        if (len > 0) {
+            buf[len - 1] = '/';
+        }
+
+        OI_MemCopy(&buf[len], OI_PBAP_upbdirs[pb], OI_PBAP_upbdirsizes[pb] * sizeof(OI_CHAR16));
+        len += OI_PBAP_upbdirsizes[pb];
+    }
+
+    OI_DBG_PRINT2(("Path = \"%s\"", buf, len));
+
+    return len;
+}
+
+/**
+ * BuildPbVCardPathName()
+ *
+ * This function builds the full path name to a phonebook vCard starting from
+ * the current directory.  It depends on *buf having ample room for
+ * "SIM1/telecom/ich.vcf".
+ */
+static OI_INT BuildPbVCardPathName(PBAP_PATH_STATE *pstate,
+                                   OI_PBAP_REPOSITORY repo,
+                                   OI_PBAP_PHONEBOOK pb,
+                                   OI_CHAR16 *buf)
+{
+    OI_INT len = 0;
+    OI_INT plen;
+
+    OI_TRACE_USER(("BuildPbVCardPathName(<*pstate = %x>, repo = %d, pb = %d, <*buf = %x>)",
+                          pstate, repo, pb, buf));
+
+    len += BuildPbDirPathName(pstate, repo, pb, buf) - 1;
+
+    plen = OI_StrLenUtf16(OI_PBAP_usim1) + 1;  /* Count the nul terminator too. */
+    OI_MemCopy(&buf[len], OI_PBAP_vcf, plen * sizeof(OI_CHAR16));
+    len += plen;
+
+    OI_DBG_PRINT2(("Path = \"%s\"\n", buf, len));
+
+    return len;
+}
+
+/**
+ * BuildVCardPathName()
+ *
+ * This function builds the full path name to a specific vCard starting from
+ * the current directory.  It depends on *buf having ample room for
+ * "SIM1/telecom/ich/65535.vcf".
+ */
+static OI_INT BuildVCardPathName(PBAP_PATH_STATE *pstate,
+                                 OI_PBAP_REPOSITORY repo,
+                                 OI_PBAP_PHONEBOOK pb,
+                                 OI_UINT32 entry,
+                                 OI_CHAR16 *buf)
+{
+    OI_INT len;
+    OI_INT baseLen;
+    OI_UINT8 digit;
+    OI_UINT32 i;
+    OI_INT plen;
+
+    OI_TRACE_USER(("BuildVCardPathName(<*pstate = %x>, repo = %d, pb = %d, entry = %d, <*buf = %x>)",
+                          pstate, repo, pb, entry, buf));
+
+    len = BuildPbDirPathName(pstate, repo, pb, buf);
+
+    if (len > 0) {
+        buf[len - 1] = '/';
+    }
+    baseLen = len;
+
+    for (i = 0x10000000; i > 0; i /= 16) {
+        digit = (OI_UINT8)(entry / i);
+        entry -= digit * i;
+
+        if ((digit >= 10) && (digit <= 16)) {
+
+            buf[len++] = (digit - 10) + 'A';
+
+        } else if ((1==i) || (digit > 0) || (len > baseLen)) {
+            /* (digit > 0) || (len > baseLen) check eliminates leading zeros. */
+            /* 1==i check is for 0.vcf. */
+            buf[len++] = digit + '0';
+        }
+    }
+    plen = OI_StrLenUtf16(OI_PBAP_usim1) + 1;  /* Count the nul terminator too. */
+    OI_MemCopy(&buf[len], OI_PBAP_vcf, plen * sizeof(OI_CHAR16));
+    len += plen;
+
+    OI_DBG_PRINT2(("Path = \"%s\"\n", buf, len));
+
+    return len;
+}
+
+static void SetPath(PBAP_CLIENT *client,
+                    PBAP_PATH_STATE *pstate);
+
+/**
+ * ToRootDirCfm()
+ *
+ * This is just the SETPATCH CFM callback that gets called when the root
+ * directory is entered.
+ */
+static void ToRootDirCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId, OI_STATUS status)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    PBAP_PATH_STATE *pstate;
+
+    OI_TRACE_USER(("ToRootDirCfm(connectionId = %d, status = %d)",
+                          connectionId, status));
+
+    OI_ASSERT(client);
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("Client lookup failed"));
+        return;
+    }
+
+    pstate = &client->pathState;
+
+    if (OI_SUCCESS(status)) {
+        pstate->currRepo = OI_PBAP_LOCAL_REPOSITORY;
+        pstate->inTelecom = FALSE;
+        pstate->currPb = OI_PBAP_INVALID_PHONEBOOK;
+
+        if (pstate->destRepo == OI_PBAP_INVALID_REPOSITORY) {
+            OI_TRACE_USER(("Calling SetPathDone(<*client = %x>, status = %d)",
+                                  client, status));
+            pstate->SetPathDone(client, status);
+        } else {
+            SetPath(client, pstate);
+        }
+    } else {
+        OI_TRACE_USER(("Calling SetPathDone(<*client = %x>, status = %d)",
+                              client, status));
+        pstate->SetPathDone(client, status);
+    }
+}
+
+/**
+ * ToSim1DirCfm()
+ *
+ * This is just the SETPATCH CFM callback that gets called when the SIM1
+ * directory is entered.
+ */
+static void ToSim1DirCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId, OI_STATUS status)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    PBAP_PATH_STATE *pstate;
+
+    OI_TRACE_USER(("ToSim1DirCfm(connectionId = %d, status = %d)",
+                          connectionId, status));
+
+    OI_ASSERT(client);
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("Client lookup failed"));
+        return;
+    }
+
+    pstate = &client->pathState;
+
+    if (OI_SUCCESS(status)) {
+        pstate->currRepo = OI_PBAP_SIM1_REPOSITORY;
+        pstate->currPb = OI_PBAP_INVALID_PHONEBOOK;
+
+        SetPath(client, pstate);
+    } else {
+        OI_TRACE_USER(("Calling SetPathDone(<*client = %x>, status = %d)",
+                              client, status));
+        pstate->SetPathDone(client, status);
+    }
+}
+
+/**
+ * ToTelecomDirCfm()
+ *
+ * This is just the SETPATCH CFM callback that gets called when the telecom
+ * directory is entered.
+ */
+static void ToTelecomDirCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId, OI_STATUS status)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    PBAP_PATH_STATE *pstate;
+
+    OI_TRACE_USER(("ToTelecomDirCfm(connectionId = %d, status = %d)",
+                          connectionId, status));
+
+    OI_ASSERT(client);
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("Client lookup failed"));
+        return;
+    }
+
+    pstate = &client->pathState;
+
+    if (OI_SUCCESS(status)) {
+        pstate->inTelecom = TRUE;
+        pstate->currPb = OI_PBAP_INVALID_PHONEBOOK;
+
+        SetPath(client, pstate);
+    } else {
+        OI_TRACE_USER(("Calling SetPathDone(<*client = %x>, status = %d)",
+                              client, status));
+        pstate->SetPathDone(client, status);
+    }
+}
+
+/**
+ * ToPbDirCfm()
+ *
+ * This is just the SETPATCH CFM callback that gets called when a phonebook
+ * directory is entered.
+ */
+static void ToPbDirCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId, OI_STATUS status)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    PBAP_PATH_STATE *pstate;
+
+    OI_TRACE_USER(("ToPbDirCfm(connectionId = %d, status = %d)",
+                          connectionId, status));
+
+    OI_ASSERT(client);
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("Client lookup failed"));
+        return;
+    }
+
+    pstate = &client->pathState;
+
+    if (OI_SUCCESS(status)) {
+        pstate->currPb = pstate->destPb;
+    }
+    OI_TRACE_USER(("Calling SetPathDone(<*client = %x>, status = %d)",
+                          client, status));
+    pstate->SetPathDone(client, status);
+}
+
+/**
+ * SetPath()
+ *
+ * This function is the brains behind deciding which SETPATH command to send
+ * next to get to the correct directory.
+ */
+static void SetPath(PBAP_CLIENT *client, PBAP_PATH_STATE *pstate)
+{
+    OI_STATUS status = OI_OK;
+    OI_OBEX_UNICODE upath;
+
+    OI_TRACE_USER(("SetPath(<*client = %x>, <*pstate = %x>)", client, pstate));
+
+    if (pstate->destRepo != pstate->currRepo) {
+        if (pstate->currRepo == OI_PBAP_LOCAL_REPOSITORY &&
+            !pstate->inTelecom) {
+            if (pstate->destRepo != OI_PBAP_INVALID_REPOSITORY) {
+                upath.str = (OI_CHAR16*)OI_PBAP_usim1;
+                upath.len = OI_StrLenUtf16(OI_PBAP_usim1) + 1;  /* Count the nul terminator too. */
+                OI_DBG_PRINT2(("dest path: \"%s\"\n", upath.str, upath.len));
+                status = OI_OBEXCLI_SetPath(client->id, &upath, TRUE, FALSE, ToSim1DirCfm, NULL);
+            } else {
+                OI_TRACE_USER(("Calling SetPathDone(<*client = %x>, status = %d)",
+                                      client, status));
+                pstate->SetPathDone(client, status);
+            }
+        } else {
+            OI_DBG_PRINT2(("dest path: <root>\n"));
+            status = OI_OBEXCLI_SetPath(client->id, NULL, TRUE, FALSE, ToRootDirCfm, NULL);
+        }
+    } else {
+        if (!pstate->inTelecom) {
+            upath.str = (OI_CHAR16*)OI_PBAP_utelecom;
+            upath.len = OI_StrLenUtf16(OI_PBAP_utelecom) + 1;  /* Count the nul terminator too. */
+            OI_DBG_PRINT2(("dest path: \"%s\"\n", upath.str, upath.len));
+            status = OI_OBEXCLI_SetPath(client->id, &upath, TRUE, FALSE, ToTelecomDirCfm, NULL);
+        } else {
+            if (pstate->destPb != pstate->currPb) {
+                if (pstate->currPb == OI_PBAP_INVALID_PHONEBOOK) {
+                    upath.str = (OI_CHAR16*)OI_PBAP_upbdirs[pstate->destPb];
+                    upath.len = OI_PBAP_upbdirsizes[pstate->destPb];
+                    OI_DBG_PRINT2(("dest path: \"%s\"\n", upath.str, upath.len));
+                    status = OI_OBEXCLI_SetPath(client->id, &upath, TRUE, FALSE, ToPbDirCfm, NULL);
+                } else {
+                    OI_DBG_PRINT2(("dest path: <up>\n"));
+                    status = OI_OBEXCLI_SetPath(client->id, NULL, TRUE, TRUE, ToTelecomDirCfm, NULL);
+                }
+            } else {
+                OI_TRACE_USER(("Calling SetPathDone(<*client = %x>, status = %d)",
+                                      client, status));
+                pstate->SetPathDone(client, status);
+            }
+        }
+    }
+    if (!OI_SUCCESS(status)) {
+        OI_TRACE_USER(("Calling SetPathDone(<*client = %x>, status = %d)",
+                              client, status));
+        pstate->SetPathDone(client, status);
+    }
+}
+
+/**
+ * SetPhonebookDir()
+ *
+ * This function serves as an entry point for the rest of the PBAP client code
+ * for ensuring that the correct directory is set.
+ */
+static void SetPhonebookDir(PBAP_CLIENT *client,
+                            OI_PBAP_REPOSITORY repo,
+                            OI_PBAP_PHONEBOOK pb,
+                            PBAP_SET_PATH_DONE SetPathDone)
+{
+    PBAP_PATH_STATE *pstate = &client->pathState;
+
+    OI_TRACE_USER(("SetPhonebookDir(<*client = %x>, repo = %d, pb = %d, <SetPathDone = %x>)",
+                          client, repo, pb, SetPathDone));
+
+    pstate->destRepo = repo;
+    pstate->destPb = pb;
+    pstate->SetPathDone = SetPathDone;
+
+    SetPath(client, pstate);
+}
+
+
+/************************************************************************
+ *
+ * Application Parameter handling utility functions
+ *
+ ************************************************************************/
+
+/**
+ * ExtractAppParams()
+ *
+ * This function just abstracts away the code that parses the the GET Response
+ * APPLICATION PARAMETERs.
+ */
+static void ExtractAppParams(PBAP_CLIENT *client, OI_OBEX_HEADER *hdr)
+{
+    OI_BYTE_STREAM bs;
+    OI_UINT8 tagId = 0;
+    OI_UINT8 tagLen = 0;
+    OI_UINT16 bufLen = hdr->val.applicationParams.len;
+
+    ByteStream_Init(bs, hdr->val.applicationParams.data, bufLen);
+    ByteStream_Open(bs, BYTESTREAM_READ);
+
+    while (bufLen) {
+        ByteStream_GetUINT8_Checked(bs, tagId);
+        ByteStream_GetUINT8_Checked(bs, tagLen);
+        bufLen -= 2 * sizeof(OI_UINT8);
+
+        if (tagId == OI_PBAP_TAG_ID_NEW_MISSED_CALLS) {
+            ByteStream_GetUINT8_Checked(bs, client->req.results.newMissedCalls);
+        } else if (tagId == OI_PBAP_TAG_ID_PHONEBOOK_SIZE) {
+            ByteStream_GetUINT16_Checked(bs, client->req.results.phonebookSize, OI_BIG_ENDIAN_BYTE_ORDER);
+        } else {
+            OI_DBG_PRINT2(("Ingnoring unexpected Application Parameter: %d\n", tagId));
+            ByteStream_Skip_Checked(bs, tagLen);
+        }
+        bufLen -= tagLen;
+
+        if(ByteStream_Error(bs)) {
+            OI_LOG_ERROR(("Failed to parse application parameters"));
+            break;
+        }
+    }
+
+    ByteStream_Close(bs);
+}
+
+/**
+ * SetAppParamTagInfo()
+ *
+ * Helper macro to reduce the tedium of setting the tag ID and tag length.
+ */
+#define SetAppParamTagInfo(bs, tagId, tagLen)   \
+    do {                                        \
+        ByteStream_PutUINT8((bs), (tagId));     \
+        ByteStream_PutUINT8((bs), (tagLen));    \
+    } while (0)
+
+/**
+ * BuildAppParams()
+ *
+ * Helper function to build the APPLICATION PARAMETERs.
+ */
+static OI_STATUS BuildAppParams(PBAP_CLIENT *client,
+                                const OI_PBAP_ORDER_TAG_VALUES *order,
+                                const OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES *searchAttribute,
+                                const OI_BYTE *searchValue,
+                                OI_UINT8 searchValueLen,
+                                const OI_UINT16 *listStartOffset,
+                                const OI_UINT16 *maxListCount,
+                                const OI_UINT64 *filter,
+                                const OI_PBAP_FORMAT_TAG_VALUES *format,
+                                const OI_UINT32 *supportedFeatures)
+{
+    OI_BYTE_STREAM bs;
+    OI_UINT16 paramLen = ((order           ? OI_PBAP_APP_PARAM_ORDER_SIZE                       : 0) +
+                          (searchAttribute ? OI_PBAP_APP_PARAM_SEARCHATTRIBUTE_SIZE             : 0) +
+                          (searchValue     ? OI_PBAP_APP_PARAM_SEARCHVALUE_SIZE(searchValueLen) : 0) +
+                          (listStartOffset ? OI_PBAP_APP_PARAM_LISTSTARTOFFSET_SIZE             : 0) +
+                          (maxListCount    ? OI_PBAP_APP_PARAM_MAXLISTCOUNT_SIZE                : 0) +
+                          (filter          ? OI_PBAP_APP_PARAM_FILTER_SIZE                      : 0) +
+                          (format          ? OI_PBAP_APP_PARAM_FORMAT_SIZE                      : 0) +
+                          (supportedFeatures ? OI_PBAP_APP_PARAM_SUPP_FEATURE_SIZE              : 0));
+
+    if (paramLen == 0) {
+        client->req.appParam = NULL;
+        client->req.appParamLen = 0;
+        return OI_OK;
+    }
+
+    client->req.appParam = OI_Malloc(paramLen);
+    if (!client->req.appParam) {
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+
+    ByteStream_Init(bs, client->req.appParam, paramLen);
+    ByteStream_Open(bs, BYTESTREAM_WRITE);
+
+    if (filter) {
+        SetAppParamTagInfo(bs, OI_PBAP_TAG_ID_FILTER, sizeof(OI_UINT64));
+        ByteStream_PutUINT32(bs, filter->I1, OI_BIG_ENDIAN_BYTE_ORDER);
+        ByteStream_PutUINT32(bs, filter->I2, OI_BIG_ENDIAN_BYTE_ORDER);
+    }
+
+    if (format) {
+        SetAppParamTagInfo(bs, OI_PBAP_TAG_ID_FORMAT, sizeof(OI_UINT8));
+        ByteStream_PutUINT8(bs, (OI_UINT8)*format);
+    }
+
+    if (order) {
+        SetAppParamTagInfo(bs, OI_PBAP_TAG_ID_ORDER, sizeof(OI_UINT8));
+        ByteStream_PutUINT8(bs, (OI_UINT8)*order);
+    }
+
+    if (searchValue) {
+        SetAppParamTagInfo(bs, OI_PBAP_TAG_ID_SEARCH_VALUE, searchValueLen);
+        ByteStream_PutBytes(bs, searchValue, searchValueLen);
+
+        if (searchAttribute) {
+            SetAppParamTagInfo(bs, OI_PBAP_TAG_ID_SEARCH_ATTRIBUTE, sizeof(OI_UINT8));
+            ByteStream_PutUINT8(bs, (OI_UINT8)*searchAttribute);
+        }
+    }
+
+    if (listStartOffset) {
+        SetAppParamTagInfo(bs, OI_PBAP_TAG_ID_LIST_START_OFFSET, sizeof(OI_UINT16));
+        ByteStream_PutUINT16(bs, *listStartOffset, OI_BIG_ENDIAN_BYTE_ORDER);
+    }
+
+    if (maxListCount) {
+        SetAppParamTagInfo(bs, OI_PBAP_TAG_ID_MAX_LIST_COUNT, sizeof(OI_UINT16));
+        ByteStream_PutUINT16(bs, *maxListCount, OI_BIG_ENDIAN_BYTE_ORDER);
+    }
+
+    if (supportedFeatures) {
+        SetAppParamTagInfo(bs, OI_PBAP_TAG_ID_SUPP_FEATURES, sizeof(OI_UINT32));
+        ByteStream_PutUINT32(bs, *supportedFeatures, OI_BIG_ENDIAN_BYTE_ORDER);
+    }
+
+    ByteStream_Close(bs);
+    client->req.appParamLen = ByteStream_GetSize(bs);
+
+    return OI_OK;
+}
+
+
+/************************************************************************
+ *
+ * GET Request functions.
+ *
+ ************************************************************************/
+
+static void PbapDataCB(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                       OI_OBEX_HEADER_LIST *rspHeaders,
+                       OI_STATUS rcvStatus);
+
+/**
+ * PullAbortCfm()
+ *
+ * This function handles the abort confirmation resulting from a get/pull error.
+ */
+static void PullAbortCfm(OI_OBEXCLI_CONNECTION_HANDLE connection)
+{
+    PBAP_CLIENT *client = PbapClient(connection);
+
+    if (client == NULL)
+        return;
+
+    OI_TRACE_USER(("PullAbortCfm(connection = %d)", connection));
+    OI_DBG_PRINT2(("Closing file 0x%x\n", client->fh));
+    FileClose(client, OI_OBEX_FILEOP_ERROR);
+}
+
+/**
+ * PbapWriteCfm()
+ *
+ * This function is called by the application to inform the stack of the
+ * success or failure of the write operation.
+ */
+static void PbapWriteCfm(OI_PBAP_HANDLE handle,
+                         OI_STATUS status,
+                         OI_PBAP_CONNECTION pbapConnection)
+{
+    PBAP_CLIENT *client = PbapClient(pbapConnection);
+
+    if (client == NULL)
+        return;
+
+    OI_TRACE_USER(("PbapWriteCfm(<*handle = %x>, status = %d, pbapConnection = %d)",
+                       handle, status, pbapConnection));
+
+    VALIDATE_CFM_STATE("PbapWriteCfm", client,
+                       ((client->state == CLIENT_STATE_PULLING_VCARD) ||
+                        (client->state == CLIENT_STATE_PULLING_PHONEBOOK) ||
+                        (client->state == CLIENT_STATE_PULLING_VCARD_LISTING)));
+
+    if (!client->final) {
+        if (!OI_SUCCESS(status)) {
+            OI_DBG_PRINT1(("File write returned error %d\n", status));
+
+            /*
+             * Let OBEX know we are terminating the GET because of an error.
+             */
+            status = OI_OBEXCLI_Abort(client->id, PullAbortCfm);
+        } else {
+            status = OI_OBEXCLI_Get(client->id, NULL, PbapDataCB, TRUE);
+            if (OI_SUCCESS(status)) {
+                return;
+            }
+            OI_DBG_PRINT1(("OI_OBEXCLI_Get returned error %d\n", status));
+        }
+    }
+
+    if (client->final || !OI_SUCCESS(status)) {
+        OI_DBG_PRINT2(("Closing file 0x%x\n", client->fh));
+        FileClose(client, status);
+    }
+}
+
+/**
+ * PbapDataCB()
+ *
+ * This function handles the GET Response from the PBAP server.  If there is
+ * data to be written to the file handle it will do so.
+ */
+static void PbapDataCB(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                       OI_OBEX_HEADER_LIST *rspHeaders,
+                       OI_STATUS rcvStatus)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    OI_INT i;
+    OI_OBEX_HEADER *hdr;
+    OI_OBEX_HEADER *bodyHdr = NULL;
+    OI_STATUS status;
+
+    OI_TRACE_USER(("PbapDataCB(connectionId = %d, <*rspHeaders = %x>, rcvStatus = %d)",
+                          connectionId, rspHeaders, rcvStatus));
+
+    if (client == NULL)
+        return;
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("PbapDataCB while PBAP not connected"));
+        return;
+    }
+
+    if (OI_SUCCESS(rcvStatus) || rcvStatus == OI_OBEX_CONTINUE) {
+        OI_PBAP_DumpObexHeaders(rspHeaders);
+        for (i = 0; i < rspHeaders->count; i++) {
+            hdr = &rspHeaders->list[i];
+            switch (hdr->id) {
+            case OI_OBEX_HDR_BODY:
+            case OI_OBEX_HDR_END_OF_BODY:
+                bodyHdr = hdr;
+                break;
+
+            case OI_OBEX_HDR_APPLICATION_PARAMS:
+                ExtractAppParams(client, hdr);
+                break;
+
+            default:
+                OI_DBG_PRINT2(("Received unexpected obex header %2x", hdr->id));
+                break;
+            }
+        }
+
+        client->final = (rcvStatus == OI_OK);
+
+        /* Check to see if we're just supposed to be getting the phonebook
+         * size. */
+        if (client->state == CLIENT_STATE_PULLING_PHONEBOOK_SIZE) {
+            if (!client->final) {
+                /* The entire OBEX response should be in one packet
+                 * considering that the only thing we should be getting is
+                 * just the phonebook size. */
+                OI_SLOG_ERROR(OI_STATUS_NONE,
+                              ("PBAP server erroneously indicates more data to get while getting the phonebook size"));
+                OI_OBEXCLI_Abort((OI_OBEXCLI_CONNECTION_HANDLE)connectionId, NULL);
+            }
+        } else {
+            client->fileOpCfmPending = TRUE;
+            if ((bodyHdr == NULL) || (bodyHdr->val.body.len == 0)) {
+                /*
+                 * Nothing to write to file this time.
+                 */
+                PbapWriteCfm(client->fh, OI_OK, client->id);
+                return;
+            }
+
+            OI_TRACE_USER(("Calling write(<*handle = %x>, <*data = %x>, size = %d, <*writeCfm = %x>, id = %d)",
+                              client->fh, bodyHdr->val.body.data, bodyHdr->val.body.len,
+                              PbapWriteCfm, client->id));
+            status = client->fops->write(client->fh, bodyHdr->val.body.data, bodyHdr->val.body.len,
+                                         PbapWriteCfm, client->id);
+            if (!OI_SUCCESS(status)) {
+                OI_SLOG_ERROR(status, ("App Write failed"));
+                OI_OBEXCLI_Abort((OI_OBEXCLI_CONNECTION_HANDLE)connectionId, PullAbortCfm);
+            }
+        }
+    } else {
+        OI_SLOG_WARNING(rcvStatus, ("PBAP: Failed to get phonebook data"));
+    }
+
+    if (rcvStatus != OI_OBEX_CONTINUE) {
+        /* FileClose does more than just close the file handle, and we need
+         * that other functionality here. */
+        FileClose(client, rcvStatus);
+    }
+}
+
+/**
+ * FinishReq()
+ *
+ * This function actually issues the OBEX GET request.  It is common to all
+ * PBAP GET requests and will get called after entering the appropriate
+ * directory and the application's file is opened if applicable.
+ */
+static void FinishReq(PBAP_CLIENT *client, OI_STATUS status)
+{
+    OI_OBEX_HEADER hdr[3];
+    OI_INT hdrCnt = 0;
+    OI_OBEX_HEADER_LIST hdrList;
+
+    OI_TRACE_USER(("FinishReq(<*client = %x>, status = %d)", client, status));
+
+    if (OI_SUCCESS(status)) {
+        client->req.results.phonebookSize = 0;
+        client->req.results.newMissedCalls = 0;
+
+        hdr[0].id = OI_OBEX_HDR_NAME;
+        hdr[0].val.name.str = client->req.pathStr;
+        hdr[0].val.name.len = client->req.pathStrLen;
+        hdrCnt++;
+
+        hdr[1].id = OI_OBEX_HDR_TYPE;
+        hdr[1].val.type.data = (OI_BYTE*)client->req.type;
+        hdr[1].val.type.len = client->req.typeLen;
+        hdrCnt++;
+
+        if (client->req.appParam) {
+            hdr[2].id = OI_OBEX_HDR_APPLICATION_PARAMS;
+            hdr[2].val.applicationParams.data = client->req.appParam;
+            hdr[2].val.applicationParams.len = client->req.appParamLen;
+            hdrCnt++;
+        }
+
+        hdrList.list = hdr;
+        hdrList.count = hdrCnt;
+
+        OI_PBAP_DumpObexHeaders(&hdrList);
+
+        client->final = FALSE;
+        status = OI_OBEXCLI_Get(client->id, &hdrList, PbapDataCB, TRUE);
+    }
+
+    if (!OI_SUCCESS(status)) {
+        PbapDataCB(client->id, NULL, status);
+    }
+}
+
+/**
+ * PbapOpenCfm()
+ *
+ * This function is called by the application to indicate the success or
+ * failure of the open operation and to provide the handle for writing data.
+ */
+static void PbapOpenCfm(OI_PBAP_HANDLE handle,
+                        OI_STATUS openStatus,
+                        OI_PBAP_CONNECTION pbapConnection)
+{
+    PBAP_CLIENT *client = PbapClient(pbapConnection);
+
+    OI_TRACE_USER(("PbapOpenCfm(handle = %x, openStatus = %d, pbapConnection = %d)",
+                      handle, openStatus, pbapConnection));
+
+    if (client) {
+        VALIDATE_CFM_STATE("PbapOpenCfm", client,
+                           ((client->state == CLIENT_STATE_PULLING_VCARD) ||
+                            (client->state == CLIENT_STATE_PULLING_PHONEBOOK) ||
+                            (client->state == CLIENT_STATE_PULLING_VCARD_LISTING)));
+
+        if (!IS_CLIENT_CONNECTED) {
+            OI_SLOG_ERROR(OI_STATUS_NONE, ("PbapOpenCfm while PBAP not connected"));
+            return;
+        }
+
+        if (OI_SUCCESS(openStatus)) {
+            client->fileOpen = TRUE;
+            client->fh = handle;
+            FinishReq(client, OI_OK);
+        } else {
+            FileClose(client, openStatus);
+        }
+    }
+}
+
+/**
+ * PbapOpen()
+ *
+ * This function opens a handle to the application for writing data to.
+ */
+static void PbapOpen(PBAP_CLIENT *client, OI_STATUS status)
+{
+    OI_OBEX_UNICODE path;
+
+    OI_TRACE_USER(("PbapOpen(<*client = %x>, status = %d)\n", client, status));
+
+    path.str = client->req.pathStr;
+    path.len = client->req.pathStrLen;
+
+    if (OI_SUCCESS(status)) {
+        client->fileOpCfmPending = TRUE;
+        OI_TRACE_USER(("Calling open(path = \"%s\", <*openCfm = %x>, id = %d)",
+                          path.str, PbapOpenCfm, client->id));
+        status = client->fops->open(&path, PbapOpenCfm, (OI_PBAP_CONNECTION)client->id);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("File Op Open failed"));
+            setState(client, CLIENT_STATE_CONNECTED);
+        }
+    } else {
+        FileClose(client, status);
+    }
+}
+
+/**
+ * PbapSetPathDone()
+ *
+ * This function builds the appropriate path name to the desired object after
+ * all the requisite SETPATHs have successfully been performed.  It will also
+ * call the application's Open callback to open file handle if necessary. */
+static void PbapSetPathDone(PBAP_CLIENT *client, OI_STATUS status)
+{
+    if (OI_SUCCESS(status)) {
+        client->req.pathStr[0] = 0;
+
+        switch (client->state) {
+        case CLIENT_STATE_PULLING_PHONEBOOK:
+            client->req.pathStrLen = BuildPbVCardPathName(&client->pathState, client->req.repo,
+                                                          client->req.pb, client->req.pathStr);
+            OI_DBG_PRINT1(("PBAP Pull Phonebook: \"%s\"\n", client->req.pathStr));
+            PbapOpen(client, status);
+            break;
+
+        case CLIENT_STATE_PULLING_VCARD:
+            client->req.pathStrLen = BuildVCardPathName(&client->pathState, client->req.repo,
+                                                        client->req.pb, client->req.entry,
+                                                        client->req.pathStr);
+            OI_DBG_PRINT1(("PBAP Pull vCard: \"%s\"\n", client->req.pathStr));
+            PbapOpen(client, status);
+            break;
+
+        case CLIENT_STATE_PULLING_PHONEBOOK_SIZE:
+            if (client->pathState.currPb == OI_PBAP_INVALID_PHONEBOOK) {
+                client->req.pathStrLen = BuildPbVCardPathName(&client->pathState, client->req.repo,
+                                                              client->req.pb, client->req.pathStr);
+            } else {
+                client->req.pathStrLen = BuildPbDirPathName(&client->pathState, client->req.repo,
+                                                            client->req.pb, client->req.pathStr);
+            }
+            OI_DBG_PRINT1(("PBAP Get Phonebook Size: \"%s\"\n", client->req.pathStr));
+            FinishReq(client, status);
+            break;
+
+        case CLIENT_STATE_PULLING_VCARD_LISTING:
+            client->req.pathStrLen = BuildPbDirPathName(&client->pathState, client->req.repo,
+                                                        client->req.pb, client->req.pathStr);
+            OI_DBG_PRINT1(("PBAP List Phonebook vCards: \"%s\"\n", client->req.pathStr));
+            PbapOpen(client, status);
+            break;
+
+        default:
+            OI_SLOG_ERROR(OI_FAIL, ("Finish building PBAP GET request in invalid state: %d",
+                                    client->state));
+            FinishReq(client, OI_FAIL);
+        }
+    } else {
+        OI_SLOG_ERROR(status, ("SET PATH failed"));
+        FinishReq(client, status);
+    }
+}
+
+/**
+ * OI_PBAPClient_GetPhonebookSize()
+ *
+ * This function is the API used by an application to request the size of a
+ * phonebook.
+ */
+OI_STATUS OI_PBAPClient_GetPhonebookSize(OI_PBAP_CONNECTION connectionId,
+                                         OI_PBAP_REPOSITORY repository,
+                                         OI_PBAP_PHONEBOOK phonebook,
+                                         OI_PBAP_CLIENT_GET_PHONEBOOK_SIZE_CB getPhonebookSizeCB)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    OI_STATUS status;
+    OI_UINT16 maxListCount = 0;  /* Get the number of entries in the phonebook */
+
+    OI_TRACE_USER(("OI_PBAPClient_GetPhonebookSize(connectionId = %d, repository = %d, phonebook = %d, <getPhonebookSizeCB = %x>)",
+                      connectionId, repository, phonebook, getPhonebookSizeCB));
+
+    OI_ARGCHECK(repository < OI_PBAP_INVALID_REPOSITORY);
+    OI_ARGCHECK(phonebook < OI_PBAP_INVALID_PHONEBOOK);
+    OI_ARGCHECK(getPhonebookSizeCB != NULL);
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_DBG_PRINT1(("Not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    client->req.cb.getSize = getPhonebookSizeCB;
+    client->req.repo = repository;
+    client->req.pb = phonebook;
+
+    status = BuildAppParams(client,
+                            NULL,               /* order (N/A) */
+                            NULL,               /* search attribute (N/A) */
+                            NULL,               /* search value (N/A) */
+                            0,                  /* search value len (N/A) */
+                            NULL,               /* list start offset (N/A) */
+                            &maxListCount,      /* max list count */
+                            NULL,               /* filter (N/A) */
+                            NULL,               /* format (N/A) */
+                            NULL);              /* supported features (N/A) */
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+
+    setState(client, CLIENT_STATE_PULLING_PHONEBOOK_SIZE);
+
+    if ((client->pathState.currPb == OI_PBAP_INVALID_PHONEBOOK) ||
+        (client->pathState.currRepo != client->req.repo)) {
+        client->req.type = OI_PBAP_PHONEBOOK_TYPE;
+        client->req.typeLen = sizeof(OI_PBAP_PHONEBOOK_TYPE);
+
+        /* Make sure we are in the <root> directory. */
+        SetPhonebookDir(client, OI_PBAP_INVALID_REPOSITORY, OI_PBAP_INVALID_PHONEBOOK, PbapSetPathDone);
+    } else {
+        client->req.type = OI_PBAP_VCARD_LISTING_TYPE;
+        client->req.typeLen = sizeof(OI_PBAP_VCARD_LISTING_TYPE);
+
+        /* Make sure we are in the right directory. */
+        SetPhonebookDir(client, repository, phonebook, PbapSetPathDone);
+    }
+
+    return OI_OK;
+}
+
+/**
+ * OI_PBAPClient_PullPhonebook()
+ *
+ * This function is the API used by an application to request the entire
+ * contents of a phonebook.
+ */
+OI_STATUS OI_PBAPClient_PullPhonebook(OI_PBAP_CONNECTION connectionId,
+                                      OI_PBAP_REPOSITORY repository,
+                                      OI_PBAP_PHONEBOOK phonebook,
+                                      const OI_UINT64 *filter,
+                                      OI_PBAP_FORMAT_TAG_VALUES format,
+                                      OI_UINT16 maxListCount,
+                                      OI_UINT16 listStartOffset,
+                                      OI_PBAP_CLIENT_PULL_PHONEBOOK_CB pullPhonebookCB)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    OI_STATUS status;
+
+    OI_TRACE_USER(("OI_PBAPClient_PullPhonebook(connectionId = %d, repository = %d, phonebook = %d, filter = %x-%x, format = %d, maxListCount = %d, listStartOffset = %d, <pullPhonebookCB = %x>)",
+                      connectionId, repository, phonebook,
+                      filter ? filter->I1 : 0, filter ? filter->I2 : 0,
+                      format, maxListCount, listStartOffset, pullPhonebookCB));
+
+    OI_ARGCHECK(repository < OI_PBAP_INVALID_REPOSITORY);
+    OI_ARGCHECK(phonebook < OI_PBAP_INVALID_PHONEBOOK);
+    OI_ARGCHECK(pullPhonebookCB != NULL);
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_DBG_PRINT1(("Not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    client->req.cb.pullPb = pullPhonebookCB;
+    client->req.repo = repository;
+    client->req.pb = phonebook;
+
+    client->req.type = OI_PBAP_PHONEBOOK_TYPE;
+    client->req.typeLen = sizeof(OI_PBAP_PHONEBOOK_TYPE);
+
+    status = BuildAppParams(client,
+                            NULL,               /* order (N/A) */
+                            NULL,               /* search attribute (N/A) */
+                            NULL,               /* search value (N/A) */
+                            0,                  /* search value len (N/A) */
+                            &listStartOffset,   /* list start offset */
+                            &maxListCount,      /* max list count */
+                            filter,             /* filter */
+                            &format,            /* format */
+                            NULL);              /* supported features (N/A) */
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+
+    setState(client, CLIENT_STATE_PULLING_PHONEBOOK);
+
+    /* Make sure we are in the <root> directory. */
+    SetPhonebookDir(client, OI_PBAP_INVALID_REPOSITORY, OI_PBAP_INVALID_PHONEBOOK, PbapSetPathDone);
+
+    return OI_OK;
+}
+
+/**
+ * OI_PBAPClient_PullvCardListing()
+ *
+ * This function is the API used by the appliction to get a vCard listing from
+ * the PBAP server.
+ */
+OI_STATUS OI_PBAPClient_PullvCardListing(OI_PBAP_CONNECTION connectionId,
+                                         OI_PBAP_REPOSITORY repository,
+                                         OI_PBAP_PHONEBOOK phonebook,
+                                         OI_PBAP_ORDER_TAG_VALUES order,
+                                         OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES searchAttribute,
+                                         OI_BYTE *searchValue,
+                                         OI_UINT8 searchValueLen,
+                                         OI_UINT16 maxListCount,
+                                         OI_UINT16 listStartOffset,
+                                         OI_PBAP_CLIENT_PULL_VCARD_LISTING_CB pullvCardListingCB)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    OI_STATUS status;
+
+    OI_ARGCHECK(repository < OI_PBAP_INVALID_REPOSITORY);
+    OI_ARGCHECK(phonebook < OI_PBAP_INVALID_PHONEBOOK);
+    OI_ARGCHECK(pullvCardListingCB != NULL);
+
+    OI_TRACE_USER(("OI_PBAPClient_PullvCardListing(connectionId = %d, repository = %d, phonebook = %d, order = %d, searchAttribute = %d, searchValue = \"%s\", searchValueLen = %d maxListCount = %d, listStartOffset = %d, <pullvCardListingCB = %x>)",
+                      connectionId, repository, phonebook, order, searchAttribute,
+                      searchValue ? (const OI_CHAR*)searchValue : "<null>", searchValueLen,
+                      maxListCount, listStartOffset, pullvCardListingCB));
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_DBG_PRINT1(("Not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    client->req.cb.pullList = pullvCardListingCB;
+    client->req.repo = repository;
+    client->req.pb = phonebook;
+
+    client->req.type = OI_PBAP_VCARD_LISTING_TYPE;
+    client->req.typeLen = sizeof(OI_PBAP_VCARD_LISTING_TYPE);
+
+    status = BuildAppParams(client,
+                            &order,             /* order */
+                            &searchAttribute,   /* search attribute */
+                            searchValue,        /* search value */
+                            searchValueLen,     /* search value len */
+                            &listStartOffset,   /* list start offset */
+                            &maxListCount,      /* max list count */
+                            NULL,               /* filter (N/A) */
+                            NULL,               /* format (N/A) */
+                            NULL);              /* supported features (N/A) */
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+
+    setState(client, CLIENT_STATE_PULLING_VCARD_LISTING);
+
+    SetPhonebookDir(client, repository, phonebook, PbapSetPathDone);
+
+    return OI_OK;
+}
+
+/**
+ * OI_PBAPClient_Pull_vCard_Entry()
+ *
+ * This function is the API used by the application to request a specific
+ * vCard from the PBAP server.
+ */
+OI_STATUS OI_PBAPClient_PullvCardEntry(OI_PBAP_CONNECTION connectionId,
+                                       OI_PBAP_REPOSITORY repository,
+                                       OI_PBAP_PHONEBOOK phonebook,
+                                       OI_UINT32 entry,
+                                       const OI_UINT64 *filter,
+                                       OI_PBAP_FORMAT_TAG_VALUES format,
+                                       OI_PBAP_CLIENT_PULL_VCARD_ENTRY_CB pullvCardCB)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    OI_STATUS status;
+
+    OI_TRACE_USER(("OI_PBAPClient_Pull_vCard_Entry(connectionId = %d, repository = %d, phonebook = %d, entry = %d, filter = %x-%x, format = %d, <pullvCardCB = %x>)",
+                      connectionId, repository, phonebook, entry,
+                      filter ? filter->I1 : 0, filter ? filter->I2 : 0,
+                      format, pullvCardCB));
+
+    OI_ARGCHECK(repository < OI_PBAP_INVALID_REPOSITORY);
+    OI_ARGCHECK(phonebook < OI_PBAP_INVALID_PHONEBOOK);
+    OI_ARGCHECK(pullvCardCB != NULL);
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_DBG_PRINT1(("Not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    client->req.cb.pullVCard = pullvCardCB;
+    client->req.repo = repository;
+    client->req.pb = phonebook;
+    client->req.entry = entry;
+
+    client->req.type = OI_PBAP_VCARD_TYPE;
+    client->req.typeLen = sizeof(OI_PBAP_VCARD_TYPE);
+
+    status = BuildAppParams(client,
+                            NULL,       /* order (N/A) */
+                            NULL,       /* search attribute (N/A) */
+                            NULL,       /* search value (N/A) */
+                            0,          /* search value len (N/A) */
+                            NULL,       /* list start offset (N/A) */
+                            NULL,       /* max list count (N/A) */
+                            filter,     /* filter */
+                            &format,    /* format */
+                            NULL);      /* supported features (N/A) */
+    if (!OI_SUCCESS(status)) {
+        return status;
+    }
+
+    setState(client, CLIENT_STATE_PULLING_VCARD);
+
+    SetPhonebookDir(client, repository, phonebook, PbapSetPathDone);
+
+    return OI_OK;
+}
+
+/**
+ * AbortCfm()
+ *
+ * This function handles the deferred abort confirmation.
+ */
+static void AbortCfm(OI_OBEXCLI_CONNECTION_HANDLE connection)
+{
+    PBAP_CLIENT *client = PbapClient(connection);
+
+    OI_TRACE_USER(("AbortCfm(connection = %d)\n", connection));
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("AbortCfm while PBAP not connected"));
+        return;
+    }
+
+    if (client->abortCfm) {
+        OI_TRACE_USER(("Calling abortCfm(connection = %d)", connection));
+        client->abortCfm((OI_PBAP_CONNECTION)connection);
+    }
+
+    if (client->state == CLIENT_STATE_ABORTING) {
+        setState(client, CLIENT_STATE_CONNECTED);
+    }
+}
+
+/**
+ * OI_PBAPClient_Abort()
+ *
+ * This function tells the connected PBAP server to abort the data transfer.
+ */
+OI_STATUS OI_PBAPClient_Abort(OI_PBAP_CONNECTION connectionId, OI_PBAP_ABORT_CFM abortCfm)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    OI_STATUS status;
+
+    OI_TRACE_USER(("OI_PBAPClient_Abort(connectionId = %d, <abortCfm = %x>)",
+                      connectionId, abortCfm));
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_DBG_PRINT1(("Not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    client->abortCfm = abortCfm;
+    status = OI_OBEXCLI_Abort((OI_OBEXCLI_CONNECTION_HANDLE)connectionId, AbortCfm);
+    if (OI_SUCCESS(status)) {
+        setState(client, CLIENT_STATE_ABORTING);
+    }
+
+    return status;
+}
+
+
+/************************************************************************
+ *
+ * Connection management functions.
+ *
+ ************************************************************************/
+
+/**
+ * ClientConnectCfm()
+ *
+ * This function indicates the success or failure of a connection attempt to a
+ * PBAP server.
+ */
+static void ClientConnectCfm(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                             OI_BOOL readOnly,
+                             OI_STATUS status)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    OI_PBAP_CONNECTION_CFM connectionCfm;
+
+    OI_TRACE_USER(("ClientConnectCfm(connectionId = %d, readOnly = %d, status = %d)",
+                          connectionId, readOnly, status));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("connectionId lookup failure"));
+        return;
+    }
+
+    connectionCfm = client->connectionCfm;
+
+    if (OI_SUCCESS(status)) {
+        OI_ASSERT(connectionId == client->id);
+        setState(client, CLIENT_STATE_CONNECTED);
+    } else {
+        OI_SLOG_WARNING(status, ("PBAP client connect failed"));
+        OI_Free(client);
+        client = NULL;
+        OI_INIT_FLAG_PUT_FLAG(FALSE, PBAP_CLI);
+    }
+
+    OI_TRACE_USER(("Calling connectionCfm(connectionId = %d, status = %d)",
+                      connectionId, status));
+    connectionCfm(connectionId, status);
+}
+
+/**
+ * ClientDisconnectInd()
+ *
+ * This function indicates the disconnection from a PBAP server.
+ */
+static void ClientDisconnectInd(OI_OBEXCLI_CONNECTION_HANDLE connectionId)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+
+    OI_TRACE_USER(("ClientDisconnectInd(connectionId = %d)", connectionId));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("connectionID lookup failed"));
+        return;
+    }
+
+    /*
+     * record the disconnect event for subsequent processes
+     */
+    client->disconnected = TRUE;
+
+    /* If there was a close pending we need to make sure it is called now
+     * because we are about to free the client.
+     */
+    if (client->dispatchHandle) {
+        OI_DBG_PRINT2(("Disconnect: calling the set repository/phonebook complete now"));
+        OI_Dispatch_CallFunc(client->dispatchHandle);
+        return;
+    }
+
+    if (client->fileOpCfmPending) {
+        /*
+         * We're waiting for a file op confirm callback, just have to keep
+         * waiting
+         */
+    } else {
+        /*
+         * Status to be reported to the file op code and app depends on
+         * whether we're idle or getting/putting.
+         */
+        OI_DBG_PRINT2(("Closing file handle %x\n", client->fh));
+        FileClose(client, client->state > CLIENT_STATE_CONNECTED ? OI_OBEX_NOT_CONNECTED : OI_OK);
+    }
+}
+
+/**
+ * ClientAuthenticationInd()
+ *
+ * This function informs the application of the need for authentication.
+ */
+static void ClientAuthenticationInd(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                    OI_BOOL userIdRequired,
+                                    OI_OBEX_REALM *realm)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+
+    OI_TRACE_USER(("ClientAuthenticationInd(connectionId = %d, userIdRequired = %d)",
+                          connectionId, userIdRequired));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("connectionID lookup failed"));
+        return;
+    }
+
+    setState(client, CLIENT_STATE_AUTHENTICATING);
+    OI_TRACE_USER(("Calling authenticationCB(connectionId = %d, userIdRequired = %d)",
+                      connectionId, userIdRequired));
+    client->authenticationCB(connectionId, userIdRequired);
+}
+
+OI_STATUS OI_PBAPClient_Connect(OI_BD_ADDR *addr,
+                                OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                                OI_OBEXCLI_AUTHENTICATION authentication,
+                                OI_PBAP_CONNECTION *connectionId,
+                                OI_UINT32 supportedFeatures,
+                                OI_PBAP_CONNECTION_CFM connectionCfm,
+                                OI_PBAP_DISCONNECTION_IND disconnectInd,
+                                OI_PBAP_CLIENT_AUTHENTICATION_CB authenticationCB,
+                                const OI_PBAP_CLIENT_FILESYS_FUNCTIONS *fops)
+{
+    static const OI_OBEXCLI_CB_LIST clientCallbacks = {
+        ClientConnectCfm,           /* connectCfmCB         */
+        ClientDisconnectInd,        /* disconnectIndCB      */
+        ClientAuthenticationInd,    /* authChallengeIndCB   */
+        NULL,                       /* progressIndCB        */
+        NULL                        /* bulkPutCfm        */
+    };
+    PBAP_CLIENT *client;
+    static OI_BYTE target[OI_OBEX_UUID_SIZE] = OI_PBAP_OBEX_TARGET_UUID;
+    static OI_OBEX_HEADER_LIST hdrList;
+    OI_INT hdrCnt = 0;
+    static OI_OBEX_HEADER hdr[2];
+    OI_OBEX_CONNECTION_OPTIONS connOpts;
+    OI_STATUS status;
+
+    OI_ARGCHECK(addr);
+    OI_TRACE_USER(("OI_PBAPClient_Connect(bdaddr = %:, lowerProtocol = %x, <authentication = %x>, "
+                    "<*connectionId = %x>, <connectionCfm = %x>, <disconnectInd = %x>, <authenticationCB = %x>,"
+                    "<*fops = %x>)", addr, lowerProtocol, authentication, connectionId,
+                    connectionCfm, disconnectInd, authenticationCB, fops));
+
+    OI_ARGCHECK(connectionCfm && disconnectInd && authenticationCB &&
+             (connectionId != NULL) && (fops != NULL));
+    OI_ARGCHECK(fops->open && fops->close && fops->write);
+
+    /* Current implementation only allows one PBAP connection at a time. */
+    if (OI_INIT_FLAG_VALUE(PBAP_CLI)) {
+        return OI_STATUS_ALREADY_CONNECTED;
+    }
+
+    client = OI_Calloc(sizeof(PBAP_CLIENT));
+    if (client == NULL) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS,
+                      ("Failed to allocate memory for PBAP client structure"));
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+
+    client->pathState.currRepo = OI_PBAP_LOCAL_REPOSITORY;
+    client->pathState.inTelecom = FALSE;
+    client->pathState.currPb = OI_PBAP_INVALID_PHONEBOOK;
+
+    client->connectionCfm = connectionCfm;
+    client->disconnectInd = disconnectInd;
+    client->authenticationCB = authenticationCB;
+    client->fops = fops;
+
+    /* Target header specifies the OBEX PBAP service. */
+    hdr[0].id = OI_OBEX_HDR_TARGET;
+    hdr[0].val.body.data = target;
+    hdr[0].val.body.len = OI_OBEX_UUID_SIZE;
+    hdrCnt ++;
+
+    if (lowerProtocol->protocol == OI_OBEX_LOWER_L2CAP) {
+        status = BuildAppParams(client,
+                                NULL,               /* order (N/A) */
+                                NULL,               /* search attribute (N/A) */
+                                NULL,               /* search value (N/A) */
+                                0,                  /* search value len (N/A) */
+                                NULL,               /* list start offset (N/A) */
+                                NULL,               /* max list count (N/A) */
+                                NULL,               /* filter (N/A) */
+                                NULL,               /* format (N/A) */
+                                &supportedFeatures);/* supported features */
+        if (!OI_SUCCESS(status)) {
+            return status;
+        }
+        if (client->req.appParam) {
+            hdr[1].id = OI_OBEX_HDR_APPLICATION_PARAMS;
+            hdr[1].val.applicationParams.data = client->req.appParam;
+            hdr[1].val.applicationParams.len = client->req.appParamLen;
+            hdrCnt ++;
+        }
+    }
+
+    hdrList.list = &hdr;
+    hdrList.count = hdrCnt;
+    /*
+     * We allow SRM for OPP
+     */
+    connOpts.enableSRM = TRUE;
+
+    status = OI_OBEXCLI_Connect(addr,
+                                lowerProtocol,
+                                &connOpts,
+                                authentication,
+                                &hdrList,
+                                &clientCallbacks,
+                                connectionId,
+                                &connectPolicy);
+
+    if (OI_SUCCESS(status)) {
+        client->id = *connectionId;
+        /* Set our initialization flag TRUE - we're initialized. */
+        OI_INIT_FLAG_PUT_FLAG(TRUE, PBAP_CLI);
+        /*
+         * Associate the "client" pointer with the OBEX client handle
+         */
+        OI_OBEXCLI_SetConnectionContext(*connectionId, (void*)client);
+    } else {
+        OI_Free(client);
+        OI_SLOG_ERROR(status, ("OI_OBEXCLI_Connect failed"));
+    }
+    return status;
+
+}
+
+
+/**
+ * OI_PBAPClient_Disconnect()
+ *
+ * This function disconnects from a currently connected PBAP server.
+ */
+OI_STATUS OI_PBAPClient_Disconnect(OI_PBAP_CONNECTION connectionId)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+    OI_STATUS status;
+
+    OI_TRACE_USER(("OI_PBAPClient_Disconnect(connectionId = %d)", connectionId));
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_DBG_PRINT1(("Not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    status = OI_OBEXCLI_Disconnect(client->id, NULL);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_WARNING(status, ("OI_OBEXCLI_Disconnect failed"));
+    }
+    return status;
+}
+
+/**
+ * OI_PBAPClient_AuthenticationRsp()
+ *
+ * This function provides authentication information to the PBAP server.
+ */
+OI_STATUS OI_PBAPClient_AuthenticationRsp(OI_PBAP_CONNECTION connectionId,
+                                          const OI_BYTE *userId,
+                                          OI_UINT8 userIdLen,
+                                          const OI_CHAR *password)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+
+    OI_TRACE_USER(("OI_PBAPClient_AuthenticationRsp(connectionId = %d, userId = \"%s\", userIdLen = %d, password = \"%s\")",
+                   connectionId, userId, userIdLen, password));
+
+    if (!client) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS, ("connectionID lookup failed"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (OI_INIT_FLAG_VALUE(PBAP_CLI) && (client->state == CLIENT_STATE_AUTHENTICATING)) {
+        return OI_OBEXCLI_Authentication(client->id, userId, userIdLen, password, NULL);
+    } else {
+        return OI_OBEX_INVALID_OPERATION;
+    }
+}
+
+/**
+ * PbapSetExplicitPathDone()
+ *
+ * This function builds the appropriate path name to the desired object after
+ * all the requisite SETPATHs have successfully been performed. */
+static void PbapSetExplicitPathDone(PBAP_CLIENT *client, OI_STATUS status)
+{
+    if (client->req.cb.setPath)
+        client->req.cb.setPath(client->id, status);
+}
+
+/**
+ * OI_PBAPClient_SetPath()
+ *
+ * This function sets path on the currently connected PBAP server.
+ */
+OI_STATUS OI_PBAPClient_SetPath(OI_PBAP_CONNECTION connectionId,
+                                       OI_PBAP_REPOSITORY repository,
+                                       OI_PBAP_PHONEBOOK phonebook,
+                                       OI_PBAP_CLIENT_SETPATH_CB setPathCB)
+{
+    PBAP_CLIENT *client = PbapClient(connectionId);
+
+    OI_TRACE_USER(("OI_PBAPClient_SetPath(connectionId = %d, repository = %d, phonebook = %d, <setPathCB = %x>)",
+                      connectionId, repository, phonebook, setPathCB));
+
+    OI_ARGCHECK(setPathCB != NULL);
+
+
+    if (!IS_CLIENT_CONNECTED) {
+        OI_DBG_PRINT1(("Not connected"));
+        return OI_OBEX_NOT_CONNECTED;
+    }
+
+    client->req.repo = repository;
+    client->req.pb = phonebook;
+    client->req.cb.setPath = setPathCB;
+
+    SetPhonebookDir(client, repository, phonebook, PbapSetExplicitPathDone);
+    return OI_OK;
+}
+
diff --git a/obex_profiles/profiles/pbap/pbap_private.c b/obex_profiles/profiles/pbap/pbap_private.c
new file mode 100644
index 0000000..9e7da0e
--- /dev/null
+++ b/obex_profiles/profiles/pbap/pbap_private.c
@@ -0,0 +1,271 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @file
+  @internal
+
+  Phonebook Access Profile internals
+  */
+
+#define __OI_MODULE__ OI_MODULE_PBAP_SRV
+
+#include "oi_bytestream.h"
+#include "oi_debug.h"
+#include "oi_stddefs.h"
+#include "oi_obexspec.h"
+#include "oi_pbap_consts.h"
+#include "oi_unicode.h"
+#include "oi_utils.h"
+
+
+const OI_CHAR16 OI_PBAP_usim1[] = { 'S', 'I', 'M', '1', 0 };
+const OI_CHAR16 OI_PBAP_utelecom[] = { 't', 'e', 'l', 'e', 'c', 'o', 'm', 0 };
+const OI_CHAR16 OI_PBAP_vcf[] = { '.', 'v', 'c', 'f', 0 };
+
+static const OI_CHAR16 pb[] = { 'p','b', 0 };
+static const OI_CHAR16 ich[] = { 'i', 'c', 'h', 0 };
+static const OI_CHAR16 och[] = { 'o', 'c', 'h', 0 };
+static const OI_CHAR16 mch[] = { 'm', 'c', 'h', 0 };
+static const OI_CHAR16 cch[] = { 'c', 'c', 'h', 0 };
+const OI_CHAR16 * OI_PBAP_upbdirs[] = {
+    pb,
+    ich,
+    och,
+    mch,
+    cch
+};
+const OI_UINT16 OI_PBAP_upbdirsizes[] = {
+    OI_ARRAYSIZE(pb),
+    OI_ARRAYSIZE(ich),
+    OI_ARRAYSIZE(och),
+    OI_ARRAYSIZE(mch),
+    OI_ARRAYSIZE(cch)
+};
+
+
+/***********************************************************************
+ *
+ * Debug Print code for reporting application paramters and OBEX headers
+ *
+ ***********************************************************************/
+
+#ifdef OI_DEBUG
+
+/**
+ * DumpAppParams()
+ *
+ * Helper debug function for nicely displaying PBAP APPLICATION PARMATERs.
+ */
+static void DumpAppParams(OI_BYTE *buf, OI_INT bufLen)
+{
+    OI_BYTE_STREAM bs;
+    OI_UINT8 tagId = 0;
+    OI_UINT8 tagLen = 0;
+
+    ByteStream_Init(bs, buf, (OI_UINT16)bufLen);
+    ByteStream_Open(bs, BYTESTREAM_READ);
+
+    OI_DBG_PRINT2(("PBAP OBEX header APPLICATION PARAMETERS: %@\n",
+                      buf, bufLen));
+
+    while (bufLen > 0) {
+        ByteStream_GetUINT8_Checked(bs, tagId);
+        ByteStream_GetUINT8_Checked(bs, tagLen);
+        bufLen -= (2 + tagLen);
+
+        if (bufLen >= 0) {
+            switch (tagId) {
+            case OI_PBAP_TAG_ID_ORDER:
+            {
+                OI_UINT8 order = 0;
+                const OI_CHAR *orderStr[] = { "Indexed",
+                                              "Alphabetical",
+                                              "Phonetical",
+                                              "Invalid" };
+                DEBUG_ONLY((void) orderStr[0];)  /* Suppresses GCC warning for specialized debug builds. */
+
+                ByteStream_GetUINT8_Checked(bs, order);
+                OI_DBG_PRINT2(("    PBAP tag Order: %d (%s)\n",
+                                  order, orderStr[OI_MIN(order, OI_ARRAYSIZE(orderStr) - 1)]));
+                break;
+            }
+
+            case OI_PBAP_TAG_ID_SEARCH_VALUE:
+                OI_DBG_PRINT2(("    PBAP tag Search Value = \"%s\"\n",
+                                  ByteStream_GetCurrentBytePointer(bs), tagLen));
+                ByteStream_Skip_Checked(bs, tagLen);
+                break;
+
+            case OI_PBAP_TAG_ID_SEARCH_ATTRIBUTE:
+            {
+                OI_UINT8 searchAttr = 0;
+                const OI_CHAR *searchAttrStr[] = { "Name",
+                                                   "Number",
+                                                   "Sound",
+                                                   "Invalid" };
+                DEBUG_ONLY((void) searchAttrStr[0];)  /* Suppresses GCC warning for specialized debug builds. */
+
+                ByteStream_GetUINT8_Checked(bs, searchAttr);
+                OI_DBG_PRINT2(("    PBAP tag Search Attribute: %d (%s)\n", searchAttr,
+                                  searchAttrStr[OI_MIN(searchAttr,
+                                                       OI_ARRAYSIZE(searchAttrStr) - 1)]));
+                break;
+            }
+
+            case OI_PBAP_TAG_ID_MAX_LIST_COUNT:
+            {
+                OI_UINT16 maxListCount = 0;
+
+                ByteStream_GetUINT16_Checked(bs, maxListCount, OI_BIG_ENDIAN_BYTE_ORDER);
+                OI_DBG_PRINT2(("    PBAP tag Max List Count: %d\n", maxListCount));
+                break;
+            }
+
+            case OI_PBAP_TAG_ID_LIST_START_OFFSET:
+            {
+                OI_UINT16 listStartOffset = 0;
+
+                ByteStream_GetUINT16_Checked(bs, listStartOffset, OI_BIG_ENDIAN_BYTE_ORDER);
+                OI_DBG_PRINT2(("    PBAP tag List Start Offset: %d\n", listStartOffset));
+                break;
+            }
+
+            case OI_PBAP_TAG_ID_FILTER:
+            {
+                OI_UINT64 filter = {0,0};
+
+                ByteStream_GetUINT32_Checked(bs, filter.I1, OI_BIG_ENDIAN_BYTE_ORDER);
+                ByteStream_GetUINT32_Checked(bs, filter.I2, OI_BIG_ENDIAN_BYTE_ORDER);
+                OI_DBG_PRINT2(("    PBAP tag Filter: %08x-%08x\n", filter.I1, filter.I2));
+                break;
+            }
+
+            case OI_PBAP_TAG_ID_FORMAT:
+            {
+                OI_UINT8 format = 0;
+                const OI_CHAR *formatStr[] = { "2.1",
+                                               "3.0",
+                                               "Invalid" };
+                DEBUG_ONLY((void) formatStr[0];)  /* Suppresses GCC warning for specialized debug builds. */
+
+                ByteStream_GetUINT8_Checked(bs, format);
+                OI_DBG_PRINT2(("    PBAP tag Format: %d (vCard version %s)\n",
+                                  format, formatStr[OI_MIN(format, OI_ARRAYSIZE(formatStr) - 1)]));
+                break;
+            }
+
+            case OI_PBAP_TAG_ID_PHONEBOOK_SIZE:
+            {
+                OI_UINT16 size = 0;
+
+                ByteStream_GetUINT16_Checked(bs, size, OI_BIG_ENDIAN_BYTE_ORDER);
+                OI_DBG_PRINT2(("    PBAP tag Phonebook Size: %d\n", size));
+                break;
+            }
+
+            case OI_PBAP_TAG_ID_NEW_MISSED_CALLS:
+            {
+                OI_UINT8 newMissedCalls = 0;
+
+                ByteStream_GetUINT8_Checked(bs, newMissedCalls);
+                OI_DBG_PRINT2(("    PBAP tag New Missed Calls: %d\n", newMissedCalls));
+                break;
+            }
+
+            default:
+                OI_DBG_PRINT2(("    PBAP tag UNKNOWN: %02x (%d bytes in size)\n", tagId, tagLen));
+                ByteStream_Skip_Checked(bs, tagLen);
+            }
+        }
+    }
+
+    if ((bufLen < 0) || ByteStream_Error(bs)) {
+        OI_LOG_ERROR(("Invalid application parameter length\n"));
+    }
+
+    ByteStream_Close(bs);
+}
+
+
+/**
+ * OI_PBAP_DumpObexHeaders()
+ *
+ * Helper debug function for nicely displaying OBEX headers relevant to PBAP.
+ */
+void OI_PBAP_DumpObexHeaders(const OI_OBEX_HEADER_LIST *hdrList)
+{
+    OI_INT i;
+
+    if (!hdrList || hdrList->count == 0) {
+        OI_DBG_PRINT2(("No PBAP OBEX headers.\n"));
+        return;
+    }
+
+    for (i = 0; i < hdrList->count; i++) {
+        OI_OBEX_HEADER *hdr = &hdrList->list[i];
+
+        switch (hdr->id) {
+        case OI_OBEX_HDR_NAME:
+            OI_DBG_PRINT2(("PBAP OBEX header NAME: \"%s\"\n",
+                              hdr->val.name.str, hdr->val.name.len));
+            break;
+
+        case OI_OBEX_HDR_TYPE:
+            OI_DBG_PRINT2(("PBAP OBEX header TYPE: \"%s\"\n",
+                              hdr->val.type.data, hdr->val.type.len));
+            break;
+
+        case OI_OBEX_HDR_APPLICATION_PARAMS:
+
+
+            if((NULL != hdr->val.applicationParams.data) && (0 != hdr->val.applicationParams.len)) {
+                DumpAppParams(hdr->val.applicationParams.data, hdr->val.applicationParams.len);
+            } else {
+                OI_DBG_PRINT2(("PBAP OBEX header APPLICATION_PARAMS empty\n"));
+            }
+            break;
+
+        case OI_OBEX_HDR_BODY:
+            OI_DBG_PRINT2(("PBAP OBEX header BODY: %@", hdr->val.body.data,
+                              OI_MIN(hdr->val.body.len, 16)));
+            break;
+
+        case OI_OBEX_HDR_END_OF_BODY:
+            OI_DBG_PRINT2(("PBAP OBEX header END OF BODY: %@", hdr->val.body.data,
+                              OI_MIN(hdr->val.body.len, 16)));
+            break;
+
+        default:
+            OI_DBG_PRINT2(("PBAP OBEX header UNRECOGNIZED: %x (ignored)\n", hdr->id));
+        }
+    }
+}
+#endif
diff --git a/obex_profiles/profiles/pbap/pbap_server.c b/obex_profiles/profiles/pbap/pbap_server.c
new file mode 100644
index 0000000..7696377
--- /dev/null
+++ b/obex_profiles/profiles/pbap/pbap_server.c
@@ -0,0 +1,1850 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ * @internal
+ *
+ * Phonebook Access Profile server.
+ */
+
+#define __OI_MODULE__ OI_MODULE_PBAP_SRV
+
+#include "oi_pbap_server.h"
+#include "oi_pbap_sys.h"
+#include "oi_obexsrv.h"
+#include "oi_std_utils.h"
+#include "oi_memmgr.h"
+#include "oi_debug.h"
+#include "oi_assert.h"
+#include "oi_bt_assigned_nos.h"
+#include "oi_sdpdb.h"
+#include "oi_sdp_utils.h"
+#include "oi_argcheck.h"
+#include "oi_dispatch.h"
+
+#include "oi_init_flags.h"
+#include "oi_config_table.h"
+#include "oi_bt_profile_config.h"
+
+#include "oi_bytestream.h"
+#include "oi_unicode.h"
+
+#include "oi_pbap_private.h"
+
+
+
+/*****************************************************************
+ *
+ * Service record
+ *
+ *****************************************************************/
+
+/** service class ID list */
+static const OI_DATAELEM ServiceClassIDList[] = {
+    OI_ELEMENT_UUID32(OI_UUID_PhonebookAccessServer)
+};
+
+/* protocol descriptor list */
+static const OI_DATAELEM L2CAP_Descriptor[] = {
+    OI_ELEMENT_UUID32(OI_UUID_L2CAP)
+};
+
+/** the RFCOMM server channel
+ *      @note: This variable is static in order that its address can be known at
+ *      compile time. This lets us put a constant pointer into the SDP descriptor.
+ */
+static OI_DATAELEM OurServerChannel;
+
+static const OI_DATAELEM RFCOMM_Descriptor[] = {
+    OI_ELEMENT_UUID32(OI_UUID_RFCOMM),
+    OI_ELEMENT_REF(OurServerChannel)
+};
+
+static const OI_DATAELEM OBEX_Descriptor[] = {
+    OI_ELEMENT_UUID32(OI_UUID_OBEX)
+};
+
+static const OI_DATAELEM ProtocolDescriptorList[] = {
+    OI_ELEMENT_SEQ(L2CAP_Descriptor),
+    OI_ELEMENT_SEQ(RFCOMM_Descriptor),
+    OI_ELEMENT_SEQ(OBEX_Descriptor)
+};
+
+/* profile descriptor list */
+static const OI_DATAELEM Profile0[] = {
+    OI_ELEMENT_UUID32(OI_UUID_PhonebookAccess),
+    OI_ELEMENT_UINT16(0x0100) //version 1.0
+};
+
+static const OI_DATAELEM ProfileDescriptorList[] = {
+    OI_ELEMENT_SEQ(Profile0)
+};
+
+static OI_DATAELEM SupportedRepositories;
+
+/** SDP attribute lists */
+static const OI_SDPDB_ATTRIBUTE ServiceDescription[] = {
+    { OI_ATTRID_ServiceClassIDList,                   OI_ELEMENT_SEQ(ServiceClassIDList) },
+    { OI_ATTRID_ProtocolDescriptorList,               OI_ELEMENT_SEQ(ProtocolDescriptorList) },
+    { OI_ATTRID_BluetoothProfileDescriptorList,       OI_ELEMENT_SEQ(ProfileDescriptorList) },
+    { OI_ATTRID_SupportedRepositories,                OI_ELEMENT_REF(SupportedRepositories) }
+};
+
+/*
+ * Note that the order of these values is important.
+ */
+typedef enum {
+    PBAP_SERVER_IDLE               = 0,
+    PBAP_SERVER_CONNECTED          = 1,
+    PBAP_GETTING_PHONEBOOK         = 2,
+    PBAP_GETTING_PHONEBOOK_SIZE    = 3,
+    PBAP_GETTING_PHONEBOOK_LISTING = 4,
+    PBAP_GETTING_VCARD             = 5
+} PBAP_SERVER_STATE;
+
+
+
+typedef enum {
+    PBAP_SERVER_LISTING,
+    PBAP_SERVER_VCARD,
+    PBAP_SERVER_PHONEBOOK
+} PBAP_SERVER_GET_OBJECT;
+
+
+/*
+ * Struct for an OBEX PBAP server connection.
+ */
+
+typedef struct {
+    PBAP_SERVER_STATE state;                        /**< current state of the PBAP server */
+    OI_PBAP_HANDLE file;                            /**< handle for file operations */
+    const OI_PBAP_SERVER_FILESYS_FUNCTIONS *fops;   /**< file operations */
+
+    OI_UINT16 maxRead;                              /**< maximum read for the current connection */
+
+    OI_OBEXSRV_CONNECTION_HANDLE id;                /**< connection ID number */
+
+    OI_PBAP_CONNECTION_IND connectInd;              /**< connection event callback */
+    OI_PBAP_DISCONNECTION_IND disconnectInd;        /**< disconnect event callback */
+    OI_PBAP_SERVER_GET_PHONEBOOK_SIZE_IND getPhonebookSize; /**< get phonebook size request event callback */
+
+    OI_UINT32 srecHandle;                           /**< Service record handle for the PBAP service */
+    OI_OBEX_SERVER_HANDLE serverHandle;             /**< OBEX server handle for the registered PBAP server */
+
+
+    OI_PBAP_REPOSITORY repository;                  /**< Currently set repository */
+    OI_PBAP_PHONEBOOK phonebook;                    /**< Currently set phonebook */
+    OI_BOOL repositorySet;                          /**< TRUE if a valid repository is set */
+    OI_BOOL phonebookSet;                           /**< TRUE if a valid phonebook is set */
+
+    OI_UINT8 folderLevel;                           /**< 0 means at root folder */
+
+    OI_CHAR16 *pathElements[4];
+    OI_UINT16 pathElemCnt;
+
+    OI_UINT32 entry;                                /**< vCard entry to retrieve */
+
+    OI_BOOL reportMissedCalls;                      /**< flag indicating when to send newly missed calls to client */
+    OI_UINT8 newMissedCalls;                        /**< number of newly missed calls */
+
+    PBAP_SERVER_GET_OBJECT getObject;               /**< type of object to get */
+
+    struct {
+        OI_PBAP_ORDER_TAG_VALUES order;             /**< application parameter, Order: listing sort order */
+        OI_BOOL orderSet;                           /**< flag indicating if the client set the Order parameter */
+
+        OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES searchAttribute;    /**< application parameter, SearchAttribute: specifies vCard field to search */
+        OI_BOOL searchAttributeSet;                 /**< flag indicating if the client set the SearchAttribute parameter */
+
+        OI_BYTE *searchValue;                       /**< application parameter, SearchValue: the search criteria */
+        OI_UINT8 searchValueLen;                    /**< length of the search criteria */
+        OI_BOOL  searchValueSet;                    /**< flag indicating if the client set the SearchValue parameter */
+
+        OI_UINT16 maxListCount;                     /**< applicatoin parameter, MaxListCount: maximum number of vCards the client will accept */
+        OI_BOOL   maxListCountSet;                  /**< flag indicating if the client set the MaxListCount application paramter */
+
+        OI_UINT16 listStartOffset;                  /**< application parameter, ListStartOffset: first vCard entry the client wants to receive */
+        OI_BOOL   listStartOffsetSet;               /**< flag indicating if the client set the ListStartOffset application parameter */
+
+        OI_UINT64 filter;                           /**< application parameter, Filter: specifies which vCard fields to include in the data sent to the client */
+        OI_BOOL   filterSet;                        /**< flag indicating if the client set the Filter application parameter */
+
+        OI_PBAP_FORMAT_TAG_VALUES format;           /**< application parameter, Format: specifies the vCard format */
+        OI_BOOL                   formatSet;        /**< flag indicating if the client set the Format application parameter */
+    } appParams;
+
+    OI_BOOL unauthorized;                           /**< flag indicating if connecting client needs to provid authentication */
+    OI_BOOL incompleteGet;                          /**< flag indication if the server has more data to send */
+} PBAP_SERVER;
+
+
+static PBAP_SERVER *server;
+
+/**
+ * Connection policy.
+ */
+static const OI_CONNECT_POLICY  connectPolicy =
+{
+    OI_ELEMENT_UUID32(OI_UUID_PhonebookAccessServer),     /* OI_DATAELEM         serviceUuid           */
+    FALSE,                              /* OI_BOOL             mustBeMaster          */
+    NULL,                               /* OI_L2CAP_FLOWSPEC   *flowspec;            */
+    0                                   /* OI_UINT8            powerSavingDisables ; */
+};
+
+/*
+ * Struct for deferred fops->close() call
+ */
+typedef struct  {
+    OI_PBAP_HANDLE fileHandle;
+    OI_STATUS status;
+    OI_PBAP_CONNECTION serverId;
+} DEFERRED_FILE_CLOSE_ARGS;
+
+
+
+
+
+#if defined(OI_DEBUG)
+/**
+ * ServerStateText()
+ *
+ * Helper function to convert the state to a human readable string for printing.
+ */
+static const OI_CHAR *ServerStateText(PBAP_SERVER_STATE state)
+{
+    switch (state) {
+    case PBAP_SERVER_IDLE:                  return "PBAP_SERVER_IDLE";
+    case PBAP_SERVER_CONNECTED:             return "PBAP_SERVER_CONNECTED";
+    case PBAP_GETTING_PHONEBOOK:            return "PBAP_GETTING_PHONEBOOK";
+    case PBAP_GETTING_PHONEBOOK_SIZE:       return "PBAP_GETTING_PHONEBOOK_SIZE";
+    case PBAP_GETTING_PHONEBOOK_LISTING:    return "PBAP_GETTING_PHONEBOOK_LISTING";
+    case PBAP_GETTING_VCARD:                return "PBAP_GETTING_VCARD";
+    }
+    return "<unknown state>";
+}
+
+/**
+ * setState()
+ *
+ * Helper macro for setting the state.  (Written as a macro so that the
+ * OI_DBG_PRINT1() reports the line in the function where the state changed
+ * rather than the line in setState().
+ */
+#define setState(_server, _newState)                    \
+    do {                                                \
+        OI_DBG_PRINT1(("PBAP Server state %s ==> %s\n",      \
+                     ServerStateText((_server)->state), \
+                     ServerStateText(_newState)));      \
+        (_server)->state = (_newState);                 \
+    } while (0)
+#else
+/**
+ * ServerStateText()
+ *
+ * Empty definition of above incase it is used by non-debug code.
+ */
+#define ServerStateText(state) ""
+
+/**
+ * setState()
+ *
+ * Non-debug version of the setState() macro.
+ */
+#define setState(_client, _newState)            \
+    do {                                        \
+        (_client)->state = (_newState);         \
+    } while (0);
+#endif
+
+
+/*
+ * dispatcher calls us so we can call close()
+ */
+static void deferredFileClose(DISPATCH_ARG *args)
+{
+    DEFERRED_FILE_CLOSE_ARGS *pCbArgs;
+
+    pCbArgs = (DEFERRED_FILE_CLOSE_ARGS*)(args->data);
+    server->fops->close(pCbArgs->fileHandle, pCbArgs->serverId, pCbArgs->status);
+    if (server->appParams.searchValueSet) {
+        OI_FreeIf(&server->appParams.searchValue);
+    }
+}
+
+static void setupDeferredFileClose(OI_PBAP_HANDLE handle,
+                                   OI_PBAP_CONNECTION serverId,
+                                   OI_STATUS status)
+{
+    DEFERRED_FILE_CLOSE_ARGS closeArgs;
+    DISPATCH_ARG dispatchArg;
+    OI_STATUS retVal;
+
+    closeArgs.fileHandle = handle;
+    closeArgs.status = status;
+    closeArgs.serverId = serverId;
+    Dispatch_SetArg(dispatchArg, closeArgs);
+    retVal = OI_Dispatch_RegisterFunc(deferredFileClose, &dispatchArg, NULL);
+    if (!OI_SUCCESS(retVal)) {
+        OI_SLOG_ERROR(retVal, ("Failed to register deferred close"));
+    }
+}
+
+
+static OI_STATUS TokenizePath(const OI_OBEX_UNICODE *ustr, OI_CHAR16 **elements, OI_UINT16 *elemCnt)
+{
+    OI_UINT16 maxCnt = *elemCnt;
+    OI_CHAR16 *path;
+
+    if ((ustr->len == 0) || (ustr->len == 1 && ustr->str[0] == 0x0000)) {
+        *elemCnt = 0;
+        return OI_OK;
+    }
+
+    path = OI_Malloc((ustr->len + 1) * sizeof(OI_CHAR16));
+    if (!path) {
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+
+
+    OI_MemCopy(path, ustr->str, ustr->len * sizeof(OI_CHAR16));
+    path[ustr->len] = 0;  /* Make sure the path is nul terminated. */
+
+    if (path[0] == '/') {
+        /* Invalid path */
+        return OI_OBEX_NOT_FOUND;
+    }
+
+    *elemCnt = 0;
+    elements[*elemCnt] = path;
+    (*elemCnt)++;
+
+    while (*path != '\0') {
+        if (*path == '/') {
+            if (*elemCnt == maxCnt) {
+                 /* path too long; obviously invalid */
+                return OI_OBEX_NOT_FOUND;
+            }
+            *path = '\0';
+            path++;
+            OI_DBG_PRINT2(("Tokenized path element: \"%S\"\n", elements[*elemCnt - 1]));
+            elements[*elemCnt] = path;
+            (*elemCnt)++;
+        } else {
+            path++;
+        }
+    }
+
+    OI_DBG_PRINT2(("Tokenized final path element: \"%S\"\n", elements[*elemCnt - 1]));
+    return OI_OK;
+}
+
+
+/******************************************************************************
+ * Parse fileName into Phonebook files/directories
+ */
+
+static OI_STATUS GetRepository(OI_CHAR16 **elements, OI_UINT16 elemCnt, OI_PBAP_REPOSITORY *repo)
+{
+    if (server->repositorySet) {
+        *repo = server->repository;
+        return OI_OK;
+    } else if (elemCnt >= 2) {
+        if ((OI_StrcmpUtf16(elements[0], OI_PBAP_usim1) == 0) &&
+            (OI_StrcmpUtf16(elements[1], OI_PBAP_utelecom) == 0)) {
+            *repo = OI_PBAP_SIM1_REPOSITORY;
+            return OI_OK;
+        } else if (OI_StrcmpUtf16(elements[0], OI_PBAP_utelecom) == 0) {
+            /* Even if server->repositorySet is FALSE, server->repository will
+             * still refer to OI_PBAP_SIM1_REPOSITORY if the client has sent a
+             * SETPATH NAME="SIM1". */
+            *repo = server->repository;
+            return OI_OK;
+        }
+    }
+    return OI_OBEX_NOT_FOUND;
+}
+
+
+static OI_STATUS LookupPhonebook(const OI_CHAR16 *pbStr, OI_PBAP_PHONEBOOK *pb)
+{
+    OI_INT i;
+
+    OI_DBG_PRINT1(("LookupPhonebook(pbStr = \"%S\", <*pb = %x>)", pbStr, pb));
+
+    for (i = 0; i < OI_PBAP_INVALID_PHONEBOOK; i++) {
+        if (OI_StrncmpUtf16(pbStr, OI_PBAP_upbdirs[i], (OI_UINT16)(OI_PBAP_upbdirsizes[i] - 1)) == 0) {
+            *pb = (OI_PBAP_PHONEBOOK)i;
+            return OI_OK;
+        }
+    }
+    return OI_OBEX_NOT_FOUND;
+}
+
+
+#define PRINT_BADPATH(_msg, _server)                                    \
+    OI_DBG_PRINT1(("\t%s: \"%S%s%S%s%S%s%S\" from \"%s%s%S\"\n",     \
+                      (_msg),                                           \
+                      (_server)->pathElements[0],                       \
+                      ((_server)->pathElemCnt) > 1 ? "/" : "",          \
+                      ((_server)->pathElemCnt) > 1 ? (_server)->pathElements[1] : (const OI_CHAR16*)"\0", \
+                      ((_server)->pathElemCnt) > 2 ? "/" : "",          \
+                      ((_server)->pathElemCnt) > 2 ? (_server)->pathElements[2] : (const OI_CHAR16*)"\0", \
+                      ((_server)->pathElemCnt) > 3 ? "/" : "",          \
+                      ((_server)->pathElemCnt) > 3 ? (_server)->pathElements[3] : (const OI_CHAR16*)"\0", \
+                      (_server)->repositorySet ? (((_server)->repository == OI_PBAP_SIM1_REPOSITORY) ? "SIM1/telecom" : "telecom") : "<root>", \
+                      (_server)->phonebookSet ? "/" : "",               \
+                      (_server)->phonebookSet ? OI_PBAP_upbdirs[(_server)->phonebook] : (const OI_CHAR16*)"\0")); \
+
+
+static OI_STATUS ParseEntryName(OI_PBAP_REPOSITORY *repo, OI_PBAP_PHONEBOOK *pb, OI_UINT32 *entry)
+{
+    OI_UINT pos;
+    OI_UINT32 e;  /* Use 32-bit int to check for overflow */
+    OI_UINT32 digit;
+    const OI_CHAR16 *fn;
+    OI_UINT fnLen;
+    OI_STATUS status = OI_OK;
+    OI_UINT vcfLen = OI_StrLenUtf16(OI_PBAP_vcf);
+
+    status = GetRepository(server->pathElements, server->pathElemCnt, repo);
+    if ((server->pathElemCnt == 4) && (*repo == OI_PBAP_LOCAL_REPOSITORY)) {
+        status = OI_OBEX_NOT_FOUND;
+    }
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_WARNING(status, ("Repository check failed"));
+        goto out;
+    }
+
+    if (server->phonebookSet && (server->pathElemCnt == 1)) {
+        *pb = server->phonebook;
+    } else if (!server->phonebookSet && (server->pathElemCnt >= 2)) {
+        status = LookupPhonebook(server->pathElements[server->pathElemCnt - 2], pb);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_WARNING(status, ("Phonebook lookup failed"));
+            goto out;
+        }
+    } else {
+        OI_SLOG_WARNING(OI_OBEX_NOT_FOUND, ("Not enough path components"));
+        status = OI_OBEX_NOT_FOUND;
+        goto out;
+    }
+
+
+    /* vCard entries can only be "<number>.vcf", where number is between 0 and
+     * 0xffffffff */
+
+    fn = server->pathElements[server->pathElemCnt - 1];
+    fnLen = OI_StrLenUtf16(fn);
+
+    /* Verify the last 4 characters match ".vcf" */
+    if (OI_StrcmpUtf16(&fn[fnLen - vcfLen], OI_PBAP_vcf) != 0) {
+        OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                        ("Requested vCard name is not long enough for \".vcf\""));
+        status = OI_OBEX_NOT_FOUND;
+        goto out;
+    }
+
+    /* Make sure the name isn't obviously too large. */
+    if (fnLen > sizeof("1234567890.vcf")) {
+        OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                        ("Requested vCard name is obviously too long: %d should be less than 14",
+                         fnLen));
+        status = OI_OBEX_NOT_FOUND;
+        goto out;
+    }
+
+    e = 0;
+
+    for (pos = 0; pos < (fnLen - vcfLen); pos++) {
+        digit = fn[pos] - '0';
+
+        /* Validate the digit */
+        if (digit > 9) {
+            /* Handle upper case */
+            digit = 10 + fn[pos] - 'A';
+            if(digit > 15 || digit < 10) {
+                /* Handle lower case */
+                digit = 10 + fn[pos] - 'a';
+                if(digit > 15 || digit < 10) {
+                    OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                                    ("Invalid character found in vCard file name: \"%c\" (0x%2x)",
+                                     digit + '0', digit + '0'));
+                    status = OI_OBEX_NOT_FOUND;
+                    goto out;
+                }
+            }
+        }
+        e *= 16;
+        e += digit;
+    }
+
+    *entry = (OI_UINT32)e;
+
+  out:
+    if (!OI_SUCCESS(status)) {
+        PRINT_BADPATH("Remote PBAP client requested invalid vCard file", server);
+    }
+
+    return status;
+}
+
+static OI_STATUS ParsePhonebookvCard(OI_PBAP_REPOSITORY *repo, OI_PBAP_PHONEBOOK *pb)
+{
+    OI_STATUS status = OI_OK;
+
+
+    if (server->phonebookSet && (server->pathElemCnt < 2)) {
+        OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                        ("Can't get the phonebook file while in a phonebook directory"));
+        status = OI_OBEX_NOT_FOUND;
+        goto out;
+    }
+
+    status = GetRepository(server->pathElements, server->pathElemCnt, repo);
+    if ((server->pathElemCnt == 3) && (*repo == OI_PBAP_LOCAL_REPOSITORY)) {
+        status = OI_OBEX_NOT_FOUND;
+    }
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_WARNING(status, ("Repository check failed"));
+        goto out;
+    }
+
+    status = LookupPhonebook(server->pathElements[server->pathElemCnt - 1], pb);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_WARNING(status, ("Phonebook lookup failed"));
+        goto out;
+    }
+
+    if (OI_StrLenUtf16(server->pathElements[server->pathElemCnt - 1]) != (OI_PBAP_upbdirsizes[*pb] + OI_StrLenUtf16(OI_PBAP_vcf) - 1)) {
+        OI_SLOG_WARNING(OI_OBEX_NOT_FOUND, ("Phonebook filename length is wrong"));
+        status = OI_OBEX_NOT_FOUND;
+    }
+
+  out:
+    if (!OI_SUCCESS(status)) {
+        PRINT_BADPATH("Remote PBAP client requested invalid phonebook file", server);
+    }
+    return status;
+}
+
+
+static OI_STATUS ParsePhonebookDir(OI_PBAP_REPOSITORY *repo, OI_PBAP_PHONEBOOK *pb)
+{
+    OI_STATUS status = OI_OK;
+
+    if (server->phonebookSet) {
+        if (server->pathElemCnt > 0) {
+            OI_SLOG_WARNING(OI_OBEX_NOT_FOUND, ("Already in a phonebook directory"));
+            status = OI_OBEX_NOT_FOUND;
+        } else {
+            *repo = server->repository;
+            *pb = server->phonebook;
+        }
+    } else {
+        status = GetRepository(server->pathElements, server->pathElemCnt, repo);
+        if ((server->pathElemCnt == 3) && (*repo == OI_PBAP_LOCAL_REPOSITORY)) {
+            status = OI_OBEX_NOT_FOUND;
+        }
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_WARNING(status, ("Repository check failed"));
+            goto out;
+        }
+
+        status = LookupPhonebook(server->pathElements[server->pathElemCnt - 1], pb);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_WARNING(status, ("Phonebook lookup failed"));
+            goto out;
+        }
+
+        if (OI_StrLenUtf16(server->pathElements[server->pathElemCnt - 1]) != (OI_UINT16)(OI_PBAP_upbdirsizes[*pb] - 1)) {
+            OI_SLOG_WARNING(OI_OBEX_NOT_FOUND, ("Phonebook dirname length is wrong"));
+            status = OI_OBEX_NOT_FOUND;
+        }
+    }
+
+  out:
+    if (!OI_SUCCESS(status)) {
+        PRINT_BADPATH("Remote PBAP client requested invalid phonebook dir", server);
+    }
+    return status;
+}
+
+
+/******************************************************************************
+ * Parameter parsing routines.
+ */
+
+static OI_STATUS ParseAppParams(const OI_OBEX_BYTESEQ *appParams)
+{
+    OI_BYTE_STREAM bs;
+    OI_PBAP_APPLICATION_PARAM_TAG_IDS tag;
+    OI_UINT8 len = 0;
+    OI_STATUS status = OI_OK;
+    OI_UINT8 rawByte = 0;
+
+    ByteStream_Init(bs, appParams->data, appParams->len);
+    ByteStream_Open(bs, BYTESTREAM_READ);
+
+    while (ByteStream_NumReadBytesAvail(bs) > 0) {
+        ByteStream_GetUINT8_Checked(bs, rawByte);
+        ByteStream_GetUINT8_Checked(bs, len);
+        tag = (OI_PBAP_APPLICATION_PARAM_TAG_IDS)rawByte;  /* Some compilers' type checking is too strong. */
+
+        switch (tag) {
+        case OI_PBAP_TAG_ID_ORDER:
+            if (len != sizeof(OI_UINT8)) {
+                OI_SLOG_ERROR(OI_OBEX_PRECONDITION_FAILED,
+                              ("PBAP: Order value has wrong length"));
+                status = OI_OBEX_PRECONDITION_FAILED;
+                    goto out;
+            }
+            if (server->appParams.orderSet) {
+                OI_SLOG_WARNING(OI_STATUS_NONE,
+                                ("PBAP: Order already set, ignoring duplicate tag"));
+                ByteStream_Skip_Checked(bs, len);
+            } else {
+                ByteStream_GetUINT8_Checked(bs, rawByte);
+                server->appParams.order = (OI_PBAP_ORDER_TAG_VALUES)rawByte;
+                if ((server->appParams.order != OI_PBAP_ORDER_INDEXED) &&
+                    (server->appParams.order != OI_PBAP_ORDER_ALPHANUMERIC) &&
+                    (server->appParams.order != OI_PBAP_ORDER_PHONETIC)) {
+                    OI_SLOG_ERROR(OI_OBEX_PRECONDITION_FAILED,
+                                  ("PBAP: client sent invalid order value: %d\n",
+                                   server->appParams.order));
+                    status = OI_OBEX_PRECONDITION_FAILED;
+                    goto out;
+                }
+                server->appParams.orderSet = TRUE;
+            }
+            break;
+
+        case OI_PBAP_TAG_ID_SEARCH_VALUE:
+            if (server->appParams.searchValueSet) {
+                OI_SLOG_WARNING(OI_STATUS_NONE,
+                                ("SearchValue already set, ignoring duplicate tag"));
+                ByteStream_Skip_Checked(bs, len);
+            } else {
+                server->appParams.searchValueLen = len;
+                server->appParams.searchValue = OI_Malloc(len);
+                if (!server->appParams.searchValue) {
+                    OI_SLOG_ERROR(OI_STATUS_OUT_OF_MEMORY,
+                                  ("Failed to allocate memory for SearchValue"));
+                    status = OI_STATUS_OUT_OF_MEMORY;
+                    goto out;
+                }
+                ByteStream_GetBytes_Checked(bs, server->appParams.searchValue, len);
+                server->appParams.searchValueSet = TRUE;
+            }
+            break;
+
+        case OI_PBAP_TAG_ID_SEARCH_ATTRIBUTE:
+            if (server->appParams.searchAttributeSet) {
+                OI_SLOG_WARNING(OI_STATUS_NONE,
+                                ("SearchAttribute already set, ignoring duplicate tag"));
+                ByteStream_Skip_Checked(bs, len);
+            } else {
+                OI_UINT8 sAttr = 0;
+                /* Convert the text representation of the search attribute to
+                 * a much easier enum value.
+                 */
+                ByteStream_GetUINT8_Checked(bs, sAttr);
+                server->appParams.searchAttribute = (OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES)sAttr;
+                server->appParams.searchAttributeSet = TRUE;
+            }
+            break;
+
+        case OI_PBAP_TAG_ID_MAX_LIST_COUNT:
+            if (len != sizeof(OI_UINT16)) {
+                OI_SLOG_ERROR(OI_OBEX_PRECONDITION_FAILED,
+                              ("PBAP: MaxListCount value has wrong length"));
+                status = OI_OBEX_PRECONDITION_FAILED;
+                    goto out;
+            }
+            if (server->appParams.maxListCountSet) {
+                OI_SLOG_WARNING(OI_STATUS_NONE,
+                                ("maxListCount already set, ignoring duplicate tag"));
+                ByteStream_Skip_Checked(bs, len);
+            } else {
+                ByteStream_GetUINT16_Checked(bs, server->appParams.maxListCount,
+                                             OI_BIG_ENDIAN_BYTE_ORDER);
+                server->appParams.maxListCountSet = TRUE;
+            }
+            break;
+
+        case OI_PBAP_TAG_ID_LIST_START_OFFSET:
+            if (len != sizeof(OI_UINT16)) {
+                OI_SLOG_ERROR(OI_OBEX_PRECONDITION_FAILED,
+                              ("PBAP: ListStartOffset value has wrong length"));
+                status = OI_OBEX_PRECONDITION_FAILED;
+                    goto out;
+            }
+            if (server->appParams.listStartOffsetSet) {
+                OI_SLOG_WARNING(OI_STATUS_NONE,
+                                ("ListStartOffset already set, ignoring duplicate tag"));
+                ByteStream_Skip_Checked(bs, len);
+            } else {
+                ByteStream_GetUINT16_Checked(bs, server->appParams.listStartOffset,
+                                             OI_BIG_ENDIAN_BYTE_ORDER);
+                server->appParams.listStartOffsetSet = TRUE;
+            }
+            break;
+
+        case OI_PBAP_TAG_ID_FILTER:
+            if (len != sizeof(OI_UINT64)) {
+                OI_SLOG_ERROR(OI_OBEX_PRECONDITION_FAILED,
+                              ("PBAP: Filter value has wrong length"));
+                status = OI_OBEX_PRECONDITION_FAILED;
+                    goto out;
+            }
+            if (server->appParams.filterSet) {
+                OI_SLOG_WARNING(OI_STATUS_NONE,
+                                ("Filter already set, ignoring duplicate tag"));
+                ByteStream_Skip_Checked(bs, len);
+            } else {
+                ByteStream_GetUINT32_Checked(bs, server->appParams.filter.I1,
+                                             OI_BIG_ENDIAN_BYTE_ORDER);
+                ByteStream_GetUINT32_Checked(bs, server->appParams.filter.I2,
+                                             OI_BIG_ENDIAN_BYTE_ORDER);
+                server->appParams.filterSet = TRUE;
+            }
+            break;
+
+        case OI_PBAP_TAG_ID_FORMAT:
+            if (len != sizeof(OI_UINT8)) {
+                OI_SLOG_ERROR(OI_OBEX_PRECONDITION_FAILED, ("PBAP: Format has wrong length"));
+                status = OI_OBEX_PRECONDITION_FAILED;
+                    goto out;
+            }
+            if (server->appParams.formatSet) {
+                OI_SLOG_WARNING(OI_STATUS_NONE,
+                                ("PBAP: Format already set, ignoring duplicate tag"));
+                ByteStream_Skip_Checked(bs, len);
+            } else {
+                ByteStream_GetUINT8_Checked(bs, rawByte);
+                server->appParams.format = (OI_PBAP_FORMAT_TAG_VALUES)rawByte;
+                if ((server->appParams.format != OI_PBAP_FORMAT_VCARD_2_1) &&
+                    (server->appParams.format != OI_PBAP_FORMAT_VCARD_3_0)) {
+                    OI_SLOG_ERROR(OI_OBEX_PRECONDITION_FAILED,
+                                  ("PBAP: client sent invalid Format: %d\n",
+                                   server->appParams.format));
+                    status = OI_OBEX_PRECONDITION_FAILED;
+                    goto out;
+                }
+                server->appParams.formatSet = TRUE;
+            }
+            break;
+
+        default:
+            break;
+        }
+    }
+
+    if (ByteStream_Error(bs)) {
+        OI_SLOG_ERROR(OI_OBEX_PRECONDITION_FAILED,
+                     ("PBAP: Application parameters are corrupted"));
+        status = OI_OBEX_PRECONDITION_FAILED;
+    }
+
+  out:
+    ByteStream_Close(bs);
+
+    return status;
+}
+
+
+static OI_STATUS ParseObexHeader(const OI_OBEX_HEADER_LIST *cmdHeaders)
+{
+    OI_INT i;
+    OI_OBEX_HEADER *hdr;
+    OI_OBEX_BYTESEQ *type = NULL;
+    OI_STATUS status = OI_OK;
+
+    OI_PBAP_DumpObexHeaders(cmdHeaders);
+
+    for (i = 0; i < cmdHeaders->count; ++i) {
+        hdr = &cmdHeaders->list[i];
+
+        switch (hdr->id) {
+        case OI_OBEX_HDR_NAME:
+            if (server->pathElemCnt == 0) {
+                if (hdr->val.name.str) {
+                    status = TokenizePath(&hdr->val.name, server->pathElements, &server->pathElemCnt);
+                    if (!OI_SUCCESS(status)) {
+                        goto out;
+                    }
+                } else {
+                    server->pathElemCnt = 0;
+                }
+            } else {
+                OI_SLOG_WARNING(OI_STATUS_NONE,
+                                ("File name received twice.  Ignoring duplicate"));
+            }
+            break;
+
+        case OI_OBEX_HDR_TYPE:
+            type = &hdr->val.type;
+            /* Only 3 OBEX types are supported by PBAP:
+             *     - x-bt/vcard
+             *     - x-bt/vcard-listing
+             *     - x-bt/phonebook
+             */
+            if (type->len > 0 && type->data) {
+                if (OI_StrncmpInsensitive((OI_CHAR*)type->data,
+                                          OI_PBAP_VCARD_LISTING_TYPE,
+                                          sizeof(OI_PBAP_VCARD_LISTING_TYPE) - 1) == 0) {
+                    OI_DBG_PRINT2(("Getting a Listing..."));
+                    server->getObject = PBAP_SERVER_LISTING;
+                } else if (OI_StrncmpInsensitive((OI_CHAR*)type->data,
+                                                 OI_PBAP_VCARD_TYPE,
+                                                 sizeof(OI_PBAP_VCARD_TYPE) - 1) == 0) {
+                    OI_DBG_PRINT2(("Getting a vCard..."));
+                    server->getObject = PBAP_SERVER_VCARD;
+                } else if (OI_StrncmpInsensitive((OI_CHAR*)type->data,
+                                                 OI_PBAP_PHONEBOOK_TYPE,
+                                                 sizeof(OI_PBAP_PHONEBOOK_TYPE) - 1) == 0) {
+                    OI_DBG_PRINT2(("Getting a Phonebook..."));
+                    server->getObject = PBAP_SERVER_PHONEBOOK;
+                } else {
+                    /* Invalid type requested. */
+                    OI_DBG_PRINT2(("Getting nothing... Invalid type: \"%s\"", type->data));
+                    status = OI_OBEX_ACCESS_DENIED;
+                    goto out;
+                }
+            } else {
+                /* Invalid type, cannot be empty. */
+                OI_SLOG_WARNING(OI_OBEX_ACCESS_DENIED,
+                                ("Getting nothing... Invalid type: \"%s\"", type->data));
+                status = OI_OBEX_ACCESS_DENIED;
+                goto out;
+            }
+            break;
+
+        case OI_OBEX_HDR_APPLICATION_PARAMS:
+            status = ParseAppParams(&hdr->val.applicationParams);
+            if (!OI_SUCCESS(status)) {
+                goto out;
+            }
+            break;
+
+        default:
+            break;
+        }
+    }
+
+  out:
+    return status;
+}
+
+
+void OI_PBAPServer_SetNewMissedCalls(OI_UINT8 newMissedCalls)
+{
+    OI_TRACE_USER(("OI_PBAPServer_SetNewMissedCalls(newMissedCalls = %d)", newMissedCalls));
+    server->newMissedCalls = newMissedCalls;
+}
+
+
+/******************************************************************************
+ * Get phonebook size routines
+ */
+OI_STATUS OI_PBAPServer_GetPhonebookSizeRsp(OI_PBAP_CONNECTION connectionId,
+                                            OI_UINT16 size,
+                                            OI_STATUS getStatus)
+{
+    static OI_OBEX_HEADER hdr;
+    static OI_OBEX_HEADER_LIST hdrList;
+    static OI_BYTE_STREAM bs;
+    static OI_BYTE buffer[(2 * OI_OBEX_APPLICATION_PARAMETER_PREFIX_LEN) +
+                          sizeof(OI_UINT16) + sizeof(OI_UINT8)];
+    OI_STATUS status = OI_OK;
+    int param_cnt = 0;
+
+    OI_TRACE_USER(("OI_PBAPServer_GetPhonebookSizeRsp(connectionId = %d, size = %d, getStatus = %d)",
+                 connectionId, size, getStatus));
+
+    hdrList.list = &hdr;
+    hdrList.count = 1;
+
+    if (!OI_SUCCESS(getStatus)) {
+        /* For whatever reason the application was unable to provide a size so
+         * tell the client that the service is unavailable.
+         */
+        setState(server, PBAP_SERVER_CONNECTED);
+        status = OI_OBEXSRV_GetResponse(server->id, NULL, OI_OBEX_SERVICE_UNAVAILABLE);
+    } else {
+        ByteStream_Init(bs, buffer, sizeof(buffer));
+        ByteStream_Open(bs, BYTESTREAM_WRITE);
+
+        ByteStream_PutUINT8(bs, OI_PBAP_TAG_ID_PHONEBOOK_SIZE);
+        ByteStream_PutUINT8(bs, 2);
+        ByteStream_PutUINT16(bs, size, OI_BIG_ENDIAN_BYTE_ORDER);
+        param_cnt += OI_OBEX_APPLICATION_PARAMETER_PREFIX_LEN + sizeof(OI_UINT16);
+
+        if (server->reportMissedCalls) {
+            ByteStream_PutUINT8(bs, OI_PBAP_TAG_ID_NEW_MISSED_CALLS);
+            ByteStream_PutUINT8(bs, 1);
+            ByteStream_PutUINT8(bs, server->newMissedCalls);
+            param_cnt += OI_OBEX_APPLICATION_PARAMETER_PREFIX_LEN + sizeof(OI_UINT8);
+        }
+
+        hdr.id = OI_OBEX_HDR_APPLICATION_PARAMS;
+        hdr.val.applicationParams.len = param_cnt;
+        hdr.val.applicationParams.data = ByteStream_GetDataPointer(bs);
+
+        ByteStream_Close(bs);
+
+        OI_PBAP_DumpObexHeaders(&hdrList);
+
+        setState(server, PBAP_SERVER_CONNECTED);
+        status = OI_OBEXSRV_GetResponse(server->id, &hdrList, OI_OK);
+    }
+
+    return status;
+}
+
+
+
+static OI_STATUS GetPhonebookSize(void)
+{
+    OI_PBAP_REPOSITORY repo;
+    OI_PBAP_PHONEBOOK pb;
+    OI_STATUS status;
+
+    OI_TRACE_USER(("GetPhonebookSize(<void>)"));
+
+    setState(server, PBAP_GETTING_PHONEBOOK_SIZE);
+
+    if (server->getObject == PBAP_SERVER_LISTING) {
+        status = ParsePhonebookDir(&repo, &pb);
+        if (!OI_SUCCESS(status)) {
+            return status;
+        }
+    } else {
+        status = ParsePhonebookvCard(&repo, &pb);
+        if (!OI_SUCCESS(status)) {
+            return status;
+        }
+    }
+
+    if (pb == OI_PBAP_MISSED_CALLS_HISTORY) {
+        server->reportMissedCalls = TRUE;
+    }
+
+    server->getPhonebookSize(server->id, repo, pb);
+
+    return OI_OK;
+}
+
+
+/******************************************************************************
+ * Phonebook file related routines.
+ */
+
+static void FileReadCfm(OI_PBAP_HANDLE handle,
+                        OI_BYTE *data,
+                        OI_UINT16 len,
+                        OI_STATUS cfmStatus,
+                        OI_PBAP_CONNECTION pbapConnection)
+{
+    static OI_OBEX_HEADER hdr;
+    static OI_OBEX_HEADER_LIST hdrList;
+    OI_STATUS status;
+
+    OI_TRACE_USER(("FileReadCfm(<*handle = %x>, <*data = %x>, len = %d, cfmStatus = %d, pbapConnection = %d)",
+                 handle, data, len, cfmStatus, pbapConnection));
+
+    if (!OI_SUCCESS(cfmStatus) && (cfmStatus != OI_STATUS_END_OF_FILE)) {
+        /*
+         * File read error: close the file and report error to obex.
+         */
+        OI_PBAP_HANDLE fileSv = server->file;
+
+        OI_SLOG_ERROR(cfmStatus, ("File read error"));
+        server->file = NULL;
+        setupDeferredFileClose(fileSv, server->id, cfmStatus);
+        status = OI_OBEXSRV_GetResponse(server->id, NULL, cfmStatus);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Failed to inform client of Read Failure (%d)", cfmStatus));
+        }
+        setState(server, PBAP_SERVER_CONNECTED);
+        return;
+    }
+
+    if (cfmStatus == OI_STATUS_END_OF_FILE) {
+        hdr.id = OI_OBEX_HDR_END_OF_BODY;
+        status = OI_OK;
+    } else {
+        hdr.id = OI_OBEX_HDR_BODY;
+        status = OI_OBEX_CONTINUE;
+    }
+
+    hdr.val.body.data = data;
+    hdr.val.body.len = len;
+    hdrList.list = &hdr;
+    hdrList.count = 1;
+
+    OI_PBAP_DumpObexHeaders(&hdrList);
+
+    status = OI_OBEXSRV_GetResponse(server->id, &hdrList, status);
+    if (!OI_SUCCESS(status)) {
+        OI_PBAP_HANDLE fileSv = server->file;
+
+        server->file = NULL;
+        setupDeferredFileClose(fileSv, server->id, status);
+
+        setState(server, PBAP_SERVER_CONNECTED);
+    }
+}
+
+
+static void OpenCfm(OI_PBAP_HANDLE handle,
+                    OI_STATUS cfmStatus,
+                    OI_PBAP_CONNECTION pbapConnection)
+{
+    static OI_OBEX_HEADER hdr;
+    static OI_OBEX_HEADER_LIST hdrList;
+    OI_STATUS status = cfmStatus;
+
+    OI_TRACE_USER(("OpenCfm(<*handle = %x>, cfmStatus = %d, pbapConnection = %d)",
+                 handle, status, pbapConnection));
+
+    OI_ASSERT(NULL != handle);
+    if (NULL == handle) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS, ("Invalid handle"));
+        status = OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    if (!OI_SUCCESS(status)) {
+        /*
+         * File was not opened so it doesn't need to be closed but we need to
+         * report the error to obex.
+         */
+        setState(server, PBAP_SERVER_CONNECTED);
+        status = OI_OBEXSRV_GetResponse(server->id, NULL, status);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Failed to inform the client of the open failure (%d)",
+                          cfmStatus));
+        }
+
+        if (server->appParams.searchValueSet) {
+            OI_DBG_PRINT2(("freeing server->appParams.searchValue"));
+            server->appParams.searchValueSet = FALSE;
+            OI_FreeIf(&server->appParams.searchValue);
+        }
+        return;
+    }
+
+    server->file = handle;
+
+    hdrList.list = &hdr;
+    hdrList.count = 0;
+
+    if ((server->state == PBAP_GETTING_PHONEBOOK ||
+         server->state == PBAP_GETTING_PHONEBOOK_LISTING) &&
+        server->reportMissedCalls) {
+        static OI_BYTE_STREAM bs;
+        static OI_BYTE buffer[OI_OBEX_APPLICATION_PARAMETER_PREFIX_LEN + sizeof(OI_UINT8)];
+
+        ByteStream_Init(bs, buffer, sizeof(buffer));
+        ByteStream_Open(bs, BYTESTREAM_WRITE);
+
+        ByteStream_PutUINT8(bs, OI_PBAP_TAG_ID_NEW_MISSED_CALLS);
+        ByteStream_PutUINT8(bs, 1);
+        ByteStream_PutUINT8(bs, server->newMissedCalls);
+
+        hdr.id = OI_OBEX_HDR_APPLICATION_PARAMS;
+        hdr.val.applicationParams.len = OI_OBEX_APPLICATION_PARAMETER_PREFIX_LEN + sizeof(OI_UINT8);
+        hdr.val.applicationParams.data = ByteStream_GetDataPointer(bs);
+
+        ByteStream_Close(bs);
+
+        hdrList.count++;
+    }
+
+    OI_PBAP_DumpObexHeaders(&hdrList);
+
+    status = OI_OBEXSRV_GetResponse(server->id, &hdrList, OI_OBEX_CONTINUE);
+    if (!OI_SUCCESS(status)) {
+        /*
+         * Close the file and cleanup.  Cannot call application on application
+         * thread, so put the fops close() on dispatcher.
+         */
+        setupDeferredFileClose(server->file, server->id, status);
+        server->file = NULL;
+        setState(server, PBAP_SERVER_CONNECTED);
+    }
+}
+
+
+static OI_STATUS OpenDataHandle(void)
+{
+    OI_PBAP_REPOSITORY repo;
+    OI_PBAP_PHONEBOOK pb;
+    OI_UINT32 entry = 0; /* initialize to avoid compiler warnings */
+    OI_STATUS status = OI_OK;
+
+    if (server->getObject == PBAP_SERVER_LISTING) {
+        status = ParsePhonebookDir(&repo, &pb);
+        if (!OI_SUCCESS(status)) {
+            goto out;
+        }
+
+        if (pb == OI_PBAP_MISSED_CALLS_HISTORY) {
+            server->reportMissedCalls = TRUE;
+        }
+
+        setState(server, PBAP_GETTING_PHONEBOOK_LISTING);
+        status = server->fops->listPB(repo,
+                                      pb,
+                                      server->appParams.order,
+                                      server->appParams.searchAttribute,
+                                      server->appParams.searchValue,
+                                      server->appParams.searchValueLen,
+                                      server->appParams.maxListCount,
+                                      server->appParams.listStartOffset,
+                                      OpenCfm,
+                                      (OI_PBAP_CONNECTION)server->id);
+    } else if (server->getObject == PBAP_SERVER_VCARD) {
+        status = ParseEntryName(&repo, &pb, &entry);
+
+        if (OI_SUCCESS(status)) {
+            setState(server, PBAP_GETTING_VCARD);
+            status = server->fops->openvCard(repo,
+                                             pb,
+                                             entry,
+                                             &server->appParams.filter,
+                                             server->appParams.format,
+                                             OpenCfm,
+                                             (OI_PBAP_CONNECTION)server->id);
+        }
+    } else {
+        status = ParsePhonebookvCard(&repo, &pb);
+        if (!OI_SUCCESS(status)) {
+            goto out;
+        }
+
+        if (pb == OI_PBAP_MISSED_CALLS_HISTORY) {
+            server->reportMissedCalls = TRUE;
+        }
+
+        setState(server, PBAP_GETTING_PHONEBOOK);
+        status = server->fops->openPB(repo,
+                                      pb,
+                                      &server->appParams.filter,
+                                      server->appParams.format,
+                                      server->appParams.maxListCount,
+                                      server->appParams.listStartOffset,
+                                      OpenCfm,
+                                      (OI_PBAP_CONNECTION)server->id);
+    }
+
+  out:
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_WARNING(status, ("Opening a handle for requested %s in %s-%s",
+                                 ((server->getObject == PBAP_SERVER_LISTING) ? "Phonebook Listing"     :
+                                  (server->getObject == PBAP_SERVER_VCARD)   ? "Phonebook Entry vCard" : "Phonebook vCard"),
+                                 ((repo == OI_PBAP_LOCAL_REPOSITORY) ? "local" :
+                                  (repo == OI_PBAP_SIM1_REPOSITORY)  ? "SIM1"  : "Invalid"),
+                                 ((pb == OI_PBAP_MAIN_PHONEBOOK)         ? "pb"  :
+                                  (pb == OI_PBAP_INCOMING_CALLS_HISTORY) ? "ich" :
+                                  (pb == OI_PBAP_OUTGOING_CALLS_HISTORY) ? "och" :
+                                  (pb == OI_PBAP_MISSED_CALLS_HISTORY)   ? "mch" :
+                                  (pb == OI_PBAP_COMBINED_CALLS_HISTORY) ? "cch" : "Invalid")));
+        setState(server, PBAP_SERVER_CONNECTED);
+    }
+
+    return status;
+}
+
+/******************************************************************************
+ * Routine for rejecting PUT request from the client.
+ */
+static OI_STATUS ServerPutInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                              OI_OBEX_HEADER_LIST *cmdHeaders,
+                              OI_STATUS obexStatus)
+{
+
+    OI_TRACE_USER(("ServerPutInd(connectionId = %d, <*cmdHeaders = %x>, obexStatus = %d)",
+                      connectionId, cmdHeaders, obexStatus));
+
+    if (OI_SUCCESS(obexStatus) || (obexStatus == OI_OBEX_CONTINUE)) {
+        OI_SLOG_WARNING(OI_OBEX_BAD_REQUEST,
+                        ("Invalid PUT request"));
+        OI_DBG_PRINT1(("ServerPutInd terminated with status: OI_OBEX_BAD_REQUEST;!"));
+        return OI_OBEX_BAD_REQUEST;
+    }
+
+    return obexStatus;
+}
+
+/******************************************************************************
+ * Routines for basic GET indication from the client.
+ */
+
+static void ClearAppParams(void)
+{
+    /* The PBAP spec doesn't clearly indicate that the "Type" OBEX header is
+     * required or what to assume if it is missing, so we'll default the
+     * operation of the PBAP server to be as if it received the "x-bt/vcard"
+     * type. */
+    server->getObject = PBAP_SERVER_VCARD;
+
+    server->reportMissedCalls = FALSE;
+
+    server->appParams.orderSet           = FALSE;
+    server->appParams.searchAttributeSet = FALSE;
+    server->appParams.searchValueSet     = FALSE;
+    server->appParams.maxListCountSet    = FALSE;
+    server->appParams.listStartOffsetSet = FALSE;
+    server->appParams.filterSet          = FALSE;
+    server->appParams.formatSet          = FALSE;
+
+    server->appParams.order           = OI_PBAP_ORDER_INDEXED;
+    OI_FreeIf(&server->appParams.searchValue);
+    server->appParams.searchValueLen  = 0;
+    server->appParams.searchAttribute = OI_PBAP_SEARCH_ATTRIBUTE_NAME;
+    server->appParams.maxListCount    = 65535;
+    server->appParams.listStartOffset = 0;
+    server->appParams.filter.I1       = 0;
+    server->appParams.filter.I2       = 0;
+    server->appParams.format          = OI_PBAP_FORMAT_VCARD_2_1;
+}
+
+static OI_STATUS ServerGetInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                              OI_OBEX_HEADER_LIST *cmdHeaders,
+                              OI_STATUS obexStatus)
+{
+    OI_STATUS status;
+
+    OI_TRACE_USER(("ServerGetInd(connectionId = %d, <*cmdHeaders = %x>, obexStatus = %d)",
+                      connectionId, cmdHeaders, obexStatus));
+
+    /* If there was an error or the GET operation is now complete, close the
+     * file and free memory allocated.
+     */
+    if (OI_SUCCESS(obexStatus) ||
+        ((obexStatus != OI_OBEX_CONTINUE) && (obexStatus != OI_OBEXSRV_INCOMPLETE_GET))) {
+        OI_DBG_PRINT1(("ServerGetInd terminated with status: %d", obexStatus));
+        status = OI_OK;
+        goto ServerGetCleanup;
+    }
+
+    /* Continuing a file or folder get operation. */
+    if (!server->incompleteGet && (server->state > PBAP_SERVER_CONNECTED)) {
+        OI_DBG_PRINT1(("Get more data..."));
+        status = server->fops->read(server->file,
+                                    server->maxRead,
+                                    FileReadCfm,
+                                    (OI_PBAP_CONNECTION)server->id);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_WARNING(status, ("File read failed"));
+            status = OI_OBEXSRV_GetResponse(connectionId, NULL, OI_OBEX_CONTINUE);
+            if (!OI_SUCCESS(status)) {
+                OI_SLOG_ERROR(status, ("Failed to inform client of read failure"));
+            }
+            goto ServerGetCleanup;
+        }
+        return OI_OK;
+    }
+
+    /* If this is a new request, set all the application parameters to their
+     * default values.
+     */
+    if(!server->incompleteGet) {
+        ClearAppParams();
+    }
+
+    /* Extract all the parameters from the OBEX headers. */
+    status = ParseObexHeader(cmdHeaders);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("Failed to parse OBEX header"));
+        goto ServerGetCleanup;
+    }
+
+
+    /* If the get is incomplete we need to send a continue response. */
+    server->incompleteGet = (obexStatus == OI_OBEXSRV_INCOMPLETE_GET);
+    if (server->incompleteGet) {
+        status = OI_OBEXSRV_GetResponse(connectionId, NULL, OI_OBEX_CONTINUE);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Failed to send OBEX GET repsonse"));
+            goto ServerGetCleanup;
+        }
+        return OI_OK;
+    }
+
+    /* Get request is complete */
+    if (server->appParams.maxListCountSet && server->appParams.maxListCount == 0) {
+        OI_DBG_PRINT1(("Get Phonebook Size"));
+        status = GetPhonebookSize();
+    } else {
+        OI_DBG_PRINT1(("Get Phonebook, Listing, or vCard"));
+        status = OpenDataHandle();
+    }
+
+    if (OI_SUCCESS(status)) {
+        OI_FreeIf(&server->pathElements[0]);
+        server->pathElemCnt = 0;
+        return OI_OK;
+    }
+
+  ServerGetCleanup:
+
+    /* Close file if we are already reading from it. */
+    if (!server->incompleteGet && (server->state > PBAP_SERVER_CONNECTED)) {
+        /* If we've called file open() but have not yet gotten the openCfm()
+         * our state is GETTING, but there is no file open yet.  Only call
+         * close if the file is open.
+         */
+        if (server->file) {
+            OI_PBAP_HANDLE fileSv = server->file;
+
+            server->file = NULL;
+            setupDeferredFileClose(fileSv, server->id, obexStatus);
+        }
+    }
+    OI_FreeIf(&server->pathElements[0]);
+    server->pathElemCnt = 0;
+    OI_FreeIf(&server->appParams.searchValue);
+    server->incompleteGet = FALSE;
+    setState(server, PBAP_SERVER_CONNECTED);
+
+    return status;
+}
+
+
+
+/******************************************************************************
+ * Handle set repository and phonebook operations from the client.
+ */
+
+static OI_STATUS ServerSetPathInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                  OI_OBEX_UNICODE *folder,
+                                  OI_BOOL upLevel,
+                                  OI_BOOL create)
+{
+    OI_STATUS status = OI_OK;
+    OI_STATUS status2;
+#if defined(OI_DEBUG)
+    const OI_CHAR16 root[] = {'<', 'r', 'o', 'o', 't', '>', 0};
+    (void) root;  /* Suppresses GCC warning for specialized debug builds. */
+#endif
+
+    OI_TRACE_USER(("ServerSetPathInd(connectionId = %d, <*folder = %x>, upLevel = %d, create = %d)",
+                 connectionId, folder, upLevel, create));
+
+#if defined(OI_DEBUG)
+    OI_DBG_PRINT2(("folder = \"%s\"\n",
+                      (folder && folder->str && (folder->len > 0)) ? folder->str : root,
+                      (folder && folder->str && (folder->len > 0)) ? folder->len : 6));
+#endif
+
+    if (!server)
+        return OI_OBEX_INTERNAL_SERVER_ERROR;
+
+    /*
+     * Create is illegal for phonebook access.
+     */
+    if (create) {
+        status = OI_OBEX_ACCESS_DENIED;
+        goto out;
+    }
+
+    /*
+     * NULL or empty folder name means set to root or parent folder
+     */
+    if ((folder == NULL) || (folder && folder->str == NULL) ||
+        (folder && folder->str[0] == 0)) {
+        if (upLevel) {
+            /*
+             * Check we are not aleady at the root folder
+             */
+            if (server->folderLevel == 0) {
+                OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                                ("Remote PBAP client requested invalid directory in setPath, \"%S\"",
+                             folder ? folder->str : "NULL"));
+                status = OI_OBEX_NOT_FOUND;
+                goto out;
+            }
+            server->folderLevel--;
+
+            if (server->phonebookSet) {
+                OI_DBG_PRINT2(("Setting path to parent \"telecom\" or <root> directory"));
+                server->phonebookSet = FALSE;
+            } else {
+                if (server->folderLevel == 0) {
+                    OI_DBG_PRINT2(("Setting path to <root> directory"));
+                    server->repositorySet = FALSE;
+                    server->repository = OI_PBAP_LOCAL_REPOSITORY;
+                } else if ((server->repository == OI_PBAP_SIM1_REPOSITORY) &&
+                           (server->folderLevel == 1)) {
+                    OI_DBG_PRINT2(("Setting path to \"SIM1\" directory"));
+                    server->repositorySet = FALSE;
+                }
+            }
+        } else {
+            OI_DBG_PRINT2(("Setting path to <root> directory"));
+            server->repositorySet = FALSE;
+            server->phonebookSet = FALSE;
+            server->repository = OI_PBAP_LOCAL_REPOSITORY;
+            server->folderLevel = 0;
+        }
+    } else {
+        /* Handle decending into the specified folder */
+        OI_CHAR16 *elements[3];  /* 3 elements are all that's needed: SIM1, telecom, pb */
+        OI_UINT16 elemCnt = OI_ARRAYSIZE(elements);
+        OI_UINT16 elem;
+
+
+        /*
+         * Check we have a valid folder name
+         */
+        if (folder->len == 0) {
+            OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                            ("Remote PBAP client requested invalid phonebook directory"));
+            status = OI_OBEX_NOT_FOUND;
+            goto out;
+        }
+
+        /* There are no directories under the phonebook directories. */
+        if (server->phonebookSet) {
+            OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                            ("Remote PBAP client requested SetPath while in a leaf directory, \"%S\"",
+                             folder->str));
+            status = OI_OBEX_NOT_FOUND;
+            goto out;
+        }
+
+        status = TokenizePath(folder, elements, &elemCnt);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_WARNING(status, ("PBAP: Error tokenizing folder, \"%S\"", folder->str));
+            OI_Free(elements[0]);
+            goto out;
+        }
+
+        if (server->folderLevel + elemCnt > 3) {
+            OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                            ("Remote PBAP client requested folder path that exceeds the maximum depth"));
+            status = OI_OBEX_NOT_FOUND;
+            OI_Free(elements[0]);
+            goto out;
+        }
+
+        for (elem = 0; (OI_SUCCESS(status) && (elem < elemCnt)); elem++) {
+            switch(server->folderLevel) {
+            case 0:     /* In the <root> directory. */
+                if (OI_StrcmpUtf16(elements[elem], OI_PBAP_usim1) == 0) {
+                    server->repository = OI_PBAP_SIM1_REPOSITORY;
+                    server->folderLevel++;
+                    OI_DBG_PRINT2(("Set path to SIM1"));
+                } else if (OI_StrcmpUtf16(elements[elem], OI_PBAP_utelecom) == 0) {
+                    server->repository = OI_PBAP_LOCAL_REPOSITORY;
+                    server->repositorySet = TRUE;
+                    server->folderLevel++;
+                    OI_DBG_PRINT2(("Set path to telecom"));
+                } else {
+                    OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                                    ("Remote PBAP client requested invalid directory in SetPath, \"%s\"",
+                                     elements[elem]));
+                    status = OI_OBEX_NOT_FOUND;
+                }
+                break;
+
+            case 1:     /* In the "SIM1" or "telecom" directory. */
+                if ((server->repository == OI_PBAP_SIM1_REPOSITORY) &&
+                    (OI_StrcmpUtf16(elements[elem], OI_PBAP_utelecom) == 0)) {
+                    server->repositorySet = TRUE;
+                    server->folderLevel++;
+                    OI_DBG_PRINT2(("Set path to SIM1/telecom"));
+                } else {
+                    status = LookupPhonebook(elements[elem], &server->phonebook);
+                    if (OI_SUCCESS(status)) {
+                        server->phonebookSet = TRUE;
+                        server->folderLevel++;
+                        OI_DBG_PRINT2(("Set path to telecom/%S",
+                                          OI_PBAP_upbdirs[server->phonebook]));
+                    } else {
+                        OI_SLOG_WARNING(status,
+                                        ("Remote PBAP client requested invalid directory in SetPath, \"%s\"",
+                                         elements[elem]));
+                    }
+                }
+                break;
+
+            case 2:     /* In the "SIM1/telecom" or "telecom/<phonebook>" directory. */
+                if (server->repository == OI_PBAP_LOCAL_REPOSITORY) {
+                    OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                                    ("Remote PBAP client requested invalid directory in SetPath: \"%s\"",
+                                     elements[elem]));
+                    status = OI_OBEX_NOT_FOUND;
+                } else {
+                    status = LookupPhonebook(elements[elem], &server->phonebook);
+                    if (OI_SUCCESS(status)) {
+                        server->phonebookSet = TRUE;
+                        server->folderLevel++;
+                        OI_DBG_PRINT2(("Set path to SIM1/telecom/%S",
+                                          OI_PBAP_upbdirs[server->phonebook]));
+                    } else {
+                        OI_SLOG_WARNING(status,
+                                        ("Remote PBAP client requested invalid directory in SetPath, \"%s\"",
+                                         elements[elem]));
+                    }
+                }
+                break;
+
+            default:    /* No more subdirectories below SIM1/telecom/<phonebook>. */
+                OI_SLOG_WARNING(OI_OBEX_NOT_FOUND,
+                                ("Remote PBAP client requested invalid directory in SetPath, \"%s\"",
+                                 elements[elem]));
+                status = OI_OBEX_NOT_FOUND;
+                break;
+            }
+        }
+
+        OI_Free(elements[0]);
+    }
+
+  out:
+    status2 = OI_OBEXSRV_ConfirmSetpath(server->id, status, NULL);
+    if (!OI_SUCCESS(status2)) {
+        OI_SLOG_ERROR(status2, ("Failed to confirm (%d) the set path operation with the client",
+                                status));
+    }
+
+    return status;
+}
+
+
+
+/******************************************************************************
+ * Basic connection management routines.
+ */
+
+OI_STATUS OI_PBAPServer_AuthenticationResponse(OI_PBAP_CONNECTION connectionId,
+                                               const OI_BYTE *userId,
+                                               OI_UINT8 userIdLen,
+                                               const OI_CHAR *password)
+{
+    OI_STATUS status;
+
+    OI_TRACE_USER(("OI_PBAPServer_AuthenticationResponse(connectionId = %d, server's userId = \"%s\", server's userIdLen = %d, server's password = \"%s\")",
+                 connectionId, userId, userIdLen, userIdLen, password));
+
+    if (!OI_INIT_FLAG_VALUE(PBAP_SRV)) {
+        status = OI_STATUS_NOT_INITIALIZED;
+    } else if ((server->state != PBAP_SERVER_IDLE) || !server->unauthorized) {
+        status = OI_OBEX_INVALID_OPERATION;
+    } else {
+        status = OI_OBEXSRV_AuthenticationResponse(server->id, userId, userIdLen, password, TRUE);
+
+        if (OI_SUCCESS(status)) {
+            server->maxRead = OI_OBEXSRV_OptimalBodyHeaderSize(server->id);
+    }
+    }
+
+    return status;
+}
+
+
+static void ServerConnectInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                             OI_BOOL                      unauthorized,
+                             OI_BYTE                      *userId,
+                             OI_UINT8                     userIdLen,
+                             OI_OBEX_REALM                *realm)
+{
+    OI_STATUS status;
+    OI_BD_ADDR clientAddr;
+
+    OI_TRACE_USER(("ServerConnectInd(connectionId = %d, unauthorized = %d, client's userId = \"%s\", client's userIdLen = %d)",
+                      connectionId, unauthorized,
+                      userId, userIdLen, userIdLen));
+
+    /*
+     * Check that the server is not already in use.
+     */
+    if (server->state > PBAP_SERVER_IDLE) {
+        OI_SLOG_ERROR(OI_STATUS_NONE, ("PBAP server already in use"));
+        status = OI_OBEXSRV_AcceptConnect(connectionId, FALSE, OI_STATUS_NO_RESOURCES, NULL);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Failed to inform client of connection failure"));
+        }
+        return;
+    }
+
+    server->unauthorized = unauthorized;
+    server->id = connectionId;
+
+    /*
+     * Pass address of connecting client to application.
+     */
+    status = OI_OBEXSRV_GetClientAddr(connectionId, &clientAddr);
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("Failed to get client address"));
+        status = OI_OBEXSRV_AcceptConnect(connectionId, FALSE, OI_FAIL, NULL);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Failed to inform client of connection failure"));
+        }
+    } else {
+        server->connectInd(&clientAddr, unauthorized, userId, userIdLen, connectionId);
+    }
+}
+
+
+OI_STATUS OI_PBAPServer_AcceptConnection(OI_PBAP_CONNECTION connectionId,
+                                         OI_UINT8 newMissedCalls,
+                                         OI_BOOL accept)
+{
+    OI_STATUS status = OI_OK;
+
+    OI_TRACE_USER(("OI_PBAPServer_AcceptConnection(connectionId = %d, newMissedCalls = %d, accept = %d)",
+                 connectionId, newMissedCalls, accept));
+
+    if (!OI_INIT_FLAG_VALUE(PBAP_SRV)) {
+        status = OI_STATUS_NOT_INITIALIZED;
+        goto out;
+    }
+    if ((server->state != PBAP_SERVER_IDLE) || (server->id != connectionId)) {
+        status = OI_OBEX_INVALID_OPERATION;
+        goto out;
+    }
+    /*
+     * If the connection is being rejected or was unauthorized reject the
+     * connection.
+     */
+    if (server->unauthorized || !accept) {
+
+        status = OI_OBEX_ACCESS_DENIED;
+
+        OI_DBG_PRINT2(("Denying OBEX access: status = %d", status));
+        status = OI_OBEXSRV_AcceptConnect(server->id, FALSE, status, NULL);
+        if (!OI_SUCCESS(status)) {
+            OI_SLOG_ERROR(status, ("Failed to inform client of connection rejection"));
+        }
+        goto out;
+    }
+
+    server->folderLevel = 0;
+    server->repositorySet = FALSE;
+    server->phonebookSet = FALSE;
+    server->repository = OI_PBAP_LOCAL_REPOSITORY;
+    server->newMissedCalls = newMissedCalls;
+
+    status = OI_OBEXSRV_AcceptConnect(server->id, TRUE, OI_OK, NULL);
+    if (OI_SUCCESS(status)) {
+        setState(server, PBAP_SERVER_CONNECTED);
+        server->maxRead = OI_OBEXSRV_OptimalBodyHeaderSize(server->id);
+    } else {
+        OI_SLOG_ERROR(status, ("PBAP: Failed to accept connection"));
+    }
+  out:
+    return status;
+}
+
+
+static void ServerDisconnectInd(OI_OBEXSRV_CONNECTION_HANDLE connectionId)
+{
+    OI_TRACE_USER(("ServerDisconnectInd(connectionId = %d)", connectionId));
+
+    OI_ASSERT(server->id == connectionId);
+    server->id = 0;
+    setState(server, PBAP_SERVER_IDLE);
+    server->disconnectInd(connectionId);
+}
+
+
+OI_STATUS OI_PBAPServer_ForceDisconnect(OI_PBAP_CONNECTION connectionId)
+{
+    OI_TRACE_USER(("OI_PBAPServer_ForceDisconnect(connectionId = %d)", connectionId));
+
+    if (!OI_INIT_FLAG_VALUE(PBAP_SRV)) {
+        return OI_STATUS_NOT_INITIALIZED;
+    }
+    if (connectionId != server->id) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    if (server->state < PBAP_SERVER_CONNECTED) {
+        return OI_OBEX_NOT_CONNECTED;
+    }
+    return OI_OBEXSRV_ForceDisconnect(server->id);
+}
+
+
+/******************************************************************************
+ * Basic service registration management routines.
+ */
+
+OI_STATUS OI_PBAPServer_Register(OI_OBEXSRV_AUTHENTICATION authentication,
+                                 OI_PBAP_CONNECTION_IND connectInd,
+                                 OI_PBAP_DISCONNECTION_IND disconnectInd,
+                                 OI_PBAP_SERVER_GET_PHONEBOOK_SIZE_IND getPhonebookSize,
+                                 const OI_PBAP_SERVER_FILESYS_FUNCTIONS *fileOperations,
+                                 const OI_SDP_STRINGS *strings,
+                                 OI_UINT32 *srecHandle,
+                                 OI_UINT8 suppRepositories,
+                                 OI_OBEX_SERVER_HANDLE *serverHandle)
+{
+    static OI_OBEXSRV_CB_LIST CBList = {
+        ServerConnectInd,       /* connectInd       */
+        ServerDisconnectInd,    /* disconnectInd    */
+        ServerGetInd,           /* getInd           */
+        ServerPutInd,           /* putInd           */
+        ServerSetPathInd,       /* setPathInd       */
+        NULL,                   /* bulkGetInd        */
+        NULL,                   /* actionInd        */
+        NULL,                   /* progressInd      */
+        NULL,                   /* authInd          */
+        NULL                   /* abortInd         */
+    };
+    static OI_BYTE uuid[OI_OBEX_UUID_SIZE] = OI_PBAP_OBEX_TARGET_UUID;
+    OI_OBEX_LOWER_PROTOCOL lowerProtocol;
+    OI_OBEX_BYTESEQ target = { OI_ARRAYSIZE(uuid), uuid };
+    OI_SDPDB_SERVICE_RECORD srec;
+    OI_STATUS status;
+
+    OI_TRACE_USER(("OI_PBAPServer_Register(<*authentication = %x>, <*connectInd = %x>, <*disconnectInd = %x>, <*getPhonebookSize = %x>, <*fileOperations = %x>, <*strings = %x>, <*srecHandle = %x>, suppRepositories = %s%s%s)",
+                 authentication, connectInd, disconnectInd, getPhonebookSize, fileOperations, strings,
+                 srecHandle,
+                 suppRepositories & OI_PBAP_SUPPORTED_REPOSITORIES_LOCAL ? "LOCAL" : "",
+                 ~suppRepositories & (OI_PBAP_SUPPORTED_REPOSITORIES_LOCAL | OI_PBAP_SUPPORTED_REPOSITORIES_SIM) ? "" : " and ",
+                 suppRepositories & OI_PBAP_SUPPORTED_REPOSITORIES_SIM ? "SIM1" : ""));
+
+    OI_ARGCHECK(fileOperations && connectInd && disconnectInd && strings);
+    OI_ARGCHECK((suppRepositories & ~(OI_PBAP_SUPPORTED_REPOSITORIES_LOCAL |
+                                   OI_PBAP_SUPPORTED_REPOSITORIES_SIM)) == 0);
+
+    if (OI_INIT_FLAG_VALUE(PBAP_SRV)) {
+        return OI_STATUS_ALREADY_REGISTERED;
+    }
+
+    server = OI_Calloc(sizeof(PBAP_SERVER));
+    if (server == NULL) {
+        OI_SLOG_ERROR(OI_STATUS_OUT_OF_MEMORY,
+                      ("Failed to allocate memory for PBAP server structure"));
+        return OI_STATUS_OUT_OF_MEMORY;
+    }
+
+    /* Store the root folder. The current folder is reset to the root folder at
+     * the start of each new connection.
+     */
+    server->connectInd = connectInd;
+    server->disconnectInd = disconnectInd;
+    server->getPhonebookSize = getPhonebookSize;
+    server->fops = fileOperations;
+
+    /* There is no file open. */
+    server->file = NULL;
+
+    lowerProtocol.protocol = OI_OBEX_LOWER_RFCOMM;
+    /* Try and get the preferred PBAP channel number. */
+    lowerProtocol.svcId.rfcommChannel = OI_CONFIG_TABLE_GET(PBAP_SRV)->rfcomm_channel_pref;
+
+    status = OI_OBEXSRV_RegisterServer(&target,
+                                       &CBList,
+                                       authentication,
+                                       NULL,
+                                       &lowerProtocol,
+                                       1,
+                                       &connectPolicy,
+                                       &server->serverHandle);
+    if (!OI_SUCCESS(status) ) {
+        goto ErrorExit;
+    }
+
+    /* Register service record. */
+    OI_SET_UINT_ELEMENT(OurServerChannel, lowerProtocol.svcId.rfcommChannel);
+    OI_SET_UINT_ELEMENT(SupportedRepositories, suppRepositories);
+
+    srec.Attributes = ServiceDescription;
+    srec.NumAttributes = OI_ARRAYSIZE(ServiceDescription);
+    srec.Strings = strings->attrs;
+    srec.NumStrings = strings->num;
+
+    OI_DBG_PRINT1(("Registered Phonebook Access Profile"));
+
+    OI_INIT_FLAG_INCREMENT(PBAP_SRV);
+
+    /* Return the server handle to the caller. */
+    *serverHandle = server->serverHandle;
+
+    /* Return the SDP record handle to the caller. */
+    if (srecHandle) {
+        *srecHandle = server->srecHandle;
+    }
+
+    return OI_OK;
+  ErrorExit:
+
+    OI_SLOG_ERROR(status, ("OI_PBAPServer_Register failed"));
+
+    if (server) {
+        if (server->serverHandle) {
+            OI_OBEXSRV_DeregisterServer(server->serverHandle);
+        }
+        OI_Free(server);
+    }
+
+    return status;
+}
+
+
+OI_STATUS OI_PBAPServer_Deregister(OI_OBEX_SERVER_HANDLE serverHandle)
+{
+    OI_STATUS status;
+
+    OI_TRACE_USER(("OI_PBAPServer_Deregister"));
+
+    if (!OI_INIT_FLAG_VALUE(PBAP_SRV)) {
+        return OI_STATUS_NOT_REGISTERED;
+    }
+    if (!server) {
+            return OI_STATUS_INVALID_HANDLE;
+    }
+    if (server->serverHandle != serverHandle) {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+
+    status = OI_OBEXSRV_DeregisterServer(server->serverHandle);
+
+    if (!OI_SUCCESS(status)) {
+        OI_SLOG_ERROR(status, ("Error deregistering server"));
+        goto fail;
+    }
+
+    if(server)
+        OI_Free(server);
+    server = NULL;
+
+    OI_INIT_FLAG_DECREMENT(PBAP_SRV);
+
+    return OI_OK;
+
+ fail:
+    return status;
+}
diff --git a/obex_profiles/sdk/include/oi_argcheck.h b/obex_profiles/sdk/include/oi_argcheck.h
new file mode 100644
index 0000000..5396f3c
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_argcheck.h
@@ -0,0 +1,83 @@
+#ifndef _ARGCHECK_H
+#define _ARGCHECK_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+
+This file provides a macro for validating function arguments.
+*/
+
+#include "oi_assert.h"
+#include "oi_status.h"
+
+/** \addtogroup Debugging */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * The OI_ARGCHECK macro is to be used for checking function arguments in
+ * public interfaces. It takes a conditional as an argument and
+ * succeeds if the conditional is TRUE. If the conditional is FALSE,
+ * an assertion is perfomed, and OI_STATUS_INVALID_PARAMETERS is returned.
+ * Assertions can be disabled by not defining OI_DEBUG.
+ *
+ * If OI_SUPPRESS_ARGCHECK is defined, no argument checking is performed.
+ * This allows us to use strong argument checking when the caller may
+ * not be known (e.g., under Windows) and use assertions for debugging,
+ * but leave the code out of the release build, when the stack and
+ * application are tightly coupled (e.g., a deeply embedded system).
+ *
+ * Note that the documentation for BLUEmagic 3.0 software assumes that
+ * OI_SUPPRESS_ARGCHECK is NOT defined. To leave argument checking code
+ * out of build, pass -DOI_SUPPRESS_ARGCHECK on your compiler command line.
+ */
+
+#ifndef OI_SUPPRESS_ARGCHECK
+#define OI_ARGCHECK(x) {OI_ASSERT((x)); if (!(x)) return OI_STATUS_INVALID_PARAMETERS; }
+#else
+#define OI_ARGCHECK(x)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _ARGCHECK_H */
+
+
diff --git a/obex_profiles/sdk/include/oi_assert.h b/obex_profiles/sdk/include/oi_assert.h
new file mode 100644
index 0000000..31ec7b5
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_assert.h
@@ -0,0 +1,94 @@
+#ifndef _OI_ASSERT_H
+#define _OI_ASSERT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @file
+  This file provides macros and functions for compile-time and run-time assertions.
+
+  When the OI_DEBUG preprocessor value is defined, the macro OI_ASSERT is compiled into
+  the program, providing for a runtime assertion failure check.
+  C_ASSERT is a macro that can be used to perform compile time checks.
+*/
+
+/** \addtogroup Debugging Debugging APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef OI_DEBUG
+
+/** The macro OI_ASSERT takes a condition argument. If the asserted condition
+    does not evaluate to true, the OI_ASSERT macro calls the host-dependent function,
+    OI_AssertFail(), which reports the failure and generates a runtime error.
+*/
+void OI_AssertFail(char* file, int line, char* reason);
+
+
+#define OI_ASSERT(condition) \
+    { if (!(condition)) OI_AssertFail(__FILE__, __LINE__, #condition); }
+
+#define OI_ASSERT_FAIL(msg) \
+    { OI_AssertFail(__FILE__, __LINE__, msg); }
+
+#else
+
+
+#define OI_ASSERT(condition)
+#define OI_ASSERT_FAIL(msg)
+
+#endif
+
+
+/**
+   C_ASSERT() can be used to perform many compile-time assertions: type sizes, field offsets, etc.
+   An assertion failure results in compile time error C2118: negative subscript.
+   Unfortunately, this elegant macro doesn't work with GCC, so it's all commented out
+   for now. Perhaps later.....
+*/
+
+#ifndef C_ASSERT
+// #define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
+// #define C_ASSERT(e)
+#endif
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_ASSERT_H */
+
diff --git a/obex_profiles/sdk/include/oi_bt.h b/obex_profiles/sdk/include/oi_bt.h
new file mode 100644
index 0000000..c069532
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_bt.h
@@ -0,0 +1,93 @@
+#ifndef _OI_BT_H
+#define _OI_BT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+   @file
+   This file contains a list of most of the header files.
+ */
+
+/* OEM headers */
+#include "oi_wrapper.h"
+
+/* General includes */
+#include "oi_assert.h"
+#include "oi_bt_assigned_nos.h"
+#include "oi_bt_profile_config.h"
+#include "oi_bt_spec.h"
+#include "oi_bt_stack_config.h"
+#include "oi_bt_stack_init.h"
+#include "oi_common.h"
+#include "oi_config_table.h"
+#include "oi_connect_policy.h"
+#include "oi_cpu_dep.h"
+#include "oi_dataelem.h"
+#include "oi_debugcontrol.h"
+#include "oi_dump.h"
+#include "oi_l2cap.h"
+#include "oi_modules.h"
+#include "oi_osinterface.h"
+#include "oi_rfcomm.h"
+#include "oi_rfcomm_prefs.h"
+#include "oi_sdp.h"
+#include "oi_sdpdb.h"
+#include "oi_status.h"
+#include "oi_statustext.h"
+#include "oi_stddefs.h"
+#include "oi_text.h"
+#include "oi_time.h"
+#include "oi_unicode.h"
+#include "oi_utils.h"
+
+/* Profiles */
+#include "oi_bip_cli.h"
+#include "oi_bip_spec.h"
+#include "oi_bip_srv.h"
+#include "oi_bnep.h"
+#include "oi_bpp.h"
+#include "oi_bpp_printer.h"
+#include "oi_bpp_sender.h"
+#include "oi_ftp_client.h"
+#include "oi_ftp_file.h"
+#include "oi_ftp_server.h"
+#include "oi_ftp_sys.h"
+#include "oi_obexcli.h"
+#include "oi_obex_sd.h"
+#include "oi_obexspec.h"
+#include "oi_obexsrv.h"
+#include "oi_opp_client.h"
+#include "oi_opp_ofs.h"
+#include "oi_opp_server.h"
+#include "oi_opp_sys.h"
+
+#endif /* _OI_BT_H */
+
diff --git a/obex_profiles/sdk/include/oi_bt_assigned_nos.h b/obex_profiles/sdk/include/oi_bt_assigned_nos.h
new file mode 100644
index 0000000..3c2964f
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_bt_assigned_nos.h
@@ -0,0 +1,694 @@
+#ifndef _OI_BT_ASSIGNED_NOS_H
+#define _OI_BT_ASSIGNED_NOS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @file
+
+    This file contains constant definitions for Bluetooth assigned numbers, including
+    Bluetooth device types, L2CAP PSMs (protocol/service multiplexors), and
+    SDP UUIDs (universally unique identifiers) and Attribute Identifiers.
+
+    For up-to-date information on these various assigned numbers, see the Bluetooth
+    wireless technology "Assigned Numbers" specification, which is no longer part of
+    the core Bluetooth specification but is maintained on the Bluetooth SIG website at
+    http://www.bluetooth.org/assigned-numbers/.
+
+*/
+
+#include "oi_stddefs.h"
+#include "oi_bt_spec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+/**
+ * @name Class of Device/Service field
+ * The Class of Device/Service bitfield indicates Bluetooth device type and
+ * is composed by using the ClassOfDevice macro with service class, major device
+ * class, and minor device class values as input.
+ * @{
+ */
+
+/** Create a class of device field from major service, major device, and minor device numbers. */
+#define OI_CLASS_OF_DEVICE(majserv, majdev, mindev) ((majserv) | (majdev) | (mindev))
+
+/**
+ * Extract the Major Service Class from a class of device.
+ */
+#define OI_GET_MAJOR_SERVICE(cod)  ((cod) & OI_BT_DEV_CLASS_MAJOR_SERVICE_MASK)
+
+/**
+ * Extract the Major Device Class from a class of device.
+ */
+#define OI_GET_MAJOR_DEVICE(cod) ((cod) & OI_BT_DEV_CLASS_MAJOR_DEVICE_MASK)
+
+/**
+ * Extract the Minor Device Class from a class of device.
+ */
+#define OI_GET_MINOR_DEVICE(cod) ((cod) & OI_BT_DEV_CLASS_MINOR_DEVICE_MASK)
+
+/** Convert a number to a major device class value. */
+#define OI_BT_MAJOR_DEVICE_CLASS(x) ((x) << 8)
+
+/** Convert a number to a minor device class value. */
+#define OI_BT_MINOR_DEVICE_CLASS(x) ((x) << 2)
+
+/**@}*/
+
+
+/**
+ * @name Service class
+ * This field indicates type of service.
+ * @note OI_BIT14 and OI_BIT15 are reserved.
+ * @{
+ */
+
+#define OI_SERVICE_CLASS_LIMITED_DISCOVERABLE  OI_BIT13
+//OI_BIT14 and OI_BIT15 reserved
+#define OI_SERVICE_CLASS_POSITIONING           OI_BIT16
+#define OI_SERVICE_CLASS_NETWORKING            OI_BIT17
+#define OI_SERVICE_CLASS_RENDERING             OI_BIT18
+#define OI_SERVICE_CLASS_CAPTURING             OI_BIT19
+#define OI_SERVICE_CLASS_OBJECT_TRANSFER       OI_BIT20
+#define OI_SERVICE_CLASS_AUDIO                 OI_BIT21
+#define OI_SERVICE_CLASS_TELEPHONY             OI_BIT22
+#define OI_SERVICE_CLASS_INFORMATION           OI_BIT23
+
+/**@}*/
+
+/**
+ * @name Major device class
+ * This field indicates major device class.
+ * @{
+ */
+
+#define OI_BT_MAJOR_DEVICE_CLASS_MISCELLANEOUS      OI_BT_MAJOR_DEVICE_CLASS(0)
+#define OI_BT_MAJOR_DEVICE_CLASS_COMPUTER           OI_BT_MAJOR_DEVICE_CLASS(1)
+#define OI_BT_MAJOR_DEVICE_CLASS_PHONE              OI_BT_MAJOR_DEVICE_CLASS(2)
+#define OI_BT_MAJOR_DEVICE_CLASS_ACCESS_POINT       OI_BT_MAJOR_DEVICE_CLASS(3)
+#define OI_BT_MAJOR_DEVICE_CLASS_AUDIO_VIDEO        OI_BT_MAJOR_DEVICE_CLASS(4)
+#define OI_BT_MAJOR_DEVICE_CLASS_PERIPHERAL         OI_BT_MAJOR_DEVICE_CLASS(5)
+#define OI_BT_MAJOR_DEVICE_CLASS_IMAGING            OI_BT_MAJOR_DEVICE_CLASS(6)
+#define OI_BT_MAJOR_DEVICE_CLASS_WEARABLE           OI_BT_MAJOR_DEVICE_CLASS(7)
+#define OI_BT_MAJOR_DEVICE_CLASS_UNCATEGORIZED      OI_BT_MAJOR_DEVICE_CLASS(31)
+
+
+/**@}*/
+
+/**
+ * @name Minor device class: uncategorized
+ * This value indicates that the device's minor device class is uncategorized.
+ * @{
+ */
+
+#define OI_BT_MINOR_DEVICE_CLASS_UNCATEGORIZED      0
+
+/**@}*/
+
+/**
+ * @name Minor device class within computer major device class
+ * This field indicates minor device class within the computer major device class.
+ * @{
+ */
+
+#define OI_BT_MINOR_DEVICE_CLASS_DESKTOP            OI_BT_MINOR_DEVICE_CLASS(1)
+#define OI_BT_MINOR_DEVICE_CLASS_SERVER             OI_BT_MINOR_DEVICE_CLASS(2)
+#define OI_BT_MINOR_DEVICE_CLASS_LAPTOP             OI_BT_MINOR_DEVICE_CLASS(3)
+#define OI_BT_MINOR_DEVICE_CLASS_HANDHELD           OI_BT_MINOR_DEVICE_CLASS(4)
+#define OI_BT_MINOR_DEVICE_CLASS_PALM_SIZED         OI_BT_MINOR_DEVICE_CLASS(5)
+#define OI_BT_MINOR_DEVICE_CLASS_WEARABLE           OI_BT_MINOR_DEVICE_CLASS(6)
+
+/**@}*/
+
+/**
+ * @name Minor device class within phone major device class
+ * This field indicates minor device class within the phone major device class.
+ * @{
+ */
+
+#define OI_BT_MINOR_DEVICE_CLASS_CELLULAR           OI_BT_MINOR_DEVICE_CLASS(1)
+#define OI_BT_MINOR_DEVICE_CLASS_CORDLESS           OI_BT_MINOR_DEVICE_CLASS(2)
+#define OI_BT_MINOR_DEVICE_CLASS_SMARTPHONE         OI_BT_MINOR_DEVICE_CLASS(3)
+#define OI_BT_MINOR_DEVICE_CLASS_MODEM              OI_BT_MINOR_DEVICE_CLASS(4) /**< Wired modem or voice gateway */
+#define OI_BT_MINOR_DEVICE_CLASS_ISDN_ACCESS        OI_BT_MINOR_DEVICE_CLASS(5)
+
+/**@}*/
+
+/**
+ * @name Minor device class within audio/video major device class
+ * This field indicates minor device class within the audio/video major device class.
+ * @note Values 3 and 17 are reserved.
+ * @{
+ */
+
+#define OI_BT_MINOR_DEVICE_CLASS_HEADSET            OI_BT_MINOR_DEVICE_CLASS(1)
+#define OI_BT_MINOR_DEVICE_CLASS_HANDS_FREE         OI_BT_MINOR_DEVICE_CLASS(2)
+                                          //3 reserved
+#define OI_BT_MINOR_DEVICE_CLASS_MICROPHONE         OI_BT_MINOR_DEVICE_CLASS(4)
+#define OI_BT_MINOR_DEVICE_CLASS_LOUDSPEAKER        OI_BT_MINOR_DEVICE_CLASS(5)
+#define OI_BT_MINOR_DEVICE_CLASS_HEADPHONES         OI_BT_MINOR_DEVICE_CLASS(6)
+#define OI_BT_MINOR_DEVICE_CLASS_PORTABLE_AUDIO     OI_BT_MINOR_DEVICE_CLASS(7)
+#define OI_BT_MINOR_DEVICE_CLASS_CAR_AUDIO          OI_BT_MINOR_DEVICE_CLASS(8)
+#define OI_BT_MINOR_DEVICE_CLASS_SET_TOP_BOX        OI_BT_MINOR_DEVICE_CLASS(9)
+#define OI_BT_MINOR_DEVICE_CLASS_HIFI_AUDIO         OI_BT_MINOR_DEVICE_CLASS(10)
+#define OI_BT_MINOR_DEVICE_CLASS_VCR                OI_BT_MINOR_DEVICE_CLASS(11)
+#define OI_BT_MINOR_DEVICE_CLASS_VIDEO_CAMERA       OI_BT_MINOR_DEVICE_CLASS(12)
+#define OI_BT_MINOR_DEVICE_CLASS_CAMCORDER          OI_BT_MINOR_DEVICE_CLASS(13)
+#define OI_BT_MINOR_DEVICE_CLASS_VIDEO_MONITOR      OI_BT_MINOR_DEVICE_CLASS(14)
+#define OI_BT_MINOR_DEVICE_CLASS_VIDEO_DISPLAY      OI_BT_MINOR_DEVICE_CLASS(15)
+#define OI_BT_MINOR_DEVICE_CLASS_VIDEO_CONFERENCING OI_BT_MINOR_DEVICE_CLASS(16)
+/* #define OI_BT_MINOR_DEVICE_CLASS_RESERVED        OI_BT_MINOR_DEVICE_CLASS(17) */
+#define OI_BT_MINOR_DEVICE_CLASS_VIDEO_GAMING       OI_BT_MINOR_DEVICE_CLASS(18)
+
+/**@}*/
+
+
+/**
+ * @name Minor device class within peripheral major device class
+ * This field indicates minor device class within the peripheral major device class.
+ * @{
+ */
+
+#define OI_BT_MINOR_DEVICE_CLASS_KEYBOARD           OI_BIT6
+#define OI_BT_MINOR_DEVICE_CLASS_POINTING_DEVICE    OI_BIT7
+#define OI_BT_MINOR_DEVICE_CLASS_COMBO_KEYBOARD_POINTING  (OI_BIT6 | OI_BIT7)
+
+#define OI_BT_MINOR_DEVICE_CLASS_JOYSTICK           OI_BT_MINOR_DEVICE_CLASS(1)
+#define OI_BT_MINOR_DEVICE_CLASS_GAMEPAD            OI_BT_MINOR_DEVICE_CLASS(2)
+#define OI_BT_MINOR_DEVICE_CLASS_REMOTE_CONTROL     OI_BT_MINOR_DEVICE_CLASS(3)
+#define OI_BT_MINOR_DEVICE_CLASS_SENSING_DEVICE     OI_BT_MINOR_DEVICE_CLASS(4)
+#define OI_BT_MINOR_DEVICE_CLASS_DIGITIZER_TABLET   OI_BT_MINOR_DEVICE_CLASS(5)
+
+/**@}*/
+
+/**
+ * @name Minor device class within imaging major device class
+ * This field indicates minor device class within the imaging major device class.
+ * @{
+ */
+
+#define OI_BT_MINOR_DEVICE_CLASS_DISPLAY  OI_BIT4
+#define OI_BT_MINOR_DEVICE_CLASS_CAMERA   OI_BIT5
+#define OI_BT_MINOR_DEVICE_CLASS_SCANNER  OI_BIT6
+#define OI_BT_MINOR_DEVICE_CLASS_PRINTER  OI_BIT7
+
+/**
+ * @name Minor device class within Wearable major device class
+ * This field indicates minor device class within the Wearable major device class.
+ * @{
+ */
+
+#define OI_BT_MINOR_DEVICE_CLASS_WRISTWATCH         OI_BT_MINOR_DEVICE_CLASS(1)
+#define OI_BT_MINOR_DEVICE_CLASS_PAGER              OI_BT_MINOR_DEVICE_CLASS(2)
+#define OI_BT_MINOR_DEVICE_CLASS_JACKET             OI_BT_MINOR_DEVICE_CLASS(3)
+#define OI_BT_MINOR_DEVICE_CLASS_HELMET             OI_BT_MINOR_DEVICE_CLASS(4)
+#define OI_BT_MINOR_DEVICE_CLASS_GLASSES            OI_BT_MINOR_DEVICE_CLASS(5)
+
+/**@}*/
+
+
+/**
+ * @name Protocol/Service Multiplexer Definitions.
+ * @{
+ * These numbers identify protocols to L2CAP and to L2CAP client protocols.
+ */
+
+#define OI_PSM_SDP                 0x0001 /**< Service Discovery Protocol (SDP) */
+#define OI_PSM_RFCOMM              0x0003 /**< RFCOMM */
+#define OI_PSM_TCS                 0x0005 /**< Telephony Control protocol Specification (TCS) */
+#define OI_PSM_TCS_CORDLESS        0x0007 /**< Telephony Control protocol Specification (TCS), cordless */
+#define OI_PSM_BNEP                0x000F /**< Bluetooth Network Encapsulation Protocal */
+#define OI_PSM_HID_CONTROL         0x0011 /**< Human Interface Device Control */
+#define OI_PSM_HID_INTERRUPT       0x0013 /**< Human Interface Device Interrupt */
+#define OI_PSM_AVCTP               0x0017 /**< Audio/Video Control Transport Protocol */
+#define OI_PSM_AVDTP               0x0019 /**< Audio/Video Distribution Transport Protocol */
+#define OI_PSM_AVCTP_BROWSING      0x001B /**< Audio/Video Control Transport Protocol for Browsing */
+#define OI_PSM_UDI_C_PLANE         0x001D /**< Unrestricted Digital Information Profile [UDI] */
+
+/**@}*/
+
+
+/**
+ * @name Bluetooth Base UUID definition
+ * @{
+ * This definition initializes the base 128-bit Bluetooth UUID, OI_UUID_BASE_UUID128.
+ */
+
+#define OI_UUID_BASE_UUID128 \
+    { 0x00000000, { 0x00, 0x00, 0x10, 0x00, 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB } }
+
+/**@}*/
+
+/**
+ * A 128-bit UUID initialized to the base UUID.
+ */
+extern const OI_UUID128 OI_UUID_BaseUUID128;
+
+
+/**
+ * @name Protocol UUIDs
+ * @{
+ */
+
+#define OI_UUID_NULL                    0      /**< special value for invalid or unknown UUID */
+
+#define OI_UUID_SDP                    0x0001  /**< Bluetooth Service Discovery Protocol (SDP) */
+#define OI_UUID_UDP                    0x0002  /**< UDP (User Datagram Protocol) */
+#define OI_UUID_RFCOMM                 0x0003  /**< RFCOMM with TS 07.10 */
+#define OI_UUID_TCP                    0x0004  /**< TCP (Transmission Control Protocol) */
+#define OI_UUID_TCS_BIN                0x0005  /**< Bluetooth Telephony Control Specification / TCS Binary */
+#define OI_UUID_TCS_AT                 0x0006  /**< modem */
+#define OI_UUID_OBEX                   0x0008  /**< OBEX */
+#define OI_UUID_IP                     0x0009  /**< IP (Internet Protocol) */
+#define OI_UUID_FTP                    0x000A  /**< FTP (File Transfer Protocol) */
+#define OI_UUID_HTTP                   0x000C  /**< HTTP (Hypertext Transport Protocol) */
+#define OI_UUID_WSP                    0x000E  /**< WSP (Wireless Session Protocol (related to WAP) */
+#define OI_UUID_BNEP                   0x000F  /**< BNEP (Basic Network Encapsulation Protocol) */
+#define OI_UUID_UPNP                   0x0010  /**< ESDP (Extended Service Discovery Protocol for Universal Plug and Play) */
+#define OI_UUID_HIDP                   0x0011  /**< HID (Human Interface Device Profile) */
+#define OI_UUID_HardcopyControlChannel 0x0012  /**< part of HCRP (Hardcopy Cable Replacement Profile) */
+#define OI_UUID_HardcopyDataChannel    0x0014  /**< part of HCRP (Hardcopy Cable Replacement Profile) */
+#define OI_UUID_HardcopyNotification   0x0016  /**< part of HCRP (Hardcopy Cable Replacement Profile) */
+#define OI_UUID_AVCTP                  0x0017  /**< Audio/Video Control Transport Protocol */
+#define OI_UUID_AVDTP                  0x0019  /**< Audio/Video Distribution Transport Protocol */
+#define OI_UUID_CMPT                   0x001B  /**< CAPI Message Transport Protocol */
+#define OI_UUID_UDI_C_Plane            0x001D  /**< Unrestricted Digital Information Profile [UDI] */
+#define OI_UUID_MCAP_Control           0x001E  /**< Multi-channel adaptation protocol (MCAP), control channel */
+#define OI_UUID_MCAP_Data              0x001F  /**< Multi-channel adaptation protocol (MCAP), data channel */
+#define OI_UUID_L2CAP                  0x0100  /**< Logical Link Control and Adaptation Protocol specification */
+
+/**@}*/
+
+/**
+ * @name Service class identifiers and names
+ * @{
+ * If the specified service class directly and exactly implies a certain profile,
+ * then the profile is identified.
+ */
+
+#define OI_UUID_ServiceDiscoveryServerServiceClassID  0x1000  /**< service class for SDP itself */
+#define OI_UUID_BrowseGroupDescriptorServiceClassID   0x1001  /**< See SDP. */
+#define OI_UUID_PublicBrowseGroup                     0x1002  /**< root browse group UUID */
+#define OI_UUID_SerialPort                            0x1101  /**< See Generic Access Profile. */
+#define OI_UUID_LANAccessUsingPPP                     0x1102  /**< See Local Area Network Access Profile. */
+#define OI_UUID_DialupNetworking                      0x1103  /**< See Dial-Up Networking Profile. */
+#define OI_UUID_IrMCSync                              0x1104  /**< See Synchronization Profile. */
+#define OI_UUID_OBEXObjectPush                        0x1105  /**< See Object Push Profile. */
+#define OI_UUID_OBEXFileTransfer                      0x1106  /**< See File Transfer Profile. */
+#define OI_UUID_IrMCSyncCommand                       0x1107  /**< See Synchronization Profile. */
+#define OI_UUID_Headset                               0x1108  /**< See Generic Access Profile. */
+#define OI_UUID_CordlessTelephony                     0x1109  /**< See Cordless Telephony Profile. */
+#define OI_UUID_AudioSource                           0x110A  /**< n/a */
+#define OI_UUID_AudioSink                             0x110B  /**< n/a */
+#define OI_UUID_AV_RemoteControlTarget                0x110C  /**< Audio/Video Control Profile */
+#define OI_UUID_AdvancedAudioDistribution             0x110D  /**< Advanced Audio Distribution Profile */
+#define OI_UUID_AV_RemoteControl                      0x110E  /**< Audio/Video Control Profile */
+#define OI_UUID_VideoConferencing                     0x110F  /**< Video Conferencing Profile */
+#define OI_UUID_Intercom                              0x1110  /**< See Intercom Profile. */
+#define OI_UUID_Fax                                   0x1111  /**< See Fax Profile. */
+#define OI_UUID_HeadsetAudioGateway                   0x1112  /**< See Generic Access Profile. */
+#define OI_UUID_WAP                                   0x1113  /**< See Interoperability Requirements for Bluetooth as a WAP. */
+#define OI_UUID_WAP_CLIENT                            0x1114  /**< See Interoperability Requirements for Bluetooth as a WAP. */
+#define OI_UUID_PANU                                  0x1115  /**< See Personal Area Networking profile. */
+#define OI_UUID_NAP                                   0x1116  /**< See Personal Area Networking profile. */
+#define OI_UUID_GN                                    0x1117  /**< See Personal Area Networking profile. */
+#define OI_UUID_DirectPrinting                        0x1118  /**< See Basic Printing Profile */
+#define OI_UUID_ReferencePrinting                     0x1119  /**< See Basic Printing Profile */
+#define OI_UUID_Imaging                               0x111A  /**< [IMAGING] */
+#define OI_UUID_ImagingResponder                      0x111B  /**< [IMAGING] */
+#define OI_UUID_ImagingAutomaticArchive               0x111C  /**< [IMAGING] */
+#define OI_UUID_ImagingReferencedObjects              0x111D  /**< [IMAGING] */
+#define OI_UUID_Handsfree                             0x111E  /**< Handsfree Profile */
+#define OI_UUID_HandsfreeAudioGateway                 0x111F  /**< Handsfree Profile */
+#define OI_UUID_DirectPrintingReferenceObjectsService 0x1120  /**< See Basic Printing Profile. */
+#define OI_UUID_ReflectedUI                           0x1121  /**< See Basic Printing Profile. */
+#define OI_UUID_BasicPrinting                         0x1122  /**< See Basic Printing Profile. */
+#define OI_UUID_PrintingStatus                        0x1123  /**< See Basic Printing Profile. */
+#define OI_UUID_HumanInterfaceDeviceService           0x1124  /**< See Human Interface Device. */
+#define OI_UUID_HardcopyCableReplacement              0x1125  /**< See Hardcopy Cable Replacement Profile. */
+#define OI_UUID_HCR_Print                             0x1126  /**< See Hardcopy Cable Replacement Profile. */
+#define OI_UUID_HCR_Scan                              0x1127  /**< See Hardcopy Cable Replacement Profile. */
+#define OI_UUID_Common_ISDN_Access                    0x1128  /**< See CAPI Message Transport Protocol */
+#define OI_UUID_VideoConferencingGW                   0x1129  /**< See Video Conferencing Profile (VCP) */
+#define OI_UUID_UID_MT                                0x112A  /**< See UID */
+#define OI_UUID_UID_TA                                0x112B  /**< See UID */
+#define OI_UUID_Audio_Video                           0x112C  /**< See Video Conferencing Profile (VCP)*/
+#define OI_UUID_SIM_Access                            0x112D  /**< See SIM Access Profile (SAP) */
+#define OI_UUID_PhonebookAccessClient                 0x112E  /**< Phonebook Access Profile Client Equipment */
+#define OI_UUID_PhonebookAccessServer                 0x112F  /**< Phonebook Access Profile Server Equipment */
+#define OI_UUID_PhonebookAccess                       0x1130  /**< Phonebook Access Profile ID */
+#define OI_UUID_Headset_HS                            0x1131  /**< Headset profile */
+#define OI_UUID_MessageAccessServer                   0x1132  /**< MAP profile */
+#define OI_UUID_MessageNotificationServer             0x1133  /**< MAP profile */
+#define OI_UUID_MessageAccessProfile                  0x1134  /**< MAP profile */
+
+#define OI_UUID_PnPInformation                        0x1200  /**< Bluetooth Device Identification */
+#define OI_UUID_GenericNetworking                     0x1201  /**< n/a */
+#define OI_UUID_GenericFileTransfer                   0x1202  /**< n/a */
+#define OI_UUID_GenericAudio                          0x1203  /**< n/a */
+#define OI_UUID_GenericTelephony                      0x1204  /**< n/a */
+#define OI_UUID_UPNP_Service                          0x1205  /**< [ESDP} and possible future profiles */
+#define OI_UUID_UPNP_IP_Service                       0x1206  /**< [ESDP} and possible future profiles */
+
+#define OI_UUID_ESDP_UPNP_IP_PAN                      0x1300  /**< [ESDP] */
+#define OI_UUID_ESDP_UPNP_IP_LAP                      0x1301  /**< [ESDP] */
+#define OI_UUID_ESDP_UPNP_IP_L2CAP                    0x1302  /**< [ESDP] */
+
+#define OI_UUID_VideoSource                           0x1303  /**< Video Distribution Profile */
+#define OI_UUID_VideoSink                             0x1304  /**< Video Distribution Profile */
+#define OI_UUID_VideoDistribution                     0x1305  /**< Video Distribution Profile */
+
+#define OI_UUID_HDP                                   0x1400  /**< Health Device Profile */
+#define OI_UUID_HDPSource                             0x1401  /**< Health Device Profile */
+#define OI_UUID_HDPSink                               0x1402  /**< Health Device Profile */
+
+#define OI_UUID_MAX_VALUE                             0x1402  /**< The current maximum UUID value */
+
+/**@}*/
+
+
+/**
+ * @name Attribute Identifier Codes
+ * @{
+ */
+
+#define OI_ATTRID_ServiceRecordHandle               0x0000  /**< See Bluetooth Service Discovery Protocol (SDP). */
+#define OI_ATTRID_ServiceClassIDList                0x0001  /**< [SDP] */
+#define OI_ATTRID_ServiceRecordState                0x0002  /**< [SDP] */
+#define OI_ATTRID_ServiceID                         0x0003  /**< [SDP] */
+#define OI_ATTRID_ProtocolDescriptorList            0x0004  /**< [SDP] */
+#define OI_ATTRID_BrowseGroupList                   0x0005  /**< [SDP] */
+#define OI_ATTRID_LanguageBaseAttributeIDList       0x0006  /**< [SDP] */
+#define OI_ATTRID_ServiceInfoTimeToLive             0x0007  /**< [SDP] */
+#define OI_ATTRID_ServiceAvailability               0x0008  /**< [SDP] */
+#define OI_ATTRID_BluetoothProfileDescriptorList    0x0009  /**< [SDP] */
+#define OI_ATTRID_DocumentationURL                  0x000A  /**< [SDP] */
+#define OI_ATTRID_ClientExecutableURL               0x000B  /**< [SDP] */
+#define OI_ATTRID_IconURL                           0x000C  /**< [SDP] */
+#define OI_ATTRID_AdditionalProtocolDescriptorLists 0x000D  /**< [SDP] */
+#define OI_ATTRID_GroupID                           0x0200  /**< [SDP] */
+#define OI_ATTRID_IpSubnet                          0x0200  /**< See Personal Area Networking profile. */
+#define OI_ATTRID_VersionNumberList                 0x0200  /**< [SDP] */
+#define OI_ATTRID_SupportFeaturesList               0x0200  /**< [HDP] */
+#define OI_ATTRID_ServiceDatabaseState              0x0201  /**< [SDP] */
+#define OI_ATTRID_Service_Version                   0x0300  /**< n/a */
+#define OI_ATTRID_DataExchangeSpecification         0x0301  /**< See Health Device Profile (HDP) */
+#define OI_ATTRID_External_Network                  0x0301  /**< See Cordless Telephony Profile. */
+#define OI_ATTRID_Network                           0x0301  /**< See the Handsfree Profile (HFP) */
+#define OI_ATTRID_Supported_Data_Stores_List        0x0301  /**< See Synchronization Profile. */
+#define OI_ATTRID_FaxClass1Support                  0x0302  /**< standard fax (See Fax Profile.) */
+#define OI_ATTRID_RemoteAudioVolumeControl          0x0302  /**< See Generic Access Profile. */
+#define OI_ATTRID_MCAP_SupportedFeatures            0x0302  /**< See Health Device Profile (HFP). */
+#define OI_ATTRID_FaxClass20Support                 0x0303  /**< standard fax (See Fax Profile.) */
+#define OI_ATTRID_SupportedFormatsList              0x0303  /**< See Object Push Profile. */
+#define OI_ATTRID_FaxClass2Support                  0x0304  /**< non-standard fax (See Fax Profile.)*/
+#define OI_ATTRID_Audio_Feedback_Support            0x0305  /**< N/A */
+#define OI_ATTRID_NetworkAddress                    0x0306  /**< See Interoperability Requirements for Bluetooth as a WAP */
+#define OI_ATTRID_WAPGateWay                        0x0307  /**< See Interoperability Requirements for Bluetooth as a WAP */
+#define OI_ATTRID_HomePageURL                       0x0308  /**< See Interoperability Requirements for Bluetooth as a WAP */
+#define OI_ATTRID_WAPStackType                      0x0309  /**< See Interoperability Requirements for Bluetooth as a WAP */
+#define OI_ATTRID_SecurityDescription               0x030A  /**< See Personal Area Networking profile. */
+#define OI_ATTRID_NetAccessType                     0x030B  /**< See Personal Area Networking profile. */
+#define OI_ATTRID_MaxNetAccessRate                  0x030C  /**< See Personal Area Networking profile. */
+#define OI_ATTRID_IPV4_Subnet                       0x030D  /**< See Personal Area Networking profile. */
+#define OI_ATTRID_IPV6_Subnet                       0x030E  /**< See Personal Area Networking profile. */
+#define OI_ATTRID_SupportedCapabilities             0x0310  /**< [IMAGING] */
+#define OI_ATTRID_SupportedFeatures                 0x0311  /**< [IMAGING],[HFP],[BPAP] */
+#define OI_ATTRID_SupportedFunctions                0x0312  /**< [IMAGING] */
+#define OI_ATTRID_TotalImagingDataCapacity          0x0313  /**< [IMAGING] */
+#define OI_ATTRID_SupportedRepositories             0x0314  /**< [PBAP] */
+#define OI_ATTRID_MAS_InstanceID                    0x0315  /**< Message Access Profile */
+#define OI_ATTRID_SupportedMessageTypes             0x0316  /**< Message Access Profile */
+
+#define OI_ATTRID_BPP_DocumentFormats               0x0350  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_CharacterRepertoires          0x0352  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_XHTMLPrintImageFormats        0x0354  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_Color                         0x0356  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_1284ID                        0x0358  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_PrinterName                   0x035a  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_PrinterLocation               0x035c  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_Duplex                        0x035e  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_MediaTypes                    0x0360  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_MaxMediaWidth                 0x0362  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_MaxMediaLength                0x0364  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_EnhancedLayout                0x0366  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_RUIFormats                    0x0368  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_ReferencePrintingRUI          0x0370  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_DirectPrintingRUI             0x0372  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_ReferencePrintingTopURL       0x0374  /**<  Basic Printing Profile */
+#define OI_ATTRID_BPP_DirectPrintingTopURL          0x0376  /**<  Basic Printing Profile */
+#define OI_ATTRID_MAX_VALUE                         0x0377  /**< highest attribute ID used; not maximum allowable, which is 0xFFFF */
+
+#define OI_ATTRID_OBEX_over_L2CAP                   0x0200  /**< Attribute for publishing the PSM for OBEX/L2CAP (this value has not yet been established) */
+
+/**@}*/
+
+/**
+ * @name Extended Inquiry Response Data types (GAP spec)
+ * @{
+ */
+
+#define OI_EIR_FLAGS                            0x01  /**< Flags */
+#define OI_EIR_UUID16_SOME                      0x02  /**< 16-bit UUID, more available */
+#define OI_EIR_UUID16_ALL                       0x03  /**< 16-bit UUID, all listed */
+#define OI_EIR_UUID32_SOME                      0x04  /**< 32-bit UUID, more available */
+#define OI_EIR_UUID32_ALL                       0x05  /**< 32-bit UUID, all listed */
+#define OI_EIR_UUID128_SOME                     0x06  /**< 128-bit UUID, more available */
+#define OI_EIR_UUID128_ALL                      0x07  /**< 128-bit UUID, all listed */
+#define OI_EIR_NAME_SHORT                       0x08  /**< shortened local name */
+#define OI_EIR_NAME_COMPLETE                    0x09  /**< complete local name */
+#define OI_EIR_TX_POWER                         0x0A  /**< Transmit power level */
+#define OI_OOB_CLASS_OF_DEVICE                  0x0D  /**< Class of Device (OOB only) */
+#define OI_OOB_SIMPLE_PAIRING_HASH_C            0x0E  /**< Simple Pairing HashC (OOB only) */
+#define OI_OOB_SIMPLE_PAIRING_RAND_R            0x0F  /**< Simple Pairing RandR (OOB only) */
+#define OI_EIR_DEVICE_ID                        0x10  /**< Device ID */
+#define OI_EIR_MANF_DATA                        0xFF  /**< Manufacturer Specific Data */
+
+
+
+/**@}*/
+/**
+ * @name String Attribute Identifiers
+ * @{
+ * Attribute Identifier codes for string attributes are computed by adding
+ * a base offset, as given by the LanguageBaseOffset attribute.
+ * For the primary language, this is 0x0100, as described in section 5.1.8 of
+ * the Bluetooth specification v3.0+HS vol 3 part B.
+ */
+
+#define OI_ATTRID_DEFAULT_LanguageBaseOffset 0x0100
+
+#define OI_ATTRID_ServiceName                0x0000  /**< [SDP] */
+#define OI_ATTRID_ServiceDescription         0x0001  /**< [SDP] */
+#define OI_ATTRID_ProviderName               0x0002  /**< [SDP] */
+#define OI_ATTRID_ServiceName_Primary        (OI_ATTRID_ServiceName | OI_ATTRID_DEFAULT_LanguageBaseOffset)         /**< primary service name computed by adding OI_ATTRID_DEFAULT_LanguageBaseOffset to OI_ATTRID_ServiceName */
+#define OI_ATTRID_ServiceDescription_Primary (OI_ATTRID_ServiceDescription | OI_ATTRID_DEFAULT_LanguageBaseOffset)  /**< primary service name computed by adding OI_ATTRID_DEFAULT_LanguageBaseOffset to OI_ATTRID_ServiceDescription */
+#define OI_ATTRID_ProviderName_Primary       (OI_ATTRID_ProviderName | OI_ATTRID_DEFAULT_LanguageBaseOffset)        /**< primary service name computed by adding OI_ATTRID_DEFAULT_LanguageBaseOffset to OI_ATTRID_ProviderName */
+
+/**@}*/
+
+/**
+ * @name SDP language identifiers
+ * @{
+ * These definitions come from ISO 639:1988.
+ */
+#define OI_LANG_ID(c1, c2)    ((OI_UINT16) ((c1 << 8) | (c2)))  /**< Macro for generating unsigned 16 bit value for language id */
+
+#define OI_LANG_ID_ARABIC   OI_LANG_ID('a','r')
+#define OI_LANG_ID_GERMAN   OI_LANG_ID('d','e')
+#define OI_LANG_ID_ENGLISH  OI_LANG_ID('e','n')
+#define OI_LANG_ID_SPANISH  OI_LANG_ID('e','s')
+#define OI_LANG_ID_FRENCH   OI_LANG_ID('f','r')
+#define OI_LANG_ID_HEBREW   OI_LANG_ID('h','e')
+#define OI_LANG_ID_JAPANESE OI_LANG_ID('j','a')
+#define OI_LANG_ID_KOREAN   OI_LANG_ID('k','o')
+#define OI_LANG_ID_CHINESE  OI_LANG_ID('z','h')
+/**@}*/
+
+/**
+ * @name SDP Character Sets
+ * @{
+ * Defines for character set encodings. The Bluetooth specification recommends
+ * the use of UTF-8 encoding.
+ *
+ * These are "MIBenum" values as defined in the IANA character set assignment
+ * registry. This document may be found at
+ * http://www.iana.org/assignments/character-sets
+ */
+#define OI_LANG_ENCODING_US_ASCII         3  /**< ISO646-US encoding. See IETF RFC 1345 */
+#define OI_LANG_ENCODING_ISO_8859_1       4  /**< ISO-8859-1 encoding, also known as ISO Latin 1. See IETF RFC 1345 */
+#define OI_LANG_ENCODING_JIS             16  /**< JIS X 0202-1991 encoding */
+#define OI_LANG_ENCODING_SHIFT_JIS       17  /**< JIS X 0208:1997 Appendix 1 */
+#define OI_LANG_ENCODING_EUC_JP          18  /**< OSF/UNIX standard */
+#define OI_LANG_ENCODING_KSC_5601        36  /**< ECMA standard */
+#define OI_LANG_ENCODING_ISO_2022_KR     37  /**< IETF RFC 1557, KS_C_5601-1987 */
+#define OI_LANG_ENCODING_EUC_KR          38  /**< IETF RFC 1557, KS_C_5861-1992 */
+#define OI_LANG_ENCODING_ISO_2022_JP     39  /**< IETF RFC 1468, IETF RFC 2237 */
+#define OI_LANG_ENCODING_ISO_2022_JP_2   40  /**< IETF RFC 1554 */
+#define OI_LANG_ENCODING_GB2312_80       57  /**< ECMA */
+#define OI_LANG_ENCODING_UTF8           106  /**< IETF RFC 2279 */
+#define OI_LANG_ENCODING_GBK            113  /**< http://www.iana.org/assignments/charset-reg/GBK */
+#define OI_LANG_ENCODING_UTF16BE       1013  /**< UTF-16, big-endian byte order. See IETF RFC 2781 */
+#define OI_LANG_ENCODING_UTF16LE       1014  /**< UTF-16, little-endian byte order. See IETF RFC 2781 */
+#define OI_LANG_ENCODING_UTF16         1015  /**< UTF-16, byte order specified by optional BOM. See IETF RFC 2781 */
+#define OI_LANG_ENCODING_BIG5_HKSCS    2101  /**< http://www.iana.org/assignments/charset-reg/Big5-HKSCS */
+#define OI_LANG_ENCODING_BIG5          2026  /**< Taiwanese encoding */
+
+/**@}*/
+
+/**
+ * @def OI_ATTRID_RANGE
+ * This macro constructs an attribute range as defined in the SDP section of
+ * the Bluetooth specification. The attribute identifier range is a 32-bit value that
+ * describes a list of attributes with consecutive identifiers and is sent as a response
+ * to an SDP attribute request. The high-order 16 bits are the low bound of the range.
+ * The low-order 16 bits are the high bound of the range.
+ *
+ * @param lowBound is the low bound of an attribute range
+ *
+ * @param highBound is the high bound of an attribute range
+ */
+
+#define OI_ATTRID_RANGE(lowBound, highBound)   ((((OI_UINT32)(lowBound)) << 16) | ((OI_UINT32)(highBound)))
+
+/**
+ * @def OI_ATTRID_RANGE_ALL
+ * This macro constructs an attribute range which covers all attribute IDs. This
+ * value may be used to construct an SDP query to retrieve all information about
+ * a service
+ */
+
+#define OI_ATTRID_RANGE_ALL OI_ATTRID_RANGE(0x0000, 0xFFFF)
+
+/**
+ * @name Protocol Parameter Indices
+ * @{
+ */
+
+#define OI_PROTOCOL_PARAM_PSM                            1
+#define OI_PROTOCOL_PARAM_RFCOMM_Channel                 1
+#define OI_PROTOCOL_PARAM_TCP_Port                       1
+#define OI_PROTOCOL_PARAM_UDP_Port                       1
+#define OI_PROTOCOL_PARAM_BNEP_Version                   1
+#define OI_PROTOCOL_PARAM_BNEP_SupportedNetworkTypeList  2
+
+/**@}*/
+
+/**
+ * This function returns a text string corresponding to an attribute ID.
+ * NULL will be returned if the attribute ID is not in the list of Bluetooth
+ * assigned numbers.
+ *
+ * @param AttrId an attribute ID from the assigned numbers list
+ *
+ * @return a text string or NULL
+ */
+
+OI_CHAR* OI_AttrIdText(OI_UINT16 AttrId);
+
+
+/**
+ * This function returns a text string corresponding to a UUID16 or UUID32.
+ * NULL will be returned if the UUID is not in the list of Bluetooth assigned
+ * numbers.
+ *
+ * @param UUID            This is a 16-bit or 32-bit universally unique identifier.
+ *                        A 16-bit UUID (of type OI_UINT16) can be cast to OI_UUID32.
+ *
+ * @return a text string or NULL
+ */
+
+OI_CHAR* OI_UUIDText(OI_UUID32 UUID);
+
+/**
+ * This function returns a text string corresponding to a UUID128.
+ * NULL will be returned if the UUID is not in the list of Bluetooth assigned
+ * numbers.
+ *
+ * @param UUID           A pointer to a 128 bit UUID.
+ *
+ * @return a text string or NULL
+ */
+
+OI_CHAR* OI_UUID128Text(OI_UUID128 *UUID);
+
+/**
+ * This function returns a text string corresponding to a fixed PSM.
+ * Empty string ("") will be returned if the PSM is not in the list of Bluetooth assigned numbers.
+ *
+ * @param PSM       psm
+ *
+ * @return a text string
+ */
+
+OI_CHAR* OI_PSMText(OI_UINT16 psm);
+
+/**
+ * @name Character Set repertoires
+ * @{
+ * These constants are used to indicate support for the character reportoire of
+ * the referenced standard. They does not refer to the character encoding used by
+ * that standard.
+ */
+
+#define OI_CHARSET_ISO_8859_1       OI_BIT0        /**< Latin alphabet No. 1 */
+#define OI_CHARSET_ISO_8859_2       OI_BIT1        /**< Latin alphabet No. 2 */
+#define OI_CHARSET_ISO_8859_3       OI_BIT2        /**< Latin alphabet No. 3 */
+#define OI_CHARSET_ISO_8859_4       OI_BIT3        /**< Latin alphabet No. 4 */
+#define OI_CHARSET_ISO_8859_5       OI_BIT4        /**< Latin/Cyrillic alphabet */
+#define OI_CHARSET_ISO_8859_6       OI_BIT5        /**< Latin/Arabic alphabet */
+#define OI_CHARSET_ISO_8859_7       OI_BIT6        /**< Latin/Greek alphabet */
+#define OI_CHARSET_ISO_8859_8       OI_BIT7        /**< Latin/Hebrew alphabet */
+#define OI_CHARSET_ISO_8859_9       OI_BIT8        /**< Latin alphabet No. 5 */
+#define OI_CHARSET_ISO_8859_10      OI_BIT9        /**< Latin alphabet No. 6 */
+#define OI_CHARSET_ISO_8859_13      OI_BIT10       /**< Latin alphabet No. 7 */
+#define OI_CHARSET_ISO_8859_14      OI_BIT11       /**< Latin alphabet No. 8 */
+#define OI_CHARSET_ISO_8859_15      OI_BIT12       /**< Latin alphabet No. 9 */
+#define OI_CHARSET_GB_2312_80       OI_BIT13       /**< Chinese (People's Republic of China) */
+#define OI_CHARSET_SHIFT_JIS        OI_BIT14       /**< Japanese */
+#define OI_CHARSET_KS_C_5601_1987   OI_BIT15       /**< Korean */
+#define OI_CHARSET_BIG5             OI_BIT16       /**< Chinese (Taiwan) */
+#define OI_CHARSET_TIS_620          OI_BIT17       /**< Thai */
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*****************************************************************************/
+#endif /* _OI_BT_ASSIGNED_NOS_H */
diff --git a/obex_profiles/sdk/include/oi_bt_module_init.h b/obex_profiles/sdk/include/oi_bt_module_init.h
new file mode 100644
index 0000000..468b083
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_bt_module_init.h
@@ -0,0 +1,93 @@
+#ifndef _OI_BT_MODULE_INIT_H
+#define _OI_BT_MODULE_INIT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides the interface for initialization and control of the protocol stack.
+ *
+ * Initialization functions for the individual protocol stack and support modules of
+ * BLUEmagic 3.0 software are collected together by this file (oi_bt_stack_init.h).
+ * In the default implementation, module initialization is performed by oi_bt_stack_init_default.c.
+ * Configuration parameters for all modules primarily control the amount of data memory space (RAM)
+ * that will be allocated for buffers, queues, et cetera. The initialization parameter values
+ * should be modified according to the needs of the application.
+ *
+ * Configuration data structures are defined in oi_bt_stack_config.h. Configuration values are set
+ * in oi_bt_stack_config_default.c; documentation for this file contains recommendations for parameter settings.
+ */
+
+#include "oi_status.h"
+#include "oi_stddefs.h"
+#include "oi_support_init.h"
+#include "oi_bt_stack_config.h"
+#include "oi_bt_stack_init.h"
+
+/** \addtogroup InitConfig */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ *  This function resets all initialization flags.
+ *
+ *  Do not call this function unless you are sure that you know what you are doing.
+ *
+ *  This function should only be called as part of a global, reset/restart process.
+ */
+extern void OI_InitFlags_ResetAllFlags(void);
+
+
+/**
+ * This function initializes the configuration table.
+ *
+ * Do not call this function unless you are sure that you know what you are doing.
+ *
+ * Initialization sets all configuration pointers to their default values.
+ * This function should be called before initializing any profiles or core protocol stack
+ * components.
+ */
+extern void OI_ConfigTable_Init(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* _OI_BT_MODULE_INIT_H */
+
diff --git a/obex_profiles/sdk/include/oi_bt_profile_config.h b/obex_profiles/sdk/include/oi_bt_profile_config.h
new file mode 100644
index 0000000..bc3c750
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_bt_profile_config.h
@@ -0,0 +1,220 @@
+#ifndef _OI_BT_PROFILE_CONFIG_H
+#define _OI_BT_PROFILE_CONFIG_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *
+ * This file provides type definitions for configuration of data structures for each
+ * BLUEmagic 3.0 profile, used for configuring memory usage.
+ *
+ * The comments in this file contain details on recommended and required usage of the
+ * parameters defined herein. The values of these parameters may be changed in the file
+ * oi_bt_profile_config_default.c.
+ *
+ * Adhering to naming conventions is critical to proper operation.
+ *  The typedef for the configuration structure is
+ *      OI_CONFIG_<module>
+ *  where module is one of the enumerated module IDs, minus the OI_MODULE_ prefix
+ * (e.g., OI_CONFIG_AVDTP).
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_time.h"
+#include "oi_bt_spec.h"
+#include "oi_rfcomm_prefs.h"
+
+/** \addtogroup InitConfig */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/********************************************************/
+
+/** This structure defines the Basic Imaging Profile (Client).
+        There are currently no configuration parameters for
+        this profile. The structure below is just a placeholder.
+*/
+typedef struct {
+    OI_UINT32 dummy;
+} OI_CONFIG_BIP_CLI;
+
+/** This structure defines the Basic Imaging Profile (Server).
+*/
+typedef struct  {
+    OI_UINT maxServers;      /**< number of servers that can be registered simultaneously     */
+} OI_CONFIG_BIP_SRV;
+
+/** Basic Imaging Profile, Server role
+*/
+extern const OI_CONFIG_BIP_SRV oi_default_config_BIP_SRV;
+
+/********************************************************/
+
+/** This structure defines the Basic Printing Profile (Sender)
+        configuration. There are currently no configuration
+        parameters for this profile. The structure below is just
+        a placeholder.
+*/
+typedef struct  {
+    OI_UINT32 dummy;
+} OI_CONFIG_BPP_SENDER;
+
+/** This structure defines the Basic Printing Profile (Printer)
+        configuration. There are currently no configuration
+        parameters for this profile. The structure below is just
+        a placeholder.
+*/
+typedef struct  {
+    OI_UINT32 dummy;
+} OI_CONFIG_BPP_PRINTER;
+
+/********************************************************/
+
+/** This structure defines the File Transfer Profile (Server)
+    configuration.
+*/
+typedef struct  {
+    OI_UINT8 rfcomm_channel_pref;           /**< Preferred RFCOMM channel ID (from oi_rfcomm_prefs.h) */
+} OI_CONFIG_FTP_SRV;
+
+/** This structure defines the File Transfer Profile (Client)
+    configuration.
+*/
+typedef struct  {
+    OI_UINT8 max_folder_tree_depth;         /**< Maximum folder recursion for folder put/get */
+} OI_CONFIG_FTP_CLI;
+
+/** File Transfer Profile (Server) */
+extern const OI_CONFIG_FTP_SRV oi_default_config_FTP_SRV;
+
+/** File Transfer Profile (Client) */
+extern const OI_CONFIG_FTP_CLI oi_default_config_FTP_CLI;
+
+/********************************************************/
+
+/**  This structure defines the Generic Object Exchange Profile
+     client configuration.
+*/
+typedef struct {
+    OI_INTERVAL responseTimeout;   /**< how long to wait for a response to an OBEX command */
+    OI_UINT     unused;
+    OI_UINT16   maxPktLen;         /**< maximum length of a request packet */
+    OI_CHAR     *privateKey;       /**< key used for OBEX authentication */
+} OI_CONFIG_OBEX_CLI;
+
+/**  This structure defines the Generic Object Exchange Profile
+     server configuration.
+*/
+typedef struct {
+    OI_INTERVAL connectTimeout;   /**< how long to wait for completion of an unauthenticated connect request to a multiplexed service above OBEX after RFCOMM connection has been established */
+    OI_INTERVAL authTimeout;      /**< how long to wait for completion of an authenticated connect request to a multiplexed service above OBEX after RFCOMM connection has been established */
+    OI_UINT     unused;
+    OI_UINT16   maxPktLen;        /**< maximum length packet (must be >= 255) */
+    OI_CHAR     *privateKey;      /**< pointer to key used for OBEX authentication */
+} OI_CONFIG_OBEX_SRV;
+
+/** Generic Object Exchange Profile client */
+extern const OI_CONFIG_OBEX_CLI     oi_default_config_OBEX_CLI;
+
+/** Generic Object Exchange Profile server */
+extern const OI_CONFIG_OBEX_SRV     oi_default_config_OBEX_SRV;
+
+/********************************************************/
+
+/** This structure defines the Object Push Profile server
+    configuration.
+*/
+typedef struct  {
+    OI_UINT8 rfcomm_channel_pref;     /**< preferred RFCOMM channel ID (from oi_rfcomm_prefs.h) */
+    OI_UINT16 l2cap_psm_pref;         /**< preferred L2CAP PSM (from oi_l2cap_prefs.h) */
+} OI_CONFIG_OPP_SRV;
+
+/** Object Push Profile */
+extern const OI_CONFIG_OPP_SRV oi_default_config_OPP_SRV;
+
+/********************************************************/
+
+/** This structure defines the Phonebook Access Profile server
+    configuration.
+*/
+typedef struct  {
+    OI_UINT8 rfcomm_channel_pref;           /**< Preferred RFCOMM channel ID (from oi_rfcomm_prefs.h) */
+    OI_UINT16 l2cap_psm_pref;               /**< preferred L2CAP PSM (from oi_l2cap_prefs.h) */
+} OI_CONFIG_PBAP_SRV;
+
+/** This structure defines the Phonebook Access Profile client
+    configuration.
+*/
+typedef struct  {
+    OI_UINT32 dummy;
+} OI_CONFIG_PBAP_CLI;
+
+/** Phonebook Access Profile */
+extern const OI_CONFIG_PBAP_SRV oi_default_config_PBAP_SRV;
+/* extern const OI_CONFIG_FTP_CLI oi_default_config_FTP_CLI; */
+
+/********************************************************/
+
+/** This structure defines the Message Access Profile (Server)
+    configuration.
+*/
+typedef struct  {
+    OI_UINT8 rfcomm_channel_pref; /**< Preferred RFCOMM channel ID (from oi_rfcomm_prefs.h) */
+    OI_UINT8 maxConnections;     /* Max. MAS connections to the server */
+    OI_UINT8 maxMCEConnected;   /* Max. no. of MCEs that can be connected to the server */ 
+} OI_CONFIG_MAP_SRV;
+
+/** MAP Server */
+extern const OI_CONFIG_MAP_SRV oi_default_config_MAP_SRV;
+/********************************************************/
+
+/** This structure defines the Message Notification Service (Server)
+    configuration.
+*/
+typedef struct  {
+    OI_UINT8 rfcomm_channel_pref;           /**< Preferred RFCOMM channel ID (from oi_rfcomm_prefs.h) */
+} OI_CONFIG_MAP_CLI;
+
+/** MAP Server */
+extern const OI_CONFIG_MAP_CLI oi_default_config_MAP_CLI;
+/********************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif  /* _OI_BT_PROFILE_CONFIG_H */
+
diff --git a/obex_profiles/sdk/include/oi_bt_spec.h b/obex_profiles/sdk/include/oi_bt_spec.h
new file mode 100644
index 0000000..7670fb6
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_bt_spec.h
@@ -0,0 +1,263 @@
+#ifndef _OI_BT_SPEC_H
+#define _OI_BT_SPEC_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *
+ * This file contains common definitions from the Bluetooth specification.
+ *
+ */
+
+#include "oi_stddefs.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** The maximum number of active slaves in a piconet. */
+#define OI_BT_MAX_ACTIVE_SLAVES 7
+
+/** the number of bytes in a Bluetooth device address (BD_ADDR) */
+#define OI_BD_ADDR_BYTE_SIZE   6
+
+/**
+   This structure describes the 48-bit Bluetooth device address.
+ *
+ * Because 48-bit integers may not be supported on all platforms, the
+ * address is defined as an array of bytes. This array is big-endian,
+ * meaning that
+ *  - array[0] contains bits 47-40,
+ *  - array[1] contains bits 39-32,
+ *  - array[2] contains bits 31-24,
+ *  - array[3] contains bits 23-16,
+ *  - array[4] contains bits 15-8, and
+ *  - array[5] contains bits 7-0.
+ */
+typedef struct  {
+    OI_UINT8    addr[OI_BD_ADDR_BYTE_SIZE] ;   /**< Bluetooth device address represented as an array of 8-bit values */
+} OI_BD_ADDR ;
+
+/**
+ * @name Data types for working with UUIDs
+ * UUIDs are 16 bytes (128 bits).
+ *
+ * To avoid having to pass around 128-bit values all the time, 32-bit and 16-bit
+ * UUIDs are defined, along with a mapping from the shorter versions to the full
+ * version.
+ *
+ * @{
+ */
+
+/**
+ * 16-bit representation of a 128-bit UUID
+ */
+typedef OI_UINT16 OI_UUID16;
+
+/**
+ * 32-bit representation of a 128-bit UUID
+ */
+typedef OI_UINT32 OI_UUID32;
+
+/**
+ * number of bytes in a 128 bit UUID
+ */
+#define OI_BT_UUID128_SIZE  16
+
+/**
+ * number of bytes in IPv6 style addresses
+ */
+#define OI_BT_IPV6ADDR_SIZE  16
+
+/**
+   This structure defines the type definition for a 128-bit
+   UUID.
+ *
+ * To simplify conversion between 128-bit UUIDs and 16-bit and 32-bit UUIDs,
+ * the most significant 32 bits are stored with the same endian-ness as is
+ * native on the target (local) device. The remainder of the 128-bit UUID is
+ * stored as bytes in big-endian order.
+ */
+typedef struct {
+    OI_UINT32 ms32bits;                                    /**< Most significant 32 bits of 128-bit UUID */
+    OI_UINT8 base[OI_BT_UUID128_SIZE - sizeof(OI_UINT32)]; /**< Remainder of 128-bit UUID, array of 8-bit values */
+} OI_UUID128;
+
+/** @} */
+
+/** number of bytes in a link key */
+#define OI_BT_LINK_KEY_SIZE      16
+
+/** generic AMP key identifier */
+#define OI_BT_GAMP_KEY_ID        ((const OI_BYTE *) "gamp")
+
+/** number of bytes in a generic AMP key */
+#define OI_BT_GAMP_KEY_SIZE      32
+
+/** dedicated AMP 802.11 PAL key identifier */
+#define OI_BT_DED_802_KEY_ID     ((const OI_BYTE *) "802b")
+
+/** number of bytes in dedicated AMP 802.11 PAL key */
+#define OI_BT_DED_802_KEY_SIZE   32
+
+/**
+   This structure defines the type definition for a baseband
+   link key.
+ *
+ * Because 128-bit integers may not be supported on all platforms, we define
+ * link keys as an array of bytes. Unlike the Bluetooth device address,
+ * the link key is stored in little-endian order, meaning that
+ *  - array[0]  contains bits 0  - 7,
+ *  - array[1]  contains bits 8  - 15,
+ *  - array[2]  contains bits 16 - 23,
+ *  - array[3]  contains bits 24 - 31,
+ *  - array[4]  contains bits 32 - 39,
+ *  - array[5]  contains bits 40 - 47,
+ *  - array[6]  contains bits 48 - 55,
+ *  - array[7]  contains bits 56 - 63,
+ *  - array[8]  contains bits 64 - 71,
+ *  - array[9]  contains bits 72 - 79,
+ *  - array[10] contains bits 80 - 87,
+ *  - array[11] contains bits 88 - 95,
+ *  - array[12] contains bits 96 - 103,
+ *  - array[13] contains bits 104- 111,
+ *  - array[14] contains bits 112- 119, and
+ *  - array[15] contains bits 120- 127.
+ */
+typedef struct {
+    OI_UINT8    key[OI_BT_LINK_KEY_SIZE] ;   /**< Link key represented as an array of 8-bit values */
+} OI_LINK_KEY ;
+
+
+/** Out-of-band data size - C and R values are 16-bytes each */
+#define OI_BT_OOB_NUM_BYTES     16
+
+/**
+   This structure defines the OOB data.
+ */
+typedef struct {
+    OI_UINT8    value[OI_BT_OOB_NUM_BYTES] ;   /**< same struct used for C and R values */
+} OI_OOB_DATA ;
+     
+
+/**
+ * link key types
+ */
+typedef enum  {
+    OI_LINK_KEY_TYPE_COMBO              = 0,    /**< combination key */
+    OI_LINK_KEY_TYPE_LOCAL_UNIT         = 1,    /**< local unit key */
+    OI_LINK_KEY_TYPE_REMOTE_UNIT        = 2,    /**< remote unit key */
+    OI_LINK_KEY_TYPE_DEBUG_COMBO        = 3,    /**< debug combination key */
+    OI_LINK_KEY_TYPE_UNAUTHENTICATED    = 4,    /**< Unauthenticated */
+    OI_LINK_KEY_TYPE_AUTHENTICATED      = 5,    /**< Authenticated */
+    OI_LINK_KEY_TYPE_CHANGED_COMBO      = 6,    /**< Changed */
+    OI_LINK_KEY_TYPE_MAX_VALUE          = 6,    /**< Max value for validity checking (not defined in BT spec) */
+    
+    OI_LINK_KEY_TYPE_INVALID_VALUE      = 0xFF /**< Spec defines 7-0xFF as reserved */
+    
+} OI_BT_LINK_KEY_TYPE ;
+
+
+/** amount of space allocated for a PIN (personal indentification number) in bytes */
+#define OI_BT_PIN_CODE_SIZE    16
+
+/** This structure defines the data type for a PIN (PINs are
+    treated as strings, so endianness does not apply.) */
+typedef struct  {
+    OI_UINT8    pin[OI_BT_PIN_CODE_SIZE] ; /**< PIN represented as an array of 8-bit values */
+} OI_PIN_CODE ;
+
+/** World location regulatory domain */
+typedef struct {
+    OI_CHAR   countryCode[2];
+    OI_CHAR   suffix;
+} OI_REG_DOMAIN;
+
+/** maximum number of SCO connections per device, which is 3 as of version 2.0+EDR
+    of the Bluetooth specification (see sec 4.3 of vol 2 part B) */
+#define OI_BT_MAX_SCO_CONNECTIONS  3
+
+/** data type for clock offset */
+typedef OI_UINT16   OI_BT_CLOCK_OFFSET ;
+
+/** data type for a LM handle */
+typedef OI_UINT16 OI_HCI_LM_HANDLE;
+
+/** opaque data type for a SCO or ACL connection handle */
+typedef struct _OI_HCI_CONNECTION *OI_HCI_CONNECTION_HANDLE;
+
+/** data type for HCI Error Code, as defined in oi_hcispec.h */
+typedef OI_UINT8    OI_HCI_ERROR_CODE ;
+
+/**
+ * The Bluetooth device type is indicated by a 24-bit bitfield, represented as a
+ * 32-bit number in the stack. The bit layout and values for device class are specified
+ * in the file oi_bt_assigned_nos.h and in the Bluetooth "Assigned Numbers" specification
+ * at http://www.bluetooth.org/assigned-numbers/.
+ */
+typedef OI_UINT32   OI_BT_DEVICE_CLASS ;
+
+#define OI_BT_DEV_CLASS_FORMAT_MASK        0x000003    /**< Bits 0-1 contain format type. */
+#define OI_BT_DEV_CLASS_MINOR_DEVICE_MASK  0x0000FC    /**< Bits 2-7 contain minor device class value. */
+#define OI_BT_DEV_CLASS_MAJOR_DEVICE_MASK  0x001F00    /**< Bits 8-12 contain major device class value. */
+#define OI_BT_DEV_CLASS_MAJOR_SERVICE_MASK 0xFFE000    /**< Bits 13-23 contain major service class value. */
+
+/** There is currently only one device class format defined, type 00. */
+#define OI_BT_DEV_CLASS_FORMAT_TYPE        00
+
+/** Bit 13 in device class indicates limited discoverability mode (GAP v2.0+EDR, section 4.1.2.2) */
+#define OI_BT_DEV_CLASS_LIMITED_DISCO_BIT  OI_BIT13
+
+/** macro to test validity of the Device Class Format */
+#define OI_BT_VALID_DEVICE_CLASS_FORMAT(class) (OI_BT_DEV_CLASS_FORMAT_TYPE == ((class) & OI_BT_DEV_CLASS_FORMAT_MASK))
+
+/** the time between baseband clock ticks, currently 625 microseconds (one slot) */
+#define OI_BT_TICK 625
+/** some macros to convert to/from baseband clock ticks - use no floating point! */
+#define OI_SECONDS_TO_BT_TICKS(secs)    ((secs)*1600)
+#define OI_BT_TICKS_TO_SECONDS(ticks)   ((ticks)/1600)
+#define OI_MSECS_TO_BT_TICKS(msecs)     (((msecs)*8)/5)
+#define OI_BT_TICKS_TO_MSECS(ticks)     (((ticks)*5)/8)
+
+/** EIR byte order */
+#define OI_EIR_BYTE_ORDER   OI_LITTLE_ENDIAN_BYTE_ORDER
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* _OI_BT_SPEC_H */
diff --git a/obex_profiles/sdk/include/oi_bt_stack_config.h b/obex_profiles/sdk/include/oi_bt_stack_config.h
new file mode 100644
index 0000000..c2b81df
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_bt_stack_config.h
@@ -0,0 +1,143 @@
+#ifndef _OI_BT_STACK_CONFIG_H
+#define _OI_BT_STACK_CONFIG_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * This file provides type definitions for configuration of data structures for various subsystems
+ * of the BLUEmagic 3.0 protocol stack, used for configuring memory usage
+ *
+ * The comments in this file contain details on recommended and required usage of the
+ * parameters defined herein. The values of these parameters may be changed in the file
+ * oi_bt_stack_config_default.c.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_time.h"
+#include "oi_bt_spec.h"
+#include "oi_connect_policy.h"
+#include "oi_sdpdb.h"
+#include "oi_support_init.h"
+
+/** \addtogroup InitConfig */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**************************************************
+    Common Configuration
+**************************************************/
+/**
+    This constant structure is used to configure parameters used by several
+    modules of the BLUEmagic 3.0 Bluetooth protocol stack.
+ */
+typedef struct  {
+    OI_UINT8    maxAclConnections ; /**< This parameter indicates how many concurrent ACL connections the protocol
+                                         stack should support.
+                                         Memory usage - possibly significant, this value is used to size control
+                                         data structures a number of modules. */
+
+    OI_UINT8    maxLogicalConnections ; /**< This parameter indicates how many concurrent logical connections the protocol
+                                         stack should support.
+                                         Memory usage - possibly significant, this value is used to size control
+                                         data structures a number of modules. */
+
+    OI_UINT8    maxScoConnections ; /**< This parameter indicates how many concurrent
+                                         SCO connections the protocol stack should support.
+                                         This value is used to size control data structures. */
+
+    OI_UINT8    deviceNameMaxLen ;  /**< The Bluetooth specification v2.0+EDR allows device names
+                                         to be up to 248 characters. This definition allows the local
+                                         device name to be limited to something less than 248 bytes.
+                                         Note that applications can write name of any length, but a read of local
+                                         device will be limited by this parameter.
+                                         OI_DEVMGR_EnumerateDevices() uses this same parameter to limit remote
+                                         device names in the enumeration database.
+                                         Length is specified as a number of bytes and INCLUDES (!!) the
+                                         NULL terminator. */
+
+    OI_UINT16 maxMTU;               /**< This parameter configures the maximum incoming L2CAP MTU that will be supported.
+                                         Memory usage - significant impact, L2CAP allocates a buffer this size for each
+                                         of the 'maxAclConnections'. */
+
+    OI_UINT16 maxMPS;               /**< This parameter configures the maximum incoming L2CAP MPS that will be supported.
+                                         This parameter only applies in ERTM and STREAMING mode. */
+
+    OI_UINT8 automaticUnPark;       /**< TRUE/FALSE controls Unpark behavior if outbound data is queued for transmission */
+
+    OI_UINT8 automaticUnSniff;      /**< TRUE/FALSE controls UnSniff behavior if outbound data is queued for transmission */
+
+}   OI_CONFIG_COMMON_CONFIG ;
+
+/** The common system configuration is global, accessible to all modules at all times. */
+extern const OI_CONFIG_COMMON_CONFIG oi_default_config_COMMON_CONFIG ;
+
+/**************************************************
+    Dispatcher Configuration
+**************************************************/
+
+/** This sructure configures the size of the table used by the
+    CThru Dispatcher to store callback function registration
+    entries. The parameter indicates the size of the table in
+    16-bit units, not number of entries. An entry consumes
+    between 16 and 20 bytes. A reasonable parameter setting for
+    many applications would be 64. A feasible minimum might be
+    between 16 and 32.
+ */
+
+typedef struct {
+    OI_UINT16  DispatchTableSize;   /**< size of Dispatcher table */
+
+} OI_CONFIG_DISPATCH;
+
+extern const OI_CONFIG_DISPATCH oi_default_config_DISPATCH ;
+
+/*****************************************************
+ * Memory Manager configuration parameters
+ *****************************************************/
+
+#ifndef OI_USE_NATIVE_MALLOC
+extern const OI_CONFIG_MEMMGR oi_default_config_MEMMGR ;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/*****************************************************************************/
+#endif  /* _OI_BT_STACK_CONFIG_H */
+
diff --git a/obex_profiles/sdk/include/oi_bt_stack_init.h b/obex_profiles/sdk/include/oi_bt_stack_init.h
new file mode 100644
index 0000000..d8d3c75
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_bt_stack_init.h
@@ -0,0 +1,170 @@
+#ifndef _OI_BT_STACK_INIT_H
+#define _OI_BT_STACK_INIT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *
+ * This file provides the interface for initialization and control of the protocol stack.
+ *
+ * Initialization functions for the entire BLUEmagic 3.0 protocol
+ * stack software are collected together by this file.
+ *
+ * Configuration data structures are defined in oi_bt_stack_config.h. Configuration values are set
+ * in oi_bt_stack_config_default.c; documentation for this file contains recommendations for parameter settings.
+ */
+
+#include "oi_status.h"
+#include "oi_stddefs.h"
+
+/** \addtogroup InitConfig */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+    A callback function of this type is used to indicate that BM3 initialization has completed.
+
+    @param status    status code
+*/
+typedef void(*OI_INIT_COMPLETE_CB)(OI_STATUS status);
+
+/**
+ * A callback function of this type is used to indicate when the BLUEmagic 3.0 protocol stack
+ * requires service by the application's dispatch thread/routine.
+ *
+ * @param msec      number of milliseconds before the protocol stack requires service
+ */
+typedef void(*OI_DISPATCH_SERVICE_REQUEST_HANDLER)(OI_UINT msec);
+
+/**
+ *
+ * This function invokes all callback functions that are ready to run.
+ * See the @ref dispatch_docpage section for details.
+ *
+ * @return               a count of the number of callback functions that were called, a value that can
+ *                       be used to test if any callback functions were called
+ */
+extern OI_INT16 OI_Dispatch_Run(void);
+
+/**
+ *
+ * This function initializes the entire BLUEmagic 3.0 protocol stack and its support modules.
+ *
+ * @param initComplete   This is a function in the application that is called
+ *                       when initialization has completed. No BM3 calls should
+ *                       be made until this callback occurs with a successful
+ *                       result code.  Callback may not be NULL.
+ *
+ * @param handler   This is a function in the runtime environment that is called by the BLUEmagic 3.0
+ *                  protocol stack to request immediate or future service from the runtime environment.
+ *                  The stack initialization function simply passes this function on to OI_Dispatch_Init().
+ * @note This function is not part of the BLUEmagic 3.0 protocol stack per se; this function implementation
+ *          must be provided by the user of the stack.  A default implementation of this function
+ *          is provided in the SDK.
+ */
+OI_STATUS OI_BT_StackInit(OI_INIT_COMPLETE_CB                 initComplete,
+                          OI_DISPATCH_SERVICE_REQUEST_HANDLER handler);
+
+/**
+ *
+ * This function initializes the entire BLUEmagic 3.0 protocol stack and its support modules.
+ *
+ *  Customization:
+ *      The customCB is called after the configuration table is initialized with the default values (typically
+ *      specified in oi_bt_stack_config_default.c), but before any core stack components (HCI, L2CAP, etc)
+ *      have been initialized.
+ *
+ *      In the customCB, the application may specify its custom configuration(s) with the API's provided in
+ *      oi_config_table.h.  The customCB must not call any BM3 api other than OI_CONFIG_TABLE_PUT() and/or
+ *      OI_CONFIG_TABLE_GET().  Please refer to oi_config_table.h file for details of these api's.
+ *
+ * @param initComplete   This is a function in the application that is called
+ *                       when initialization has completed. No further BM3 calls should
+ *                       be made until this callback occurs with a successful
+ *                       result code.  Callback may not be NULL.
+ *
+ * @param handler   This is a function in the runtime environment that is called by the BLUEmagic 3.0
+ *                  protocol stack to request immediate or future service from the runtime environment.
+ *                  The stack initialization function simply passes this function on to OI_Dispatch_Init().
+ *
+ * @param customCB  This is the callback that is to be invoked at the appropriate point during initialization.
+ *                  Specify NULL if there is no customization required
+ *
+ * @return      OI_OK, if initialization request is accepted, callback will be called.
+ *              Any other value, initialization request failed, callback will not be called.
+ *
+ * @note This function is not part of the BLUEmagic 3.0 protocol stack, per se; this function implementation
+ *          must be provided by the user of the stack. A default implementation of this function
+ *          is provided in the SDK.
+ */
+OI_STATUS OI_BT_StackInit_Custom(OI_INIT_COMPLETE_CB                 initComplete,
+                                 OI_DISPATCH_SERVICE_REQUEST_HANDLER handler,
+                                 void (*customCB)(void));
+
+/**
+ * This function terminates the entire stack and profiles.
+ *
+ *  The stack is terminated by removing any pending callbacks from the dispatcher
+ *  and marking all stack modules as un-initialized.  Any subsequent calls into the
+ *  will fail.
+ *
+ *  Prior to stack termination, both the radio and transports should be closed by
+ *  calling :
+ *      OI_HCI_RadioClose()
+ *      OI_HCI_CloseAllTransports()
+ *
+ *  Closing the radio will cleanly disconnect all existing connections and will prevent
+ *  new operations while the stack is being terminated.
+ *
+ *  Closing the transports relinquishes any OS resources that may have been allocated
+ *  when opening transports.
+ *
+ *  @Note OI_BT_Stack_Terminate() must be called an application thread!!  It must not be
+ *  called from a stack callback.  Failure to follow the sequence described above might
+ *  result in race or deadlock condition.
+ *
+ * @return      termination result.
+ */
+
+OI_STATUS OI_BT_Stack_Terminate(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_BT_STACK_INIT_H */
+
diff --git a/obex_profiles/sdk/include/oi_common.h b/obex_profiles/sdk/include/oi_common.h
new file mode 100644
index 0000000..dde03a0
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_common.h
@@ -0,0 +1,51 @@
+#ifndef _OI_COMMON_H
+#define _OI_COMMON_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *
+ * This file is used to group commonly used BLUEmagic 3.0 software
+ * header files.
+ *
+ * This file should be included in application source code along with the header
+ * files for the specific modules of the protocol stack being used.
+ */
+
+#include "oi_bt_spec.h"
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_time.h"
+#include "oi_osinterface.h"
+
+
+/*****************************************************************************/
+#endif /* _OI_COMMON_H */
diff --git a/obex_profiles/sdk/include/oi_config_table.h b/obex_profiles/sdk/include/oi_config_table.h
new file mode 100644
index 0000000..4d82d27
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_config_table.h
@@ -0,0 +1,139 @@
+#ifndef _OI_CONFIG_TABLE_H
+#define _OI_CONFIG_TABLE_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * This file provides the interface to the configuration table.
+ *
+ * Associated with each module defined in oi_modules.h is a
+ * configuration structure type definition.
+ *
+ *  Naming conventions:
+ *  - Configuration type definition is OI_CONFIG_<module>
+ *    (e.g., OI_CONFIG_MEMMGR, OI_CONFIG_L2CAP).
+ *  - Default configuration structure name is oi_default_config_<module>
+ *    (e.g., oi_default_config_MEMMGR, oi_default_config_L2CAP)
+ *
+ *
+ *
+ * Do not call the function OI_ConfigTable_Init() unluess you are sure that you
+ * know what you are doing. It should only be called as part of a global, reset/restart
+ * process. Initialization sets the all configuration pointers to their default values.
+ * This function should be called before initializing any profiles or core protocol stack
+ * and support module components. This function is defined in oi_bt_stack_init.h with the
+ * other stack initialization prototypes.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_modules.h"
+
+/** \addtogroup InitConfig */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern const void* OI_ConfigTable_GetConfig(OI_MODULE module) ;
+extern void  OI_ConfigTable_SetConfig(const void *configPtr, OI_MODULE module) ;
+
+/**
+ *    This macro is used for accessing the configuration table.
+      It returns a pointer to the configuration structure for
+      the module.
+
+      Specify the module name without the OI_MODULE_ prefix. For
+      example, call OI_CONFIG_TABLE_GET (DEVMGR), not
+      OI_CONFIG_TABLE_GET (OI_MODULE_DEVMGR). The result is a
+      pointer to the module's configuration structure.
+ */
+#define OI_CONFIG_TABLE_GET(module)              \
+        ((const OI_CONFIG_##module*)(OI_ConfigTable_GetConfig(OI_MODULE_##module)))
+
+/**
+ * This macro is provided primarily to enable backward compatibility with applications
+   written with previous versions of the BLUEmagic 3.0 APIs.
+
+   Normally, configuration structures are compiled into the
+   application by defining a the variable
+   oi_default_config_<module>. This macro updates the
+   configuration table entry for the specified module with the
+   specified pointer. The caller must guarantee the integrity of
+   both the pointer and the data being pointed to. The
+   configuration structure may not change in any way while the
+   module is 'in use'. If you cannot be sure when a module is
+   'in use' or not, do not change the configuration.
+ *
+ *    Specify module name without the OI_MODULE_ prefix. For example, call
+ *    OI_CONFIG_TABLE_GET (DEVMGR), not OI_CONFIG_TABLE_GET (OI_MODULE_DEVMGR).
+ *
+ *
+ *
+   Usage notes: \n To set the configuration for a module, you
+   should define a static const structure of the appropriate
+   type and then use OI_CONFIG_TABLE_PUT() to update the configuration table
+   with your structure. The configuration table retains a
+   pointer to your structure, so your structure must persist and
+   the contents of your structure may not be changed after it
+   has been put into the table.
+ *
+ * If should you wish to change one or more individual elements in a structure while retaining the
+   default values for other elements, you should do the
+   following:
+ *
+       -# Use OI_CONFIG_TABLE_GET() to get a reference to the
+         current configuration.
+       -# Copy the current configuration into a local, static
+         structure.
+       -# Modify the desired elements in the local structure.
+       -# Use OI_CONFIG_TABLE_PUT() to put a reference to your
+        local structure into the configuration table.
+ *
+ */
+
+#define OI_CONFIG_TABLE_PUT(configPtr, module)   \
+        (OI_ConfigTable_SetConfig(configPtr, OI_MODULE_##module))
+
+/** Validate the parameters in the configuration table. */
+void OI_ConfigTable_Validate(void);
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_CONFIG_TABLE_H */
+
diff --git a/obex_profiles/sdk/include/oi_connect_policy.h b/obex_profiles/sdk/include/oi_connect_policy.h
new file mode 100644
index 0000000..c96a506
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_connect_policy.h
@@ -0,0 +1,158 @@
+#ifndef _OI_CONNECT_POLICY_H
+#define _OI_CONNECT_POLICY_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+
+This file defines the connection policy structure that is used to
+communicate application and service requirements.
+*/
+
+#include "oi_stddefs.h"
+#include "oi_l2cap_qos.h"
+#include "oi_dataelem.h"
+
+
+/** \addtogroup PolicyMgr Policy Manager APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Bit definitions for the powerSavingDisables element. */
+#define OI_POLICY_DISABLE_HOLD      OI_BIT0
+#define OI_POLICY_DISABLE_SNIFF     OI_BIT1
+#define OI_POLICY_DISABLE_PARK      OI_BIT2
+
+    /**
+       This structure defines the connection policy associated with
+       the service.
+     */
+typedef struct  {
+
+    /** UUID of the service. 16-bit, 32-bit, or 128 bit UUID as
+        dataelement */
+    OI_DATAELEM         serviceUuid;
+
+    /** Indicates that the local device must be master of the ACL link */
+    OI_BOOL             mustBeMaster ;
+
+    /** Quality of service requirements for the link. This element
+        must point to a static, constant structure, which must
+        perist at least as long as the connection exists. The
+        pointer may be NULL, in which case no L2CAP quality of
+        service requirements will be enforced. Note that L2CAP
+        guaranteed quality of service is not supported by this
+        release of BLUEmagic software, nor does any profile
+        specification require it. */
+    OI_L2CAP_FLOWSPEC   *flowspec;
+
+    /** The power-saving modes that should be disallowed on this link. This is a bit-wise OR of
+        the possible power-saving mode is disabled. A value of 0
+        define all power-saving modes are enabled. */
+    OI_UINT8            powerSavingDisables ;
+
+} OI_CONNECT_POLICY ;
+
+
+/**
+The callback is called when the policy manager has finished enforcing the specified policies.
+
+@param  handle      Connection identifier which associates the callback with the original call to
+                    OI_POLICYMGR_AddConnectionPolicy().
+
+@param  status      Results of the attempt to enforce the specified policies.
+                    Any value other than OI_SUCCESS indicates that policy enforcement failed.
+
+@param  securityFailure If the status parameter is NOT OI_OK, this boolean indicates whether
+                        the failure occurred as a result of enforcing security policy.
+*/
+typedef void(*OI_POLICYMGR_ADD_CONNECT_POLICY_CB)(
+                            OI_UINT32   handle,
+                            OI_STATUS   status,
+                            OI_BOOL     securityFailure) ;
+
+
+/**
+This function requests the policy manager to enforce the specified
+policies on the indicated connection.  If successful, the policy will
+remain in effect until the acl link is disconnected or until the
+application calls OI_POLICYMGR_RemoveConnectionPolicy().
+
+@param    cb  Callback that will be called after the policies have been enforced.
+
+@param    pAddr  Bluetooth device address identifies the connection.
+
+@param    pPolicy Pointer to the policy that is to be applied to the connection. This may
+          not be NULL.
+
+@param    pHandle Identifier returned to caller. If the function
+          succeeds, it will return a handle used to identify the connection
+          policy. This handle will be passed to caller in the callback. The
+          handle is also needed in order to remove the policy when it no longer
+          needs to be in effect.
+
+@return   OI_OK if the policy manager will attempt to enforce the given policy and will
+          invoke the callback when done, or any other value, if the policy manager
+          will not attempt to enforce the policy and will not call the callback.
+*/
+OI_STATUS    OI_POLICYMGR_AddConnectionPolicy(
+                            OI_POLICYMGR_ADD_CONNECT_POLICY_CB cb,
+                            const OI_BD_ADDR            *pAddr,
+                            const OI_CONNECT_POLICY     *pPolicy,
+                            OI_UINT32                   *pHandle) ;
+
+/**
+This function removes a policy. It is important that applications remove
+policies when they are no longer needed.
+
+This is a synchronous call which always succeeds, the actual removal
+of policies is performed asynchronously.
+
+@param  handle      Identifies the policy to be removed. This is the handle that was passed to
+                    the application when the policy was added to the connection.
+*/
+void OI_POLICYMGR_RemoveConnectionPolicy(OI_UINT32   handle) ;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_CONNECT_POLICY_H */
+
+
diff --git a/obex_profiles/sdk/include/oi_cpu_dep.h b/obex_profiles/sdk/include/oi_cpu_dep.h
new file mode 100644
index 0000000..7d32dbb
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_cpu_dep.h
@@ -0,0 +1,211 @@
+#ifndef _OI_CPU_DEP_H
+#define _OI_CPU_DEP_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * This file contains definitions for characteristics of the target CPU and
+ * compiler, including primitive data types and endianness.
+ *
+ * This file defines the byte order and primitive data types for various
+ * CPU families. The preprocessor symbol 'CPU' must be defined to be an
+ * appropriate value or this header will generate a compile-time error.
+ *
+ * @note The documentation for this header file uses the x86 family of processors
+ * as an illustrative example for CPU/compiler-dependent data type definitions.
+ * Go to the source code of this header file to see the details of primitive type
+ * definitions for each platform.
+ *
+ * Additional information is available in the @ref data_types_docpage section.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+/** @name Definitions indicating family of target OI_CPU_TYPE
+ *  @{
+ */
+
+#define OI_CPU_X86         1 /**< x86 processor family */
+#define OI_CPU_ARM7_LEND  10 /**< ARM7, little-endian */
+#define OI_CPU_ARM7_BEND  11 /**< ARM7, big-endian */
+#define OI_CPU_ARM9_LEND  19 /**< ARM9, little-endian */
+#define OI_CPU_ARM11_LEND 20 /**< ARM11, little-endian */
+
+#ifndef OI_CPU_TYPE
+    #error "OI_CPU_TYPE type not defined"
+#endif
+
+/**@}*/
+
+
+/** @name Definitions indicating byte-wise endianness of target CPU
+ *  @{
+ */
+
+#define OI_BIG_ENDIAN_BYTE_ORDER    0  /**< Multiple-byte values are stored in memory beginning with the most significant byte at the lowest address.  */
+#define OI_LITTLE_ENDIAN_BYTE_ORDER 1  /**< Multiple-byte values are stored in memory beginning with the least significant byte at the lowest address. */
+
+/**@}*/
+
+
+/** @name  CPU/compiler-independent primitive data type definitions
+ *  @{
+ */
+
+typedef int             OI_BOOL;  /**< Boolean values use native integer data type for target CPU. */
+typedef int             OI_INT;   /**< Integer values use native integer data type for target CPU. */
+typedef unsigned int    OI_UINT;  /**< Unsigned integer values use native unsigned integer data type for target CPU. */
+typedef unsigned char   OI_BYTE;  /**< Raw bytes type uses native character data type for target CPU. */
+
+/**@}*/
+
+
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_X86
+
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER  /**< x86 platform byte ordering is little-endian */
+
+/** @name CPU/compiler-dependent primitive data type definitions for x86 processor family
+ *  @{
+ */
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for x86 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for x86 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for x86 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for x86 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for x86 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for x86 processor. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARM7_LEND
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+
+/** @name   little-endian CPU/compiler-dependent primitive data type definitions for the ARM7 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARM7 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARM7 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARM7 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARM7 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARM7 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARM7 processor. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARM7_BEND
+#define OI_CPU_BYTE_ORDER OI_BIG_ENDIAN_BYTE_ORDER
+/** @name   big-endian CPU/compiler-dependent primitive data type definitions for the ARM7 processor family
+ *  @{
+ */
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARM7 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARM7 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARM7 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARM7 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARM7 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARM7 processor. */
+
+/**@}*/
+
+#endif
+
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARM9_LEND
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+
+/** @name   little-endian CPU/compiler-dependent primitive data type definitions for the ARM9 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARM7 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARM7 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARM7 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARM7 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARM7 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARM7 processor. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+#if OI_CPU_TYPE==OI_CPU_ARM11_LEND
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER
+
+/** @name   little-endian CPU/compiler-dependent primitive data type definitions for the ARM11 processor family
+ *  @{
+ */
+
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for ARM7 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for ARM7 processor. */
+typedef signed long     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for ARM7 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for ARM7 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for ARM7 processor. */
+typedef unsigned long   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for ARM7 processor. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
+
+
+#ifndef OI_CPU_BYTE_ORDER
+    #error "Byte order (endian-ness) not defined"
+#endif
+
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+/*********************************************************************************/
+#endif /* _OI_CPU_DEP_H */
diff --git a/obex_profiles/sdk/include/oi_crc16_ccitt.h b/obex_profiles/sdk/include/oi_crc16_ccitt.h
new file mode 100644
index 0000000..2dc529f
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_crc16_ccitt.h
@@ -0,0 +1,83 @@
+#ifndef _OI_CRC16_CCIT_H
+#define _OI_CRC16_CCIT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+    @file
+
+    This file defines the interface to CCIT CRC16 computations as specified in the
+    HCI 3-wire specification.
+*/
+
+#include "oi_stddefs.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This function computes a 16-bit CRC on a buffer, using the caller's supplied seed as
+ * a running CRC. The result is returned to the caller in the caller's running CRC variable.
+ *
+ * @param buffer         Buffer for which to compute the CRC
+ * @param bufLen         Length of the buffer in bytes
+ * @param runningCrc     Input -  Pointer to seed for CRC computation
+ *                       Putput - Pointer to result of CRC computation
+ */
+void OI_CRC16_CCITT_Compute(const OI_BYTE *buffer,
+                            OI_UINT16 bufLen,
+                            OI_UINT16 *runningCrc);
+
+/**
+ * This function completes the CCIT CRC computation by rearranging the CRC bits and bytes
+ * into the correct order.
+ *
+ * @param crc            Computed CRC as calculated by OI_CCIT_CRC_Compute()
+ * @param crcBlock       Pointer to a 2-byte buffer where the resulting CRC will be stored
+ */
+
+void OI_CRC16_CCITT_Complete(OI_UINT16 crc,
+                             OI_BYTE   *crcBlock);
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_CRC16_CCIT_H */
+
diff --git a/obex_profiles/sdk/include/oi_dataelem.h b/obex_profiles/sdk/include/oi_dataelem.h
new file mode 100644
index 0000000..3095300
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_dataelem.h
@@ -0,0 +1,643 @@
+#ifndef _OI_DATAELEM_H
+#define _OI_DATAELEM_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file contains definitions and functions for working with Data Elements
+ * as defined in the SDP specification.
+ *
+ * The Service Discovery Protocol (SDP) is specified in volume 3 part B of the
+ * Bluetooth Specification version 2.0+EDR. Data Elements are described in
+ * Section 3 of that document.
+ *
+ * Additional information is available in the @ref SDP_docpage section of the
+ * BLUEmagic 3.0 SDK documentation.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_bt_spec.h"
+
+/** \addtogroup Marshaller Marshaller APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * This enumeration is for Data Element type descriptors as defined in Section
+ * 3.2 of the SDP specification.
+ *
+ * The Service Discovery Protocol uses the Data Element header field to describe
+ * the type and length of the data in the Data Element's data field. The Data
+ * Element header is 1, 2, 3, or 5 bytes in length.
+ *
+ * The first byte of the Data Element header is the "Data Element descriptor".
+ * The Data Element descriptor is composed of a 5-bit Data Element type
+ * descriptor (which indicates the type of the data in the Data Element's data
+ * field) followed by a 3-bit Data Element size descriptor index (which
+ * indicates the size of the Data Element's data field). The three bits of the
+ * size descriptor index are the least significant three bits of the one-byte
+ * Data Element descriptor.
+ *
+ * Data Element types #OI_DATAELEM_REF are
+ * specific and internal to implementations of the BLUEmagic 3.0 protocol stack.
+ */
+
+typedef enum {
+    OI_DATAELEM_NULL      =  0,  /**< null data */
+    OI_DATAELEM_UINT      =  1,  /**< unsigned integer data */
+    OI_DATAELEM_SINT      =  2,  /**< signed integer data */
+    OI_DATAELEM_UUID      =  3,  /**< UUID (universally unique identifier) data */
+    OI_DATAELEM_TEXT      =  4,  /**< text string data */
+    OI_DATAELEM_BOOL      =  5,  /**< Boolean data */
+    OI_DATAELEM_SEQ       =  6,  /**< a sequence of Data Elements */
+    OI_DATAELEM_ALT       =  7,  /**< Data Element alternative (a sequence of Data Elements from which one Data Element is to be selected) */
+    OI_DATAELEM_URL       =  8,  /**< URL (uniform resource locator) data */
+
+    /*
+     * Internal data element types used internally by BLUEmagic 3.0
+     * Must be >= 32 to avoid range of possible 5 bit values.
+     */
+    OI_DATAELEM_REF       = 32,  /**< used for dynamic attributes in a service record */
+    OI_DATAELEM_PARENT    = 33   /**< End of list marker that points to lists Parent Element */
+} OI_DATAELEM_TYPES;
+
+
+/**
+ * This enumeration is for Data Element size descriptor indices, which are 3-bit
+ * indices indicating Data Element size as defined in Section 3.3 of the
+ * Service Discovery Protocol specification.
+ */
+
+enum OI_DATAELEM_SIZES {
+    OI_DATAELEM8         =   0, /**< Data Element data field is one byte long; unless Data Element type is null, in which case data field is zero bytes. */
+    OI_DATAELEM16        =   1, /**< Data Element data field is two bytes long. */
+    OI_DATAELEM32        =   2, /**< Data Element data field is four bytes long. */
+    OI_DATAELEM64        =   3, /**< Data Element data field is eight bytes long. */
+    OI_DATAELEM128       =   4, /**< Data Element data field is sixteen bytes long. */
+    OI_DATAELEM_VAR8     =   5, /**< Data Element data field length is given by the following one-byte value. */
+    OI_DATAELEM_VAR16    =   6, /**< Data Element data field length is given by the following two-byte value. */
+    OI_DATAELEM_VAR32    =   7  /**< Data Element data field length is given by the following four-byte value. */
+};
+
+/**
+ * @name Data Element utility macros
+ * @{
+ */
+
+
+/**
+ * This macro extracts the Data Element type descriptor (top 5 bits) from the
+ * network representation of a Data Element descriptor.
+ */
+
+#define OI_DATAELEM_TYPE(e)            ((OI_UINT8) (((e) & 0xF8) >> 3))
+
+/**
+ * This macro extracts the Data Element size descriptor index (bottom 3 bits)
+ * from the network representation of a Data Element descriptor.
+ */
+
+#define OI_DATAELEM_SIZE_INDEX(e)      ((OI_UINT8) ((e) & 0x07))
+
+/**
+ * This macro composes the network representation of a Data Element descriptor
+ * from a Data Element type descriptor and a Data Element size descriptor.
+ */
+
+#define OI_DATAELEM_DESCRIPTOR(t, s)   ((OI_UINT8) (((t) << 3) | (s)))
+
+
+/**
+ * the size of a VAR8 Data Element header
+ */
+
+#define OI_DATAELEM_VAR8_SIZE     (sizeof(OI_UINT8) + sizeof(OI_UINT8))
+
+/**
+ * the size of a VAR16 Data Element header
+ */
+
+#define OI_DATAELEM_VAR16_SIZE    (sizeof(OI_UINT8) + sizeof(OI_UINT16))
+
+/**
+ * the size of a VAR32 Data Element header
+ */
+
+#define OI_DATAELEM_VAR32_SIZE    (sizeof(OI_UINT8) + sizeof(OI_UINT32))
+
+
+/**
+ * This macro tests whether a Data Element is one of the Data Element list types.
+ */
+
+#define OI_DATAELEM_IS_LIST(e) \
+    (((e)->ElemType == OI_DATAELEM_SEQ) || ((e)->ElemType == OI_DATAELEM_ALT))
+
+/**
+ * This macro tests whether a Data Element is one of the Data Element text types.
+ */
+
+#define OI_DATAELEM_IS_TEXT(e) \
+    (((e)->ElemType == OI_DATAELEM_TEXT) || ((e)->ElemType == OI_DATAELEM_URL))
+
+
+/**@}*/
+
+typedef struct _OI_DATAELEM OI_DATAELEM;    /**< Data Elements are stored as structures. */
+
+
+
+/**
+    OI_ELEMENT_UNION is the type used to initialize data element values.  The assumption is that
+    void* type is large enough to hold the largest numeric type used in the union, i.e. 32-bits.
+ */
+typedef void * OI_ELEMENT_UNION;
+
+/**
+   This structure is a union that represents all possible types
+   for the data in a Data Element's data field.
+ */
+
+typedef union {
+    OI_ELEMENT_UNION ElementUnion; /**< Data Element union */
+    OI_BOOL      Boolean;       /**< Boolean type */
+    OI_INT32     SInt;          /**< Signed 32-bit integer used for 8-bit, 16-bit, and 32-bit integers */
+    OI_UINT32    UInt;          /**< Unsigned 32-bit integer used for 8-bit, 16-bit, and 32-bit unsigned integers*/
+    OI_INT64     *SInt64;       /**< Pointer to a signed 64-bit integer */
+    OI_UINT64    *UInt64;       /**< Pointer to an unsigned 64-bit integer */
+    OI_INT128    *SInt128;      /**< Pointer to a signed 128-bit integer */
+    OI_UINT128   *UInt128;      /**< Pointer to an unsigned 128-bit integer */
+    OI_CHAR      *Text;         /**< Pointer to text as a string of characters */
+    OI_CHAR      *URL;          /**< Pointer to a URL as a string of characters */
+    OI_UUID32    ShortUUID;     /**< 32-bit representation of a UUID used for 16-bit and 32-bit UUIDs */
+    OI_UUID128   *LongUUID;     /**< Pointer to a 128-bit UUID */
+    OI_DATAELEM  *ElemSeq;      /**< Pointer to a sequence of Data Elements */
+    OI_DATAELEM  *ElemAlt;      /**< Pointer to a sequence of Data Elements from which one is to be selected */
+    OI_BYTE      *RawBytes;     /**< Pointer to raw bytes */
+    OI_STATUS    Status;        /**< Status code */
+    OI_DATAELEM  *ElemRef;      /**< Pointer to a Data Element of type used for dynamic attributes in a service record */
+    OI_DATAELEM  *ListParent;   /**< Internal pointer to a Data Element for use at end of ALT/SEQ lists */
+    OI_DATAELEM  const *__Elem; /**< !!! for Internal use only */
+    OI_CHAR      const *__Text;
+    OI_CHAR16    const *__Text16;
+    OI_BYTE      const *__RawBytes;
+    OI_DATAELEM  const *__ListParent;
+} OI_DATAELEM_UNION;
+
+
+/**
+ * This structure defines the in-memory representation of a Data Element.
+ */
+struct _OI_DATAELEM {
+    /**
+     * This is one of the OI_DATAELEM_TYPES values.
+     */
+    OI_UINT8 ElemType;
+    /**
+     * For primitive types, this is the length of the Data Element data field in
+     * bytes. For lists (OI_DATAELEM_ALT, OI_DATAELEM_SEQ) this is the number of
+     * Data Elements in the list.
+     */
+    OI_UINT16 Size;
+    /**
+     * The Data Element's data field value is of type OI_DATAELEM_UNION, which
+     * is a union of all possible Data Element types. Data field values that are
+     * larger than four bytes are referenced via a pointer.
+     */
+    OI_DATAELEM_UNION Value;
+};
+
+
+
+/**
+ * @note
+ * The OI_ELEMENT_VAL macro accomodates different behavior of compilers needed
+ * because the third item in each of the Data Element initialization macros is a
+ * union and compilers differ in their brace requirements for union
+ * initialization. GCC requires braces; some earlier Hitachi compileres require
+ * no braces; and Microsoft Visual C/C++ compiler accepts unions either way.
+ * The requirement of no braces is considered here to be the special case.
+ */
+
+#define OI_ELEMENT_VAL(v)    { ((OI_ELEMENT_UNION) (v)) }
+
+/**
+ * @name Macros for static initialization of Data Elements
+ *
+ * These macros are for constructing statically initialized Data Elements.
+ *
+ * When statically initializing a union, only the first item in the union is
+ * initialized. Therefore, all initialization values have been cast to
+ * OI_ELEMENT_UNION defined as an unsigned 32-bit integer so that sign extension
+ * does not occur by default. As described above, OI_ELEMENT_VAL() is a macro
+ * that deals with platform-specific union behavior and casts data items to the
+ * union OI_ELEMENT_UNION.
+ *
+ * @note that OI_ELEMENT_STRING and OI_ELEMENT_URL are expecting a null
+ * terminated string e.g. OI_ELEMENT_STRING("This is a string") and they
+ * assume (and remove) the terminating null. Use OI_ELEMENT_TEXT if the data
+ * is to be initialized exactly as specified.
+ *
+ * @{
+ */
+
+#define OI_ELEMENT_INT8(i)    { OI_DATAELEM_SINT, sizeof(OI_INT8),          OI_ELEMENT_VAL((OI_INT32)(i)) }             /**< This macro statically initializes an 8-bit signed integer Data Element. */
+#define OI_ELEMENT_INT16(i)   { OI_DATAELEM_SINT, sizeof(OI_INT16),         OI_ELEMENT_VAL((OI_INT32)(i)) }             /**< This macro statically initializes a 16-bit signed integer Data Element. */
+#define OI_ELEMENT_INT32(i)   { OI_DATAELEM_SINT, sizeof(OI_INT32),         OI_ELEMENT_VAL((OI_INT32)(i)) }             /**< This macro statically initializes a 32-bit signed integer Data Element. */
+#define OI_ELEMENT_UINT8(i)   { OI_DATAELEM_UINT, sizeof(OI_UINT8),         OI_ELEMENT_VAL((OI_UINT32)(i)) }            /**< This macro statically initializes an 8-bit unsigned integer Data Element. */
+#define OI_ELEMENT_UINT16(i)  { OI_DATAELEM_UINT, sizeof(OI_UINT16),        OI_ELEMENT_VAL((OI_UINT32)(i)) }            /**< This macro statically initializes a 16-bit unsigned integer Data Element. */
+#define OI_ELEMENT_UINT32(i)  { OI_DATAELEM_UINT, sizeof(OI_UINT32),        OI_ELEMENT_VAL((OI_UINT32)(i)) }            /**< This macro statically initializes a 32-bit unsigned integer Data Element. */
+#define OI_ELEMENT_BOOL(b)    { OI_DATAELEM_BOOL, sizeof(OI_UINT8),         OI_ELEMENT_VAL((OI_UINT32)(b)) }            /**< This macro statically initializes a boolean Data Element. */
+
+#define OI_ELEMENT_UINT64(i)  { OI_DATAELEM_UINT, sizeof(OI_UINT64),        OI_ELEMENT_VAL(i) }                         /**< This macro statically initializes a pointer to a 64-bit unsigned integer Data Element */
+#define OI_ELEMENT_UINT128(i) { OI_DATAELEM_UINT, sizeof(OI_UINT128),       OI_ELEMENT_VAL(i) }                         /**< This macro statically initializes a pointer to a 128-bit unsigned integer Data Element */
+#define OI_ELEMENT_INT64(i)   { OI_DATAELEM_SINT, sizeof(OI_INT64),         OI_ELEMENT_VAL(i) }                         /**< This macro statically initializes a pointer to a 64-bit signed integer Data Element */
+#define OI_ELEMENT_INT128(i)  { OI_DATAELEM_SINT, sizeof(OI_INT128),        OI_ELEMENT_VAL(i) }                         /**< This macro statically initializes a pointer to a 128-bit signed integer Data Element */
+
+#define OI_ELEMENT_UUID16(u)  { OI_DATAELEM_UUID, sizeof(OI_UUID16),        OI_ELEMENT_VAL(u) }                         /**< This macro statically initializes a 16-bit UUID Data Element. */
+#define OI_ELEMENT_UUID32(u)  { OI_DATAELEM_UUID, sizeof(OI_UUID32),        OI_ELEMENT_VAL(u) }                         /**< This macro statically initializes a 32-bit UUID Data Element. */
+#define OI_ELEMENT_UUID128(u) { OI_DATAELEM_UUID, sizeof(OI_UUID128),       OI_ELEMENT_VAL(u) }                         /**< This macro statically initializes a pointer to a 128-bit UUID Data Element. */
+
+#define OI_ELEMENT_NULL       { OI_DATAELEM_NULL, 0,                        OI_ELEMENT_VAL(0) }                         /**< This macro statically initializes a null Data Element. */
+
+#define OI_ELEMENT_STRING(t)  { OI_DATAELEM_TEXT, (OI_UINT16) (OI_ARRAYSIZE(t) - 1), OI_ELEMENT_VAL(((const OI_CHAR*) (t))) } /**< This macro statically initializes a pointer to a text string Data Element (removes trailing 0) */
+#define OI_ELEMENT_URL(u)     { OI_DATAELEM_URL,  (OI_UINT16) (OI_ARRAYSIZE(u) - 1), OI_ELEMENT_VAL(((const OI_CHAR*) (u))) } /**< This macro statically initializes a pointer to a URL text string Data Element (removes trailing 0) */
+#define OI_ELEMENT_TEXT(t)    { OI_DATAELEM_TEXT, (OI_UINT16) OI_ARRAYSIZE(t),       OI_ELEMENT_VAL(((const OI_CHAR*) (t))) } /**< This macro statically initializes a pointer to a TEXT Data Element */
+#define OI_ELEMENT_SEQ(s)     { OI_DATAELEM_SEQ,  (OI_UINT16) OI_ARRAYSIZE(s),       OI_ELEMENT_VAL((&(s)[0])) }        /**< This macro statically initializes a pointer to a sequence of Data Elements */
+#define OI_ELEMENT_ALT(s)     { OI_DATAELEM_ALT,  (OI_UINT16) OI_ARRAYSIZE(s),       OI_ELEMENT_VAL((&(s)[0])) }        /**< This macro statically initializes a pointer to a sequence of alternative Data Elements */
+
+#define OI_ELEMENT_SEQ_N(s,n) { OI_DATAELEM_SEQ,  (OI_UINT16) (n),                   OI_ELEMENT_VAL((&(s)[0])) }        /**< This macro statically initializes a pointer to a sequence of Data Elements */
+
+#define OI_ELEMENT_REF(e)     { OI_DATAELEM_REF,  0,                        OI_ELEMENT_VAL(&(e)) }                      /**< This macro statically initializes a pointer to a Data Element (used for dynamic attributes in a service record) */
+
+/** @}*/
+
+/**
+ * @name Macros for run-time assignment of Data Elements
+ *
+ * These macros are for run-time assignment of Data Elements.
+ *
+ * @{
+ */
+
+/**
+ * This macro sets a null Data Element.
+ *
+ * @param elem   the null Data Element to be set
+ */
+
+#define OI_SET_NULL_ELEMENT(elem) \
+{ \
+    (elem).ElemType = OI_DATAELEM_NULL; \
+}
+
+/**
+ * This macro sets a data element of signed integer type.
+ *
+ * @param elem   Specifies the data element of signed integer type to be set
+ *
+ * @param value  Signed integer value based on which the data element's size and value are set
+ */
+
+#define OI_SET_INT_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_SINT; \
+    (elem).Size = sizeof(value); \
+    (elem).Value.SInt = (OI_INT32) (value); \
+}
+
+/**
+ * This macro sets a data element of unsigned integer type.
+ *
+ * @param elem    Specifies the data element of unsigned integer type to be set
+ *
+ * @param value   Unsigned integer value based on which the data element's size and value are set
+ */
+
+#define OI_SET_UINT_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_UINT; \
+    (elem).Size = sizeof(value); \
+    (elem).Value.UInt = (OI_UINT32) (value); \
+}
+
+
+/**
+ * This macro sets a data element of UUID16 type.
+ *
+ * Note that UUID16 values are stored as 32 bits.
+ *
+ * @param elem    Specifies the data element to be set
+ *
+ * @param value   UUID16 value
+ */
+
+#define OI_SET_UUID16_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_UUID; \
+    (elem).Size = sizeof(OI_UUID16); \
+    (elem).Value.ShortUUID = (OI_UUID32) (value); \
+}
+
+
+/**
+ * This macro sets a data element of UUID32 type.
+ *
+ * @param elem    Specifies the Data Element to be set
+ *
+ * @param value   UUID32 value
+ */
+
+#define OI_SET_UUID32_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_UUID; \
+    (elem).Size = sizeof(OI_UUID32); \
+    (elem).Value.ShortUUID = (OI_UUID32) (value); \
+}
+
+/**
+ * This macro sets a data element of UUID128 type.
+ *
+ * @param elem    Specifies the data element to be set
+ *
+ * @param value   UUID128 l-value
+ */
+
+#define OI_SET_UUID128_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_UUID; \
+    (elem).Size = OI_BT_UUID128_SIZE; \
+    (elem).Value.LongUUID = (value); \
+}
+
+/**
+ * This macro sets a data element of Boolean (BOOL) type.
+ *
+ * @param elem   Specifies the data element of Boolean type to be set
+ *
+ * @param value  Boolean (TRUE/FALSE) value
+ */
+
+#define OI_SET_BOOL_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_BOOL; \
+    (elem).Size = sizeof(OI_UINT8); \
+    (elem).Value.Boolean = (OI_UINT8) (value); \
+}
+
+/**
+ * This macro sets a data element of list type.
+ *
+ * @param elem   Specifies the data element of list type to be set
+ *
+ * @param type   One of the list data element types (OI_DATAELEM_SEQ, OI_DATAELEM_ALT)
+ *
+ * @param list   Pointer to the first data element in the body of the list
+ *
+ * @param size   Number of elements in the body of the list
+ */
+
+#define OI_SET_LIST_ELEMENT(elem, type, list, size) \
+{ \
+    (elem).ElemType = type; \
+    (elem).Size = size; \
+    (elem).Value.__Elem = &(list); \
+}
+
+
+/**
+ * This macro sets a data element of list type that has no data elements.
+ *
+ * @param elem   Specifies the data element of list type to be set
+ *
+ * @param type   One of the list Data Element types (OI_DATAELEM_SEQ, OI_DATAELEM_ALT)
+ */
+
+#define OI_SET_EMPTY_LIST_ELEMENT(elem, type) \
+{ \
+    (elem).ElemType = type; \
+    (elem).Size = 0; \
+    (elem).Value.__Elem = NULL; \
+}
+
+/**
+ * This macro sets a data element of sequence type by applying the OI_SET_LIST_ELEMENT macro.
+ *
+ * @param elem   Specifies the data element of sequence type to be set
+ *
+ * @param list   First data element in the body of the list
+ */
+
+#define OI_SET_SEQ_ELEMENT(elem, list) OI_SET_LIST_ELEMENT(elem, OI_DATAELEM_SEQ, list[0], OI_ARRAYSIZE(list))
+
+/**
+ * This macro sets a data element of alternative sequence type by applying the OI_SET_LIST_ELEMENT macro.
+ *
+ * @param elem   Specifies the data element of alternative sequence type to be set
+ *
+ * @param list   First data element in the body of the list
+ */
+
+
+#define OI_SET_ALT_ELEMENT(elem, list) OI_SET_LIST_ELEMENT(elem, OI_DATAELEM_ALT, list[0], OI_ARRAYSIZE(list))
+
+
+/**
+ * This macro sets a data element of URL type.
+ *
+ * @param elem   Specifies the data element of URL type to be set
+ *
+ * @param addr   Pointer to the text string
+ *
+ * @param len    Length of the text string
+ */
+#define OI_SET_URL_ELEMENT(elem, addr, len) \
+{ \
+    (elem).ElemType = OI_DATAELEM_URL; \
+    (elem).Size = (len); \
+    (elem).Value.URL = (addr); \
+}
+
+/**
+ * This macro sets a data element of text string type.
+ *
+ * @param elem   Specifies the data element of text string type to be set
+ *
+ * @param addr   Pointer to the text string
+ *
+ * @param len    Length of the text string
+ */
+#define OI_SET_TEXT_ELEMENT(elem, addr, len) \
+{ \
+    (elem).ElemType = OI_DATAELEM_TEXT; \
+    (elem).Size = (len); \
+    (elem).Value.__Text = (addr); \
+}
+
+
+/**
+ * This macro sets a 64-bit signed integer data element.
+ *
+ * @param elem  Specifies the data element to be set
+ *
+ * @param value OI_INT64 struct
+ */
+#define OI_SET_INT64_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_SINT; \
+    (elem).Size = sizeof(OI_INT64); \
+    (elem).Value.SInt64 = &(value); \
+}
+
+/**
+ * This macro sets a 64-bit unsigned integer data element.
+ *
+ * @param elem  Specifies the data element to be set
+ *
+ * @param value OI_UINT64 struct
+ */
+#define OI_SET_UINT64_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_UINT; \
+    (elem).Size = sizeof(OI_UINT64); \
+    (elem).Value.UInt64 = &(value); \
+}
+
+/**
+ * This macro sets a 128-bit signed integer data element.
+ *
+ * @param elem  Specifies the data element to be set
+ *
+ * @param value OI_INT128 struct
+ */
+#define OI_SET_INT128_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_SINT; \
+    (elem).Size = sizeof(OI_INT128); \
+    (elem).Value.SInt128 = &(value); \
+}
+
+/**
+ * This macro sets a 128-bit unsigned integer data element.
+ *
+ * @param elem  Specifies the data element to be set
+ *
+ * @param value OI_UINT128 struct
+ */
+#define OI_SET_UINT128_ELEMENT(elem, value) \
+{ \
+    (elem).ElemType = OI_DATAELEM_UINT; \
+    (elem).Size = sizeof(OI_UINT128); \
+    (elem).Value.UInt128 = &(value); \
+}
+
+
+/** @}*/
+
+/**
+ * This function determines whether two UUID data element values represent the same UUID.
+ *
+ * UUIDs are 128-bit values, but the SDP specification defines 16-, and 32-bit
+ * shorthand formats and a standard way of converting from the short forms to
+ * the full 128-bit UUID.
+ *
+ * This function handles all permutations of 16-, 32-, and 128-bit representations.
+ *
+ * @param A            UUID to be compared
+ *
+ * @param B            UUID to be compared
+ *
+ * @returns TRUE if A and B match, FALSE if
+  - A and B are not UUID data or
+  - A and B do not match.
+ */
+
+OI_BOOL OI_DATAELEM_SameUUID(const OI_DATAELEM *A,
+                             const OI_DATAELEM *B);
+
+
+/**
+ * This function returns the UUID32 representation of a generic UUID. If there is no 32-bit
+ * representation, it returns 0.
+ *
+ * @param U    Data element UUID
+ *
+ * @returns    32 bit UUID
+ */
+
+OI_UUID32 OI_DATAELEM_ConvertToUUID32(const OI_DATAELEM *U);
+
+/**
+ * This function returns the UUID128 representation of a generic UUID.
+ *
+ * @param uuid128    128-bit UUID representation of the UUID described by
+ *                   the data element
+ *
+ * @param U          Data element UUID
+ *
+ *
+ * @returns          OI_OK if the data element was a UUID
+ */
+
+OI_STATUS OI_DATAELEM_ConvertToUUID128(OI_UUID128 *uuid128,
+                                       const OI_DATAELEM *U);
+
+
+/** This function compares a 32-bit UUID to a 128-bit UUID */
+OI_BOOL OI_ShortUUID_eq_LongUUID(OI_UUID32 shortUUID,
+                                 const OI_UUID128 *longUUID);
+
+
+/**
+ * This function returns a string pointer to text associated with a UUID data element.
+ *
+ * @param dataelem      Pointer to data element of type OI_DATAELEM_UUIDy
+ *
+ * @returns             String pointer
+ */
+
+OI_CHAR* OI_UUIDDataelemText(const OI_DATAELEM *pElem);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_DATAELEM_H */
diff --git a/obex_profiles/sdk/include/oi_debug.h b/obex_profiles/sdk/include/oi_debug.h
new file mode 100644
index 0000000..976830d
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_debug.h
@@ -0,0 +1,336 @@
+#ifndef _OI_DEBUG_H
+#define _OI_DEBUG_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/** @file
+ *
+ * This file provides a set of debug print functions and macros.
+ *
+ * The functions are all implemented, regardless of whether or not the preprocessor
+ * symbol OI_DEBUG is defined.  The specific implementation (in oi_debug.c) may differ
+ * depending on OI_DEBUG.
+ *
+ * There are currently 6 debug print macros:
+ *  - OI_SLOG_ERROR
+ *  - OI_SLOG_WARNING
+ *  - OI_DBG_PRINT1
+ *  - OI_DBG_PRINT2
+ *  - OI_TRACE
+ *  - OI_TRACE_USER
+ *
+ * Whether or not these debug print macros generate code depends on a combination of
+ * preprocessor symbol definitions:
+ *  - OI_DEBUG - if defined, all debugprint macros generate code (default for debug mode)
+ *  - OI_ENABLE_DBG_PRINT1      - OI_DBG_PRINT1 generates code
+ *  - OI_ENABLE_DBG_PRINT2      - OI_DBG_PRINT2 generates code
+ *  - OI_ENABLE_DBG_PRINT       - OI_DBG_PRINT1 and OI_DBG_PRINT2 generate code
+ *  - OI_ENABLE_TRACE           - OI_TRACE and OI_TRACE_USER generate code
+ *  - OI_ENABLE_TRACE_USER      - OI_TRACE and OI_TRACE_USER generate code
+ *  - OI_ENABLE_SLOG_ERROR      - OI_SLOG_ERROR generates code (default for release mode)
+ *  - OI_SUPPRESS_SLOG_ERROR    - Suppresses error logging for further code size reduction
+ *
+ * For debug builds (OI_DEBUG defined), all debug print macros generate calls to generate
+ * debug output.  A run-time filter is applied to selectively display output depending on
+ * module name and runtime debug level configuration for that module.
+ *
+ * For release builds (OI_DEBUG not defined), debug print macros can be selectively enabled
+ * at compile time defining the appropriate OI_ENABLE_xxxx.  This selective enabling may
+ * be applied to any or all files.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_bt_spec.h"
+#include "oi_statustext.h"
+#include "oi_text.h"
+#include "oi_debugcontrol.h"
+#include "oi_osinterface.h"
+#include "oi_l2cap.h"
+#ifdef USE_ANDROID_LOGGING
+#include <utils/Log.h>
+#else
+#include <syslog.h>
+#endif
+
+#ifdef __OI_MODULE__
+#define OI_CURRENT_MODULE __OI_MODULE__
+#else
+#define OI_CURRENT_MODULE OI_MODULE_UNKNOWN
+#endif
+
+/** \addtogroup Debugging */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Disallow test harness in release builds */
+
+#ifndef OI_DEBUG
+    #ifdef OI_TEST_HARNESS
+        #error OI_TEST_HARNESS is not supported in release builds
+    #endif /* OI_TEST_HARNESS */
+#endif /* OI_DEBUG */
+
+/*
+ * Utility functions.
+ */
+
+/**
+ * Sets the logging level
+ *
+ * @param level    The level for which logs would be printed
+ */
+void OI_SetLogLevel(OI_UINT16 level);
+
+
+/**
+ * Looks up the manufacture name given a manifacturer id.
+ *
+ * @param manufacturerId    The manufacturer id from the Bluetooth device address
+ *
+ * @return  The name of the manufacturer or NULL if there is no match for the id.
+ */
+OI_CHAR *OI_BtMfgrIdToText(OI_UINT16 manufacturerId);
+
+/**
+ * Looks up the character string for one of the stack modules.
+ *
+ * @param module  The module to lookup
+ *
+ * @return  The string name for the module or NULL if the module id is invalid.
+ */
+const OI_CHAR *OI_ModuleToString(OI_MODULE module);
+
+
+/**
+ * @name Debug Output Macros
+ * There are 7 categories of output defined.  The categories and
+ * functions/macros that implement those categories are defined below:
+ *
+ * OI_Printf(fmt, ...)                  - Always output.  Intended for use
+ *                                        primarily by the application.
+ *
+ * OI_SLOG_ERROR(status, (fmt, ...))    - Always output (except when build with
+ *                                        OI_SUPPRESS_SLOG_ERROR).  Intended
+ *                                        primarily for severe errors, errors
+ *                                        that cannot be handled, or indications
+ *                                        of bugs found at run time.
+ *
+ * OI_SLOG_WARNING(status, (fmt, ...))  - Normally output, can be suppressed
+ *                                        with appropriate control code.
+ *                                        Intended for all error conditions not
+ *                                        covered by OI_SLOG_ERROR, particularly
+ *                                        non-critical errors, for example, when
+ *                                        a remote device send corrupted data.
+ *
+ * OI_TRACE_USER((fmt, ...))            - Only output when enabled with control
+ *                                        code U.  Intended for entry to user
+ *                                        API's and prior to calling user
+ *                                        callbacks.
+ *
+ * OI_TRACE((fmt, ...))                 - Only output when enabled with control
+ *                                        code U.  Intended for tracing not within
+ *                                        the scope of OI_TRACE_USER()
+ *
+ * OI_DBG_PRINT1((fmt, ...))            - Only output when enabled with control
+ *                                        code D.  Intended for tracing
+ *                                        high-level data flow, state changes,
+ *                                        and unusual code paths.
+ *
+ * OI_DBG_PRINT2((fmt, ...))            - Only output when enabled with control
+ *                                        code E.  Intended for more verbose
+ *                                        information and for use when an
+ *                                        alternate color would make
+ *                                        understanding the debug output easier.
+ *
+ * Note that the macros OI_SLOG_*(), OI_TRACE_*() and OI_DBG_PRINT?() take the
+ * format string and its associated arguments inside a second set of
+ * parentheses.
+ *
+ * The macros OI_SLOG_*() take a parameter, status, in addition to the normal
+ * format and format arguments for reporting the status code in both debug and
+ * release mode.  See example:
+ *
+   @code
+   OI_SLOG_ERROR(OI_FAIL, ("%s, we have a problem", cityStr));
+
+   Debug Output => 1234.567 MODULE module.c:123    **** Houston, we have a problem: OI_FAIL
+   Release Output => 1234.567 SLOG_ERROR: 45,123,114
+   @endcode
+ *
+ * The debug print functions uses printf style formatting and allows multiple
+ * arguments.  The debug print function should always be called via the macros
+ * listed below, not directly.  The macros set global line and file variables
+ * that are used by the debug print function.
+ *
+ * See sdk/include/oi_debugcontrol.h for details on setting/controlling the
+ * debug output.
+ * @{
+ */
+extern int default_log_level;
+
+#if defined(OI_SUPPRESS_SLOG_ERROR)  /* if SLOG_ERRORs are suppressed, so is everything else */
+
+#define OI_SLOG_ERROR(_status, _msg)   do {} while (0)
+#define OI_SLOG_WARNING(_status, _msg) do {} while (0)
+#define _OI_DBG_MSG(_status, _msg)     do {} while (0)
+
+#else /* defined(OI_SUPPRESS_SLOG_ERROR) */
+#ifdef USE_ANDROID_LOGGING
+#define _OI_Dbg_Printf(fmt, arg...) ALOGD("%s : "fmt, "obex", ##arg)
+#else
+#define _OI_Dbg_Printf(fmt, arg...) syslog(LOG_NOTICE, "%s : "fmt, "obex", ##arg)
+#endif
+
+#define _OI_LOG_MSG(_code, _status, _msg)                               \
+    do {                                                                \
+        if (_code <= default_log_level) { \
+            _OI_Dbg_Printf _msg ;                                       \
+            _OI_Dbg_Printf ("status : %d", _status);                                \
+        }                                                               \
+    } while (0)
+
+#define _OI_DBG_MSG(_code, _msg)                                             \
+    do {                                                                     \
+        if (_code <= default_log_level) { \
+            _OI_Dbg_Printf _msg ;                                   \
+        }                                                                    \
+    } while (0)
+
+#if defined(OI_DEBUG) || defined(OI_ENABLE_SLOG_ERROR)
+#define OI_SLOG_ERROR(_status, _msg) _OI_LOG_MSG(OI_MSG_CODE_ERROR, (_status), _msg )
+#else
+#define OI_SLOG_ERROR(_status, _msg) OI_LogError(OI_CURRENT_MODULE, __LINE__, (_status))
+#endif
+
+#if defined(OI_DEBUG) || defined(OI_ENABLE_SLOG_WARNING)
+#define OI_SLOG_WARNING(_status, _msg) _OI_LOG_MSG(OI_MSG_CODE_WARNING, (_status), _msg )
+#else
+#define OI_SLOG_WARNING(_status, _msg) do {} while (0)
+#endif
+
+#endif /* defined(OI_SUPPRESS_SLOG_ERROR) */
+
+#if defined(OI_DEBUG) || defined(OI_ENABLE_TRACE) || defined(OI_ENABLE_TRACE_USER)
+#define OI_TRACE(_msg)      _OI_DBG_MSG(OI_MSG_CODE_TRACE,     _msg )
+#else
+#define OI_TRACE(_msg)      do {} while (0)
+#endif
+
+#if defined(OI_DEBUG) || defined(OI_ENABLE_TRACE) || defined(OI_ENABLE_TRACE_USER)
+#define OI_TRACE_USER(_msg)      _OI_DBG_MSG(OI_MSG_CODE_TRACE,     _msg )
+#else
+#define OI_TRACE_USER(_msg)      do {} while (0)
+#endif
+
+#if defined(OI_DEBUG) || defined(OI_ENABLE_DBG_PRINT) || defined(OI_ENABLE_DBG_PRINT1)
+#define OI_DBG_PRINT1(_msg)      _OI_DBG_MSG(OI_MSG_CODE_PRINT1, _msg )
+#else
+#define OI_DBG_PRINT1(_msg)      do {} while (0)
+#endif
+
+#if defined(OI_DEBUG) || defined(OI_ENABLE_DBG_PRINT) || defined(OI_ENABLE_DBG_PRINT2)
+#define OI_DBG_PRINT2(_msg)      _OI_DBG_MSG(OI_MSG_CODE_PRINT2, _msg )
+#else
+#define OI_DBG_PRINT2(_msg)      do {} while (0)
+#endif
+
+#if defined(OI_DEBUG) || defined(OI_ENABLE_DBG_PRINT) || defined(OI_ENABLE_DBG_PRINT2)
+#define OI_DBG_STR(_msg) \
+    do {                                                                \
+        if (OI_MSG_CODE_HEADER <= default_log_level) { \
+            _OI_Dbg_Printf ("%s", _msg);                                \
+        }                                                               \
+    } while (0)
+#else
+#define OI_DBG_STR(_msg)      do {} while (0)
+#endif
+
+/* Backwards compatibility for old-style macros. */
+#define OI_LOG_ERROR(_msg) OI_SLOG_ERROR(OI_STATUS_NONE, _msg )
+#define OI_DBGPRINT(_msg)  OI_DBG_PRINT1(_msg )
+#define OI_DBGPRINT2(_msg) OI_DBG_PRINT2(_msg )
+#define OI_DBGTRACE(_msg)  OI_TRACE_USER(_msg )
+#define OI_DBGPRINTSTR(_msg) OI_DBG_STR (_msg)
+
+#if defined(OI_DEBUG) && !defined(OI_ENABLE_SLOG_ERROR)
+#define OI_ENABLE_SLOG_ERROR 1
+#endif
+
+#if defined(OI_DEBUG) && !defined(OI_ENABLE_SLOG_WARNING)
+#define OI_ENABLE_SLOG_WARNING 1
+#endif
+
+/**@}*/
+
+/*
+ * A lot of code that is conditionally compiled in with OI_DEBUG is support
+ * code for the various debug print macros defined above.  Since it is
+ * possible to enable only a specific debug print macro at compile time for a
+ * given module, that module will most likely need OI_DEBUG defined as well.
+ */
+#if !defined(OI_DEBUG) && (defined(OI_ENABLE_SLOG_ERROR) || defined(OI_ENABLE_SLOG_WARNING) || defined(OI_ENABLE_TRACE) || defined(OI_ENABLE_TRACE_USER) || defined(OI_ENABLE_DBG_PRINT) || defined(OI_ENABLE_DBG_PRINT1) || defined(OI_ENABLE_DBG_PRINT2))
+#define OI_DEBUG_PER_MOD 1
+#endif
+
+/**
+ * DEBUG_ONLY - a little macro for single-line statements and variable declarations
+ * Avoids the clutter of \#ifdef OI_DEBUG in the source code.
+ *
+ * For example, to declare a variable that is only used when OI_DEBUG is
+ * defined:
+   @code
+       DEBUGONLY( OI_UINT counter = 0; )
+       ...
+       DEBUGONLY( ++counter; );
+       ...
+       OI_DBG_PRINT1(1, ("Counter is %d", counter));
+   @endcode
+ */
+
+#if defined(OI_DEBUG)
+#define DEBUG_ONLY(stmt)    stmt
+#else
+#define DEBUG_ONLY(stmt)
+#endif
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_DEBUG_H */
+
diff --git a/obex_profiles/sdk/include/oi_debugcontrol.h b/obex_profiles/sdk/include/oi_debugcontrol.h
new file mode 100644
index 0000000..0e9f725
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_debugcontrol.h
@@ -0,0 +1,164 @@
+#ifndef _OI_DEBUGCONTROL_H
+#define _OI_DEBUGCONTROL_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * The debugging level for each module is controlled through this header file.
+ *
+ * Additional information is available in the @ref debugging_docpage section.
+ */
+
+#include "oi_modules.h"
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_osinterface.h"
+
+/** \addtogroup Debugging Debugging APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This macro converts the message code to bit mask flag used in the encoding
+ * of the levelEnableFlags member of the OI_DBG_OUTPUT_CTRL structure.
+ */
+#define OI_DBG_MSG_ENABLE(_code) (1 << (_code))
+
+/**
+ * Convenience macros for selecting common sets of debug output classes.
+ */
+#define OI_DBG_MSG_ERROR_ENABLE (OI_DBG_MSG_ENABLE(OI_MSG_CODE_ERROR) | OI_DBG_MSG_ENABLE(OI_MSG_CODE_WARNING))
+#define OI_DBG_MSG_TRACE_ENABLE (OI_DBG_MSG_ENABLE(OI_MSG_CODE_TRACE))
+#define OI_DBG_MSG_PRINT_ENABLE (OI_DBG_MSG_ENABLE(OI_MSG_CODE_PRINT1) | OI_DBG_MSG_ENABLE(OI_MSG_CODE_PRINT2))
+#define OI_DBG_MSG_ALL_ENABLE (OI_DBG_MSG_ERROR_ENABLE | OI_DBG_MSG_TRACE_ENABLE | OI_DBG_MSG_PRINT_ENABLE)
+
+
+/**
+ * This function sets the debug output control for a given module.  The output
+ * is controlled by a sequence of control characters.  The control characters
+ * are as follows:
+ *
+ * - L     - Enable Line Number output
+ * - U     - Enable Trace output
+ * - N     - Only application output and Errors are reported. It will also override
+ *           any settings to OI_DEBUG_ALL.
+ * - ON    - Enable debug logging using the default settings.  OI_DEBUG_DEFAULT
+ *           can be used to customize default settings.  This must be set alone.
+ * - OFF   - This is similar to N, however it will not override any settings to
+ *           OI_DEBUG_ALL.  It must be set alone.
+ * - 1     - Enable Print 1 and Trace.
+ * - 2     - Enable Print 1, Print 2, and Trace.
+ * - 123   - Same as ON, but using line numbers. It must be alone.
+ *
+ * @param module    the module for which to set the debugging level
+ * @param ctrlStr   the debug output control for the specified module
+ */
+OI_STATUS OI_SetDebugControl(OI_MODULE module,
+                             const OI_CHAR *ctrlStr);
+
+/**
+ * This function sets the debug output control for a given module by the
+ * textual name of the module.  See the documentation for @ref
+ * OI_SetDebugControl for details on the control character codes.
+ *
+ * @param name      the string name for the module on which to set the debug output level
+ * @param ctrlStr   the debug output control for the specified module
+ */
+OI_STATUS OI_SetDebugControlByName(const OI_CHAR *name,
+                                   const OI_CHAR *ctrlStr);
+
+/**
+ * This function checks if specified debug messages are enabled or not for the
+ * specified module.  It will consider the settings for ALL modules as well.
+ * This function allows for fairly flexible combinations of checks:
+ * - Check both PRINT messages enabled:
+ *    OI_CheckDebugControl(module, OI_DBG_MSG_PRINT_ENABLE, 0)
+ *
+ * - Check either PRINT messages enabled:
+ *    OI_CheckDebugControl(module, 0, OI_DBG_MSG_PRINT_ENABLE)
+ *
+ * - Check both PRINT and either TRACE messages enabled:
+ *    OI_CheckDebugControl(module, OI_DBG_MSG_PRINT_ENABLE, OI_DBG_MSG_TRACE_ENABLE)
+ *
+ *
+ * @param module            module to look up
+ * @param allMsgEnable      all specified messages must be enabled
+ * @param oneMsgEnable      at least one of the specified messages must be enabled
+ *
+ * @returns TRUE if at least one of the specified flags are enabled
+ */
+OI_BOOL OI_CheckDebugControl(OI_MODULE module,
+                             OI_UINT8 allMsgEnable,
+                             OI_UINT8 oneMsgEnable);
+
+/**
+ * Parses a debug, dump or sniff command string and performs appropriate action.
+ *
+ * @param command  A null terminated string possibly containing a debug, dump
+ *                 test or sniff command.
+ *
+ * @return  OI_OK if the command was parsed
+ *          OI_STATUS_INVALID_COMMAND if not a dump, sniff, or debug command
+ *          OI_STATUS_INVALID_PARAMETERS if the debug module name is unknown
+ *          OI_STATUS_PARSE_ERROR if command was recognized but badly formed.
+ *
+ *
+ */
+OI_STATUS OI_Parse_DebugCommand(const OI_CHAR *command);
+
+
+/**  ******  THIS API IS FOR INTERNAL TESTING USE ONLY ********
+ *
+ * Parses a test command string and performs appropriate action.
+ *
+ *
+ * @param command  A null terminated string possibly containing a test command.
+ *
+ * @return  OI_OK if the command was parsed/consumed
+ *          OI_STATUS_INVALID_COMMAND if was not a test command
+ */
+OI_STATUS OI_Parse_TestCommand(const OI_CHAR *command);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_DEBUGCONTROL_H */
+
diff --git a/obex_profiles/sdk/include/oi_dump.h b/obex_profiles/sdk/include/oi_dump.h
new file mode 100644
index 0000000..2a997e3
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_dump.h
@@ -0,0 +1,149 @@
+#ifndef _OI_DUMP_H
+#define _OI_DUMP_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @file
+
+      This header file exposes interfaces to various dump utilties for debugging.
+
+    */
+
+#include "oi_utils.h"
+
+/** \addtogroup Debugging Debugging APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+#ifdef OI_DEBUG
+
+/** Dump utility for debugging L2CAP. */
+void OI_L2CAP_Dump(void);
+
+/** Dump utility for debugging RFCOMM. */
+void OI_RFCOMM_Dump(void);
+
+/** Dump utility for debugging HCI. */
+void OI_HCI_Dump(void);
+
+/** Dump utility for debugging the Device Manager. */
+void OI_DEVMGR_Dump(void);
+
+/** Dump utility for debugging the Policy Manager. */
+void OI_POLICYMGR_Dump(void);
+
+/** Dump utility for debugging the Security Manager. */
+void OI_SECMGR_Dump(void);
+
+/** Dump utility for debugging the AMP. */
+void OI_AMP_Dump(void);
+
+/** Dump utility for debugging SDPDB. */
+void OI_SDPDB_Print(void);
+
+/** Dump utility for debugging handle manager. */
+void OI_HANDLE_Dump(void);
+
+/** Dump utility for debugging Dispatcher. */
+void OI_DISPATCH_Dump(void);
+
+/** Dump utility for debugging AMP policies. */
+void OI_AMP_PolicyDump(void);
+
+#else /* OI_DEBUG */
+
+#define OI_L2CAP_Dump()                  OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_RFCOMM_Dump()                 OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_HCI_Dump()                    OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_DEVMGR_Dump()                 OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_POLICYMGR_Dump()              OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_SECMGR_Dump()                 OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_AMP_Dump()                    OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_SDPDB_Print()                 OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_HANDLE_Dump()                 OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_DISPATCH_Dump()               OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#define OI_AMP_PolicyDump()              OI_Printf("\nNot compiled with OI_DEBUG\n");
+
+#endif /* OI_DEBUG */
+
+
+#ifdef MEMMGR_PROFILE
+
+/** Dump utility for debugging the Memory Manager. */
+void OI_MEMMGR_Dump(void);
+
+#else
+
+#define OI_MEMMGR_Dump()           OI_Printf("\nNot compiled with MEMMGR_PROFILE\n")
+
+#endif /* MEMMGR_PROFILE */
+
+
+#ifdef MEMMGR_DEBUG
+
+/** Dump utility for debugging the used blocks in the Memory Manager. */
+void OI_MEMMGR_DumpUsedBlocks(void);
+
+/** Dump utility for debugging the memory pools in the Memory Manager. */
+void OI_MEMMGR_DumpPools(void);
+
+#else /* MEMMGR_DEBUG */
+
+#define OI_MEMMGR_DumpUsedBlocks() OI_Printf("\nNot compiled with MEMMGR_DEBUG\n")
+
+#define OI_MEMMGR_DumpPools()      OI_Printf("\nNot compiled with MEMMGR_DEBUG\n")
+
+#endif /* MEMMGR_DEBUG */
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_DUMP_H */
+
diff --git a/obex_profiles/sdk/include/oi_endian.h b/obex_profiles/sdk/include/oi_endian.h
new file mode 100644
index 0000000..92ec8a7
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_endian.h
@@ -0,0 +1,299 @@
+#ifndef _OI_ENDIAN_H
+#define _OI_ENDIAN_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+@file
+@internal
+
+ This file contains macros for dealing with byte-wise endianness (byte order
+ in multibyte data items).
+*/
+
+#include "oi_stddefs.h"
+#include "oi_bt_spec.h"
+
+
+/** \addtogroup Marshaller_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Write values in BIG endian order */
+
+#define SetUINT32_BigEndian(dst,value)                                 \
+do {                                                                   \
+     ((OI_UINT8*)(dst))[3] = (OI_UINT8) ((value) & 0x000000ff);        \
+     ((OI_UINT8*)(dst))[2] = (OI_UINT8)(((value) & 0x0000ff00) >> 8);  \
+     ((OI_UINT8*)(dst))[1] = (OI_UINT8)(((value) & 0x00ff0000) >> 16); \
+     ((OI_UINT8*)(dst))[0] = (OI_UINT8)(((value) & 0xff000000) >> 24); \
+} while(0)
+
+#define SetUINT24_BigEndian(dst, value)                                \
+do {                                                                   \
+     ((OI_UINT8*)(dst))[2] = (OI_UINT8) ((value) & 0x000000ff);        \
+     ((OI_UINT8*)(dst))[1] = (OI_UINT8)(((value) & 0x0000ff00) >> 8);  \
+     ((OI_UINT8*)(dst))[0] = (OI_UINT8)(((value) & 0x00ff0000) >> 16); \
+} while(0)
+
+#define SetUINT16_BigEndian(dst,value)                                 \
+do {                                                                   \
+     ((OI_UINT8*)(dst))[1] = (OI_UINT8) ((value) & 0x00ff);            \
+     ((OI_UINT8*)(dst))[0] = (OI_UINT8)(((value) & 0xff00) >> 8);      \
+} while(0)
+
+#define SetUINT8_BigEndian(dst,value)                   \
+do {                                                    \
+     ((OI_UINT8*)(dst))[0] = (OI_UINT8) ((value));      \
+} while(0)
+
+/* Write values in LITTLE endian order */
+
+#define SetUINT32_LittleEndian(dst,value)                              \
+do {                                                                   \
+     ((OI_UINT8*)(dst))[0] = (OI_UINT8) ((value) & 0x000000ff);        \
+     ((OI_UINT8*)(dst))[1] = (OI_UINT8)(((value) & 0x0000ff00) >> 8);  \
+     ((OI_UINT8*)(dst))[2] = (OI_UINT8)(((value) & 0x00ff0000) >> 16); \
+     ((OI_UINT8*)(dst))[3] = (OI_UINT8)(((value) & 0xff000000) >> 24); \
+} while(0)
+
+#define SetUINT24_LittleEndian(dst, value)                             \
+do {                                                                   \
+     ((OI_UINT8*)(dst))[0] = (OI_UINT8) ((value) & 0x000000ff);        \
+     ((OI_UINT8*)(dst))[1] = (OI_UINT8)(((value) & 0x0000ff00) >> 8);  \
+     ((OI_UINT8*)(dst))[2] = (OI_UINT8)(((value) & 0x00ff0000) >> 16); \
+} while(0)
+
+#define SetUINT16_LittleEndian(dst,value)                              \
+do {                                                                   \
+     ((OI_UINT8*)(dst))[0] = (OI_UINT8) ((value) & 0x00ff);            \
+     ((OI_UINT8*)(dst))[1] = (OI_UINT8)(((value) & 0xff00) >> 8);      \
+} while(0)
+
+#define SetUINT8_LittleEndian(dst,value)                \
+do {                                                    \
+     ((OI_UINT8*)(dst))[0] = (OI_UINT8) ((value));      \
+} while(0)
+
+
+
+/* Read values in BIG endian order */
+
+#define GetUINT32_BigEndian(src)                         \
+    ((OI_UINT32) (                                       \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[3])      )  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[2]) << 8 )  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[1]) << 16)  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[0]) << 24) ))
+
+#define GetUINT24_BigEndian(src)                         \
+    ((OI_UINT32) (                                       \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[2])      )  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[1]) << 8 )  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[0]) << 16) ))
+
+#define GetUINT16_BigEndian(src)                         \
+    ((OI_UINT16) (                                       \
+        ((OI_UINT16)(((OI_UINT8 *)(src))[1])      )  |   \
+        ((OI_UINT16)(((OI_UINT8 *)(src))[0]) << 8 ) ))
+
+#define GetUINT8_BigEndian(src)             \
+    (* ((OI_UINT8 *)(src)) )
+
+/* Read values in LITTLE endian order */
+
+#define GetUINT32_LittleEndian(src)                      \
+    ((OI_UINT32) (                                       \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[0])      )  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[1]) << 8 )  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[2]) << 16)  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[3]) << 24) ))
+
+#define GetUINT24_LittleEndian(src)                      \
+    ((OI_UINT32) (                                       \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[0])      )  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[1]) << 8 )  |   \
+        ((OI_UINT32)(((OI_UINT8 *)(src))[2]) << 16) ))
+
+#define GetUINT16_LittleEndian(src)                      \
+    ((OI_UINT16) (                                       \
+        ((OI_UINT16)(((OI_UINT8 *)(src))[0])      )  |   \
+        ((OI_UINT16)(((OI_UINT8 *)(src))[1]) << 8 ) ))
+
+#define GetUINT8_LittleEndian(src)          \
+    (* ((OI_UINT8 *)(src)) )
+
+
+/*
+ * In-place endian conversion on an array of UINT16
+ */
+
+
+/* Convert array from CPU byte order to BigEndian */
+
+void OI_SetUINT16Array_BigEndian(OI_UINT16 *data,
+                                 OI_UINT16 len);
+
+/* Convert array from BigEndian to CPU byte order */
+
+void OI_GetUINT16Array_BigEndian(OI_UINT16 *data,
+                                 OI_UINT16 len);
+
+/*
+ * BD_ADDR is an array of bytes - we have defined its native type as being a BIG
+ * ENDIAN array of bytes.
+ */
+
+#define GetBDADDR_BigEndian(dest, src)     \
+do {                                       \
+        (dest)[0] = (src)[0];              \
+        (dest)[1] = (src)[1];              \
+        (dest)[2] = (src)[2];              \
+        (dest)[3] = (src)[3];              \
+        (dest)[4] = (src)[4];              \
+        (dest)[5] = (src)[5];              \
+} while(0)
+
+#define GetBDADDR_LittleEndian(dest, src)      \
+do {                                           \
+        (dest)[0] = (src)[5];                  \
+        (dest)[1] = (src)[4];                  \
+        (dest)[2] = (src)[3];                  \
+        (dest)[3] = (src)[2];                  \
+        (dest)[4] = (src)[1];                  \
+        (dest)[5] = (src)[0];                  \
+} while(0)
+
+#define SetBDADDR_BigEndian(dest, src)      \
+do {                                        \
+        (dest)[0] = (src)[0];               \
+        (dest)[1] = (src)[1];               \
+        (dest)[2] = (src)[2];               \
+        (dest)[3] = (src)[3];               \
+        (dest)[4] = (src)[4];               \
+        (dest)[5] = (src)[5];               \
+} while(0)
+
+#define SetBDADDR_LittleEndian(dest, src)       \
+do { \
+        (dest)[0] = (src)[5];                   \
+        (dest)[1] = (src)[4];                   \
+        (dest)[2] = (src)[3];                   \
+        (dest)[3] = (src)[2];                   \
+        (dest)[4] = (src)[1];                   \
+        (dest)[5] = (src)[0];                   \
+} while(0)
+/*
+ * Natively, OI_UUID128 is a 32-bit integer followed by the remaining 96 bits as
+ * an array of bytes in BIG ENDIAN order.
+ */
+
+#define GetUUID128_BigEndian(dest, src)             \
+do {                                                \
+        (dest).ms32bits = GetUINT32_BigEndian(src); \
+        (dest).base[0]  = (src)[4];                 \
+        (dest).base[1]  = (src)[5];                 \
+        (dest).base[2]  = (src)[6];                 \
+        (dest).base[3]  = (src)[7];                 \
+        (dest).base[4]  = (src)[8];                 \
+        (dest).base[5]  = (src)[9];                 \
+        (dest).base[6]  = (src)[10];                \
+        (dest).base[7]  = (src)[11];                \
+        (dest).base[8]  = (src)[12];                \
+        (dest).base[9]  = (src)[13];                \
+        (dest).base[10] = (src)[14];                \
+        (dest).base[11] = (src)[15];                \
+} while(0)
+
+#define GetUUID128_LittleEndian(dest, src)                                                        \
+do {                                                                                              \
+        (dest).ms32bits = GetUINT32_LittleEndian(src + (OI_BT_UUID128_SIZE - sizeof(OI_UINT32))); \
+        (dest).base[0]  = (src)[11];                                                              \
+        (dest).base[1]  = (src)[10];                                                              \
+        (dest).base[2]  = (src)[9];                                                               \
+        (dest).base[3]  = (src)[8];                                                               \
+        (dest).base[4]  = (src)[7];                                                               \
+        (dest).base[5]  = (src)[6];                                                               \
+        (dest).base[6]  = (src)[5];                                                               \
+        (dest).base[7]  = (src)[4];                                                               \
+        (dest).base[8]  = (src)[3];                                                               \
+        (dest).base[9]  = (src)[2];                                                               \
+        (dest).base[10] = (src)[1];                                                               \
+        (dest).base[11] = (src)[0];                                                               \
+} while(0)
+
+#define SetUUID128_BigEndian(dest, src)              \
+do {                                                 \
+        SetUINT32_BigEndian((dest), (src).ms32bits); \
+        (dest)[4]  = (src).base[0];                  \
+        (dest)[5]  = (src).base[1];                  \
+        (dest)[6]  = (src).base[2];                  \
+        (dest)[7]  = (src).base[3];                  \
+        (dest)[8]  = (src).base[4];                  \
+        (dest)[9]  = (src).base[5];                  \
+        (dest)[10] = (src).base[6];                  \
+        (dest)[11] = (src).base[7];                  \
+        (dest)[12] = (src).base[8];                  \
+        (dest)[13] = (src).base[9];                  \
+        (dest)[14] = (src).base[10];                 \
+        (dest)[15] = (src).base[11];                 \
+} while(0)
+
+#define SetUUID128_LittleEndian(dest, src)                                                           \
+do {                                                                                                 \
+        SetUINT32_LittleEndian(((dest) + (OI_BT_UUID128_SIZE - sizeof(OI_UINT32))), (src).ms32bits); \
+        (dest)[0]  = (src).base[11];                                                                 \
+        (dest)[1]  = (src).base[10];                                                                 \
+        (dest)[2]  = (src).base[9];                                                                  \
+        (dest)[3]  = (src).base[8];                                                                  \
+        (dest)[4]  = (src).base[7];                                                                  \
+        (dest)[5]  = (src).base[6];                                                                  \
+        (dest)[6]  = (src).base[5];                                                                  \
+        (dest)[7]  = (src).base[4];                                                                  \
+        (dest)[8]  = (src).base[3];                                                                  \
+        (dest)[9]  = (src).base[2];                                                                  \
+        (dest)[10] = (src).base[1];                                                                  \
+        (dest)[11] = (src).base[0];                                                                  \
+} while(0)
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_ENDIAN_H */
+
diff --git a/obex_profiles/sdk/include/oi_handle.h b/obex_profiles/sdk/include/oi_handle.h
new file mode 100644
index 0000000..b551678
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_handle.h
@@ -0,0 +1,107 @@
+#ifndef _OI_HANDLE_H
+#define _OI_HANDLE_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * @internal
+ *
+ * This module provide a simple light-weight generic mechansim for managing handles to internal
+ * data structures. In normal usage handles are not reused.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Set the limit on the number of simultaneously maintained handles */
+#define OI_MAX_HANDLES    128
+
+
+/**
+ * Allocates and initializes a handle of a specific type.
+ *
+ * @param handleType    A unique handle type
+ *
+ * @param refData       Pointer to data referenced by the handle. This cannot be NULL.
+ *
+ * @return A new handle or NULL if handle could not be allocated.
+ */
+OI_HANDLE OI_HANDLE_Alloc(const OI_CHAR *handleType,
+                          void *refData);
+
+
+/**
+ * Checks if a handle is valid for a specific handle type.
+ *
+ * @param handle      The handle being checked
+ *
+ * @param handleType  The handle type. Note this function does not do string comparison this must be
+ *                    exactly the same const OI_CHAR pointer passed to OI_HANDLE_Alloc. .
+ */
+OI_BOOL OI_HANDLE_IsValid(OI_HANDLE handle,
+                          const OI_CHAR *handleType);
+
+
+/**
+ * Checks if a handle is stale (not longer valid)
+ *
+ * @param handle      The handle being checked
+ */
+#define OI_HANDLE_IsStale(handle) (OI_HANDLE_Deref(handle) == NULL)
+
+
+/**
+ * Returns the value referenced by a handle or NULL if the handle is invalid.
+ *
+ * @param handle   The handle to dereference
+ */
+void* OI_HANDLE_Deref(OI_HANDLE handle);
+
+
+/**
+ * Frees a handle
+ *
+ * @param handle   The handle to free.
+ *
+ * @return OI_STATUS_INVALID_HANDLE if the handle was not valid.
+ */
+OI_STATUS OI_HANDLE_Free(OI_HANDLE handle);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* _OI_HANDLE_H */
diff --git a/obex_profiles/sdk/include/oi_l2cap.h b/obex_profiles/sdk/include/oi_l2cap.h
new file mode 100644
index 0000000..d241d62
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_l2cap.h
@@ -0,0 +1,1025 @@
+#ifndef _OI_L2CAP_H
+#define _OI_L2CAP_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * This file provides the L2CAP (Logical Link Controller and Adaptation Protocol) API.
+ *
+ * See the @ref L2CAP_docpage section of the BLUEmagic 3.0 SDK documentation for more information.
+ *
+ */
+
+#include "oi_common.h"
+#include "oi_connect_policy.h"
+#include "oi_bt_spec.h"
+
+/** \addtogroup L2CAP L2CAP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** AMP Device Identifier. ID = 0 refers to the BR/EDR controller */
+typedef OI_UINT8 OI_AMP_ID;
+
+/** type for a channel identifier (CID) */
+typedef OI_UINT16 OI_L2CAP_CID;
+
+/** type for a protocol/service multiplexer (PSM) */
+typedef OI_UINT16 OI_L2CAP_PSM;
+
+
+/******************************************************************************
+
+  Connection parameters
+
+ ******************************************************************************/
+
+/**
+ * The L2CAP connection modes. The connection mode is specified when making an outbound connection or
+ * reported when an inbound connection is accepted.
+ *
+ * Note: FLOW_CONTROL_MODE and RETRANSMISSION_MODE are only listed for documentation purposes.
+ * Because they have are superceded by ENHANCED_RETRANSMISSION and STREAMING mode they
+ * are not implemented in BLUEmagic 3.0.
+ */
+typedef enum {
+    OI_L2CAP_BASIC_MODE                    = 0,
+    OI_L2CAP_FLOW_CONTROL_MODE             = 1,
+    OI_L2CAP_RETRANSMISSION_MODE           = 2,
+    OI_L2CAP_ENHANCED_RETRANSMISSION_MODE  = 3,
+    OI_L2CAP_STREAMING_MODE                = 4
+} OI_L2CAP_MODE;
+
+
+/**
+ * The L2CAP extended feature mask is a logical OR of the features bits defined below. The
+ * extended feature mask was originally defined in the Bluetooth specification.
+ *
+ * The extended feature mask is one of the stack configuration parameters defined in
+ * the OI_CONFIG_L2CAP structure in oi_bt_stack_config.h
+ */
+#define OI_L2CAP_FEATURE_VALID_BITS             (0x000003FF)
+
+#define OI_L2CAP_FEATURE_FLOW_CONTROL_MODE                     OI_BIT0
+#define OI_L2CAP_FEATURE_RETRANSMISSION_MODE                   OI_BIT1
+#define OI_L2CAP_FEATURE_BI_DIRECTIONAL_QOS                    OI_BIT2
+#define OI_L2CAP_FEATURE_ENHANCED_RETRANSMISSION_MODE          OI_BIT3
+#define OI_L2CAP_FEATURE_STREAMING_MODE                        OI_BIT4
+#define OI_L2CAP_FEATURE_FCS_OPTION                            OI_BIT5
+#define OI_L2CAP_FEATURE_EXTENDED_FLOW_SPEC                    OI_BIT6
+#define OI_L2CAP_FEATURE_FIXED_CHANNELS                        OI_BIT7
+#define OI_L2CAP_FEATURE_EXTENDED_WINDOW_SIZE                  OI_BIT8
+#define OI_L2CAP_FEATURE_UNICAST_CONNECTIONLESS_DATA_RECEPTION OI_BIT9
+
+/**
+ * FCS option values
+ */
+#define OI_L2CAP_FCS_NONE       0   /** No FCS check requested */
+#define OI_L2CAP_FCS_DEFAULT    1   /** Use the 16 bit FCS defined in section 3.3.5 of the L2CAP spec */
+
+/**
+ *  Info type requests for use in OI_L2CAP_InfoReq()
+ */
+#define OI_L2CAP_INFO_TYPE_CONNECTIONLESS_MTU         1
+#define OI_L2CAP_INFO_TYPE_EXTENDED_FEATURE_MASK      2
+#define OI_L2CAP_INFO_TYPE_FIXED_CHANNELS             3
+
+/**
+ * L2CAP Fixed channels.
+ * Fixed channels (CIDs) exist in the reserved range 0x03-0x3f.
+ * The OI_L2CAP_INFO_TYPE_FIXED_CHANNELS_MASK infoType is used to
+ * communicate which fixed (reserved) channels are in use.
+ */
+#define OI_L2CAP_NULL_CID                   0
+#define OI_L2CAP_SIGNALLING_CID             1
+#define OI_L2CAP_CONNECTIONLESS_CID         2
+#define OI_AMP_SIGNALING_CID                3
+#define OI_ATTRIBUTE_PROTOCOL_CID           4
+#define OI_AMP_TEST_MGR_CID              0x3f
+
+/**
+ * Enumeration type for flow control parameter used in OI_L2CAP_Flow()
+ */
+typedef enum {
+    OI_L2CAP_FLOW_ON,   /**< Turn flow on - allow packets to be sent to the upper layer */
+    OI_L2CAP_FLOW_OFF,  /**< Turn flow off - prevent packets from being sent to the upper layer */
+    OI_L2CAP_FLOW_RNR   /**< Immediately send an RNR to stop remote peer from sending data */
+} OI_L2CAP_FLOW_CONTROL;
+
+
+/**
+ * The service type values for the serviceType field of an extended flow specification.
+ */
+#define OI_L2CAP_SERVICE_TYPE_NO_TRAFFIC    0x00
+#define OI_L2CAP_SERVICE_TYPE_BEST_EFFORT   0x01
+#define OI_L2CAP_SERVICE_TYPE_GUARANTEED    0x02
+
+
+#define OI_L2CAP_FLAGS_NONE                             0
+
+/*
+ * If set, the L2CAP write is permitted to complete synchronously without calling the callback
+ * function. Completion means queued internally, it does not mean received by the remote device.
+ */
+#define OI_L2CAP_FLAGS_ALLOW_SYNCHRONOUS_COMPLETION   BIT0
+
+/*
+ * If set, indicates to L2CAP that the upper layer needs a quick write confirmation. In ERTM mode,
+ * L2CAP may choose to accelerate the acknowledgement of the packet by sending a poll packet or copy
+ * the packet and queue it internally. This is a no-op in BASIC and STREAMING mode.
+ *
+ * Note that care must be taken when using this flag:
+ *
+ * - This flag may cause L2CAP to make a copy of the data passed to OI_L2CAP_QueueMBUF().
+ * - The accelerated write confirm callbacks may happen before callbacks for earlier writes to the
+ *   same L2CAP channel that were not accelerated. Applications using this function should not
+ *   depend on the ordering of write confirm callbacks in this case.
+ */
+#define OI_L2CAP_FLAGS_ACCELERATE_WRITE_CFM           BIT1
+
+
+/**
+ * An extended flow specification is used for requesting a desired Quality of Service (QoS) on a
+ * channel. The flow specifications specify parameters for outgoing traffic.
+ */
+typedef struct {
+    OI_UINT8 identifier;            /**< Used internally by L2CAP, should be initialized to zero */
+    OI_UINT8 serviceType;           /**< Identifies the service type for the flow spec */
+    OI_UINT16 maximumSduSize;
+    OI_UINT32 sduInterArrivalTime;  /**< This value is specified in microseconds */
+    OI_UINT32 accessLatency;        /**< This value is specified in microseconds */
+    OI_UINT32 flushTimeout;         /**< This value is specified in microseconds */
+} OI_L2CAP_EXTENDED_FLOW_SPEC;
+
+
+/**
+ * A structure of this type is passed as an argument to OI_L2CAP_Connect() or OI_L2CAP_Accept() and
+ * carries the connection and configuration parameters used when creating or accepting a connection.
+ */
+typedef struct {
+
+    /**
+     * Maximum transmission unit (MTU): greatest acceptable size for incoming data packets (SDUs)
+     * in bytes (sec 5.1 of BT spec v2.0+EDR vol 3 part A).  Because of buffer size limitations, it
+     * may be advantageous to use the value returned by OI_L2CAP_MaxSupportedMTU if the largest
+     * possible buffer size is required.
+     */
+    OI_UINT16 inMTU;
+
+    /**
+     * Flush timeout: number of milliseconds to wait before an L2CAP packet that can not be
+     * acknowledged at the physical layer is dropped (sec 5.2 of BT spec v2.0+EDR vol 3 part A)
+     */
+    OI_UINT16 outFlushTO;
+
+    /**
+     * Link supervision timeout: number of milliseconds to wait before terminating an unresponsive
+     * link
+     */
+    OI_UINT16 linkTO;
+
+    /**
+     * Mode that is preferred or required for this link.
+     */
+    OI_L2CAP_MODE mode;
+
+    /**
+     * If TRUE, the requested mode is mandatory for this connection, otherwise other modes are
+     * acceptable for this connection. If FALSE and mode == OI_L2CAP_BASIC_MODE this is
+     * treated as "don't care" and the mode from the global configuration parameters is used.
+     */
+    OI_BOOL modeMandatory;
+
+    /**
+     * Configuration parameters for ENHANCED RETRANSMISSSION and STREAMING mode. This value must be
+     * in the range 1..16383. Window size values > 63 indicate a request to use Extended Control Fields.
+     * For ENHANCED RETRANSMISSSION mode the actual window size is negotiated and may be lower than
+     * the configured value. For STREAMING mode, the value is used solely as a request to use
+     * Extended Control Fields.
+     */
+    OI_UINT16 txWindowSize;  /**< Maximum local tx window size */
+
+    /**
+     * Configuration parameters for ENHANCED RETRANSMISSSION mode only, This value is ignored
+     * and should be zero for BASIC and STREAMING mode.
+     */
+    OI_UINT8 maxTransmit;    /**< Maximum number of retransmit attempts */
+
+    /**
+     * Configuration parameters for ENHANCED RETRANSMISSSION or STREAMING mode, These values are ignored
+     * and should be zero for BASIC and STREAMING mode.
+     */
+    OI_UINT16 mps;          /**< Maximum PDU payload size */
+    OI_UINT8 fcsOption;     /**< Frame Check Sequence option, currently this is either OI_L2CAP_FCS_NONE or OI_L2CAP_FCS_DEFAULT */
+
+    OI_AMP_ID ampId;        /**< AMP controller ID, or 0 for the BR/EDR controller */
+
+    /*
+     * An extended flow spec of NULL if none is provided. Note that the extended flow spec overrides
+     * the flush timeout.
+     */
+    OI_L2CAP_EXTENDED_FLOW_SPEC *extFlowSpec;
+
+} OI_L2CAP_CONNECT_PARAMS;
+
+
+/*
+ * ************ MTU constants ************
+ */
+
+
+/**
+ * The L2CAP specification requires that the
+ *  maximum transmission unit (MTU) for an L2CAP connection be at least 48.
+ */
+
+#define OI_L2CAP_MTU_MIN           48
+
+/**
+ * The default maximum transmission unit (MTU) for an L2CAP connection
+ */
+#define OI_L2CAP_MTU_DEFAULT       672
+
+/**
+ * The largest possible value for a maximum transmission unit (MTU) for a BASIC mode L2CAP
+ * connection as defined by the Bluetooth specification. This value should only be used by
+ * applications that know that the L2CAP channel will be configured for BASIC mode.
+ */
+#define OI_L2CAP_MTU_MAX           65535
+
+
+/**
+ * In ENHANCED_RETRANSMISSION and STREAMING modes, additional header fields and an optional FCS
+ * reduce the maximum number of payload bytes. The following value is the maximum number of payload
+ * bytes that can be assumed by an application that has no knowledge about the L2CAP channel mode or
+ * if the connection uses AMP (Alternative MAC/PHY)
+ */
+#define OI_L2CAP_SDU_SAFE_MAX       65527
+
+
+
+/*
+ * ************* Flush timeout constants ************
+ */
+
+
+/**
+ * This flush timeout value indicates to the L2CAP layer that the caller does not care
+ * what the flush timeout is. The flush timeout will be whatever it was previously.
+ */
+#define OI_L2CAP_FLUSHTO_DONT_CARE      0x0000
+
+/**
+ * This flush timeout value indicates that the L2CAP layer should perform no retransmissions.
+ * This value represents a number of milliseconds but, since 1 millisecond is smaller than a
+ * baseband timeslot pair, the interpretation is that no retransmissions will occur.
+ */
+#define OI_L2CAP_FLUSHTO_NO_RETRANSMIT  0x0001
+
+
+/**
+ * This flush timeout value indicates that the L2CAP layer should perform retransmissions until
+ * the link timeout terminates the channel. This is referred to as 'reliable channel'. Note that
+ * this is the default value.
+ */
+#define OI_L2CAP_FLUSHTO_INFINITE       0xFFFF
+
+
+/**
+ * The L2CAP APIs specify the flush timeout in milliseconds; this value is the maximum flush timeout
+ * expressed as milliseconds.  This is computed from the following formula  0x7FF * 0.625ms where
+ * 0x7FF is the maximum value allowed by the underlying Write Automatic Flush Timeout HCI command
+ * (expressed as Bluetooth ticks, tick = 0.625ms).
+ */
+#define OI_L2CAP_FLUSHTO_MAX            1279
+
+
+/**
+ * ************** Link timeout constants ***********************
+ */
+
+
+/**
+ * This is a special value to indicate to the L2CAP layer that the caller does not care what
+ * the link supervision timeout is. The link supervision timeout will be whatever it was previously.
+ */
+#define OI_L2CAP_LINKTO_DONT_CARE       0xffff
+
+/**
+ * This is a special value to indicate that no link supervision timeout should be set.
+ */
+#define OI_L2CAP_LINKTO_INFINITE        0xfffe
+
+/**
+ * The L2CAP APIs specify the link supervision timeout in milliseconds; this value is the maximum
+ * link supervision timeout expressed as milliseconds. This is computed from the following formula
+ * 0xFFFF * 0.625ms where 0xFFFF is the maximum value allowed by the underlying Write Link
+ * Supervision Timeout HCI command (expressed as Bluetooth ticks, tick = 0.625ms).
+ * time).
+ */
+#define OI_L2CAP_LINKTO_MAX            40959
+
+
+
+/******************************************************************************
+
+  indication callback function type definitions
+
+ ******************************************************************************/
+
+/**
+ * A callback function of this type indicates that a connection request has been received from a remote device.
+ * This request should be responded to by calling OI_L2CAP_Accept().
+ *
+ * @param psm             Specifies the protocol/service multiplexer of the protocol or service requesting the connection
+ * @param addr            Pointer to the Bluetooth device address of the remote device
+ * @param localAmpId      ID of local AMP device receiving the connection attempt or 0 for BR/EDR
+ * @param cid             Channel identifier (CID) of the connection
+ */
+typedef void (*OI_L2CAP_CONNECT_IND)(OI_L2CAP_PSM psm,
+                                     OI_BD_ADDR *addr,
+                                     OI_AMP_ID localAmpId,
+                                     OI_L2CAP_CID cid);
+
+/**
+ * A callback function of this type informs a higher layer of the success or failure of a
+ * call to OI_L2CAP_MoveChannel().
+ *
+ * @param cid     Channel ID affected by the move operation.
+ * @param ampId   New local AMP ID for the L2CAP channel.
+ * @param result  Indicates success or failure of the move operation.
+ */
+typedef void (*OI_L2CAP_MOVE_CFM)(OI_L2CAP_CID cid,
+                                  OI_AMP_ID localAmpId,
+                                  OI_STATUS result);
+
+/**
+ * A callback function of this type indicates an incoming request to move an existing L2CAP channel
+ * has been received. The implementation of OI_L2CAP_MOVE_IND should call OI_L2CAP_AcceptMoveChannel()
+ * to allow (or disallow) the move operation and to establish a move complete callback.
+ *
+ * @param cid             Channel identifier (CID) of the connection
+ * @param addr            Pointer to the Bluetooth device address of the remote device
+ * @param currentAmpId    ID of the local AMP device currently (before move) associated with channel.
+ * @param finalAmpId      ID of the local AMP device that will be associated with channel if move is successful.
+ */
+typedef void (*OI_L2CAP_MOVE_IND)(OI_L2CAP_CID cid,
+                                  const OI_BD_ADDR *addr,
+                                  OI_AMP_ID currentAmpId,
+                                  OI_AMP_ID finalAmpId);
+
+/**
+ * A callback function of this type indicates that the QoS agreement between the
+ * local device and a remote device has been violated. This indication does not require a response.
+ * Since quality of service management is not supported in the present BLUEmagic 3.0 software implementation
+ * of L2CAP, this callback function will never be called.
+ *
+ * @param addr            Pointer to the address of the remote Bluetooth device
+ */
+typedef void (*OI_L2CAP_QOS_VIOLATION_IND)(OI_BD_ADDR *addr);
+
+
+typedef enum {
+    OI_L2CAP_RECV_OK,           /**< Packet was received successfully */
+    OI_L2CAP_RECV_INCOMPLETE,   /**< In STREAMING mode: packet was incomplete */
+    OI_L2CAP_RECV_CORRUPT,      /**< In STREAMING mode: packet was corrupt */
+    OI_L2CAP_RECV_PKT_DISCARDED /**< In STREAMING mode: packet was received but discarded */
+} OI_L2CAP_RECV_STATUS;
+
+
+/**
+ * A callback function of this type indicates that data was received on the specified connection.
+ *
+ * @param cid            Channel identifier for the channel on which data was received
+ * @param buf            Pointer to buffer holding the received data
+ * @param length         Number of bytes received in the buffer
+ * @param recvStatus     Indicates the status of the received packet
+ */
+typedef void(*OI_L2CAP_RECV_DATA_IND)(OI_L2CAP_CID cid,
+                                      OI_UINT8 *buf,
+                                      OI_UINT16 length,
+                                      OI_L2CAP_RECV_STATUS recvStatus);
+
+/**
+ * A callback function of this type indicates that the specified connection was disconnected.
+ *
+ * @param cid            Specifies the local channel identifier for the connection being disconnected
+ * @param reason         Specifies the reason for the disconnection
+ */
+typedef void (*OI_L2CAP_DISCONNECT_IND)(OI_L2CAP_CID cid,
+                                        OI_STATUS reason);
+
+/******************************************************************************
+
+  confirmation callback function type definitions
+
+ ******************************************************************************/
+
+/**
+ * A callback function of this type informs a higher program layer of the success or failure of an
+ * OI_L2CAP_Connect() or OI_L2CAP_Accept() command. A status of OI_OK
+ * indicates that a connection corresponding to the specified CID has been created and configured
+ * and is therefore in the open state. A callback function of this type will also be
+ * called if a reconfiguration of the connection takes place. The fields inMTU and outMTU
+ * carry the parameters for maximum transmission unit (MTU) for incoming data and outgoing data.
+ *
+ * @param cid         Local channel identifier for the connection being created
+ * @param result      Success or failure status code for the connection request
+ * @param inMTU       MTU for incoming packets
+ * @param outMTU      MTU for outgoing packets
+ */
+typedef void(*OI_L2CAP_CONNECT_COMPLETE_CALLBACK)(OI_L2CAP_CID cid,
+                                                  OI_UINT16 inMTU,
+                                                  OI_UINT16 outMTU,
+                                                  OI_STATUS result);
+
+/**
+ * A callback function of this type informs a higher program layer that L2CAP no longer needs access
+ * to the data buffer and report the success or failure of an earlier call to OI_L2CAP_Write().
+ *
+ * @param cid        Local channel identifier for the connection to which the data is to be written
+ * @param buf        Pointer to the buffer from which data was written
+ * @param sendCount  Number of bytes written from the send buffer
+ * @param result     Success or failure status code for the write command
+ */
+typedef void(*OI_L2CAP_DATA_WRITE_CFM)(OI_L2CAP_CID cid,
+                                       OI_UINT8 *buf,
+                                       OI_UINT16 sendCount,
+                                       OI_STATUS result);
+
+
+/**
+ * A callback function of this type informs a higher program layer that L2CAP no longer needs access
+ * to the data buffer and report the success or failure of an earlier call to OI_L2CAP_QueueWrite().
+ *
+ * @param cid        Local channel identifier for the connection to which the data is to be written
+ * @param buf        Pointer to the buffer from which data was written
+ * @param sendCount  Number of bytes written from the send buffer
+ * @param queueFull  Returns TRUE if the queue is full, FALSE if the queue is not full. If the queue
+ *                   is not full, another write can be queued by calling OI_L2CAP_QueueWrite().
+ * @param result     Success or failure status code for the write command
+ */
+typedef void(*OI_L2CAP_DATA_QUEUE_WRITE_CFM)(OI_L2CAP_CID cid,
+                                             OI_UINT8 *buf,
+                                             OI_UINT16 sendCount,
+                                             OI_BOOL queueFull,
+                                             OI_STATUS result);
+
+/**
+ * A callback function of this type informs a higher program layer of the results of
+ * a call to OI_L2CAP_EchoReq().
+ *
+ * @param addr        Bluetooth device address for the responding device
+ * @param context     Context pointer provided by the caller of the echo function
+ * @param sentData    Pointer to the data buffer provided by the caller of the echo request function
+ * @param sentLength  Number of bytes passed by the caller or the echo request function
+ * @param echoData    Pointer to the buffer holding data returned by the responding device
+ * @param echoLength  Number of bytes of data returned by the responding device
+ * @param result      Success or failure status code for the echo command
+ */
+typedef void(*OI_L2CAP_ECHO_RSP)(const OI_BD_ADDR *addr,
+                                 void *context,
+                                 OI_UINT8 *sentData,
+                                 OI_UINT16 sendLength,
+                                 OI_UINT8  *echoData,
+                                 OI_UINT16 echoLength,
+                                 OI_STATUS result);
+
+/**
+ * A callback function of this type informs a higher program layer of the success or failure of
+ * a call to OI_L2CAP_InfoReq().
+ *
+ * @param addr       Address of device to receive the information request
+ * @param context    Opaque user-defined context
+ * @param infoType   Specifies the type of data requested
+ * @param infoData   Pointer to the buffer holding response data returned by the remote device
+ * @param size       Number of bytes of information response data
+ * @param result     Success or failure status code for the information request
+ */
+typedef void(*OI_L2CAP_INFO_RSP)(const OI_BD_ADDR *addr,
+                                 void             *context,
+                                 OI_UINT16         infoType,
+                                 OI_UINT8         *infoData,
+                                 OI_UINT16         size,
+                                 OI_STATUS         result);
+
+
+/****************************************************************
+
+  Functions
+
+ *****************************************************************/
+
+/**
+ * This function registers a client protocol or service PSM (protocol/service multiplexer)
+ * and callback functions with the L2CAP layer. This allows the L2CAP layer to
+ * notify the protocol or service when remote hosts attempt to connect to it. If this particular
+ * protocol or service will not respond to incoming connection requests, then registration is unnecessary.
+ *
+ * @param psm            Specifies the PSM (Protocol/Service Multiplexer) of the client protocol or service
+ * @param connectInd     Callback used to notify the application of incoming connections
+ * @param moveInd        Callback used to notify the application of incoming requests to move a channel
+ *
+ * @return               Status of registration request: OI_OK, if successful; failure code otherwise
+ */
+OI_STATUS OI_L2CAP_Register(OI_L2CAP_PSM psm,
+                            OI_L2CAP_CONNECT_IND connectInd,
+                            OI_L2CAP_MOVE_IND moveInd);
+
+/**
+ * This function deregisters a protocol registered on a specified PSM.
+ *
+ * @param psm  Specifies the PSM to deregister
+ */
+OI_STATUS OI_L2CAP_Deregister(OI_L2CAP_PSM psm);
+
+/**
+ * This function obtains a dynamically allocated PSM (Protocol/Service Multiplexer) for
+ * an application that does not have a static PSM. Once a PSM has been allocated, the
+ * application should call OI_L2CAP_Register() to register the newly allocated PSM.
+ *
+ * @param psm            Pointer to a PSM to hold the newly allocated PSM
+ */
+OI_STATUS OI_L2CAP_AllocPSM(OI_L2CAP_PSM *psm);
+
+
+/**
+ * This function returns the PSM for a given L2CAP channel.
+ *
+ * @param cid  Specifies the L2CAP channel from which to obtain the PSM
+ *
+ * @return  The PSM for the channel or 0 if the channel ID is invalid.
+ */
+OI_L2CAP_PSM OI_L2CAP_GetPSM(OI_L2CAP_CID cid);
+
+
+/**
+ * This function requests that a connection be created and configured. The cid parameter is a pointer
+ * to a location where the channel identifier for the connection will be written once the
+ * OI_L2CAP_CONNECT_COMPLETE_CALLBACK callback function is called with a success status code, confirming
+ * that the connection has been successfully created. Configuration of the channel will be negotiated
+ * with the remote device. If the remote device agrees, then the configuration parameters used will be
+ * those specified by the connectSpec parameter; a null connectSpec pointer specifies the default configuration
+ * values. If the remote device does not agree with the configuration parameters specified, then
+ * the parameters requested by the remote side will be used.
+ *
+ * @param confirmCB       Callback function to be called with the result of this connection request
+ * @param disconnectInd   Callback function to indicate that the connection created by this request was disconnected
+ * @param recvDataInd     Callback function to indicate that data was received on the connection created by this request
+ * @param targetPSM       PSM (Protocol/Service Multiplexer) of the remote protocol to which to connect
+ * @param addr            Pointer to the Bluetooth device address of the remote device to which to connect
+ * @param params          Pointer to the structure containing the configuration parameters requested by the
+ *                        local device for this connection; a NULL value for this pointer indicates that the
+ *                        default values are to be used.
+ * @param cid             [out] Pointer to where the connection's channel identifier will be written once the connection
+ *                        has been created
+ * @param policy          Pointer to the connection policy required on this connection, which will be managed
+ *                        and enforced by the Policy Manager.  This parameter must not be NULL.
+ *
+ * @return                Status of connection request: OI_OK, if successful; failure code otherwise
+ */
+OI_STATUS OI_L2CAP_Connect(OI_L2CAP_CONNECT_COMPLETE_CALLBACK confirmCB,
+                           OI_L2CAP_DISCONNECT_IND disconnectInd,
+                           OI_L2CAP_RECV_DATA_IND recvDataInd,
+                           OI_L2CAP_PSM targetPSM,
+                           OI_BD_ADDR *addr,
+                           const OI_L2CAP_CONNECT_PARAMS *params,
+                           OI_L2CAP_CID *cid,
+                           const OI_CONNECT_POLICY *policy);
+
+/**
+ * This function is used to respond to a connection request, indicating that the connection should be
+ * established and configured without further client interaction. This function should be called
+ * in response to an OI_L2CAP_CONNECT_IND indication callback. The OI_L2CAP_CONNECT_COMPLETE_CALLBACK callback
+ * function will be called when establishment and configuration of the accepted connection are complete.
+ *
+ * @param confirmCB      Callback function to be called with the result of the attempt to establish and configure
+ *                       the connection; may be NULL if the response parameter does not indicate success
+ * @param disconnectInd  Callback function to indicate that the connection created by this request was disconnected
+ * @param recvDataInd    Callback function to indicate that data was received on the connection created by this request
+ * @param cid            Specifies the local channel identifier for the connection created by this request
+ * @param connectSpec    Pointer to the structure containing the configuration parameters requested by the
+ *                       local device for this connection; a NULL value for this pointer indicates that the
+ *                       default values are to be used.
+ * @param accept         TRUE to accept the connection, FALSE to reject
+ * @param policy         Pointer to the connection policy required on this connection
+ *                       which will be managed and enforced by the Policy Manager
+ *
+ * @return               Status of connection acceptance request: OI_OK, if successful; failure code otherwise
+ */
+OI_STATUS OI_L2CAP_Accept(OI_L2CAP_CONNECT_COMPLETE_CALLBACK confirmCB,
+                          OI_L2CAP_DISCONNECT_IND disconnectInd,
+                          OI_L2CAP_RECV_DATA_IND recvDataInd,
+                          OI_L2CAP_CID cid,
+                          const OI_L2CAP_CONNECT_PARAMS *connectSpec,
+                          OI_BOOL accept,
+                          const OI_CONNECT_POLICY *policy);
+
+
+/**
+ * This function allows the caller to provide a receive buffer for a specific L2CAP channel. Received data will be
+ * reassembled directly into this buffer rather than using L2CAP's internal reassembly buffer. For
+ * some applications this can avoid memory to memory copies. The buffer must be large enough for the
+ * L2CAP MTU for this channel. Note that L2CAP "owns" the buffer passed in until another buffer is
+ * set or is set to NULL.
+ *
+ * @param cid         Identifies the L2CAP channel on which to set a receive buffer
+ *
+ * @param buffer      Pointer to the receive buffer or NULL to revert to using the internal L2CAP
+ *                    buffer.
+ *
+ * @param bufLen      Specifies the size of the buffer being passed in.
+ *
+ * @param prevBuffer  Returns the buffer set by the previous call to this function, or NULL if there
+ *                    was no previous buffer.
+ *
+ * @return
+ *               - OI_OK on success
+ *               - OI_STATUS_INVALID_STATE if not called from within a receive indication callback
+ *               - OI_STATUS_BUFFER_TOO_SMALL if the bufLen is less than the L2CAP MTU
+ *               - Or other error status codes.
+ */
+OI_STATUS OI_L2CAP_SetReceiveBuffer(OI_L2CAP_CID cid,
+                                    OI_BYTE *buffer,
+                                    OI_UINT16 bufLen,
+                                    OI_BYTE **prevBuffer);
+
+
+/**
+ * This function gets a pointer to the buffer previously set on an L2CAP channel by a call to
+ * OI_L2CAP_SetReceiveBuffer().
+ *
+ * @param cid   Identifies the L2CAP channel for which to get the receive buffer.
+ *
+ * @return      Pointer to the receive buffer, or NULL if no buffer has been set on this
+ *              channel or if the cid is invalid.
+ */
+OI_BYTE* OI_L2CAP_GetReceiveBuffer(OI_L2CAP_CID cid);
+
+
+/**
+ * This function returns the connection mode for a given L2CAP connection. Since the mode requested
+ * in a connection may not be supported by the remote device, a profile or application can call this
+ * API to determine the mode that is actually configured.
+ * `
+ * @param cid            Local channel identifier for the connection being queried
+ * @param mode           Pointer value returned by this function
+ *
+ * @return               OI_OK or an error status if the connection id is invalid.
+ */
+OI_STATUS OI_L2CAP_GetMode(OI_L2CAP_CID cid,
+                           OI_L2CAP_MODE *mode);
+
+
+/**
+ * This function is called to determine if a specific L2CAP connection mode is supported by the local
+ * device.
+ *
+ * @param mode  Specifies the mode to query for support.
+ *
+ * @return TRUE if the mode is supported, FALSE if it is not.
+ */
+OI_BOOL OI_L2CAP_IsModeSupported(OI_L2CAP_MODE mode);
+
+
+/**
+ * This function returns the SDU and MPS sizes for the given L2CAP connection. In Basic mode, the SDU
+ * and MPS will be the same size. In Enhanced Retransmission mode and Streaming mode, the application
+ * may want to write data in packets in the largest whole number multiple of the MPS size that fits
+ * within the SDU size.
+ * `
+ * @param cid            Local channel identifier for the connection being queried
+ * @param mtu            Pointer to MTU value returned by this function
+ * @param mps            Pointer to MPS value returned by this function
+ *
+ * @return               OI_OK or an error status if the connection id is invalid.
+ */
+OI_STATUS OI_L2CAP_GetTxSizes(OI_L2CAP_CID cid,
+                              OI_UINT16 *mtu,
+                              OI_UINT16 *mps);
+
+
+/**
+ * This function commands the termination of a connection associated with a particular channel identifier.
+ * The disconnect callback function passed to OI_L2CAP_Accept() or OI_L2CAP_Connect() will be called when the
+ * disconnection is complete.
+ *
+ * @param  cid       Specifies the local channel identifier (CID) of the connection to terminate
+ */
+OI_STATUS OI_L2CAP_Disconnect(OI_L2CAP_CID cid);
+
+
+/**
+ * This function calls for data to be written from the output buffer associated with a particular connection.
+ *
+ * Once this function has been called to write data to a particular connection (CID), it must not be
+ * called again to write to that same connection until a callback of type OI_L2CAP_DATA_WRITE_CFM
+ * has been received for that connection, confirming that L2CAP has finished writing from the output
+ * buffer and no longer needs access to it. Calling this function twice with the same CID parameter
+ * without an intervening OI_L2CAP_DATA_WRITE_CFM confirmation for that CID will result in an error
+ * return status and the data will not be written.
+ *
+ * Concurrent writes to different channels are always permitted, since each channel has its own output buffer.
+ *
+ * @param callback       Callback to be called for confirmation that the data has been written to the connection
+ *                       from the output buffer
+ *
+ * @param cid            Local channel identifier (CID) of the connection to which to write
+ *
+ * @param outBuffer      Pointer to the output buffer containing the data to be written
+ *
+ * @param length         Number of bytes to write from the buffer
+ *
+ * @return               - OI_OK if the packet has been accepted by L2CAP
+ *
+ *                       - OI_STATUS_WRITE_IN_PROGRESS indicates that the write failed becauses of a
+ *                         write in progress. Caller can retry the write after the write confirm callback.
+ *
+ *                       - Other status codes indicating that the write failed.
+ */
+OI_STATUS OI_L2CAP_Write(OI_L2CAP_DATA_WRITE_CFM callback,
+                         OI_L2CAP_CID cid,
+                         OI_UINT8 *outBuffer,
+                         OI_UINT16 length);
+
+
+
+/**
+ * This function calls for queued data to be written from the output buffer associated with a particular connection.
+ *
+ * In BASIC and STREAMING mode, only one packet can be queued at a time on a given L2CAP channel, in
+ * ENHANCED_RETRANSMISSION mode, multiple packets can be queued up to the limit of internal memory.
+ * The status code indicates if the packed was successfully queued. Packets will be sent in the
+ * order in which they are queued and the callback functions will be called in the order in which
+ * the packets are sent. After the callback function has been called the queue may no longer be
+ * full in which case another call to OI_L2CAP_QueueWrite() is permitted.
+ *
+ * Concurrent writes to different channels are always permitted, since each channel has its own queue.
+ *
+ * @param callback       Callback to be called for confirmation that the data has been written to
+ *                       the connection from the output buffer. The callback function is not called
+ *                       if the OI_L2CAP_FLAGS_ALLOW_SYNCRONOUS_COMPLETION flags is set and return
+ *                       status is OI_STATUS_SEND_COMPLETE.
+ *
+ * @param cid            Local channel identifier (CID) of the connection to which to write
+ *
+ * @param outBuffer      Pointer to the output buffer containing the data to be written
+ *
+ * @param length         Number of bytes to write from the buffer
+ *
+ * @param writeFlags     OI_L2CAP_FLAGS_NONE or a logical OR of the following flags:
+ *                       - OI_L2CAP_FLAGS_ALLOW_SYNCRONOUS_COMPLETION
+ *                       - OI_L2CAP_FLAGS_ACCELERATE_WRITE_CFM
+ *
+ * @param queueFull      Pointer to a boolean value to return the queue status. Returns TRUE if the
+ *                       queue is full or FALSE if another packet can be queued.
+ *
+ * @return               - OI_OK if the packet has been succesfully queued with L2CAP
+ *
+ *                       - OI_STATUS_SEND_COMPLETE if the OI_L2CAP_FLAGS_ALLOW_SYNCRONOUS_COMPLETION
+ *                         flag was set and the data has been sent or queued in an internal buffer.
+ *
+ *                       - OI_STATUS_WRITE_IN_PROGRESS indicates that the write failed becauses the
+ *                         queue was full. Caller can retry the write after a write confirm callback indicates
+ *                         that the queue is no longer full.
+ *
+ *                       - Other status codes indicating that the write failed.
+ */
+OI_STATUS OI_L2CAP_QueueWrite(OI_L2CAP_DATA_QUEUE_WRITE_CFM callback,
+                              OI_L2CAP_CID cid,
+                              OI_UINT8 *outBuffer,
+                              OI_UINT16 length,
+                              OI_UINT8 writeFlags,
+                              OI_BOOL *queueFull);
+
+/**
+ * This functions determines if a call to L2CAP_QueueWrite will succeed.
+ *
+ * @param cid            Local channel identifier (CID) of the connection to check.
+ *
+ * @return               - OI_OK if the packet can be written.
+ *
+ *                       - OI_STATUS_WRITE_IN_PROGRESS indicates that the write will fail becauses
+ *                         there is a write in progress on this channel.
+ *
+ *                       - Other status codes indicating that the write will fail.
+ */
+OI_STATUS OI_L2CAP_CanWrite(OI_L2CAP_CID cid);
+
+/**
+ * This function sends an L2CAP echo request to the remote device.
+ *
+ * @param callback        Callback function to be called for confirmation that the echo has succeeded
+ * @param context         Callers context will be returned in the callback function
+ * @param bdaddr          Bluetooth device to which to send the echo request
+ * @param echoData        Pointer to the buffer containing the (optional) echo data to send
+ * @param length          Length of echoData in bytes
+ */
+OI_STATUS OI_L2CAP_EchoReq(OI_L2CAP_ECHO_RSP   callback,
+                           void                *context,
+                           const OI_BD_ADDR    *addr,
+                           OI_UINT8            *echoData,
+                           OI_UINT16           dataLen);
+
+/**
+ * This function performs an L2CAP information request.
+ *
+ * @param callback        Callback function to be called when the request has completed
+ * @param context         Callers context will be returned in the callback function
+ * @param bdaddr          Bluetooth device to which to send the information request
+ * @param infoType        Type of information to get, valid types are defined in the Bluetooth specification.
+ */
+OI_STATUS OI_L2CAP_InfoReq(OI_L2CAP_INFO_RSP    callback,
+                           void                *context,
+                           const OI_BD_ADDR    *addr,
+                           OI_UINT16            infoType);
+
+
+/**
+ * This function enables or disables packet flow when in any mode other than BASIC mode. If the
+ * channel ID is for a channel configured for BASIC mode, this function will return an error status
+ * code. In ERTM mode after flow has been turned off (control == OI_L2CAP_FLOW_OFF), L2CAP will stop
+ * delivering data to the upper layer on the specified channel but flow-off does not necessarily
+ * cause the L2CAP layer to send an RNR to the remote peer. Use the OI_L2CAP_FLOW_RNR value to force
+ * L2CAP to send an RNR immediately.
+ *
+ * @param cid             Local channel identifier to set flow on
+ * @param control         Enables or disables flow on the channel
+ */
+OI_STATUS OI_L2CAP_Flow(OI_L2CAP_CID          cid,
+                        OI_L2CAP_FLOW_CONTROL control);
+
+
+/**
+ * This function associates an upper layer context with an L2CAP connection. Call
+ * OI_L2CAP_GetContext() to retrieve the context. If the context is not NULL and
+ * a context is already set, this function returns an error status.
+ *
+ * @param cid       Specifies the local channel identifier (CID) on which to set the context
+ * @param context   Pointer to an upper layer context to set
+ *
+ * @return          OI_OK or an error status if the connection ID is invalid.
+ */
+OI_STATUS OI_L2CAP_SetContext(OI_L2CAP_CID cid,
+                              void *context);
+
+
+/**
+ * This function returns an upper layer context associated with an L2CAP connection. Call
+ * OI_L2CAP_SetContext() to set a context.
+ *
+ * @param cid       Specifies the local channel identifier (CID) on which to set the context
+ * @param context   Pointer variable to return upper layer context pointer
+ *
+ * @return          OI_OK or an error status if the connection id is invalid.
+ */
+OI_STATUS OI_L2CAP_GetContext(OI_L2CAP_CID cid,
+                              void **context);
+
+
+/**
+ * Get the remote BDAddr associated with a channel ID.
+ *
+ * @param cid       Specifies the local channel identifier.
+ * @return          Remote BD address associated with connection oriented cid or NULL if no such channel.
+ */
+const OI_BD_ADDR * OI_L2CAP_GetBDAddr(OI_L2CAP_CID cid);
+
+
+/**
+ * This function returns the maximum value of the MTU currently be supported by L2CAP. This is
+ * a compile time configuration parameter.
+ */
+OI_UINT16 OI_L2CAP_MaxSupportedMTU(void);
+
+
+/**
+ * This function requests that an L2CAP channel be created and associated with a given
+ * fixed channel ID.  This function completes synchronously (i.e., does not call the
+ * connect confirm callback) if the underlying ACL connection is already up and running.
+ * If the ACL link is not established before calling this function, then the confirmCB
+ * will be called once the ACL link is established and the fixed channel is created.
+ *
+ * This "sometimes synchronous" behavior is needed because OI_L2CAP_OpenFixedChannel is
+ * called to create a "just-in-time" fixed channel when an incoming fixed channel packet is
+ * received from a new remote addr. In this case, L2CAP has already reconstucted the packet
+ * and is trying to process it. There is no opportunity to wait for callback in this case.
+ * And, in fact, there is no reason to wait for one since all channel creation operations
+ * other than ACL establishment can occur synchronously.
+ *
+ * Unlike dynamic L2CAP channels created with OI_L2CAP_Connect and OI_L2CAP_Accept, there is no
+ * negociated configuration, PSM or Policy Management.
+ *
+ * @param confirmCB       Callback function called with the result of this connection request if
+ *                        operation will complete asynchronously (return status equals OI_STATUS_PENDING).
+ * @param disconnectInd   Callback function to indicate that the connection created by this request was disconnected
+ * @param recvInd         Callback function to indicate that data was received on the connection created by this request
+ * @param addr            Pointer to the Bluetooth device address of the remote device to which to connect
+ * @param fixedCid        Channel identifier (as viewed from the network) for the new L2CAP channel.
+ * @param params          Pointer to the structure containing the configuration parameters. A NULL value for this
+ *                        pointer indicates that the default values are to be used.
+ * @param cid             [out] Pointer to where the connection's channel handle will be written once the
+ *                        connection has been created. This param is valid if the return status is OI_OK or
+ *                        OI_STATUS_PENDING.
+ *
+ * @return                OI_OK if connection attempt was successful and function returned synchronously.
+ *                        OI_STATUS_PENDING if operation will be completed asynchronously. In this case,
+ *                        confirmCB will be called.
+ */
+OI_STATUS OI_L2CAP_OpenFixedChannel(OI_L2CAP_CONNECT_COMPLETE_CALLBACK    confirmCB,
+                                    OI_L2CAP_DISCONNECT_IND               disconnectInd,
+                                    OI_L2CAP_RECV_DATA_IND                recvInd,
+                                    const OI_BD_ADDR                     *addr,
+                                    OI_UINT16                             fixedCid,
+                                    const OI_L2CAP_CONNECT_PARAMS        *params,
+                                    OI_L2CAP_CID                         *cid);
+
+/**
+ * Close a fixed channel connection.
+ * This function should only be used with channels created with OI_L2CAP_OpenFixedChannel
+ *
+ * @param cid   L2CAP channel handle to be closed
+ */
+OI_STATUS OI_L2CAP_CloseFixedChannel(OI_L2CAP_CID cid);
+
+
+/**
+ * Move an existing L2CAP channel to another AMP/BR-EDR controller.
+ *
+ * @param moveCompleteCB    Callback called when move is completed (successfully or unsuccessfully)
+ * @param localCID          L2CAP channel ID of channel to be moved
+ * @param remoteAmpID       ID of the remote AMP device to where the channel should be moved
+ * @return OI_OK if successful
+ */
+OI_STATUS OI_L2CAP_MoveChannel(OI_L2CAP_MOVE_CFM moveCompleteCB,
+                               OI_L2CAP_CID      localCID,
+                               OI_AMP_ID         remoteAmpId);
+
+
+/**
+ * Accept or reject an incoming attempt to move an existing logical channel.
+ * This function should only be called from within a registered implementation of
+ * OI_L2CAP_MOVE_IND.
+ *
+ * @param moveCompleteCB   Callback called upon successful or unsuccessful completion of move operation.
+ * @param cid              Channel ID involved in the move operation.
+ * @param allowMove        TRUE if move attempt should be allowed. FALSE otherwise.
+ */
+OI_STATUS OI_L2CAP_AcceptMoveChannel(OI_L2CAP_MOVE_CFM moveCompleteCB,
+                                     OI_L2CAP_CID      cid,
+                                     OI_BOOL           allowMove);
+
+/**
+ * Given a local L2CAP CID as input, return the remote CID for the same
+ * channel.
+ *
+ * @param local   Local CID designation for a currently existing L2CAP channel
+ * @param remote  [OUT] Location to place remote L2CAP CID
+ *
+ * @return OI_OK  if channel exists
+ */
+OI_STATUS OI_L2CAP_GetRemoteCid(OI_L2CAP_CID      local,
+                                OI_L2CAP_CID     *remote);
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_L2CAP_H */
+
diff --git a/obex_profiles/sdk/include/oi_l2cap_prefs.h b/obex_profiles/sdk/include/oi_l2cap_prefs.h
new file mode 100644
index 0000000..93b8bc4
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_l2cap_prefs.h
@@ -0,0 +1,66 @@
+#ifndef _OI_L2CAP_PREFS_H
+#define _OI_L2CAP_PREFS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file defines L2CAP preferences.
+ *
+ The following are the L2CAP PSM number preferences for the various
+    profiles which register L2CAP servers. If the numbers are selected
+    appropriately, a given service using L2CAP will always be assigned the
+    same L2CAP PSM number.
+
+    @note: Numbers are restricted to range of 1-30.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define L2CAP_PREF_OPP_SRV         0x1003
+#define L2CAP_PREF_FTP_SRV         0x1005
+#define L2CAP_PREF_PBAP_SRV        0x1007
+#define L2CAP_PREF_MAP_SRV         0x1009
+#define L2CAP_PREF_MNS_SRV         0x100B
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_L2CAP_PREFS_H */
+
diff --git a/obex_profiles/sdk/include/oi_l2cap_qos.h b/obex_profiles/sdk/include/oi_l2cap_qos.h
new file mode 100644
index 0000000..f2adef9
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_l2cap_qos.h
@@ -0,0 +1,109 @@
+#ifndef _OI_L2CAP_QOS
+#define _OI_L2CAP_QOS
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ * This file contains values from the flow specification for guaranteed Quality of Service.
+ *
+ * Management of guaranteed quality of service at the L2CAP level is not supported
+ * in the present BLUEmagic 3.0 software implementation of L2CAP.
+ * This file contains some of the infrastructure for management of L2CAP guaranteed
+ * quality of service. The flow specification structures defined in this file do not
+ * presently have any functional effect at the L2CAP level. L2CAP management of
+ * guaranteed quality of service will be supported in a future version of BLUEmagic software.
+ */
+
+#include "oi_stddefs.h"
+
+/** \addtogroup L2CAP L2CAP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** This structure indicates the flow specification for an L2CAP
+ *  connection. */
+typedef struct _OI_L2CAP_FLOWSPEC {
+
+    /** level of service required */
+    OI_UINT8   serviceType;
+
+    /** rate at which traffic credits are granted in bytes/sec */
+    OI_UINT32   tokenRate;
+
+    /** size of the token bucket in bytes */
+    OI_UINT32   tokenBucketSize;
+
+    /** limit in bytes/second on how fast packets may be sent back-to-back from applications */
+    OI_UINT32   peakBandwidth;
+
+    /** maximum delay between tranmission by sender and tranmission over air, in microseconds */
+    OI_UINT32   latency;
+
+    /** difference between maximum and minimum delay that a packet will experience */
+    OI_UINT32   delayVariation;
+
+} OI_L2CAP_FLOWSPEC;
+
+#define OI_L2CAP_SERVICE_TYPE_NO_TRAFFIC   0x00                             /**< service type: no traffic  */
+#define OI_L2CAP_SERVICE_TYPE_BEST_EFFORT  0x01                             /**< service type: best effort  */
+#define OI_L2CAP_SERVICE_TYPE_GUARANTEED   0x02                             /**< service type: guaranteed  */
+#define OI_L2CAP_SERVICE_TYPE_DEFAULT      OI_L2CAP_SERVICE_TYPE_BEST_EFFORT   /**< The default service type is best effort.  */
+
+#define OI_L2CAP_TOKEN_RATE_NONE           0                                /**< No token rate is specified.  */
+#define OI_L2CAP_TOKEN_RATE_MAX            0xffffffff                       /**< Token rate is maximum available.  */
+#define OI_L2CAP_TOKEN_RATE_DEFAULT        OI_L2CAP_TOKEN_RATE_NONE            /**< The default is for no token rate to be specified.  */
+
+#define OI_L2CAP_TOKEN_BUCKET_NONE         0                                /**< No token bucket is needed.  */
+#define OI_L2CAP_TOKEN_BUCKET_MAX          0xffffffff                       /**< Token bucket is maximum available.  */
+#define OI_L2CAP_TOKEN_BUCKET_DEFAULT      OI_L2CAP_TOKEN_BUCKET_NONE          /**< The default is for no token rate to be specified.  */
+
+#define OI_L2CAP_PEAK_BANDWIDTH_UNKNOWN    0                                /**< Maximum bandwidth is unknown. */
+#define OI_L2CAP_PEAK_BANDWIDTH_DEFAULT    OI_L2CAP_PEAK_BANDWIDTH_UNKNOWN     /**< The default is for the maximum bandwidth setting to indicate that maximum bandwidth is unknown. */
+
+#define OI_L2CAP_LATENCY_DONT_CARE         0xffffffff                       /**< The application does not care about latency. */
+#define OI_L2CAP_LATENCY_DEFAULT           OI_L2CAP_LATENCY_DONT_CARE          /**< The default is for the latency setting to indicate that the application does not care about latency. */
+
+#define OI_L2CAP_DELAY_VARIATION_DONT_CARE 0xffffffff                       /**< The application does not care about delay variation. */
+#define OI_L2CAP_DELAY_VARIATION_DEFAULT   OI_L2CAP_DELAY_VARIATION_DONT_CARE  /**< The default is for the delay variation setting to indicate that the application does not care about delay variation. */
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_L2CAP_QOS */
+
diff --git a/obex_profiles/sdk/include/oi_list.h b/obex_profiles/sdk/include/oi_list.h
new file mode 100644
index 0000000..0a39e57
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_list.h
@@ -0,0 +1,116 @@
+#ifndef _OI_LIST_H
+#define _OI_LIST_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ @file
+@internal
+
+ Doubly-linked list interface. A linked list consists of a dummy
+ header OI_LIST_ELEM and an OI_LIST_ELEM for each actual element in
+ the list.
+*/
+
+#include "oi_stddefs.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct OI_LIST_ELEM {
+    struct OI_LIST_ELEM *next;
+    struct OI_LIST_ELEM *prev;
+} OI_LIST_ELEM;
+
+/** Initialize a list */
+#define OI_LIST_INIT(x) { &(x), &(x) }
+
+/** Compile-time init */
+#define OI_LIST(x) OI_LIST_ELEM x = OI_LIST_INIT(x)
+
+/**
+ * Obtain a pointer to the structure containing a given list element.
+ *
+ * @param elem  The list element.
+ * @param type  The type of the containing structure.
+ * @param field  The name of the list field in the containing structure.
+ */
+#define OI_LIST_ENTRY(elem, type, field) \
+  ((type *) (((OI_CHAR *) elem) - OI_OFFSETOF(type, field)))
+
+/** Iterate through a list.
+ *
+ * @param pos   The loop variable (OI_LIST_ELEM *).
+ * @param list  The list (OI_LIST_ELEM *).
+ */
+#define OI_LIST_FOREACH(pos, list) for( (pos) = (list)->next; (pos) != (list); (pos) = (pos)->next )
+
+/** Initialize a list at runtime. */
+void OI_List_DynamicInit(OI_LIST_ELEM *list);
+
+/** Add the new element to the front of the list specified by list. */
+void OI_List_Add(OI_LIST_ELEM *newElem, OI_LIST_ELEM *list);
+
+/** Add the new element to the tail of the list specified by list. */
+void OI_List_AddTail(OI_LIST_ELEM *newElem, OI_LIST_ELEM *list);
+
+/**
+ * Delete the specified elem from its list.
+ *
+ * @return  The element before the elem that was deleted.
+ */
+OI_LIST_ELEM* OI_List_Del(OI_LIST_ELEM *elem);
+
+
+/** Remove and return the first element in the list. */
+OI_LIST_ELEM *OI_List_RemoveHead(OI_LIST_ELEM *list);
+
+
+/**
+ * Returns a count of the number of elements in the list
+ */
+OI_UINT OI_List_CountElements(OI_LIST_ELEM *list);
+
+
+/** Test whether a list is empty.
+OI_BOOL OI_List_IsEmpty(OI_LIST_ELEM *head)
+*/
+#define OI_List_IsEmpty(head) ((head)->next == (head))
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/obex_profiles/sdk/include/oi_mbuf.h b/obex_profiles/sdk/include/oi_mbuf.h
new file mode 100644
index 0000000..5bc380e
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_mbuf.h
@@ -0,0 +1,586 @@
+#ifndef _OI_MBUF_H
+#define _OI_MBUF_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+ This module implements a non-linear buffering scheme called "mbufs"
+ that allows data to be passed down the stack layers without requiring
+ data copying at each layer. With an mbuf, a data packet is stored in
+ multiple buffers rather than in a single contiguous data buffer. As
+ each stack layer proceses data from the higher layers, data can be
+ segmented and packetized without the need to actually copy any of the
+ data. This improves performance by eliminating memory-to-memory
+ copying and reduces total memory usage by elminating the need for
+ each stack layer to allocate buffers to accomodate payloads passed in
+ from the upper layers.
+
+ Each contiguous "chunk" of data (or nested mbuf) associated with an
+ mbuf occupies one cell within the mbuf. The maximum number of cells
+ that an mbuf may contain must be specified when the mbuf is
+ created. Mbufs that are allocated off of the heap using
+ OI_MBUF_Alloc() can be initialized to contain any number of
+ cells. Stack variables, globals and other non-heap allocated mbuf
+ instances initialized with OI_MBUF_Init() may contain no more than
+ DEFAULT_MBUF_CELLS cells.
+
+ An Mbuf producer (an entity that creates an mbuf) fills the mbuf with
+ data and/or data references using OI_MBUF_Append(), OI_MBUF_Prepend()
+ and OI_MBUF_AppendMbuf(). Depending on the size of the data and the
+ disposition (OI_MBUF_DISPOSITION) specified, the data pointer passed
+ to OI_MBUF_Append() or OI_MBUF_Prepend() is either dereferenced and
+ copied to heap-allocated or internal mbuf storage (OI_COPY) or the
+ pointer is stored directly in the mbuf without copying (OI_KEEP or OI_FREE).
+
+ Mbufs may be nested to allow appending/prepending of mbuf data without
+ requiring the original mbuf to have unused cells. The current mbuf
+ implementation does not manage the life-cycle of nested mbufs. This
+ means that external logic must ensure that nested mbufs are
+ freed once the containing (outer) mbuf is no longer in use.
+
+ Consumers of Mbuf data do not need to be aware of the existence of
+ cell boundaries within mbufs. Consumers access the contents of mbufs
+ by calling OI_MBUF_PullBytes() and/or OI_MBUF_PeekBytes().
+
+ MBuf provides a "windowing" feature that allows a producer to limit
+ the region of the mbuf that is exposed to consumers. This is useful
+ when you want to pass only a portion of a packet to some other entity
+ for further processing. From the consumer's point of view, the
+ windowed mbuf appears to be a normal mbuf that contains only a subset
+ of the original mbuf's data. OI_MBUF_SetWindow(),
+ OI_MBUF_SetWindowAt() and OI_MBUF_AdvanceWindow() are used to
+ manipulate windows. When nesting mbufs, all windowing information is
+ contained within the outermost mbuf. This allows for multiple
+ simultaneous windows over the same mbuf data by creating one or more
+ "outer" mbufs that all wrap the same "inner" mbuf data.
+*/
+
+#include "oi_stddefs.h"
+#include "oi_debug.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef OI_DEBUG
+
+/**
+ * OI_MBUF_DISPOSITION indicates how the ownership of data associated with
+ * an mbuf's cell will be managed.
+ */
+typedef enum {
+    MBUF_COPY   = 0,  /**< Data buffer is to be copied by mbuf into mbuf managed storage.
+                         Mbuf will manage the freeing of the copied data if needed. */
+
+    MBUF_FREE   = 1,  /**< Data buffer will be freed by mbuf when mbuf is freed, Data
+                         must have been allocated wit OI_Malloc()*/
+
+    MBUF_KEEP   = 2,  /**< Data buffer's life-time will be managed outside of mbuf.
+                         Caller is responsible for ensuring the data remains valid
+                         until mbuf is no longer in use. */
+
+    MBUF_INLINE = 3,  /**< Internal use only. Data is inline in the mbuf and cannot
+                         be freed. User cannot designate this disposition directly.
+                         It is automatically chosen if the user selectes MBUF_COPY
+                         and the size of the data fits within the cell structure. */
+
+    MBUF_NESTED = 4   /**< Cell is a nested mbuf and cannot be freed. Mbuf implementation
+                         is not responsible for managing the life-time of nested mbufs.
+                         User is responsible for externally managing the life-time
+                         of nested mbufs. */
+
+} OI_MBUF_DISPOSITION;
+
+#else
+
+#define   MBUF_COPY    0
+#define   MBUF_FREE    1
+#define   MBUF_KEEP    2
+#define   MBUF_INLINE  3
+#define   MBUF_NESTED  4
+
+typedef OI_UINT8 OI_MBUF_DISPOSITION;
+
+#endif
+
+
+struct _OI_MBUF;
+
+
+typedef struct {
+    OI_UINT16 winStart;    /** window start offset at time mbuf was nested */
+    struct _OI_MBUF *mbuf; /** the nested mbuf */
+} OI_NESTED_MBUF;
+
+
+/**
+ *
+ */
+#define MBUF_INLINE_BUF_SIZE  8
+
+
+/**
+ * Type definition for an mbuf cell. An mbuf cell has a pointer to a buffer and
+ * a length.
+ */
+typedef struct {
+    OI_MBUF_DISPOSITION disposition;
+    OI_UINT16 len;
+    union {
+        const OI_BYTE *ptr;
+        OI_BYTE data[MBUF_INLINE_BUF_SIZE];
+        OI_NESTED_MBUF mcell;
+    } buf;
+} OI_MBUF_CELL;
+
+
+#define DEFAULT_MBUF_CELLS    4
+
+/**
+ * Defines for casting function pointers to generic function pointers
+ */
+typedef void (*_F_PTR)(void);
+#define MBUF_CONTEXT_FUNC(x) ((_F_PTR)x)
+
+/**
+ * Type definition for an mbuf.
+ */
+
+typedef struct _OI_MBUF {
+    OI_UINT8 allocCells;                    /*< Number of cells allocated in this mbuf */
+    OI_UINT8 currCell;                      /*< Current cell position for pull operations */
+    OI_UINT8 usedCells;                     /*< Cells currently in use */
+    OI_UINT16 numBytes;                     /*< Current number of bytes in all cells */
+    OI_UINT16 currPos;                      /*< Current byte position in current cell for pull operations */
+
+    OI_UINT16 winStart;                     /*< Current byte offset of window from start of MBUF */
+    OI_UINT16 winSize;                      /*< Size of current window (0 means not windowed) */
+
+    union {
+        void     *v;                        /*< generic pointer value */
+        OI_INT32  i;                        /*< generic signed value */
+        OI_UINT32 u;                        /*< generic unsigned value */
+        _F_PTR    f;                        /*< generic function pointer */
+    } context;                              /*< context union data for users of mbuf */
+
+    OI_MBUF_CELL cells[DEFAULT_MBUF_CELLS]; /*< mbuf cells reference packet data */
+} OI_MBUF;
+
+
+/**
+ * An MBUF is clean if no bytes have been pulled from the MBUF. Otherwise is it dirty.
+ *
+ * The only operations that can be performed on a dirty MBUF are:
+ *
+ * OI_MBUF_PullBytes()
+ * OI_MBUF_Clear()
+ * OI_MBUF_NumBytes()
+ * OI_MBUF_NumContigBytes()
+ * OI_MBUF_PeekBytes()
+ * OI_MBUF_Unwrap()
+ *
+ * Use OI_MBUF_Clear() restore nested MBUFs to a clean (un-pulled) state.
+ */
+#define OI_MBUF_IS_DIRTY(mbuf)   (((mbuf)->currCell != 0) || ((mbuf)->currPos != 0))
+
+
+/**
+ * Initializes a non-heap allocated mbuf. The caller is responsible for ensuring that the mbuf is
+ * big enough to hold the number of cells specificed in the numCells parameter. The caller should
+ * call OI_MBUF_Clear() when finished with this MBUF.
+ *
+ * @param  mbuf  A pointer to an unitialized mbuf. This can be a pointer to an
+ *               mbuf allocated as an automatic variable.
+ *
+ * @param numCells  The number of cells in the mbuf. This must less than
+ *                  DEFAULT_MBUF_CELLS.
+ */
+
+OI_STATUS OI_MBUF_Init(OI_MBUF *mbuf,
+                       OI_UINT8 numCells);
+
+
+
+/**
+ * Allocate and initialize an mbuf sized to accomodate the requested number of cells. The caller
+ * should call OI_MBUF_Free() when finished with this MBUF.
+ *
+ * @param numCells the number of cells the mbuf can hold.
+ *
+ * @returns A pointer to a dynmically allocted mbuf or NULL if the mbuf could
+ *          not be allocated.
+ */
+
+OI_MBUF* OI_MBUF_Alloc(OI_UINT8 numCells);
+
+
+/**
+ * Helper function that wraps a buffer in an mbuf. Allocates a one cell mbuf initializes it to
+ * reference a buffer. The mbuf must be freed by calling OI_MBUF_Free().
+ *
+ * @param  data  A data buffer to initialize the mbuf with.
+ *
+ * @param  len   The size of the data buffer.
+ *
+ * @param  disposition Specifies what mbuf should do with the data buffer when
+  *                    the mbuf is freed.
+ *
+ * @return a pointer to a dynamically allocated mbuf and initialized mbuf
+ *         or NULL if the mbuf could not be allocated.
+ */
+
+OI_MBUF* OI_MBUF_Wrap(const OI_BYTE *data,
+                      OI_UINT16 len,
+                      OI_MBUF_DISPOSITION disposition);
+
+
+/**
+ * Counterpart to OI_MBUF_Wrap() - removes and frees the MBUF created by OI_MBUF_Wrap() and returns
+ * a pointer to the original data and len. Can only be used on MBUFs that were wrapped using the
+ * disposition MBUF_KEEP.
+ *
+ * @param  mbuf   Mbuf to unwrap
+ *
+ * @param  data   Returned pointer to data wrapped by mbuf.
+ *
+ * @param  len    Returned length of data wrapped by mbuf.
+ */
+void OI_MBUF_Unwrap(OI_MBUF *mbuf,
+                    OI_BYTE **data,
+                    OI_UINT16 *len);
+
+/**
+ * Free an mbuf and any data that is not flagged to be kept.
+ *
+ * @param mbuf a pointer to a dynamically allocated mbuf.
+ *
+ * @return  The number of bytes that the MBUF used to contain.
+ */
+OI_UINT16 OI_MBUF_Free(OI_MBUF *mbuf);
+
+
+/**
+ * Add a cell to the front of an mbuf. This function will typically be used to
+ * add a packet header to a payload passed from a higher layer. Prepend is only
+ * allowed on a clean mbuf, that is an mbuf that has not had data pulled from
+ * it.
+ *
+ * @param mbuf a pointer to an initialized mbuf.
+ *
+ * @param buf a pointer to a data buffer.
+ *
+ * @param len the length of the data buffer.
+ *
+ * @param disposition specifies what mbuf should do with the data buffer. There
+ * are three possibilities:
+ *
+ * - MBUF_COPY indicates that mbuf must copy the buffer. Use this if the
+ *   data buffer is an automatic variable. Mbuf will free any allocated memory
+ *   when the mbuf itself is freed.
+ *
+ * - MBUF_FREE indicates that mbuf that caller want mbuf to eventually free
+ *   the buffer. Obviously the buffer must not also be freed by the caller.
+ *
+ * - MBUF_KEEP indicates that mbuf must not free or otherwise modify the
+ *   buffer.
+ *
+ * @return OI_OK is the buffer was succesfully added or
+ *         OI_STATUS_MBUF_OVERFLOW if there are no free cells in the mbuf.
+ */
+
+OI_STATUS OI_MBUF_Prepend(OI_MBUF* mbuf,
+                          const OI_BYTE* buf,
+                          OI_UINT16 len,
+                          OI_MBUF_DISPOSITION disposition);
+
+
+/**
+ * Add a cell to the end of an mbuf. This function will typically be used to add
+ * a packet trailer to a payload passed from a higher layer. Append is only
+ * allowed on a pristine mbuf, that is an mbuf that has not had data pulled from
+ * it.
+ *
+ * @param mbuf a pointer to an initialized mbuf.
+ *
+ * @param buf a pointer to a data buffer.
+ *
+ * @param len the length of the data buffer.
+ *
+ * @param disposition specifies what mbuf should do with the data buffer. There
+ * are three possibilities:
+ *
+ * - MBUF_COPY indicates that mbuf must copy the buffer. Use this if the data
+ *   buffer is an automatic variable. Mbuf will free any allocated memory when
+ *   the mbuf itself is freed.
+ *
+ * - MBUF_FREE indicates that mbuf that caller want mbuf to eventually free the
+ *   buffer. Obviously the buffer must not also be freed by the caller.
+ *
+ * - MBUF_KEEP indicates that mbuf must not free or otherwise modify the buffer.
+ *
+ * @return OI_OK is the buffer was succesfully added or
+ *         OI_STATUS_MBUF_OVERFLOW if there are no free cells in the mbuf.
+ */
+
+OI_STATUS OI_MBUF_Append(OI_MBUF* mbuf,
+                         const OI_BYTE* buf,
+                         OI_UINT16 len,
+                         OI_MBUF_DISPOSITION disposition);
+
+
+/**
+ * Add a cell to the end of an mbuf where the contents of the appended cell is an MBUF. Note that
+ * appended MBUFs must not be freed until the enclosing MBUF has been cleared by calling
+ * OI_MBUF_Clear() or freed by calling OI_MBUF_Free().
+ *
+ * @param mbuf     a pointer to an initialized mbuf.
+ *
+ * @param added    a pointer to an initialized mbuf.
+ *
+ * @return OI_OK is the buffer was succesfully added or
+ *         OI_STATUS_MBUF_OVERFLOW if there are no free cells in the mbuf.
+ */
+OI_STATUS OI_MBUF_AppendMbuf(OI_MBUF *mbuf,
+                             OI_MBUF *added);
+
+
+/**
+ * Returns the pointer to a nested MBUF.
+ *
+ * @param mbuf   Pointer to an mbuf that has a nested MBUF cell.
+ *
+ * @param index  Cell index that contains the nested MBUF
+ *
+ * @return  Pointer to the nested MBUF or NULL
+ */
+OI_MBUF* OI_MBUF_GetNestedMbuf(OI_MBUF *mbuf,
+                               OI_UINT8 index);
+
+
+/**
+ * Copies bytes from an mbuf info a contiguous buffer. The data in the source
+ * mbuf is not modified by this operation but the state of the source mbuf is
+ * updated to reflect the data that has been pulled. Sucessive pulls will
+ * advance the internal state as if the data pulled were removed from the source
+ * mbuf. Pulling bytes from an MBUF dirties the MBUF and any nested MBUFs.
+ *
+ * @param dest a pointer to a buffer at least numBytes long.
+ *
+ * @param src is a pointer to a segmented memory buffer.
+ *
+ * @param numBytes is the maximum number of bytes to be pulled from the mbuf.
+ *
+ * @returns  The number of bytes pulled.
+ */
+
+OI_UINT16 OI_MBUF_PullBytes(OI_BYTE *dest,
+                            OI_MBUF *src,
+                            OI_UINT16 numBytes);
+
+/**
+ * Returns a pointer into the mbuf's data at a specified offset. Peeking bytes
+ * does not dirty the mbuf.
+ *
+ * @param src         Pointer to a segmented memory buffer.
+ *
+ * @param offset      Byte offset into mbuf.
+ *
+ * @param contigLen   Number of contiguous bytes that can be obtained from returned pointer.
+ *
+ * @returns  Pointer to data at requested offset or NULL if offset is past the end of mbuf.
+ */
+const OI_BYTE * OI_MBUF_PeekBytes(OI_MBUF *src,
+                                  OI_UINT16 offset,
+                                  OI_UINT16 *contigLen);
+
+/**
+ * Returns the aggregate number of bytes in the cells of an mbuf.
+ *
+ * @param mb is a pointer to an mbuf
+ *
+ */
+#ifdef OI_DEBUG
+OI_UINT16 OI_MBUF_NumBytes(OI_MBUF *mb);
+#else
+#define OI_MBUF_NumBytes(mb) ((mb)->numBytes)
+#endif
+
+/**
+ * Projects a "window" on an mbuf defined by a length. A window sets the internal state on an mbuf
+ * so that the calls to pull data from the mbuf will pull data from the range defined by the window.
+ * If the window start position + the window length is beyond the actual end of the mbuf, the length
+ * is set to its maximum possible value. If the start position is beyond the end of the mbuf the
+ * window will be empty. After a window has been set, OI_MBUF_NumBytes() will return the size of the
+ * window. The window can be advanced by calling OI_MBUF_AdvanceWindow().
+ *
+ * @param mbuf A pointer to an mbuf.
+ *
+ * @param  winSize   The size of the window.
+ *
+ * @returns  The actual window size, which may be smaller than the window size
+ *           specified if there are fewer than winSize bytes in the mbuf.
+ */
+OI_UINT16 OI_MBUF_SetWindow(OI_MBUF *mbuf,
+                            OI_UINT16 winSize);
+
+
+/**
+ * Projects a "window" on an mbuf defined by an offset and a length. A window sets the internal
+ * state on an mbuf so that the calls to pull data from the mbuf will pull data from the range
+ * defined by the window.  If the window start position + the window length is beyond the actual end
+ * of the mbuf, the length is set to its maximum possible value. If the start position is beyond the
+ * end of the mbuf the window will be empty. After a window has been set, OI_MBUF_NumBytes() will
+ * return the size of the window. The window can be advanced by calling OI_MBUF_AdvanceWindow().
+ *
+ * @param mbuf      A pointer to an mbuf.
+ *
+ * @param winStart  Offset from the start of the MBUF for the window
+ *
+ * @param winSize   The size of the window.
+ *
+ * @returns  The actual window size, which may be smaller than the window size
+ *           specified if there are fewer than winStart + winSize bytes in the
+ *           mbuf.
+ */
+OI_UINT16 OI_MBUF_SetWindowAt(OI_MBUF *mbuf,
+                              OI_UINT16 winStart,
+                              OI_UINT16 winSize);
+
+
+/**
+ * This function projects a new window on an mbuf that starts where the previous window ended.
+ * Prior to this call, OI_MBUF_SetWindow() must have been called to set an initial window. To
+ * segment a packet into fixed-size frames, repeatedly call this function until it returns 0.
+ *
+ * Note that the all of the data from the previous window must have been pulled before the window
+ * can be advanced. That is, OI_MBUF_NumBytes() must return zero before OI_MBUF_AdvanceWindow()
+ *
+ * @param mbuf     the mbuf
+ * @param winSize  the size of the new window
+ *
+ * @returns  The actual window size, which may be smaller than the window size
+ *           specified if there are fewer than winSize bytes between the current
+ *           position and the end of the mbuf.
+ */
+OI_UINT16 OI_MBUF_AdvanceWindow(OI_MBUF *mbuf,
+                                OI_UINT16 winSize);
+
+
+
+/**
+ * Frees up resources allocated for the cells of an MBUF and restores any nesteds MBUFs to a clean
+ * state. Doesn not free the MBUF itself.
+ *
+ * @param mbuf     Pointer to the mbuf to clear
+ *
+ * @return  The number of bytes that the MBUF used to contain.
+ */
+OI_UINT16 OI_MBUF_Clear(OI_MBUF *mbuf);
+
+
+/**
+ * Compute a Frame Check Sequence over an MBUF, the MBUF is not modified by this operation. This FCS
+ * is commonally know as CRC-16 and is used principally for L2CAP enhanced modes.
+ *
+ * @param mbuf        Pointer to an mbuf
+ *
+ * @param numBytes    The number of bytes to run the FCS over. Use OI_UINT16_MAX to run over the
+ *                    entire mbuf.
+ *
+ * @patam runningFCS  Pointer to variable holding the running FCS. Initialize to zero to start
+ *                    computing the FCS.
+ *
+ * @return   The number of bytes FCS was computed over.
+ */
+OI_UINT16 OI_MBUF_ComputeFCS(const OI_MBUF *mbuf,
+                             OI_UINT16 numBytes,
+                             OI_UINT16 *runningFCS);
+
+
+/**
+ * Returns the maximum cell capacity of an mbuf.
+ */
+#define OI_MBUF_NumAllocCells(mb) ((OI_UINT8) (((mb) == NULL) ? 0 : (mb)->allocCells))
+
+
+/**
+ * Returns the number of avaiable cells in an mbuf.
+ */
+#define OI_MBUF_NumFreeCells(mb) ((OI_UINT8) (((mb) == NULL) ? 0 : ((mb)->allocCells - ((mb)->usedCells))))
+
+
+/**
+ * Returns the number of used cells in an mbuf.
+ */
+#define OI_MBUF_NumUsedCells(mb) ((OI_UINT8) (((mb) == NULL) ? 0 : (mb)->usedCells))
+
+#ifdef OI_DEBUG
+
+/**
+ * Print out contents of an mbuf.
+ *
+ * @param mbuf     the mbuf to print
+ */
+void OI_MBUF_Print(OI_MBUF *mbuf);
+
+
+/**
+ * Dump the structure of an mbuf.
+ *
+ * @param mbuf     the mbuf to dump
+ * @param tag      a string to prefix to the dump info
+ */
+void OI_MBUF_Dump(OI_MBUF *mbuf,
+                  OI_CHAR *tag);
+
+#else
+
+#define OI_MBUF_Print(m)
+#define OI_MBUF_Dump(m, t)
+
+#endif /* OI_DEBUG */
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_MBUF_H */
+
diff --git a/obex_profiles/sdk/include/oi_modules.h b/obex_profiles/sdk/include/oi_modules.h
new file mode 100644
index 0000000..16042c4
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_modules.h
@@ -0,0 +1,117 @@
+#ifndef _OI_MODULES_H
+#define _OI_MODULES_H
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *
+   This file provides the enumeration type defining the
+   individual stack components.
+ *
+ */
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This enumeration lists constants for referencing the components of
+ * the BLUEmagic 3.0 protocol stack, profiles, and other functionalities.
+ *
+ * In order to distinguish types of modules, items are grouped with markers to
+ * delineate start and end of the groups
+ *
+ * The module type is used for various purposes:
+ *      identification in debug print statements
+ *      access to initialization flags
+ *      access to the configuration table
+ */
+
+typedef enum {
+    /* profiles and protocols  --> Updates to oi_debug.c and oi_config_table.c */
+
+    OI_MODULE_BIP_CLI,          /**< 0 Basic Imaging Profile protocol client */
+    OI_MODULE_BIP_SRV,          /**< 1 Basic Imaging Profile protocol server */
+    OI_MODULE_BPP_SENDER,       /**< 2 Basic Printing Profile */
+    OI_MODULE_BPP_PRINTER,      /**< 3 Basic Printing Profile */
+    OI_MODULE_FTP_CLI,          /**< 4 File Transfer Profile protocol client */
+    OI_MODULE_FTP_SRV,          /**< 5 File Transfer Profile protocol server */
+    OI_MODULE_OBEX_CLI,         /**< 6 OBEX protocol client, Generic Object Exchange Profile */
+    OI_MODULE_OBEX_SRV,         /**< 7 OBEX protocol server, Generic Object Exchange Profile */
+    OI_MODULE_OPP_CLI,          /**< 8 Object Push Profile protocol client */
+    OI_MODULE_OPP_SRV,          /**< 9 Object Push Profile protocol server */
+    OI_MODULE_PBAP_CLI,         /**< 10 Phonebook Access Profile client */
+    OI_MODULE_PBAP_SRV,         /**< 11 Phonebook Access Profile server */
+    OI_MODULE_MAP_CLI,          /**< 12 Message Access Profile client*/
+    OI_MODULE_MAP_SRV,          /**< 13 Message Access Profile server*/
+
+    OI_MODULE_COMMON_CONFIG,    /**< 14 Common configuration, module has no meaning other than for config struct */
+    OI_MODULE_DISPATCH,         /**< 15 Dispatcher */
+    OI_MODULE_DATAELEM,         /**< 16 Data Elements, marshaller */
+    OI_MODULE_MEMMGR,           /**< 17 modules that do memory management */
+    OI_MODULE_SUPPORT,          /**< 18 support functions, including CThru Dispatcher, time functions, and stack initialization */
+    // OEM files --> Updates to oi_debug.c
+    OI_MODULE_OEM,              /**< 19 Application Memory allocation */
+
+    /* various pieces of code depend on these last 2 elements occuring in a specific order:
+       OI_MODULE_ALL must be the 2nd to last element
+       OI_MODULE_UNKNOWN must be the last element
+       */
+    OI_MODULE_ALL,              /**< 20 special value identifying all modules - used for control of debug print statements */
+    OI_MODULE_UNKNOWN           /**< 21 special value - used for debug print statements */
+} OI_MODULE;
+
+/**
+ * This constant is the number of actual modules in the list.  ALL and UNKNOWN are
+ * special values that are not actually modules.
+ * Used for debug print and memmgr profiling
+ */
+#define OI_NUM_MODULES  OI_MODULE_ALL
+
+
+/**
+ * This constant is the number of profile and core components.  It is used to size
+ * the initialization and configuration tables.
+ */
+#define OI_NUM_STACK_MODULES    OI_MODULE_OEM
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_MODULES_H */
+
diff --git a/obex_profiles/sdk/include/oi_osinterface.h b/obex_profiles/sdk/include/oi_osinterface.h
new file mode 100644
index 0000000..24f9809
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_osinterface.h
@@ -0,0 +1,247 @@
+#ifndef _OI_OSINTERFACE_H
+#define _OI_OSINTERFACE_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ @file
+ * This file provides the platform-independent interface for functions for which
+ * implementation is platform-specific.
+ *
+ * The functions in this header file define the operating system or hardware
+ * services needed by the BLUEmagic 3.0 protocol stack. The
+ * actual implementation of these services is platform-dependent.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_time.h"
+#include "oi_status.h"
+#include "oi_modules.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Terminates execution.
+ *
+ * @param reason  Reason for termination
+ */
+void OI_FatalError(OI_STATUS reason);
+
+/**
+ * This function logs an error.
+ *
+ * When built for release mode, BLUEmagic 3 errors are logged to
+ * this function. (in debug mode, errors are logged via
+ * OI_Print()).
+ *
+ * @param module Module in which the error was detected (see
+ *                oi_modules.h)
+ * @param lineno Line number of the C file OI_SLOG_ERROR called
+ * @param status Status code associated with the error event
+ */
+void OI_LogError(OI_MODULE module, OI_INT lineno, OI_STATUS status);
+
+/**
+ * This function initializes the debug code handling.
+ *
+ * When built for debug mode, this function performs platform
+ * dependent initialization to handle message codes passed in
+ * via OI_SetMsgCode().
+ */
+void OI_InitDebugCodeHandler(void);
+
+
+/**
+ * This function reads the time from the real time clock.
+ *
+ * All timing in BM3 is relative, typically a granularity
+ * of 5 or 10 msecs is adequate.
+ *
+ * @param[out] now  Pointer to the buffer to which the current
+ *       time will be returned
+ */
+void OI_Time_Now(OI_TIME *now);
+
+/**
+ * This function causes the current thread to sleep for the
+ * specified amount of time. This function must be called
+ * without the stack access token.
+ *
+ * @note BM3 corestack and profiles never suspend and never call
+ * OI_Sleep. The use of OI_Sleep is limited to applications and
+ * platform-specific code.
+ *
+ * If your port and applications never use OI_Sleep, this function can be left unimplemented.
+ *
+ * @param milliseconds  Number of milliseconds to sleep
+ */
+void OI_Sleep(OI_UINT32 milliseconds);
+
+
+/**
+ * Defines for message type codes.
+ */
+#define OI_MSG_CODE_APPLICATION               0   /**< Application output */
+#define OI_MSG_CODE_ERROR                     1   /**< Error message output */
+#define OI_MSG_CODE_WARNING                   2   /**< Warning message output */
+#define OI_MSG_CODE_TRACE                     3   /**< User API function trace output */
+#define OI_MSG_CODE_PRINT1                    4   /**< Catagory 1 debug print output */
+#define OI_MSG_CODE_PRINT2                    5   /**< Catagory 2 debug print output */
+#define OI_MSG_CODE_HEADER                    6   /**< Error/Debug output header */
+
+/**
+ * This function is used to indicate the type of text being output with
+ * OI_Print(). For the Linux and Win32 platforms, it will set
+ * the color of the text. Other possible uses could be to insert
+ * HTML style tags, add some other message type indication, or
+ * be completely ignored altogether.
+ *
+ * @param code  OI_MSG_CODE_* indicating setting the message type.
+ */
+void OI_SetMsgCode(OI_UINT8 code);
+
+/**
+ * All output from OI_Printf() is sent to OI_Print.
+ * Typically, if the platform has a console, OI_Print() is sent to stdout.
+ * Embedded platforms typically send OI_Print() output to a serial port.
+ *
+ * @param str  String to print
+ */
+void OI_Print(OI_CHAR const *str);
+
+/**
+ * All BM3 debug output is sent to OI_PrintDebugOutput.  Typically, this
+ * output is simply passed to OI_Print.  On some targets, it is desirable to 
+ * filter debug output solely based on severity or verbosity in which case
+ * the implementation would check message level before passing output to 
+ * OI_Print.
+ *
+ * @param str       String to print
+ *
+ * @param msgType   Identifies message type (e.g. OI_MSG_CODE_ERROR or OI_MSG_CODE_PRINT1).
+ */
+void OI_PrintDebugOutput(OI_UINT8 msgType, OI_CHAR const *str);
+
+/** 
+ *  In cases where OI_Print() is sending output to a logfile in addition to console,
+ *  it is desirable to also put console input into the logfile.
+ *  This function can be called by the console input process.
+ * 
+ *  @note This is an optional API which is strictly
+ *  between the platform-specific stack_console and osinterface
+ *  modules. This API need only be implemented on those
+ *  platforms where is serves a useful purpose, e.g., win32.
+ *
+ * @param str  Console input string
+ */
+
+void OI_Print_ConsoleInput(OI_CHAR const *str);
+
+/**
+ *  This function computes the CRC16 of the program image.
+ */
+OI_UINT16  OI_ProgramImageCRC16(void);
+
+/**
+ * Writes an integer to stdout in hex. This macro is intended
+ * for selective use when debugging in small memory
+ * configurations or other times when it is not possible to use
+ * OI_DBGPRINT.
+ *
+ * @param n  Specifies the integer to print.
+ */
+
+#define OI_Print_Int(n) \
+{ \
+    static const OI_CHAR _digits[] = "0123456789ABCDEF"; \
+    OI_CHAR _buf[9]; \
+    OI_CHAR *_str = &_buf[8]; \
+    OI_UINT32 _i = n; \
+    *_str = 0; \
+    do { *(--_str) = _digits[(_i & 0xF)]; _i >>= 4; } while (_i); \
+    OI_Print(_str); \
+}
+
+/**
+ * Get the value of an environment variable from the execution environment.
+ *
+ * @param key    Name of environment variable to get
+ * @param value  Pointer at buffer to receive the environment variable value
+ * @param len    Length of buffer pointed to value
+ * @return       OI_OK if the value was found and was completely copied into buffer
+ */
+OI_STATUS OI_GetEnv(const OI_CHAR *key,
+                             OI_CHAR *value,
+                             OI_UINT len);
+
+
+/**
+ * Print the last system error. perror for POSIX enviroments
+ *
+ * @param str    String to prepend to output
+ */
+void OI_PrintLastError(const char *str);
+
+/**
+ * Get file size. stat in POSIX environments
+ *
+ * @param fileName    Full path of file
+ * @param fileSize    pointer at variable to return size
+ * @return       OI_OK on success
+ */
+OI_STATUS OI_GetFileSize(const char *fileName, OI_INT *fileSize);
+
+/**
+ *  Application Dynamic Memory allocation.
+ *
+ *  These APIs are provided for application use on those
+ *  platforms which have no dynamic memory support. Memory is
+ *  allocated from the pool-based heap managed by the stack's
+ *  internal memory manager.
+ */
+void *OI_APP_Malloc(OI_INT32 size);
+void OI_APP_Free(void *ptr);
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_OSINTERFACE_H */
+
diff --git a/obex_profiles/sdk/include/oi_rfcomm.h b/obex_profiles/sdk/include/oi_rfcomm.h
new file mode 100644
index 0000000..201fe2c
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_rfcomm.h
@@ -0,0 +1,856 @@
+#ifndef _OI_RFCOMM_H
+#define _OI_RFCOMM_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides the RFCOMM application programming interface (API).
+ *
+ * See the @ref RFCOMM_docpage section of the BLUEmagic 3.0 SDK documentation
+ * for more information.
+ */
+
+#include "oi_common.h"
+#include "oi_bt_stack_config.h"
+#include "oi_connect_policy.h"
+#include "oi_mbuf.h"
+#include "oi_l2cap.h"
+
+/** \addtogroup RFCOMM RFCOMM APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* RFCOMM frame size constants */
+#define OI_RFCOMM_FRAMESIZE_DEFAULT        127   /**< Default RFCOMM frame size in bytes */
+#define OI_RFCOMM_FRAMESIZE_MIN            23    /**< Minimum RFCOMM frame size in bytes */
+#define OI_RFCOMM_FRAMESIZE_MAX            32767 /**< Maximum RFCOMM frame size in bytes */
+
+/**
+ * The overhead per RFCOMM frame. These values do not include L2CAP enveloping
+ *
+ * Address field    1 byte
+ * Control field    1 byte
+ * Credit field     0 or 1 byte  (depends if credits are piggybacking on packet)
+ * Length field     1 or 2 bytes (1 byte if payload < 128, 2 bytes otherwise)
+ * FCS              1 byte
+ */
+#define OI_RFCOMM_MTU_PER_MAXFRAME(x) (((x) >= 128) ? ((x) + 6) : ((x) + 5))
+#define OI_RFCOMM_MAXFRAME_PER_MTU(x) (((x) <= (127 + 5)) ? ((x) - 5) : ((x) - 6))
+
+#define OI_RFCOMM_MIN_MTU_FRAMESIZE     OI_RFCOMM_MAXFRAME_PER_MTU(OI_L2CAP_MTU_MIN)
+
+/** Type definition for an RFCOMM link handle by which RFCOMM links are referenced. */
+typedef OI_HANDLE OI_RFCOMM_LINK_HANDLE;
+
+/**
+   This structure is used to carry
+   serial port parameters to be passed to the
+   OI_RFCOMM_SetPortParams() function
+ */
+typedef struct {
+
+    /** The bits set in this mask indicate which parameters are to be set. Bits
+     * set to zero indicate that the parameters in this structure associated
+     * with those bits are to be ignored. For example, a mask of 0x0001 in a
+     * call to OI_RFCOMM_SetPortParams() will result in the bit rate for the
+     * port being set to baudRate and every parameter other than baudRate being
+     * ignored. Instead of using 0x0001 as a mask, the more human-readable name
+     * OI_RFCOMM_MASK_BITRATE can be used. Default is OI_RFCOMM_MASK_ALL. */
+    OI_INT16    mask;
+
+    /** Bit rate; default: OI_RFCOMM_BAUDRATE_9600 */
+    OI_BYTE    baudRate;
+
+    /** Number of data bits; default: OI_RFCOMM_DATABIT_8 */
+    OI_BYTE    dataBits;
+
+    /** Number of stop bits; default: OI_RFCOMM_STOPBIT_1 */
+    OI_BYTE    stopBits;
+
+    /** Parity; default: OI_RFCOMM_NO_PARITY */
+    OI_BYTE    parity;
+
+    /** Type of parity; default: OI_RFCOMM_PARITY_ODD */
+    OI_BYTE    parityType;
+
+    /** Type of flow control; default: OI_RFCOMM_FLOW_NONE */
+    OI_BYTE    flowControlType;
+
+    /** Character to use for XON; default: 0x11 (DC1) */
+    OI_BYTE    XON_Char;
+
+    /** Character to use for XOFF; default: 0x13 (DC3) */
+    OI_BYTE    XOFF_Char;
+
+} OI_RFCOMM_PORTPARAM;
+
+/* OI_RFCOMM_PORTPARAM constant definitions */
+
+/**
+ * @name Mask bits
+ * These values are used for setting the mask parameter in OI_RFCOMM_PORTPARAM.
+ */
+/** @{ */
+#define OI_RFCOMM_MASK_OI_BITRATE     OI_BIT0        /**< Mask bit definition for setting the bit rate parameter. */
+#define OI_RFCOMM_MASK_DATA_OI_BITS   OI_BIT1        /**< Mask bit definition for setting the number of data bits parameter. */
+#define OI_RFCOMM_MASK_STOP_OI_BITS   OI_BIT2        /**< Mask bit definition for setting the number of stop bits parameter.  */
+#define OI_RFCOMM_MASK_PARITY      OI_BIT3        /**< Mask bit definition for setting the parity parameter.  */
+#define OI_RFCOMM_MASK_PARITYTYPE  OI_BIT4        /**< Mask bit definition for setting the parity type parameter.  */
+#define OI_RFCOMM_MASK_XON_CHAR    OI_BIT5        /**< Mask bit definition for setting the XON character parameter (RFCOMM v1.1 section 6) */
+#define OI_RFCOMM_MASK_XOFF_CHAR   OI_BIT6        /**< Mask bit definition for setting the XOFF character parameter (RFCOMM v1.1 section 6) */
+//          bit 7: reserved
+#define OI_RFCOMM_MASK_XON_INPUT   OI_BIT8        /**< Mask bit definition for setting the XON/XOFF flow control on input (RFCOMM v1.1 section 6) */
+#define OI_RFCOMM_MASK_XON_OUTPUT  OI_BIT9        /**< Mask bit definition for setting the XON/XOFF flow control on output (RFCOMM v1.1 section 6) */
+#define OI_RFCOMM_MASK_RTR_INPUT   OI_BIT10       /**< Mask bit definition for setting the RTR/RTS flow control on input (BRFCOMM v1.1 section 6) */
+#define OI_RFCOMM_MASK_RTR_OUTPUT  OI_BIT11       /**< Mask bit definition for setting the RTR/RTS flow control on output (RFCOMM v1.1 section 6) */
+#define OI_RFCOMM_MASK_RTC_INPUT   OI_BIT12       /**< Mask bit definition for setting the RTC/CTS flow control on input (RFCOMM v1.1 section 6) */
+#define OI_RFCOMM_MASK_RTC_OUTPUT  OI_BIT13       /**< Mask bit definition for setting the RTC/CTS flow control on output */
+#define OI_RFCOMM_MASK_ALL         ((OI_UINT16) ~(OI_BIT7 | OI_BIT14 | OI_BIT15))   /**< definition for mask that indicates that all parameters are to be set */
+/** @} */
+
+/** @name Bit rate */
+/** @{ */
+#define OI_RFCOMM_BAUDRATE_2400    0           /**< Definition for bit rate parameter setting, indicating 2,400 bits per second. */
+#define OI_RFCOMM_BAUDRATE_4800    1           /**< Definition for bit rate parameter setting, indicating 4,800 bits per second. */
+#define OI_RFCOMM_BAUDRATE_7200    2           /**< Definition for bit rate parameter setting, indicating 7,200 bits per second. */
+#define OI_RFCOMM_BAUDRATE_9600    3           /**< Definition for bit rate parameter setting, indicating 9,600 bits per second. */
+#define OI_RFCOMM_BAUDRATE_19200   4           /**< Definition for bit rate parameter setting, indicating 19,200 bits per second. */
+#define OI_RFCOMM_BAUDRATE_38400   5           /**< Definition for bit rate parameter setting, indicating 38,400 bits per second. */
+#define OI_RFCOMM_BAUDRATE_57600   6           /**< Definition for bit rate parameter setting, indicating 57,600 bits per second. */
+#define OI_RFCOMM_BAUDRATE_115200  7           /**< Definition for bit rate parameter setting, indicating 115,200 bits per second. */
+#define OI_RFCOMM_BAUDRATE_230400  8           /**< Definition for bit rate parameter setting, indicating 230,400 bits per second. */
+/** @} */
+
+/** @name Number of data bits */
+/** @{ */
+#define OI_RFCOMM_DATABIT_5    0                     /**< Definition for number of data bits, indicating 5 data bits. */
+#define OI_RFCOMM_DATAOI_BIT_6    OI_BIT1               /**< Definition for number of data bits, indicating 6 data bits. */
+#define OI_RFCOMM_DATAOI_BIT_7    OI_BIT0               /**< Definition for number of data bits, indicating 7 data bits. */
+#define OI_RFCOMM_DATAOI_BIT_8    ( OI_BIT0 | OI_BIT1 ) /**< Definition for number of data bits, indicating 8 data bits. */
+/** @} */
+
+/** @name Stop bits */
+/** @{ */
+#define OI_RFCOMM_STOPOI_BIT_1     0           /**< Definition for number of stop bits, indicating that 1 stop bit should be used. */
+#define OI_RFCOMM_STOPOI_BIT_1_5   OI_BIT2     /**< Definition for number of stop bits, indicating that 1.5 stop bits should be used. */
+/** @} */
+
+/** @name Parity */
+/** @{ */
+#define OI_RFCOMM_NO_PARITY     0           /**< Definition for parity setting, indicating that parity checking is disabled */
+#define OI_RFCOMM_PARITY        OI_BIT3     /**< Definition for parity setting, indicating that parity checking is enabled */
+/** @} */
+
+/** @name Parity type */
+/** @{ */
+#define OI_RFCOMM_PARITY_ODD    0                     /**< Definition for parity type, indicating that odd parity is used. */
+#define OI_RFCOMM_PARITY_EVEN   OI_BIT5               /**< Definition for parity type, indicating that even parity is used. */
+#define OI_RFCOMM_PARITY_MARK   OI_BIT4               /**< Definition for parity type, indicating that mark parity is used. */
+#define OI_RFCOMM_PARITY_SPACE  ( OI_BIT4 | OI_BIT5 ) /**< Definition for parity type, indicating that space parity is used. */
+/** @} */
+
+/** @name Flow control */
+/** @{ */
+#define OI_RFCOMM_FLOW_NONE        0           /**< Definition for flow control type, indicating that no flow control is used. */
+#define OI_RFCOMM_FLOW_XON_INPUT   OI_BIT0     /**< Definition for flow control type, indicating that XON/XOFF flow control is used on input. */
+#define OI_RFCOMM_FLOW_XON_OUTPUT  OI_BIT1     /**< Definition for flow control type, indicating that XON/XOFF flow control is used on output. */
+#define OI_RFCOMM_FLOW_RTR_INPUT   OI_BIT2     /**< Definition for flow control type, indicating that RTR/RTS flow control is used. */
+#define OI_RFCOMM_FLOW_RTR_OUTPUT  OI_BIT3     /**< Definition for flow control type, indicating that RTR/RTS flow control is used. */
+#define OI_RFCOMM_FLOW_RTC_INPUT   OI_BIT4     /**< Definition for flow control type, indicating that RTC/CTS flow control is used. */
+#define OI_RFCOMM_FLOW_RTC_OUTPUT  OI_BIT5     /**< Definition for flow control type, indicating that RTC/CTS flow control is used. */
+/** @} */
+
+/**
+ * @name Line status codes
+ * These line status (error) codes are passed to OI_RFCOMM_SendLineStatus()
+ */
+/** @{ */
+#define OI_RFCOMM_LINESTATUS_OVERRUN_ERR  (OI_BIT0 | OI_BIT1) /**< Line status: overrun error */
+#define OI_RFCOMM_LINESTATUS_PARITY_ERR   (OI_BIT0 | OI_BIT2) /**< Line status: parity error */
+#define OI_RFCOMM_LINESTATUS_FRAMING_ERR  (OI_BIT0 | OI_BIT3) /**< Line status: framing error  */
+/** @} */
+
+/**
+ * @name Line control bits
+ * These line control bits are passed to OI_RFCOMM_SetModemSignals()
+ */
+/** @{ */
+#define OI_RFCOMM_LINE_RTC OI_BIT2 /**< RTC (Ready To Communicate) bit; maps to DSR/DTR */
+#define OI_RFCOMM_LINE_RTR OI_BIT3 /**< RTR (Ready To Receive) bit; maps to RTS/CTS */
+#define OI_RFCOMM_LINE_IC  OI_BIT6 /**< IC (Incoming Call) bit; maps to RI */
+#define OI_RFCOMM_LINE_DV  OI_BIT7 /**< DV (Data Valid) bit; maps to DCD */
+/** @} */
+
+/************************************************************************
+
+  callback function type definitions
+
+ ************************************************************************/
+
+/**
+ * A callback function of this type confirms the establishment of a link to a
+ * remote device.
+ *
+ * @param link       Specifies the link handle.
+ *
+ * @param frameSize  Frame size to be used for the link.
+ *
+ * @param result     OI_OK if successful; failure code otherwise.
+ *
+ */
+typedef void (*OI_RFCOMM_CONNECT_CFM)(OI_RFCOMM_LINK_HANDLE link,
+                                      OI_UINT16 frameSize,
+                                      OI_STATUS result);
+
+/**
+ * A callback function of this type indicates that a remote application is
+ * attempting to establish a link.
+ *
+ * @param addr        Pointer to the address of the remote Bluetooth device
+ *                    attempting to establish a link
+ *
+ * @param channel     Specifies the server channel to which to connect.
+ *
+ * @param frameSize   Specifies the frame size for the incoming connection.
+ *
+ * @param link        Specifies the link handle for the connection.
+ */
+typedef void (*OI_RFCOMM_CONNECT_IND)(OI_BD_ADDR *addr,
+                                      OI_UINT8 channel,
+                                      OI_UINT16 frameSize,
+                                      OI_RFCOMM_LINK_HANDLE link);
+
+/**
+ * A callback function of this type indicates that the specified link has been disconnected.
+ *
+ * @param linkHandle   Specifies the handle of the link that was disconnected.
+ *
+ * @param reason       Status code indicating the reason for the disconnection.
+ */
+typedef void (*OI_RFCOMM_DISCONNECT_IND)(OI_RFCOMM_LINK_HANDLE link,
+                                         OI_STATUS reason);
+
+
+/**
+ * A callback function of this type confirms the remote port negotiation or request
+ * for the remote port parameters.
+ *
+ * @param link  Specifies the link handle.
+ *
+ * @param port  Pointer to the structure containing the port parameters.
+ */
+typedef void (*OI_RFCOMM_PORT_PARAM_CFM)(OI_RFCOMM_LINK_HANDLE link,
+                                         OI_RFCOMM_PORTPARAM *port);
+
+/**
+ * A callback function of this type indicates that the remote side of the
+ * session is requesting to set the port parameters on the local side of the
+ * virtual serial link. The implementation of this function should set the
+ * parameters in the structure pointed to by the 'port' parameter to the desired
+ * values before returning. Leaving a proposed parameter unchanged indicates
+ * acceptance of that proposed parameter.
+ *
+ * @param link  Specifies the link handle.
+ *
+ * @param port  Pointer to the structure containing the port parameters.
+ */
+typedef void (*OI_RFCOMM_PORT_PARAM_IND)(OI_RFCOMM_LINK_HANDLE link,
+                                         OI_RFCOMM_PORTPARAM *port);
+
+/**
+ * A callback function of this type indicates the control signals set by the
+ * remote device by means of the function OI_RFCOMM_SetModemSignals().
+ *
+ * @param link          Specifies the link handle for the link on which the signals were set.
+ *
+ * @param lineControl   State of the line control bits.
+ *
+ * @param breakControl  State of the break control bits.
+ *
+ */
+typedef void (*OI_RFCOMM_LINE_CONTROL_IND)(OI_RFCOMM_LINK_HANDLE link,
+                                           OI_BYTE lineControl,
+                                           OI_BYTE breakControl);
+
+/**
+ * A callback function of this type indicates the line status sent by the remote
+ * device.
+ *
+ * @param link            Specifies the link handle.
+ *
+ * @param lineStatus      Specifies the line status.
+ */
+typedef void (*OI_RFCOMM_LINE_STATUS_IND)(OI_RFCOMM_LINK_HANDLE link,
+                                          OI_BYTE lineStatus);
+
+/**
+ * A callback function of this type confirms that data was written to the
+ * specified link.
+ *
+ * @param link         Specifies the link handle for the link to where the data was written.
+ *
+ * @param dataBuf      Pointer to the buffer containing the data to be written.
+ *
+ * @param dataLen      Specifies the number of bytes written, always the same as the number
+ *                     of bytes passed to RFCOMM_Write().
+ */
+typedef void (*OI_RFCOMM_WRITE_CFM)(OI_RFCOMM_LINK_HANDLE link,
+                                    OI_UINT8 *dataBuf,
+                                    OI_UINT16 dataLen,
+                                    OI_STATUS result);
+
+
+/**
+ * A callback function of this type is called when the write to the MBUF has completed.
+ */
+typedef void (*OI_RFCOMM_WRITE_MBUF_CFM)(OI_RFCOMM_LINK_HANDLE link,
+                                         OI_MBUF *mbuf,
+                                         OI_STATUS result);
+
+
+/**
+ * A callback function of this type indicates the receipt of data on the
+ * specified link.
+ *
+ * @param link        Specifies the link handle for the link on which the data was received.
+ *
+ * @param dataBuf     Pointer to the buffer containing the received data.
+ *
+ * @param dataLen     Specifies the number of bytes received.
+ */
+typedef void (*OI_RFCOMM_RECV_DATA_IND)(OI_RFCOMM_LINK_HANDLE link,
+                                        OI_BYTE *dataBuf,
+                                        OI_UINT16 dataLen);
+
+/**
+ * A callback function of this type confirms receipt of a test response from a
+ * remote device.
+ *
+ * @param addr         Pointer to the address of the remote Bluetooth
+ *                     device.
+ *
+ * @param testPattern  Pointer to the buffer containing the test pattern data
+ *                     received from the remote device.
+ *
+ * @param length       Specifies the number of bytes in the test pattern.
+ */
+typedef void (*OI_RFCOMM_TEST_CFM)(OI_BD_ADDR *addr,
+                                   OI_UINT8 *testPattern,
+                                   OI_UINT16 length);
+
+/**
+   This structure groups together the indication callbacks
+   associated with a link and is passed to OI_RFCOMM_Connect()
+   by a client application or OI_RFCOMM_RegisterServer() by a
+   server application.
+ */
+typedef struct {
+
+    /** The callback function to be called when a link is
+        released. */
+    OI_RFCOMM_DISCONNECT_IND disconnectInd;
+
+    /** The callback function to be called when data is received. */
+    OI_RFCOMM_RECV_DATA_IND recvDataInd;
+
+    /** The callback function to be called to indicate the line
+       status sent by the remote device. (It is not necessary to
+       register this type of callback function, so this may be
+       NULL.) */
+    OI_RFCOMM_LINE_STATUS_IND lineStatusInd;
+
+    /** The callback function to be called to indicate the state of
+       the control lines. (It is not necessary to register this type
+       of callback function, so this may be NULL.) */
+    OI_RFCOMM_LINE_CONTROL_IND lineControlInd;
+
+    /** The callback function to be called to indicate that a remote
+       device wishes to configure a port. (It is not necessary to
+       register this type of callback function, so this may be
+       NULL.) */
+    OI_RFCOMM_PORT_PARAM_IND portParamInd;
+
+} OI_RFCOMM_LINK_INDICATIONS;
+
+
+/************************************************************************
+
+  functions
+
+ ************************************************************************/
+
+/**
+ * This function registers a server application with the RFCOMM layer and
+ * obtains a server channel number.
+ *
+ * @param callback      The indication callback function used to notify the
+ *                      server of a client application attempting to connect
+ *                      @param indications pointer to a structure containing
+ *                      indication callback functions to be used for any new
+ *                      link
+ *
+ * @param maxFrameSize  This indicates the maximum frame size that can be
+ *                      received on links with this server application. The
+ *                      negotiated frame size (which is reported by the
+ *                      OI_RFCOMM_CONNECT_IND callback function) may be smaller
+ *                      than this.
+ *
+ * @param bufSize       This indicates the size of buffer to use for flow
+ *                      control on a link created with this server. This
+ *                      buffering will be used for storing received data when
+ *                      incoming flow is disabled. To achieve optimal use of
+ *                      buffer space, this number should be a multiple of the
+ *                      frame size. If the buffer size is 0, then no buffer
+ *                      space will be allocated for the link and the application
+ *                      should not invoke OI_RFCOMM_FlowEnable() with the
+ *                      Boolean parameter FALSE.
+ *
+ * @param serverChannel Pointer to the location where the server channel number
+ *                      assigned to the application will be written. If the input
+ *                      value is a valid RFCOMM channel number (1 - 30), this
+ *                      channel number will be used in preference to any other.
+ *
+ * @param policy        Specifies the required connection policy.
+ *
+ * @return              OI_OK if successful; OI_STATUS_NO_RESOURCES if no more
+ *                      application registrations are allowed.
+ */
+OI_STATUS OI_RFCOMM_RegisterServer(OI_RFCOMM_CONNECT_IND callback,
+                                   const OI_RFCOMM_LINK_INDICATIONS *indications,
+                                   OI_UINT16 maxFrameSize,
+                                   OI_UINT16 bufSize,
+                                   OI_UINT8 *serverChannel,
+                                   const OI_CONNECT_POLICY *policy);
+
+/**
+ * This function deregisters a server application with the RFCOMM layer.
+ *
+ * @param serverChannel  Specifies the server channel number of the server to deregister.
+ *
+ * @return               OI_OK if successful; OI_RFCOMM_INVALID_CHANNEL if the
+ *                       server channel number is invalid.
+ */
+OI_STATUS OI_RFCOMM_DeregisterServer(OI_UINT8 serverChannel);
+
+/**
+ * This function establishes an RFCOMM link with a remote server.
+ *
+ * @param callback       Confirmation callback function to be called when
+ *                       the link is established.
+ *
+ * @param indications    Pointer to a structure containing indication callback
+ *                       functions to be used for this link.
+ *
+ * @param addr           Pointer to the Bluetooth device address of the remote
+ *                       device to which to connect.
+ *
+ * @param serverChannel  Specifies the server channel to which to connect on the remote device.
+ *
+ * @param maxFrameSize   Indicates the maximum frame size that can be
+ *                       received on this link. The negotiated frame size (which
+ *                       is reported by the OI_RFCOMM_CONNECT_IND callback
+ *                       function) may be smaller than this.
+ *
+ * @param bufSize        Indicates the size of buffer to use for flow
+ *                       control on this link. This buffering will be used for
+ *                       storing received data when incoming flow is disabled.
+ *                       To achieve optimal use of buffer space, this number
+ *                       should be a multiple of the frame size. If the buffer
+ *                       size is 0, then no buffer space will be allocated for
+ *                       the link and the application should not invoke
+ *                       OI_RFCOMM_FlowEnable() with the Boolean parameter FALSE.
+ *
+ * @param handle         Pointer to the buffer where the link handle will be written.
+ *                       This link handle can be used to reference the link once
+ *                       a success (OI_OK) status is returned and the
+ *                       OI_RFCOMM_CONNECT_CFM confirmation callback function
+ *                       has been called.
+ *
+ * @param policy         Specifies the required connection policy for this connection.
+ *
+ * @return               OI_OK if successful
+ */
+OI_STATUS OI_RFCOMM_Connect(OI_RFCOMM_CONNECT_CFM callback,
+                            const OI_RFCOMM_LINK_INDICATIONS *indications,
+                            OI_BD_ADDR *addr,
+                            OI_UINT8 serverChannel,
+                            OI_UINT16 maxFrameSize,
+                            OI_UINT16 bufSize,
+                            OI_RFCOMM_LINK_HANDLE *handle,
+                            const OI_CONNECT_POLICY *policy);
+
+/**
+ * This function is used to respond to an indication that a remote application
+ * is attempting to establish a link. No connection parameters are passed in
+ * here, since connection parameters (frame size and buffer size) were already
+ * configured in OI_RFCOMM_RegisterServer().
+ *
+ * @param callback   Specifies the confirmation callback to call when the connection has been
+ *                   established.
+ *
+ * @param link       Specifies the link handle for the connection.
+ *
+ * @param accept     TRUE to accept and establish the link; FALSE to reject.
+ */
+OI_STATUS OI_RFCOMM_Accept( OI_RFCOMM_CONNECT_CFM callback,
+                            OI_RFCOMM_LINK_HANDLE link,
+                            OI_BOOL accept);
+
+/**
+ * This function terminates the specified RFCOMM link. The disconnect indication
+ * callback function passed to OI_RFCOMM_Accept() or OI_RFCOMM_Connect() will be
+ * called when the disconnection is complete.
+ *
+ * @param link       Specifies the link handle of the link to be terminated.
+ *
+ * @return           OI_OK if successful.
+ */
+OI_STATUS OI_RFCOMM_Disconnect(OI_RFCOMM_LINK_HANDLE link);
+
+/**
+ * This function writes data to the specified RFCOMM link. Once this function
+ * has been called with a given link handle, it should not be called again with
+ * the same link handle before receiving an OI_RFCOMM_WRITE_CFM
+ * confirmation callback function for that link. Concurrent writes to the same
+ * link handle without an intervening write confirmation callback will result in
+ * an error return status from OI_RFCOMM_Write().
+ *
+ * The argument dataLen must be less than or equal to the negotiated maximum RFCOMM frame
+ * size, maxFrameSize. Use the function OI_RFCOMM_WriteSegmented() to send data
+ * with a dataLen larger than maxFrameSize.
+ *
+ * @param callback    Specifies the callback function for confirming the write.
+ *
+ * @param link        Specifies the link handle of the link to which to write data.
+ *
+ * @param data        Pointer to the output buffer containing the data to write.
+ *
+ * @param dataLen     Specifies the number of bytes to send from the data output buffer.
+ *
+ * @return            OI_OK if successful.
+ */
+OI_STATUS OI_RFCOMM_Write(OI_RFCOMM_WRITE_CFM callback,
+                          OI_RFCOMM_LINK_HANDLE link,
+                          OI_UINT8 *data,
+                          OI_UINT16 dataLen);
+
+/**
+ * This function sends an entire buffer of data. Unlike OI_RFCOMM_Write(),
+ * this function accepts a buffer with a length greater than the frame size
+ * for the specified link. If dataLen is greater than the frame size, RFCOMM
+ * will perform segmentation internally, sending multiple frames of data no
+ * more than the frame size in length. The callback will be called once the entire
+ * contents of the buffer have been sent.
+ *
+ * @param callback    Specifies the callback function for confirming the write.
+ *
+ * @param link        Specifies the link handle of the link to which to write data.
+ *
+ * @param data        Pointer to the output buffer containing the data to write.
+ *
+ * @param dataLen     Number of bytes to send from the data output buffer.
+ */
+OI_STATUS OI_RFCOMM_WriteSegmented(OI_RFCOMM_WRITE_CFM callback,
+                                   OI_RFCOMM_LINK_HANDLE link,
+                                   OI_UINT8 *data,
+                                   OI_UINT16 dataLen);
+
+
+/**
+ * Write to an MBUF. RFCOMM will segment the write into multiple frames as required.
+ *
+ * @param callback  Specifies the callback function that will be called when the MBUF has been completely
+ *                  transmitted.
+ *
+ * @param link      Specifies the RFCOMM link on which to transmit the data.
+ *
+ * @param fastCfm   Requests that RFCOMM confirm the write as quickly as possible. This may require
+ *                  data to be copied so this should only be done when there is no response expected
+ *                  from the remote device.
+ *
+ * @param mbuf      The mbuf to send.
+ */
+OI_STATUS OI_RFCOMM_WriteMBUF(OI_RFCOMM_WRITE_MBUF_CFM callback,
+                              OI_RFCOMM_LINK_HANDLE link,
+                              OI_BOOL fastCfm,
+                              OI_MBUF *mbuf);
+
+
+/**
+ * This function requests that the port parameters for the remote side of the
+ * virtual serial link specified by the OI_RFCOMM_LINK_HANDLE parameter be
+ * set to the values indicated by the OI_RFCOMM_PORTPARAM structure. A mask in
+ * this structure indicates which parameters are to be set and which are to be
+ * ignored. The result of the request will be reported in the callback.
+ *
+ * @param callback    Specifies the confirmation callback function to be called when the
+ *                    parameter setting function has completed.
+ *
+ * @param link        Specifies the link handle associated with the remote serial port for
+ *                    which the configuration is being set.
+ *
+ * @param port        Pointer to the structure containing the port parameters
+ *
+ */
+OI_STATUS OI_RFCOMM_SetPortParams(OI_RFCOMM_PORT_PARAM_CFM callback,
+                                  OI_RFCOMM_LINK_HANDLE link,
+                                  OI_RFCOMM_PORTPARAM *port);
+
+/**
+ * This function requests a read of the port parameters for the remote side of
+ * the virtual serial link specified by the OI_RFCOMM_LINK_HANDLE.
+ *
+ * @param callback    Specifies the confirmation callback function.
+ *
+ * @param handle      Specifies the link handle associated with the serial port for which
+ *                    the remote configuration is being read.
+ */
+OI_STATUS OI_RFCOMM_GetPortParams(OI_RFCOMM_PORT_PARAM_CFM callback,
+                                  OI_RFCOMM_LINK_HANDLE handle);
+
+/**
+ * This function sets the modem control signals for the specified
+ * link. If connected, the modem control signals will be sent to
+ * the remote side. If not, the signal's values will be cached and
+ * sent to the remote side after the SAMB/UA exchange establishing the RFCOMM
+ * multiplexer.
+ *
+ * This function can be called any time the application has a
+ * valid RFCOMM link handle. The earliest point in time when the application
+ * has a valid link handle is either:
+ *
+ * - upon return from OI_RFCOMM_Connect() (for an outgoing connection), or
+ * - upon #OI_RFCOMM_CONNECT_IND callback (for an incoming connection).
+ *
+ * @param link         Specifies the link handle of the link for which to set the signals.
+ *
+ * @param lineControl  Carries the line control bits. This should be
+ *                     the logical OR of any of:
+ *                     - OI_RFCOMM_LINE_RTC
+ *                     - OI_RFCOMM_LINE_RTR
+ *                     - OI_RFCOMM_LINE_IC
+ *                     - OI_RFCOMM_LINE_DV
+ *
+ * @param breakControl  Break control bits
+ */
+OI_STATUS OI_RFCOMM_SetModemSignals(OI_RFCOMM_LINK_HANDLE link,
+                                    OI_INT8 lineControl,
+                                    OI_INT8 breakControl);
+
+/**
+ * This function sends the specified line status code to the remote device.
+ *
+ * @param link        Specifies the link handle of the link on which to send the status
+ *                    code.
+ *
+ * @param lineStatus  Specifies the line status code to send.
+ */
+OI_STATUS OI_RFCOMM_SendLineStatus(OI_RFCOMM_LINK_HANDLE link,
+                                   OI_BYTE lineStatus);
+
+
+/**
+ * This function tests the data link to the specified device by sending a test
+ * data pattern. The remote device should write the same test pattern back. The
+ * callback function confirms that the response has been received.
+ *
+ * @param callback     Specifies the confirmation callback function to be called when the
+ *                     test response is received.
+ *
+ * @param addr         Pointer to the address of the remote Bluetooth
+ *                     device.
+ *
+ * @param testPattern  Pointer to the buffer containing the test pattern data to
+ *                     be sent to the remote device.
+ *
+ * @param length       Specifies the number of bytes in the test pattern, which must not
+ *                     be greater than 255.
+ */
+OI_STATUS OI_RFCOMM_Test(OI_RFCOMM_TEST_CFM callback,
+                         OI_BD_ADDR *addr,
+                         OI_BYTE *testPattern,
+                         OI_UINT8 length);
+
+/**
+ * Indicate whether credit-based flow control is being used on this link.
+ * If credit-based flow control is not being used, OI_RFCOMM_FlowEnable will
+ * use the GSM TS 7.10 styles of flow control (specifically using the Modem
+ * Status Command) which may mean that packets will arrive at the application after
+ * OI_RFCOMM_FlowEnable has been issued, but before the remote device has processed
+ * the MSC.
+ * This function may be called successfully during the OI_RFCOMM_CONNECT_CFM or
+ * anytime afterwards.
+ *
+ * @param handle  Specifies the link handle to query.
+ *
+ * @return  TRUE if using credit-based flow control.
+ */
+OI_BOOL OI_RFCOMM_CreditBasedFlowControl(OI_RFCOMM_LINK_HANDLE handle);
+
+
+/**
+ * Enables or disables the flow of data sent from RFCOMM to the
+ * application. An application that cannot receive more data should call
+ * OI_RFCOMM_FlowEnable() with the Boolean parameter <code>enable</code>
+ * set to FALSE.  This will pause the flow of data from RFCOMM to the
+ * application. See OI_RFCOMM_CreditBasedFlowControl for further discussion
+ * under links that do not support credit based flow control.
+ *
+ * @param handle  Specifies the link handle for the link on which to enable or disable flow.
+ *
+ * @param enable  TRUE to enable flow, FALSE to disable flow.
+*/
+OI_STATUS OI_RFCOMM_FlowEnable(OI_RFCOMM_LINK_HANDLE handle,
+                               OI_BOOL enable );
+
+
+/**
+ * This function returns the SCN (server channel number) aka RFCOMM DLCI for a given
+ * rfcomm link handle. This API is provided for BREW compatibility.
+ *
+ * @param handle    Specifies the RFCOMM link handle.
+ *
+ * @param[out] pSCN     Pointer to the caller's var where the SCN will be stored.
+ *
+ * @return          OI_OK if successful. Any other return value indicates failure and
+ *                  *pSCN is unchanged.
+ */
+
+OI_STATUS OI_RFCOMM_GetSCNByHandle(OI_RFCOMM_LINK_HANDLE handle,
+                                   OI_UINT8 *pSCN);
+
+
+/**
+ * Associates a caller defined context with a registered RFCOMM server channel.
+ * This context can then be retrieved by calling OI_RFCOMM_GetServerContext.
+ *
+ * This function should only be used by the application or profile that is
+ * in direct control of the RFCOMM server for the requested channel. Any
+ * other manipulation of the context value will confuse the profile that
+ * expected to have control of the context.
+ *
+ * @param serverChannel   Specifies a valid RFCOMM channel number for a registered RFCOMM
+ *                        server.
+ *
+ * @param context         Value supplied by the caller.
+ *
+ * @return                OI_OK if the context was set, OI_STATUS_NOT_FOUND if
+ *                        serverChannel is not valid.
+ */
+OI_STATUS OI_RFCOMM_SetServerContext(OI_UINT8 serverChannel,
+                                     void *context);
+
+
+/**
+ * Gets a caller defined context from a registered RFCOMM server channel. This
+ * is a value that we previously set by a call to OI_RFCOMM_SetServerContext.
+ *
+ * @param serverChannel   Valid RFCOMM channel number for a registered RFCOMM
+ *                        server.
+ *
+ * @return                Context pointer or NULL if the handle is invalid or
+ *                        there is no context associated with this server
+ *                        channel.
+ */
+void* OI_RFCOMM_GetServerContext(OI_UINT8 serverChannel);
+
+
+/**
+ * Associates a caller defined context with an RFCOMM link. This context can
+ * then be retrieved by calling OI_RFCOMM_GetLinkContext.
+ *
+ * This function should only be used by the application or profile
+ * that is in direct control of the RFCOMM link. Any other
+ * manipulation of the context value will confuse the profile that
+ * expected to have control of the context.
+ *
+ * @param handle          Specifies the RFCOMM link handle to which to associate the context.
+ *
+ * @param context         Value supplied by the caller.
+ *
+ * @return                OI_OK if the context was set, OI_STATUS_NOT_FOUND if
+ *                        the link handle is not valid.
+ */
+OI_STATUS OI_RFCOMM_SetLinkContext(OI_RFCOMM_LINK_HANDLE handle,
+                                   void *context);
+
+
+/**
+ * Gets a caller defined context associate with an RFCOMM link. This is a value
+ * that we previously set by a call to OI_RFCOMM_SetLinkContext.
+ *
+ * @param handle          Specifies the RFCOMM link handle from which to get the context.
+ *
+ * @return                Context pointer or NULL if the handle is invalid or
+ *                        there is no context associated with this handle.
+ */
+void* OI_RFCOMM_GetLinkContext(OI_RFCOMM_LINK_HANDLE handle);
+
+
+
+/**
+ * Given an RFCOMM link, this function returns the L2CAP channel ID for the RFCOMM session for this
+ * link.
+ *
+ * @param handle      Specifies the RFCOMM link handle to use.
+ * @param cid         Pointer to out parameter for the L2CAP CID
+ *
+ * @return      - OI_OK if the L2CAP channel id was returned succesfully
+ *              - OI_RFCOMM_LINK_NOT_FOUND if the handle is invalid
+ *              - OI_STATUS_NOT_CONNECTED if the RFCOMM session is not connected or is disconnecting
+ *
+ *
+ */
+OI_STATUS OI_RFCOMM_GetL2capCID(OI_RFCOMM_LINK_HANDLE handle,
+                                OI_L2CAP_CID *cid);
+
+
+/**
+ * Indicate to RFCOMM whether it should use ERTM mode for L2CAP connection.
+ *
+ * @param ertm   Specifies whether RFCOMM should specifically request ERTM mode for its L2CAP connection
+ *               or allow L2CAP to choose the mode.
+ *
+ */
+void OI_RFCOMM_SetL2capERTM(OI_BOOL ertm);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_RFCOMM_H */
diff --git a/obex_profiles/sdk/include/oi_rfcomm_prefs.h b/obex_profiles/sdk/include/oi_rfcomm_prefs.h
new file mode 100644
index 0000000..89239c2
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_rfcomm_prefs.h
@@ -0,0 +1,74 @@
+#ifndef _OI_RFCOMM_PREFS_H
+#define _OI_RFCOMM_PREFS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file defines RFCOMM preferences.
+ *
+ The following are the RFCOMM channel number preferences for the various
+    profiles which register RFCOMM servers. If the numbers are selected
+    appropriately, a given service using RFCOMM will always be assigned the
+    same RFCOMM channel number.
+
+    @note: Numbers are restricted to range of 1-30.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define RFCOMM_PREF_FAX              5
+#define RFCOMM_PREF_HANDSFREE        7
+#define RFCOMM_PREF_HANDSFREE_AG     8
+#define RFCOMM_PREF_HEADSET          9
+#define RFCOMM_PREF_HEADSET_AG      10
+#define RFCOMM_PREF_SAP_SRV         11
+#define RFCOMM_PREF_OPP_SRV         12
+#define RFCOMM_PREF_SYNC_SRV        14
+#define RFCOMM_PREF_SYNC_CMD_SVC    15
+#define RFCOMM_PREF_MAP_SRV         16
+#define RFCOMM_PREF_MNS_SRV         17
+#define RFCOMM_PREF_PBAP_SRV        19
+#define RFCOMM_PREF_FTP_SRV         20
+#define RFCOMM_PREF_SPP             21
+#define RFCOMM_PREF_DUN             25
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OI_RFCOMM_PREFS_H */
+
diff --git a/obex_profiles/sdk/include/oi_sdp.h b/obex_profiles/sdk/include/oi_sdp.h
new file mode 100644
index 0000000..973c03a
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_sdp.h
@@ -0,0 +1,458 @@
+#ifndef _OI_SDP_H
+#define _OI_SDP_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ *  This file provides the API for client-side management of connections and
+ *  queries to a remote SDP server and its service database.
+ *
+ *  For more information see the @ref SDP_docpage section of the BLUEmagic 3.0 SDK documentation.
+ */
+
+#include "oi_status.h"
+#include "oi_bt_spec.h"
+#include "oi_dataelem.h"
+#include "oi_bt_stack_config.h"
+
+/** \addtogroup SvcDisc Service Discovery APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+#define OI_SDP_ClientInit(x)         (OI_OK)
+#define OI_SDP_ClientTerminate()     (OI_OK)
+
+/**
+ * This is the type definition for a service record handle. A service record
+ * handle is returned by an SDP server in response to a service search request
+ * (OI_SDP_SearchReq()). The service record handle only has local meaning within
+ * the SDP server that returned it. The only exception to this is for the
+ * service record handle value 0, which is the service record handle for the
+ * service record for the SDP server itself.
+ */
+typedef OI_UINT32 OI_SDP_SERVICE_RECORD_HANDLE;
+
+/**
+ * This is the type definition for a service record handle. A service
+ * record handle is returned by OI_SDP_Connect() in order to uniquely
+ * identify an SDP connection. The handle is used in all SDP function
+ * calls and callbacks.
+ */
+typedef OI_UINT16 OI_SDP_CONNECTION_HANDLE;
+
+/**
+ * A callback function of this type confirms that a connection has been
+ * established to an SDP server.
+ *
+ * A callback function of this type must be provided by the client application
+ * in calls to OI_SDP_Connect() and is called when a connect request has
+ * completed, either with success or failure. If the connection request failed
+ * or was rejected by the SDP server, then the status code indicates the reason
+ * for the failure.
+ *
+ * @param handle       Identifier for the connection associated with this call.
+ *
+ * @param status       Returned status code; OI_OK if the connection was
+ *                     established, error status otherwise.
+ */
+typedef void (*OI_SDP_CONNECT_CFM_CB)(OI_SDP_CONNECTION_HANDLE handle,
+                                      OI_STATUS status);
+
+
+/**
+ * A callback function of this type indicates that a connection to an SDP server
+ * has been terminated.
+ *
+ * A callback function of this type must be provided by the client application
+ * in calls to OI_SDP_Connect() and is called when a disconnection has
+ * occurred.
+ *
+ * @param handle       Identifier for the connection associated with this call.
+ */
+typedef void (*OI_SDP_DISCONNECT_IND_CB)(OI_SDP_CONNECTION_HANDLE handle);
+
+
+/**
+ * A callback function of this type provides the results of a service
+ * search request.
+ *
+ * A callback function of this type must be provided by the client
+ * application in calls to OI_SDP_SearchReq() and is called when a
+ * service search request has completed.
+ *
+ * It is the responsibility of the client application to make use of
+ * the service record array returned by this callback function. The
+ * SDP layer does not itself maintain a data structure to assemble
+ * service search responses. If the client application is to make use
+ * of the service records returned by a service search response, the
+ * client application must copy the service record data into memory
+ * local to the application.
+ *
+ * In short, returned data must be consumed inside the callback and
+ * not referenced outside the callback.
+ *
+ *
+ * @param handle               Identifier for the connection associated with
+ *                             this call.
+ *
+ * @param serviceRecord        Pointer to an array of SDP service
+ *                             record handles.
+ *
+ * @param serviceRecordCount   Number of service records in the array.
+ *
+ * @param status               Status of the service search request; OI_OK if
+ *                             successful, error status otherwise. If the
+ *                             status is not OI_OK, then parameters
+ *                             serviceRecords and serviceRecordCount are
+ *                             undefined.
+ */
+typedef void (*OI_SDP_SEARCH_RSP_CB)(OI_SDP_CONNECTION_HANDLE handle,
+                                     OI_SDP_SERVICE_RECORD_HANDLE *serviceRecords,
+                                     OI_UINT16 serviceRecordCount,
+                                     OI_STATUS status);
+
+/**
+ * A callback function of this type provides the results of a service
+ * attribute request.
+ *
+ * A callback function of this type must be provided by the client
+ * application in calls to OI_SDP_AttributeReq() and is called when a
+ * service attribute request has completed.
+ *
+ * Attributes are returned as a pointer to a data element sequence
+ * (@ref OI_DATAELEM_SEQ) of data elements pairs in which the first
+ * data element in each pair is an attribute identifier (@ref
+ * OI_DATAELEM_UINT) and the second data element is the attribute
+ * value. In other words, the actual attribute values are two levels
+ * of indirection away from the value returned by this function.
+ *
+ * The parameter 'more' indicates that the service attribute request
+ * is incomplete and that there are more attributes that meet the
+ * search criteria. To request the remaining attributes, call
+ * OI_SDP_ContinueCurrentReq().
+ *
+ * It is the responsibility of the client application to make use of
+ * the service attribute record array returned by this callback
+ * function. The SDP layer does not itself maintain a data structure
+ * to assemble service attribute responses. If the client application
+ * is to make use of the service attribute records returned by a
+ * service attribute response, the client application must copy the
+ * service attribute record data into memory local to the application.
+ *
+ * In short, returned data must be consumed inside the callback and
+ * not referenced outside the callback.
+ *
+ * @param handle       Identifier for the connection associated with this call
+ *
+ * @param attributes   This value is a pointer to a data element sequence.
+ *                     The data element sequence value is a pointer to an array
+ *                     of data element pairs; for each of these pairs, the first
+ *                     element is an attribute ID and the second is an attribute
+ *                     value.
+ *
+ * @param more         Indicates that the service attribute request is
+ *                     incomplete and that there are more attributes that meet
+ *                     the search criteria.
+ *
+ * @param status       Status of the service attribute request is OI_OK if
+ *                     successful, error status otherwise. If the status is
+ *                     not OI_OK then other parameters (more and attributes) are
+ *                     undefined.
+ */
+typedef void (*OI_SDP_ATTRIBUTE_RSP_CB)(OI_SDP_CONNECTION_HANDLE handle,
+                                        OI_DATAELEM *attributes,
+                                        OI_BOOL more,
+                                        OI_STATUS status);
+
+
+/**
+ * A callback function of this type provides the results of a service
+ * search attribute request.
+ *
+ * A callback function of this type must be provided by the client
+ * application in calls to OI_SDP_SearchAttributeReq() and is called
+ * when a service seacrh attribute request has completed.
+ *
+ * Attributes are returned as a pointer to a data element sequence
+ * (@ref OI_DATAELEM_SEQ) of responses. Each response is itself a data
+ * element sequence; the value of each of these data element sequences
+ * is a list of data element pairs in which the first data element in
+ * each pair is an attribute identifier (@ref OI_DATAELEM_UINT) and
+ * the second data element is the attribute value. In other words, the
+ * actual attribute values are three levels of indirection away from
+ * the value returned by this function.
+ *
+ * The parameter 'more' indicates that the service attribute request
+ * is incomplete and that there are more attributes that meet the
+ * search criteria. To request the remaining attributes, call
+ * OI_SDP_ContinueCurrentReq().
+ *
+ * It is the responsibility of the client application to make use of
+ * the service attribute record array returned by this callback
+ * function. The SDP layer does not itself maintain a data structure
+ * to assemble service search attribute responses. If the client
+ * application is to make use of the service records returned by a
+ * service search attribute response, the client application must copy
+ * the service attribute record data into memory local to the
+ * application.
+ *
+ * In short, returned data must be consumed inside the callback and
+ * not referenced outside the callback.
+ *
+ * @param handle          Identifier for the connection associated with this
+ *                        call.
+ *
+ * @param attributesList  Pointer to a data element sequence.
+ *                        The data element sequence value is a pointer to a list
+ *                        (data element sequence) of responses. The value of each of
+ *                        these data element sequences is a pointer to a list of data
+ *                        element pairs; for each of these pairs, the first element
+ *                        is an attribute ID and the second is an attribute value.
+ *
+ * @param more            Indicates that the service attribute request is
+ *                        incomplete and that there are more attributes that
+ *                        meet the search criteria.
+ *
+ * @param status         Status of the service attribute request: OI_OK if
+ *                       successful, error status otherwise. If the status is
+ *                       not OI_OK then other parameters (more and attributes)
+ *                       are undefined.
+ */
+typedef void (*OI_SDP_SEARCH_ATTRIBUTE_RSP_CB)(OI_SDP_CONNECTION_HANDLE handle,
+                                               OI_DATAELEM *attributesList,
+                                               OI_BOOL more,
+                                               OI_STATUS status);
+
+
+/**
+ * This function requests a connection with an SDP server.
+ *
+ * The reason for making such a connection is to allow the SDP client on the
+ * local device to query the the SDP service database on a remote device.
+ *
+ * @param connectCfmCB        Confirmation callback function that is
+ *                            called when the connection command has completed,
+ *                            either successfully or with some error status
+ *                            returned.
+ *
+ * @param disconnectIndCB     Indication callback function that will be
+ *                            called if the connection is terminated, either
+ *                            because of an error or because the application
+ *                            explicitly called OI_SDP_Disconnect().
+ *
+ * @param deviceAddr          Pointer to the address of the remote Bluetooth device
+                              acting as the SDP server.
+ *
+ * @param handle              Output parameter for the connection handle
+ *                            created by this call.
+ *
+ * @return                    OI_OK if the connection is successfully
+ *                            established. If the connection request fails, various
+                              error codes indicate the reason for the failure.
+ */
+OI_STATUS OI_SDP_Connect(OI_SDP_CONNECT_CFM_CB connectCfmCB,
+                         OI_SDP_DISCONNECT_IND_CB disconnectIndCB,
+                         const OI_BD_ADDR* deviceAddr,
+                         OI_SDP_CONNECTION_HANDLE* handle);
+
+/**
+ * This function terminates the specified connection to an SDP server. This
+ * function does not terminate the underlying L2CAP connection if that
+ * connection is in use by other applications or profiles.
+ *
+ * When a connection to an SDP server has been terminated for any reason, this
+ * triggers the invocation of the OI_SDP_DISCONNECT_IND_CB disconnect indication
+ * callback function that was provided in the OI_SDP_Connect() call that
+ * established the connection in the first place.
+ *
+ * @param handle      Identifier for the connection associated with this call.
+ *
+ * @return            OI_OK unless there is no current connection.
+ */
+OI_STATUS OI_SDP_Disconnect(OI_SDP_CONNECTION_HANDLE handle);
+
+
+/**
+ * This function initiates a search for services in the SDP server referenced by
+ * the remote device address, using a list of service UUIDs to select the
+ * required services.
+ *
+ * @param handle             Identifier for the connection associated with this call.
+ *
+ * @param responseCB         Callback function that returns the results of the
+ *                           service search request.
+ *
+ * @param maxServiceRecords  Specifies the maximum number of service records to query for and
+ *                           return in the callback function. This must be > 0.
+ *
+ * @param UUIDList           @ref OI_DATAELEM_SEQ data element list of
+ *                           @ref OI_DATAELEM_UUID UUID data elements representing
+ *                           the UUIDs that will be searched for in the remote
+ *                           SDP server database.
+ *
+ * @return                   OI_OK if the request was succesfully queued to be
+ *                           sent to the SDP server; error status otherwise.
+ */
+OI_STATUS OI_SDP_SearchReq(OI_SDP_CONNECTION_HANDLE handle,
+                           OI_SDP_SEARCH_RSP_CB responseCB,
+                           OI_UINT16 maxServiceRecords,
+                           const OI_DATAELEM *UUIDList);
+
+/**
+ * This function initiates a search for service attributes in a service record.
+ *
+ * The service record handle is a 32-bit value that identifies the service
+ * record in the remote SDP database that is being searched by this request. The
+ * client application obtains service record handles by calling
+ * OI_SDP_SearchReq().
+ *
+ * The @ref OI_DATAELEM_SEQ attribute list that is returned by the response
+ * callback function is a list of @ref OI_DATAELEM_UINT 16- and 32-bit unsigned
+ * integer data elements. 16-bit data elements represent individual attribute
+ * IDs; 32-bit data elements represent attribute ID ranges, where the most
+ * significant 16 bits represent the attribute ID at the low bound of the range
+ * and the least significant 16 bits represent attribute ID at the high bound of
+ * the range.
+ *
+ * @note The SDP specification requires the attribute list to be sorted from low
+ * attribute ID value to high attribute ID value. It is the responsibility of
+ * the SDP server application to ensure that this ordering is correct. The
+ * attribute request function fails with an error status if the attribute IDs
+ * are out of order or there are overlapping ranges. See Volume 3 of the
+ * Bluetooth specification for more information.
+ *
+ * @param handle                Identifier for the connection associated with
+ *                              this call.
+ *
+ * @param responseCB            Callback function that returns the results of
+ *                              the service attribute request.
+ *
+ * @param serviceRecordHandle   Specifies the service record handle.
+ *
+ * @param attributeRangeList    This is a @ref OI_DATAELEM_SEQ attribute list of
+ *                              @ref OI_DATAELEM_UINT 16- and 32-bit unsigned
+ *                              integer data elements. The macro
+ *                              OI_ATTRID_RANGE in oi_bt_assigned_nos.h can be
+ *                              used to assemble a 32-bit value representing a
+ *                              range of attributes.
+ *
+ * @return                      OI_OK if the request was successfully queued to
+ *                              be sent to the server; error code otherwise.
+ */
+OI_STATUS OI_SDP_AttributeReq(OI_SDP_CONNECTION_HANDLE handle,
+                              OI_SDP_ATTRIBUTE_RSP_CB responseCB,
+                              OI_SDP_SERVICE_RECORD_HANDLE serviceRecordHandle,
+                              const OI_DATAELEM *attributeRangeList);
+
+
+/**
+ * This function combines the functionality of SDP_ServerSearchReq() and
+ * OI_SDP_AttributeReq() into a single request.
+ *
+ * @param handle                Identifier for the connection associated with
+ *                              this call
+ *
+ * @param responseCB            Callback function that returns the results of
+ *                              the service attribute request.
+ *
+ * @param UUIDList              An @ref OI_DATAELEM_SEQ data element list of
+ *                              @ref OI_DATAELEM_UUID UUID data elements
+ *                              representing the UUIDs that will be searched for
+ *                              in the remote SDP server database
+ *
+ * @param attributeRangeList    This is a @ref OI_DATAELEM_SEQ attribute list of
+ *                              @ref OI_DATAELEM_UINT 16- and 32-bit unsigned
+ *                              integer data elements. The macro
+ *                              OI_ATTRID_RANGE in oi_bt_assigned_nos.h can be
+ *                              used to assemble a 32-bit value representing a
+ *                              range of attributes.
+ *
+ * @return                      OI_OK if the request was successfully queued to
+ *                              be sent to the server; error code otherwise.
+ */
+OI_STATUS OI_SDP_SearchAttributeReq(OI_SDP_CONNECTION_HANDLE handle,
+                                    OI_SDP_SEARCH_ATTRIBUTE_RSP_CB responseCB,
+                                    const OI_DATAELEM *UUIDList,
+                                    const OI_DATAELEM *attributeRangeList);
+
+/**
+ * This function requests a continuation of the service attribute request or
+ * service search attribute request for a specific connection.
+ *
+ * When the complete response to a call to OI_SDP_AttributeReq() or
+ * OI_SDP_SearchAttributeReq() can not be returned in a single response packet,
+ * the 'more' parameter is set in the request's callback function. To request
+ * the rest of the response, the client application calls this continuation
+ * function. Depending on the amount of response data and the various packet
+ * sizes, the application may need to call the continuation function several
+ * times to retrieve the complete response.
+ *
+ * If the client application does not need to continue the request but there is
+ * still more response data outstanding, the client application must call
+ * OI_SDP_EndCurrentReq() or OI_SDP_Disconnect() to free up resources allocated
+ * to the connection and the ongoing request.
+ *
+ * @param handle      Identifier for the connection associated with this call.
+ *
+ * @return    OI_OK if the continuation request was successfully queued to be
+ *            sent to the SDP server; error status otherwise, including the case
+ *            in which there was no request currently in progress.
+ */
+OI_STATUS OI_SDP_ContinueCurrentReq(OI_SDP_CONNECTION_HANDLE handle);
+
+
+/**
+ * This function terminates the service attribute request or service
+ * attribute search request for a specific connection. See also
+ * OI_SDP_ContinueCurrentReq().
+ *
+ * @param handle      Identifier for the connection associated with this call.
+ *
+ */
+OI_STATUS OI_SDP_EndCurrentReq(OI_SDP_CONNECTION_HANDLE handle);
+
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_SDP_H */
+
diff --git a/obex_profiles/sdk/include/oi_sdpdb.h b/obex_profiles/sdk/include/oi_sdpdb.h
new file mode 100644
index 0000000..89c8e9d
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_sdpdb.h
@@ -0,0 +1,527 @@
+#ifndef _OI_SDPDB_H
+#define _OI_SDPDB_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ *  This file provides the API for management of the SDP database.
+ *
+ *  For more information see the @ref SDP_docpage section of the
+ *  BLUEmagic SDK documentation.
+ */
+
+#include "oi_status.h"
+#include "oi_bt_spec.h"
+#include "oi_dataelem.h"
+
+/** \addtogroup SvcDisc Service Discovery APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * To support multiple languages, text attribute IDs are modified by a language
+ * ID. The language ID is defined by an attribute in an SDP service record. The
+ * SDP specification also defines a language attribute ID that can always be used to
+ * select the default language. See Volume 3 the Bluetooth specification
+ * for information on the language attribute ID.
+ */
+#define OI_SDP_DEFAULT_LANGUAGE_ID(id) (id | OI_ATTRID_DEFAULT_LanguageBaseOffset)
+
+
+/**
+ * Attribute IDs are 16-bit integers.
+ */
+typedef OI_UINT16 OI_SDP_ATTRIBUTE_ID;
+
+/**
+ * A service record attribute is represented as a structure consisting of
+ * a 16-bit attribute ID and an attribute value represented by a union of type
+ * @ref OI_DATAELEM. A variety of macros defined in oi_dataelem.h can be used to
+ * statically initialize the data element in an OI_SDPDB_ATTRIBUTE.
+ * (See oi_bt_assigned_nos.h for more information on attribute IDs.)
+ */
+typedef struct {
+    OI_SDP_ATTRIBUTE_ID Id;  /**< 16-bit attribute ID */
+    OI_DATAELEM Element;     /**< Data element value for the attribute value */
+} OI_SDPDB_ATTRIBUTE;
+
+
+/**
+   This structure defines the internationalized strings to use
+   for an SDP service record.
+ *
+   @param  attrs  Attribute pairs (uuid, string)
+   @param  num    Number of attributes
+ */
+typedef struct {
+    const OI_SDPDB_ATTRIBUTE *attrs;
+    OI_UINT16 num;
+} OI_SDP_STRINGS;
+
+
+/**
+   This structure defines the attributes of a service in a
+   service record. An SDP service record is an array of
+   attribute ID/value pairs.
+ */
+typedef struct {
+    OI_SDPDB_ATTRIBUTE const *Attributes; /**< A service record is initialized with an attribute list.
+                                               This will normally be statically allocated attributes
+                                               that do not change during the lifetime of a service. */
+
+    OI_UINT16 NumAttributes;              /**< Number of attributes in the ConstAttributes array */
+
+    OI_SDPDB_ATTRIBUTE const *Strings;    /**< Name and description strings */
+    OI_UINT16 NumStrings;                 /**< Number of strings */
+
+} OI_SDPDB_SERVICE_RECORD;
+
+
+/**
+   This structure provides a means to associate an SDP service record
+   with the corresponding profile.
+ */
+typedef struct {
+    OI_UINT32   handle;             /* Service record handle */
+    OI_UUID16   serviceClassUUID16; /* Bluetooth service class UUID */
+    OI_UUID16   profileUUID16;      /* Bluetooth profile UUID */
+}  OI_SDP_SUMMARY_REC;
+
+/**
+ * This enumeration lists the different XML output formats available
+ * when using OI_SDPDB_GetRecordAsXML() and OI_SDPDB_GetAttributeAsXML().
+ * Format information in sdp_xml_formats.c depends on the order of
+ * this list.
+ */
+
+typedef enum {
+    OI_SDPDB_XML_FORMAT_OPENBLUE = 0,
+    OI_SDPDB_XML_FORMAT_BZ,
+    /* Add new formats here */
+    OI_SDPDB_XML_NUM_FORMATS  /* Must be last in the list */
+} OI_SDPDB_XML_FORMAT;
+
+/**
+ * A function of this type is called whenever a record in the SDP
+ * database is added or modified. The supplied handle may be used to
+ * get information from the SDP database.
+ *
+ * @param handle  Specifies the service record handle
+ *
+ */
+
+typedef void (*OI_SDPDB_CHANGED_RECORD)(OI_UINT32 handle);
+
+/**
+ * A function of this type is called whenever a record in the SDP
+ * database is removed. The handle is still valid when this function
+ * is called.
+ *
+ * @param handle  Specifies the service record handle
+ *
+ */
+
+typedef void (*OI_SDPDB_REMOVING_RECORD)(OI_UINT32 handle);
+
+
+/**
+ * This function requests that a service record be added to the SDP database.
+ * Once added, the service will immediately become visible to the SDP clients.
+ *
+ * @param serviceRecord       Defines the attributes of a service; an SDP service record is an array of attribute ID/value pairs.
+ *
+ * @param serviceRecordHandle Pointer to the buffer where the service record handle will be written once
+ *                            the service record is added. The service record handle is a locally unique handle
+ *                            that can be used to reference a service record when accessing attributes within the
+ *                            service record. This parameter can be NULL if the caller does not need to store the
+ *                            service record handle.
+ *
+ * @return                    OI_OK if the service record is added; error status otherwise, including if the
+ *                            SDP database is full
+ */
+OI_STATUS OI_SDPDB_AddServiceRecord(OI_SDPDB_SERVICE_RECORD const *serviceRecord,
+                                    OI_UINT32 *serviceRecordHandle);
+
+
+/**
+ * This function removes a service record from the SDP database. Once removed, the service will
+ * no longer be visible to the SDP clients.
+ *
+ * @param serviceRecordHandle      Service record handle of the service to be removed
+ *
+ * @return                         OI_OK if the service record was removed; error status otherwise, including
+ *                                 if the service record handle is invalid
+ */
+OI_STATUS OI_SDPDB_RemoveServiceRecord(OI_UINT32 serviceRecordHandle);
+
+
+/**
+ * An application can use the Service Availability attribute to advertise in
+ * the service record if a service is available. This function sets
+ * the value of the Service Availability attribute for a given service. Other
+ * than 0 (meaning not available) and 255 (meaning fully available), the
+ * interpretation of intermediate values is profile/application specific.
+ *
+ * @param serviceRecordHandle   Identifies the service record to which the
+ *                              attribute is to be added.
+ *
+ * @param availability          0 means not available, 255 means 100% available,
+ *                              128 means 50% available etc.
+ *
+ * @return                      OI_OK if the attributes was set; error status
+ *                              if the service record handle is invalid.
+ */
+OI_STATUS OI_SDPDB_SetServiceAvailability(OI_UINT32 serviceRecordHandle,
+                                          OI_UINT8 availability);
+
+/**
+ * This function dynamically sets the attributes on a service record. Memory allocated for the
+ * attributes must not be freed by the caller until the attribute list is
+ * removed from the SDP database by calling OI_SDPDB_RemoveAttributeList().
+ *
+ * @param serviceRecordHandle   Identifies the service record to which the
+ *                              attribute is to be added
+ *
+ * @param attributeList         Pointer to the list of attributes to add
+ *
+ * @param numAttributes         Number of attributes in list
+ *
+ * @return                      OI_OK if the attributes were added; error status
+ *                              otherwise, including if the service record
+ *                              handle is invalid
+ */
+OI_STATUS OI_SDPDB_SetAttributeList(OI_UINT32 serviceRecordHandle,
+                                    OI_SDPDB_ATTRIBUTE const *attributeList,
+                                    OI_UINT16 numAttributes);
+
+/**
+ * This function removes the attribute list previously set by OI_SDPDB_SetAttributeList().
+ *
+ * @param serviceRecordHandle   Identifies the service record that contains the
+ *                              attribute list to be removed.
+ *
+ * @param[out] attributeList    Returns a pointer to the attribute list that was removed;
+ *                              this is the same pointer that was passed in to
+ *                              OI_SDPBP_SetAttributeList(). The caller can now
+ *                              free any memory allocated for this attribute
+ *                              list. The parameter may be NULL if the caller does not need this
+ *                              pointer.
+ *
+ * @param[out] numAttributes    Returns the length of the attribute list that was
+ *                              removed. This parameter can be NULL if the caller does
+ *                              not need this value.
+ */
+OI_STATUS OI_SDPDB_RemoveAttributeList(OI_UINT32 serviceRecordHandle,
+                                       OI_SDPDB_ATTRIBUTE **attributeList,
+                                       OI_UINT16 *numAttributes);
+
+/**
+ * This function copies an attribute list. For example, this may be used in combination with
+ * OI_SDPDB_RemoveAttributeList to copy the returned list into a new list
+ * containing additional attributes. OI_SDPDB_FreeAttributeListElements
+ * must be called when the destination list is no longer needed to release
+ * the memory used.
+ *
+ * @param toList         Destination to which the source attributes are copied; this
+ *                       must point to enough space to include numAttributes attributes.
+ * @param fromList       Specifies the source attribute list.
+ * @param numAttributes  Specifies the number of attributes to copy from the source list into
+ *                       the destination list.
+ */
+OI_STATUS OI_SDPDB_CloneAttributeList(OI_SDPDB_ATTRIBUTE *toList,
+                                      OI_SDPDB_ATTRIBUTE *fromList,
+                                      OI_UINT16 numAttributes);
+
+/**
+ * This function frees memory allocated for data elements in an attribute list. Memory for the
+ * attribute list itself must be freed by the caller.
+ */
+void OI_SDPDB_FreeAttributeListElements(OI_SDPDB_ATTRIBUTE *attributeList,
+                                        OI_UINT16 numAttributes);
+
+/**
+ * This function explicitly sets the browse group list. By default, each time a service record is
+ * created, SDPDB automatically creates a browse group list containing the public
+ * browse group. Applications can override this default with their own browse group
+ * list using this API. This API can also be used to completely remove
+ * a browse group list from the service record.
+ *
+ * @param serviceRecordHandle   Identifies the service record to which the
+ *                              attribute is to be added
+ *
+ * @param groupList             Pointer to the browse group list;
+ *                              NULL pointer will remove the browse group list entirely
+ */
+
+OI_STATUS OI_SDPDB_SetBrowseGroupList(OI_UINT32 serviceRecordHandle,
+                                      const OI_DATAELEM *groupList);
+
+
+/**
+ * This function returns a list of SDP record handles available in the local SDP database.
+ *
+ * @param handleList          Buffer into which the service record handles are written.
+ * @param maxNumHandles       Maximum number of handles that could be returned (@handleList buffer size).
+ * @param numHandlesReturned  Number of SDP record handles written into @handleList.
+ * @param totalNumHandles     Total number of valid record handles in the local SDP database; may be larger than
+ *                            @numHandlesReturned if @handleList is not large enough to hold all the service
+ *                            record handles.
+ * @return                    OI_OK if record handles were successfully retrieved; error status otherwise.
+ *
+ */
+OI_STATUS OI_SDPDB_GetRecordHandles(OI_UINT32 *handleList,
+                                    OI_UINT32 maxNumHandles,
+                                    OI_UINT32 *numHandlesReturned,
+                                    OI_UINT32 *totalNumHandles);
+
+/**
+ * This function returns a list of SDP record handles + the associated Profile UUIDs available in the local SDP database.
+ *
+ * @param recordList          Buffer into which the service record summaries are written.
+ * @param maxNumrecords       Maximum number of record summaries that could be returned (@recordList buffer size).
+ * @param numRecordsReturned  Number of SDP record summaries written into @recordList.
+ * @param totalNumRecords     Total number of valid records in the local SDP database; may be larger than
+ *                            @numRecordsReturned if @RecordList is not large enough to hold all the service
+ *                            record handles.
+ * @return                    OI_OK if record handles were successfully retrieved; error status otherwise.
+ *
+ */
+OI_STATUS OI_SDPDB_GetLocalDBSummary(OI_SDP_SUMMARY_REC *recordList,
+                                     OI_UINT32 maxNumRecords,
+                                     OI_UINT32 *numRecordsReturned,
+                                     OI_UINT32 *totalNumRecords);
+
+/**
+ * This function returns the total number of SDP records available in local SDP database.
+ *
+ * @param totalNumRecords     Total number of valid records in the local SDP database.
+ *
+ * @return                    OI_OK if the request was successful; error status otherwise.
+ *
+ */
+OI_STATUS OI_SDPDB_GetNumServiceRecords(OI_UINT32 *totalNumRecords);
+
+
+/**
+ * This function generates an XML stream for a specified SDP reecord.
+ *
+ * @param recordHandle Indicates the requested record.
+ *
+ * @param pBufferXML  Pointer to a buffer where the generated XML
+ *                    string will be written, with NULL termination.
+ *
+ * @param pBufferSize Pointer to the size of buffer indicated by
+ *                    @pBufferXML. Upon function's return, will
+ *                    contain the actual size of the generated XML
+ *                    string. If the function returns
+ *                    OI_STATUS_NO_RESOURCES, the referenced value
+ *                    will be set to the buffer size required to
+ *                    contain the complete XML output.
+ *
+ * @return            OI_OK if the request was successful; error status
+ *                    otherwise. Error status OI_STATUS_NO_RESOURCES
+ *                    will indicate that the generated XML string did
+ *                    not fit into provided buffer. The buffer will
+ *                    contain the truncated version of XML output. The
+ *                    required total size will be written to
+ *                    @pBufferSize.
+ *
+ * @deprecated        Equivalent to OI_SDPDB_GetRecordAsXML(attr, pBufferXML, pBufferSize, indent, OI_SDPDB_XML_FORMAT_OPENBLUE)
+ */
+OI_STATUS OI_SDPDB_ReadRecordXML( OI_UINT32  recordHandle,
+                                  OI_CHAR   *pBufferXML,
+                                  OI_UINT16 *pBufferSize);
+
+/**
+ * This function generates an XML stream in the requested format for a
+ * specified SDP reecord.
+ *
+ * @param recordHandle Indicates the requested record.
+ *
+ * @param pBufferXML  Pointer to a buffer where the generated XML
+ *                    string will be written, with NULL termination.
+ *
+ * @param pBufferSize Pointer to the size of buffer indicated by
+ *                    @pBufferXML. Upon function's return, will
+ *                    contain the actual size of generated XML
+ *                    string. If the function returns
+ *                    OI_STATUS_NO_RESOURCES, the referenced value
+ *                    will be set to the buffer size required to
+ *                    contain the complete XML output.
+ *
+ * @param format      The XML format to use. Refer to
+ *                    OI_SDPDB_XML_FORMAT for the list of available
+ *                    formats.
+ *
+ * @return            OI_OK if the request was successful; error status
+ *                    otherwise. Error status OI_STATUS_NO_RESOURCES
+ *                    will indicate that the generated XML string did
+ *                    not fit into provided buffer. The buffer will
+ *                    contain the truncated version of XML output. The
+ *                    required total size will be written to
+ *                    @pBufferSize.
+ */
+OI_STATUS OI_SDPDB_GetRecordAsXML( OI_UINT32  recordHandle,
+                                   OI_CHAR   *pBufferXML,
+                                   OI_UINT16 *pBufferSize,
+                                   OI_SDPDB_XML_FORMAT format);
+
+/**
+ * This function generates an XML stream for a specified SDP attribute.
+ *
+ * @param recordHandle Indicates the requested SDP attribute.
+ *
+ * @param pBufferXML   Pointer to a buffer where the generated XML
+ *                     string will be written, with NULL termination.
+ *
+ * @param pBufferSize  Pointer to the size of buffer indicated by
+ *                     @pBufferXML. Upon function's return, will
+ *                     contain the actual size of generated XML
+ *                     string.  If the function returns
+ *                     OI_STATUS_NO_RESOURCES, the referenced value
+ *                     will be set to the buffer size required to
+ *                     contain the complete XML output.
+ *
+ * @param indent       Initial indentaion (spatial offset) of SDP attribute
+ *                     in XML form.
+ *
+ * @return             OI_OK if the request was successful; error status
+ *                     otherwise. Error status OI_STATUS_NO_RESOURCES
+ *                     will indicate that the generated XML string did
+ *                     not fit into provided buffer. The buffer will
+ *                     contain the truncated version of XML
+ *                     output. The required total size will be written
+ *                     to @pBufferSize.
+ *
+ * @deprecated         Equivalent to OI_SDPDB_GetAttributeAsXML(attr, pBufferXML, pBufferSize, indent, OI_SDPDB_XML_FORMAT_OPENBLUE)
+ */
+OI_STATUS OI_SDPDB_ReadAttrXML( OI_SDPDB_ATTRIBUTE *attr,
+                                OI_CHAR            *pBufferXML,
+                                OI_UINT16          *pBufferSize,
+                                OI_UINT8            indent);
+
+/**
+ * This function generates an XML stream in the requested format for a
+ * specified SDP attribute.
+ *
+ * @param recordHandle Indicates the requested SDP attribute.
+ *
+ * @param pBufferXML   Pointer to a buffer where the generated XML
+ *                     string will be written, with NULL termination.
+ *
+ * @param pBufferSize  Pointer to the size of buffer indicated by
+ *                     @pBufferXML. Upon function's return, will
+ *                     contain the actual size of generated XML
+ *                     string. If the function returns
+ *                     OI_STATUS_NO_RESOURCES, the referenced value
+ *                     will be set to the buffer size required to
+ *                     contain the complete XML output.
+ *
+ * @param indent       Initial indentation (spatial offset) of SDP attribute
+ *                     in XML form.
+ *
+ * @param format       The XML format to use.  Refer to
+ *                     OI_SDPDB_XML_FORMAT for the list of available
+ *                     formats.
+ *
+ * @return             OI_OK if the request was successful; error status
+ *                     otherwise. Error status OI_STATUS_NO_RESOURCES
+ *                     will indicate that the generated XML string did
+ *                     not fit into provided buffer. The buffer will
+ *                     contain the truncated version of XML
+ *                     output. The required total size will be written
+ *                     to @pBufferSize.
+ */
+OI_STATUS OI_SDPDB_GetAttributeAsXML( OI_SDPDB_ATTRIBUTE *attr,
+                                      OI_CHAR            *pBufferXML,
+                                      OI_UINT16          *pBufferSize,
+                                      OI_UINT8            indent,
+                                      OI_SDPDB_XML_FORMAT format);
+
+/**
+ * This function sets callback functions that are triggered when the SDP database
+ * is modified.  These callbacks default to NULL, and may be set to NULL or non-NULL
+ * values by this function.
+ *
+ * @param change Pointer to a function that will be called when an SDPDB record
+ *               is added or modified.
+ *
+ * @param remove Pointer to a function that will be called when an SDPDB record
+ *               is removed.
+ */
+void OI_SDPDB_RegisterNotification( OI_SDPDB_CHANGED_RECORD change,
+                                    OI_SDPDB_REMOVING_RECORD remove);
+
+
+
+/*
+ * Lookup service records in the local SBD database that contain the requested UUID
+ *
+ * @param   serviceUUID Service name UUID, 32 bit version
+ * @param   enumerator  Pointer to an integer that keeps track of progress through the
+ *                      database. The caller should set the initial value of *enumerator to zero.
+ *
+ * @return  Value of service record handle, zero if not found.
+ *
+ */
+OI_UINT32 OI_SDPDB_LookupServiceRecord(OI_UUID32 serviceUUID,
+                                       OI_UINT16 *enumerator);
+
+/*
+ * Lookup an attribute in a specific service record in the local SDP database.
+ *
+ * @param   srec        Handle to a service record
+ * @param   attrID      Attribute ID
+ *
+ * @return  Pointer to the matching attribute or NULL if the attribute is not
+ *          found. The caller must not attempt to free the result and must treat the
+ *          attribute as read only.
+ *
+ */
+const OI_DATAELEM *OI_SDPDB_LookupAttribute(OI_UINT32 srec,
+                                            OI_UINT16 attrId);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* _OI_SDPDB_H */
+
diff --git a/obex_profiles/sdk/include/oi_simplemap.h b/obex_profiles/sdk/include/oi_simplemap.h
new file mode 100644
index 0000000..461833e
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_simplemap.h
@@ -0,0 +1,101 @@
+#ifndef _OI_SIMPLEMAP_H
+#define _OI_SIMPLEMAP_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ *  Generic utility for mapping from an arbitrary key to a value.
+ */
+
+#include "oi_stddefs.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Initialize this module
+ */
+void OI_SimpleMap_Init(void);
+
+
+/**
+ * Add an entry. Key values must be unique for a given namespace.
+ *
+ * Note that the namespace is matched by pointer value not a string comparison.
+ *
+ * @param key           The key
+ * @param keyNamespace  The namespace for key
+ * @param value         The value
+ */
+void OI_SimpleMap_Add(const void *key, const OI_CHAR *keyNamespace, void *value);
+
+
+/**
+ * @param key           The key
+ * @param keyNamespace  The namespace of key
+ * @return  The previously mapped value or NULL if there was no such mapping
+ *
+ * Note that the namespace is matched by pointer value not a string comparison.
+ */
+void* OI_SimpleMap_Remove(const void *key, const OI_CHAR *keyNamespace);
+
+
+/**
+ * @param key           The key
+ * @param keyNamespace  The namespace of key
+ * @return  The mapped value or NULL if there is no such mapping
+ *
+ * Note that the namespace is matched by pointer value not a string comparison.
+ */
+void* OI_SimpleMap_Get(const void *key, const OI_CHAR *keyNamespace);
+
+
+/**
+ * Enumerates all keys for the specified namespace
+ *
+ * @param iter          Initialized to pointer to NULL, keeps track of progress
+ * @param keyNamespace  The namespace to iterate over
+ *
+ * @return The next entry or NULL when the map is exhausted
+ */
+const void* OI_SimpleMap_Enum(void **iter, const OI_CHAR *keyNamespace);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* OI_SIMPLEMAP_H */
diff --git a/obex_profiles/sdk/include/oi_status.h b/obex_profiles/sdk/include/oi_status.h
new file mode 100644
index 0000000..63163e5
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_status.h
@@ -0,0 +1,739 @@
+#ifndef _OI_STATUS_H
+#define _OI_STATUS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * This file contains status codes for BLUEmagic 3.0 software.
+ */
+
+#include "oi_stddefs.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * OI_STATUS must fit in 16 bits, so status codes can range from 0 to 66535, inclusive.
+ */
+
+typedef enum {
+    OI_STATUS_SUCCESS                      = 0,   /**< Function call succeeded alias for #OI_OK */
+    OI_OK                                  = 0,   /**< Function call succeeded alias for #OI_STATUS_SUCCESS */
+    OI_STATUS_INVALID_PARAMETERS           = 101, /**< Invalid function input parameters */
+    OI_STATUS_NOT_IMPLEMENTED              = 102, /**< Attempt to use an unimplemented function */
+    OI_STATUS_NOT_INITIALIZED              = 103, /**< Data not initialized */
+    OI_STATUS_NO_RESOURCES                 = 104, /**< Generic resource allocation failure status */
+    OI_STATUS_INTERNAL_ERROR               = 105, /**< Internal inconsistency */
+    OI_STATUS_OUT_OF_MEMORY                = 106, /**< Generally, OI_Malloc failed */
+    OI_ILLEGAL_REENTRANT_CALL              = 107, /**< Violation of non-reentrant module policy */
+    OI_STATUS_INITIALIZATION_FAILED        = 108, /**< Module initialization failed */
+    OI_STATUS_INITIALIZATION_PENDING       = 109, /**< Inititialization not yet complete */
+    OI_STATUS_NO_SCO_SUPPORT               = 110, /**< SCO operation rejected; system not configured for SCO */
+    OI_STATUS_OUT_OF_STATIC_MEMORY         = 111, /**< Static malloc failed */
+    OI_TIMEOUT                             = 112, /**< Generic timeout */
+    OI_OS_ERROR                            = 113, /**< Some operating system error */
+    OI_FAIL                                = 114, /**< Generic failure */
+    OI_STRING_FORMAT_ERROR                 = 115, /**< Error in VarString formatting string */
+    OI_STATUS_PENDING                      = 116, /**< Operation is pending. */
+    OI_STATUS_INVALID_COMMAND              = 117, /**< Command was invalid. */
+    OI_BUSY_FAIL                           = 118, /**< Command rejected due to busy */
+    OI_STATUS_ALREADY_REGISTERED           = 119, /**< Registration has already been performed. */
+    OI_STATUS_NOT_FOUND                    = 120, /**< Referenced resource was not found. */
+    OI_STATUS_NOT_REGISTERED               = 121, /**< Not registered */
+    OI_STATUS_NOT_CONNECTED                = 122, /**< Not connected */
+    OI_CALLBACK_FUNCTION_REQUIRED          = 123, /**< A callback function parameter was required. */
+    OI_STATUS_MBUF_OVERFLOW                = 124, /**< There is no room to add another buffer to an mbuf. */
+    OI_STATUS_MBUF_UNDERFLOW               = 125, /**< There was an attempt to pull too many bytes from an mbuf. */
+    OI_STATUS_CONNECTION_EXISTS            = 126, /**< Connection exists */
+    OI_STATUS_NOT_CONFIGURED               = 127, /**< Module not configured */
+    OI_LOWER_STACK_ERROR                   = 128, /**< An error was reported by lower stack API. This is used for embedded platforms. */
+    OI_STATUS_RESET_IN_PROGRESS            = 129, /**< Request failed/rejected because we're busy resetting. */
+    OI_STATUS_ACCESS_DENIED                = 130, /**< Generic access denied error. */
+    OI_STATUS_DATA_ERROR                   = 131, /**< Generic data error. */
+    OI_STATUS_INVALID_ROLE                 = 132, /**< The requested role was invalid. */
+    OI_STATUS_ALREADY_CONNECTED            = 133, /**< The requested connection is already established. */
+    OI_STATUS_PARSE_ERROR                  = 134, /**< Parse error */
+    OI_STATUS_END_OF_FILE                  = 135, /**< End of file */
+    OI_STATUS_READ_ERROR                   = 136, /**< Generic read error */
+    OI_STATUS_WRITE_ERROR                  = 137, /**< Generic write error */
+    OI_STATUS_NEGOTIATION_FAILURE          = 138, /**< Error in negotiation */
+    OI_STATUS_READ_IN_PROGRESS             = 139, /**< A read is already in progress */
+    OI_STATUS_ALREADY_INITIALIZED          = 140, /**< Initialization has already been done */
+    OI_STATUS_STILL_CONNECTED              = 141, /**< The service cannot be shutdown because there are still active connections. */
+    OI_STATUS_MTU_EXCEEDED                 = 142, /**< The packet is too big */
+    OI_STATUS_LINK_TERMINATED              = 143, /**< The link was terminated */
+    OI_STATUS_PIN_CODE_TOO_LONG            = 144, /**< Application gave us a pin code that is too long */
+    OI_STATUS_STILL_REGISTERED             = 145, /**< The service cannot be shutdown because there are still active registrations. */
+    OI_STATUS_MBUF_NOT_EMPTY               = 146, /**< An mbuf was cleared before it was emptied */
+    OI_STATUS_SPEC_VIOLATION               = 147, /**< Some application behavior contrary to BT specifications */
+    OI_STATUS_TEST_HARNESS                 = 148, /**< Used with OI_SLOG_ERROR Flags the used of a test harness function */
+    OI_STATUS_SOME_Q_ERROR                 = 149, /**< Indeterminite error from some call to external QTI process */
+    OI_STATUS_CONNECTION_COLLISION         = 150, /**< Connection request failed due to race condition between local and remote devices. */
+
+    OI_STATUS_PSM_ALREADY_REGISTERED       = 402, /**< L2CAP: The specified PSM has already been registered. */
+    OI_STATUS_INVALID_CID                  = 403, /**< L2CAP: CID is invalid or no longer valid (connection terminated) */
+    OI_STATUS_CID_NOT_FOUND                = 404, /**< L2CAP: CID does not represent a current connection */
+    OI_STATUS_CHANNEL_NOT_FOUND            = 406, /**< L2CAP: CID does not represent a current connection */
+    OI_STATUS_PSM_NOT_FOUND                = 407, /**< L2CAP: PSM not found */
+    OI_STATUS_INVALID_STATE                = 408, /**< L2CAP: Invalid state */
+    OI_STATUS_WRITE_IN_PROGRESS            = 410, /**< L2CAP: Write in progress */
+    OI_STATUS_INVALID_PACKET               = 411, /**< L2CAP: Invalid packet */
+    OI_STATUS_SEND_COMPLETE                = 412, /**< L2CAP: Send is complete */
+    OI_STATUS_INVALID_HANDLE               = 414, /**< L2CAP: Handle is invalid */
+    OI_STATUS_GROUP_FULL                   = 418, /**< L2CAP: No more members can be added to the specified group. */
+    OI_STATUS_DEVICE_ALREADY_IN_GROUP      = 423, /**< L2CAP: The device already exists in the group. */
+    OI_STATUS_DUPLICATE_GROUP              = 425, /**< L2CAP: Attempt to add more than one group */
+    OI_STATUS_EMPTY_GROUP                  = 426, /**< L2CAP: Group is empty */
+    OI_STATUS_PACKET_NOT_FOUND             = 427, /**< L2CAP: Packet not found */
+    OI_STATUS_BUFFER_TOO_SMALL             = 428, /**< L2CAP: The buffer size is too small. */
+    OI_STATUS_IDENTIFIER_NOT_FOUND         = 429, /**< L2CAP: Identifier not found */
+
+    OI_L2CAP_DISCONNECT_LOWER_LAYER        = 430, /**< L2CAP: The lower level forced a disconnect. */
+    OI_L2CAP_DISCONNECT_REMOTE_REQUEST     = 431, /**< L2CAP: The remote device requested a disconnect. */
+    OI_L2CAP_GROUP_ADD_CONNECT_FAIL        = 433, /**< L2CAP: Group add connect faiL */
+    OI_L2CAP_GROUP_REMOVE_FAILURE          = 434, /**< L2CAP: Group remove failure */
+    OI_L2CAP_DATA_WRITE_ERROR_LINK_TERM    = 435, /**< L2CAP: Data write error LINK_TERM */
+    OI_L2CAP_DISCONNECT_LOCAL_REQUEST      = 436, /**< L2CAP: Disconnect local request */
+
+    OI_L2CAP_CONNECT_TIMEOUT               = 437, /**< L2CAP: Connect timeout */
+    OI_L2CAP_DISCONNECT_TIMEOUT            = 439, /**< L2CAP: Disconnect timeout */
+    OI_L2CAP_PING_TIMEOUT                  = 440, /**< L2CAP: Ping timeout */
+    OI_L2CAP_GET_INFO_TIMEOUT              = 441, /**< L2CAP: Get info timeout */
+    OI_L2CAP_INVALID_ADDRESS               = 444, /**< L2CAP: Invalid address */
+    OI_L2CAP_CMD_REJECT_RCVD               = 445, /**< L2CAP: Remote peer sent us 'command reject' response */
+    OI_L2CAP_PEER_DOES_NOT_SUPPORT_UCD     = 446, /**< L2CAP: Peer does not support Unicast Connectionless Data */
+
+    OI_L2CAP_CONNECT_BASE                  = 450, /**< L2CAP: Connect base */
+    OI_L2CAP_CONNECT_PENDING               = 451, /**< L2CAP: Connect pending */
+    OI_L2CAP_CONNECT_REFUSED_INVALID_PSM   = 452, /**< L2CAP: Connect refused invalid PSM */
+    OI_L2CAP_CONNECT_REFUSED_SECURITY      = 453, /**< L2CAP: Connect refused security */
+    OI_L2CAP_CONNECT_REFUSED_NO_RESOURCES  = 454, /**< L2CAP: Connect refused no resources */
+
+    OI_L2CAP_INVALID_CONNECT_PARAMS        = 456, /**< L2CAP: Invalid connect parameters */
+
+    OI_L2CAP_CONFIG_BASE                   = 460, /**< L2CAP: Config base */
+    OI_L2CAP_CONFIG_FAIL_UNACCEPTABLE      = 461, /**< L2CAP: Config fail unnaccepable parameters */
+    OI_L2CAP_CONFIG_FAIL_REJECTED          = 462, /**< L2CAP: Config fail parameters are rejected */
+    OI_L2CAP_CONFIG_FAIL_UNKNOWN_OPTIONS   = 463, /**< L2CAP: Config fail unknown options */
+    OI_L2CAP_CONFIG_PENDING                = 464, /**< L2CAP: Config pending */
+    OI_L2CAP_CONFIG_FLOW_SPEC_REJECTED     = 465, /**< L2CAP: Config failed flow spec rejected */
+
+    OI_L2CAP_PACKET_FLUSHED                = 467, /**< L2CAP: A packet was flushed */
+    OI_L2CAP_CONTEXT_NOT_SET               = 468, /**< L2CAP: No caller context set on this channel */
+    OI_L2CAP_INVALID_SDU_LENGTH            = 469, /**< L2CAP: length of reassembled SDU was invalid */
+
+    OI_L2CAP_GET_INFO_BASE                 = 470, /**< L2CAP: Get info base */
+    OI_L2CAP_GET_INFO_NOT_SUPPORTED        = 471, /**< L2CAP: Get info not supported */
+    OI_L2CAP_MTU_EXCEEDED                  = 472, /**< L2CAP: The MTU of the channel was exceeded */
+    OI_L2CAP_INVALID_PSM                   = 482, /**< L2CAP: Invalid PSM */
+    OI_L2CAP_INVALID_MTU                   = 483, /**< L2CAP: Invalid MTU */
+    OI_L2CAP_INVALID_FLUSHTO               = 484, /**< L2CAP: Invalid flush timeout */
+    OI_L2CAP_INVALID_CID                   = 485, /**< L2CAP: Invalid CID in received packet */
+    OI_L2CAP_MODE_NOT_SUPPORTED            = 486, /**< L2CAP: requested L2CAP mode is not supported */
+
+    OI_L2CAP_MONITOR_TIMEOUT               = 487, /**< L2CAP: eRTM monitor timeout expired */
+    OI_L2CAP_INVALID_TXSEQ                 = 488, /**< L2CAP: eRTM invalid TxSeq received */
+    OI_L2CAP_INVALID_TX_WINDOW_SIZE        = 489, /**< L2CAP: eRTM invalid txWindow size */
+    OI_L2CAP_INVALID_MAX_PAYLOAD_SIZE      = 490, /**< L2CAP: Invalid max-payload size (eRTM or Streaming mode) */
+    OI_L2CAP_INVALID_REQSEQ                = 491, /**< L2CAP: eRTM invalid ReqSeq received */
+    OI_L2CAP_EXCEEDED_RETRY_COUNT          = 492, /**< L2CAP: eRTM exceeded number of retransmit attempts  */
+    OI_L2CAP_REMOTE_BUSY                   = 493, /**< L2CAP: write failed because the remote device is asserting flow control */
+    OI_L2CAP_REQD_REMOTE_MODE_UNSUPPORTED  = 494, /**< L2CAP: required mode not supported by remote device */
+    OI_L2CAP_MPS_EXCEEDED                  = 495, /**< L2CAP: The MPS (eRTM or Streaming mode) for the channel was exceeded */
+    OI_L2CAP_PROTOCOL_ERROR                = 496, /**< L2CAP: An unspecified protocol error */
+    OI_L2CAP_BAD_FRAME_CHECK_SEQUENCE      = 497, /**< L2CAP: Frame check sequence was bad */
+    OI_L2CAP_INCOMPLETE_SDU                = 498, /**< L2CAP: Received SDU was incomplete */
+    OI_L2CAP_FIXED_CHAN_NOT_SUPPORTED      = 499, /**< L2CAP: Fixed channels not supported */
+
+    OI_L2CAP_MOVE_BASE                     = 500, /**< L2CAP: Base error offset for L2CAP move responses */
+    OI_L2CAP_MOVE_RESULT_TIMEOUT           = 501, /**< L2CAP: Timed out waiting for non-PENDING ressult from remote host */
+    OI_L2CAP_MOVE_REFUSED_SECURITY         = 502, /**< L2CAP: Rejected move for security reasons */
+    OI_L2CAP_MOVE_REFUSED_CONTROLLER       = 503, /**< L2CAP: Rjected move due to bad/unknown controller id */
+    OI_L2CAP_MOVE_REFUSED_SAME_ID          = 504, /**< L2CAP: Rjected move because channel already uses given AMP id */
+    OI_L2CAP_MOVE_CHANNEL_REFUSED_CONFIG   = 505, /**< L2CAP: Rejected move because of conflicting config settings */
+    OI_L2CAP_MOVE_CHANNEL_COLLISION        = 506, /**< L2CAP: Rejected move due to collision with another move request */
+    OI_L2CAP_MOVE_CHANNEL_NOT_ALLOWED      = 507, /**< L2CAP: Rejected move because channel doesn't support move */
+    OI_L2CAP_MOVE_SAME_AMP_ID              = 508, /**< L2CAP: L2CAP channel already associated with specified AMP ID */
+    OI_L2CAP_MOVE_IN_PROGRESS              = 509, /**< L2CAP: Initiate move not allowed because move already in progress */
+    OI_L2CAP_LOCKSTEP_CONFIG_FAIL          = 510, /**< L2CAP: Lockstep config failed */
+
+    OI_HCI_NO_SUCH_CONNECTION               = 601, /**< HCI: Caller specified a non-existent connection handle */
+    OI_HCI_CB_LIST_FULL                     = 603, /**< HCI: Callback list is full, cannot attempt to send command */
+    OI_HCI_EVENT_UNDERRUN                   = 605, /**< HCI: Parsing event packet, premature end-of-parameters */
+    OI_HCI_UNKNOWN_EVENT_CODE               = 607, /**< HCI: Event received - event code is unknown */
+    OI_HCI_BAD_EVENT_PARM_LEN               = 608, /**< HCI: Event - parameter length is incorrect */
+    OI_HCI_CMD_QUEUE_FULL                   = 611, /**< HCI: Command queue is full */
+    OI_HCI_SHORT_EVENT                      = 612, /**< HCI: Event received, missing event code and/or parm len */
+    OI_HCI_TRANSMIT_NOT_READY               = 613, /**< HCI: ACL/SCO transmit request failed - busy or no buffers available */
+    OI_HCI_ORPHAN_SENT_EVENT                = 614, /**< HCI: Got spurious 'sent' event from transport layer */
+    OI_HCI_CMD_TABLE_ERROR                  = 615, /**< HCI: Inconsistency in the internal command table */
+    OI_HCI_UNKNOWN_CMD_ID                   = 616, /**< HCI: HciApi Command - unknown command ID */
+    OI_HCI_UNEXPECTED_EVENT                 = 619, /**< HCI: Event received which only occurs in response to our cmd */
+    OI_HCI_EVENT_TABLE_ERROR                = 620, /**< HCI: Inconsistency in the internal event table */
+    OI_HCI_EXPECTED_EVENT_TIMOUT            = 621, /**< HCI: Timed out waiting for an expected event */
+    OI_HCI_NO_CMD_DESC_FOR_OPCODE           = 622, /**< HCI: Event opcode is not known */
+    OI_HCI_INVALID_OPCODE_ERROR             = 623, /**< HCI: Command opcode is invalid */
+    OI_HCI_FLOW_CONTROL_DISABLED            = 624, /**< HCI: Cannot use host flow control APIs if disabled in configuration */
+    OI_HCI_TX_COMPLETE                      = 625, /**< HCI: Packet delivery to the host cntroller complete */
+    OI_HCI_TX_ERROR                         = 626, /**< HCI: Failed to deliver the packet to the host controller */
+    OI_HCI_DEVICE_NOT_INITIALIZED           = 627, /**< HCI: Commands from upper layers are disallowed until the device is up and running */
+    OI_HCI_UNSUPPORTED_COMMAND              = 628, /**< HCI: Command requested is not supported by local device */
+    OI_HCI_PASSTHROUGH_ERROR                = 629, /**< HCI: Error processing passthrough command */
+    OI_HCI_PASSTHROUGH_ALREADY_SET          = 630, /**< HCI: Passthrough mode already enabled */
+    OI_HCI_RESET_FAILURE                    = 631, /**< HCI: Failed to reset the device/baseband */
+    OI_HCI_TRANSPORT_RESET                  = 632, /**< HCI: Some operation failed because of a reset in the transport */
+    OI_HCI_HCIIFC_INIT_FAILURE              = 633, /**< HCI: failed to initialize the transport layer interface */
+    OI_HCI_RADIO_CLOSING                    = 634, /**< HCI: radio is in process of being closed */
+    OI_HCI_RADIO_CLOSED                     = 635, /**< HCI: radio is closed */
+    OI_HCI_RADIO_REOPEN_TIMEOUT             = 636, /**< HCI: pending command timed out waiting for radio to reopen */
+    OI_HCI_EXPECTED_EVENT_FLUSH             = 637, /**< HCI: expected event flushed due to disconnect */
+    
+
+    OI_HCIERR_FIRST_ERROR_VALUE                = 701, /**< Marker for first HCI protocol error */
+    OI_HCIERR_UNKNOWN_HCI_COMMAND              = 701, /**< HCI: Protocol error 0x01 */
+    OI_HCIERR_NO_CONNECTION                    = 702, /**< HCI: Protocol error 0x02 */
+    OI_HCIERR_HARDWARE_FAILURE                 = 703, /**< HCI: Protocol error 0x03 */
+    OI_HCIERR_PAGE_TIMEOUT                     = 704, /**< HCI: Protocol error 0x04 */
+    OI_HCIERR_AUTHENTICATION_FAILURE           = 705, /**< HCI: Protocol error 0x05 */
+    OI_HCIERR_KEY_MISSING                      = 706, /**< HCI: Protocol error 0x06 */
+    OI_HCIERR_MEMORY_FULL                      = 707, /**< HCI: Protocol error 0x07 */
+    OI_HCIERR_CONNECTION_TIMEOUT               = 708, /**< HCI: Protocol error 0x08 */
+    OI_HCIERR_MAX_NUM_OF_CONNECTIONS           = 709, /**< HCI: Protocol error 0x09 */
+    OI_HCIERR_MAX_NUM_OF_SCO_CONNECTIONS       = 710, /**< HCI: Protocol error 0x0A */
+    OI_HCIERR_ACL_CONNECTION_ALREADY_EXISTS    = 711, /**< HCI: Protocol error 0x0B */
+    OI_HCIERR_COMMAND_DISALLOWED               = 712, /**< HCI: Protocol error 0x0C */
+    OI_HCIERR_HOST_REJECTED_RESOURCES          = 713, /**< HCI: Protocol error 0x0D */
+    OI_HCIERR_HOST_REJECTED_SECURITY           = 714, /**< HCI: Protocol error 0x0E */
+    OI_HCIERR_HOST_REJECTED_PERSONAL_DEVICE    = 715, /**< HCI: Protocol error 0x0F */
+    OI_HCIERR_HOST_TIMEOUT                     = 716, /**< HCI: Protocol error 0x10 */
+    OI_HCIERR_UNSUPPORTED                      = 717, /**< HCI: Protocol error 0x11 */
+    OI_HCIERR_INVALID_PARAMETERS               = 718, /**< HCI: Protocol error 0x12 */
+    OI_HCIERR_OTHER_END_USER_DISCONNECT        = 719, /**< HCI: Protocol error 0x13 */
+    OI_HCIERR_OTHER_END_LOW_RESOURCES          = 720, /**< HCI: Protocol error 0x14 */
+    OI_HCIERR_OTHER_END_POWERING_OFF           = 721, /**< HCI: Protocol error 0x15 */
+    OI_HCIERR_CONNECTION_TERMINATED_LOCALLY    = 722, /**< HCI: Protocol error 0x16 */
+    OI_HCIERR_REPEATED_ATTEMPTS                = 723, /**< HCI: Protocol error 0x17 */
+    OI_HCIERR_PAIRING_NOT_ALLOWED              = 724, /**< HCI: Protocol error 0x18 */
+    OI_HCIERR_UNKNOWN_LMP_PDU                  = 725, /**< HCI: Protocol error 0x19 */
+    OI_HCIERR_UNSUPPORTED_REMOTE_FEATURE       = 726, /**< HCI: Protocol error 0x1A */
+    OI_HCIERR_SCO_OFFSET_REJECTED              = 727, /**< HCI: Protocol error 0x1B */
+    OI_HCIERR_SCO_INTERVAL_REJECTED            = 728, /**< HCI: Protocol error 0x1C */
+    OI_HCIERR_SCO_AIR_MODE_REJECTED            = 729, /**< HCI: Protocol error 0x1D */
+    OI_HCIERR_INVALID_LMP_PARMS                = 730, /**< HCI: Protocol error 0x1E */
+    OI_HCIERR_UNSPECIFIED_ERROR                = 731, /**< HCI: Protocol error 0x1F */
+    OI_HCIERR_UNSUPPORTED_LMP_PARAMETERS       = 732, /**< HCI: Protocol error 0x20 */
+    OI_HCIERR_ROLE_CHANGE_NOT_ALLOWED          = 733, /**< HCI: Protocol error 0x21 */
+    OI_HCIERR_LMP_RESPONSE_TIMEOUT             = 734, /**< HCI: Protocol error 0x22 */
+    OI_HCIERR_LMP_ERROR_TRANS_COLLISION        = 735, /**< HCI: Protocol error 0x23 */
+    OI_HCIERR_LMP_PDU_NOT_ALLOWED              = 736, /**< HCI: Protocol error 0x24 */
+    OI_HCIERR_ENCRYPTION_MODE_NOT_ACCEPTABLE   = 737, /**< HCI: Protocol error 0x25 */
+    OI_HCIERR_UNIT_KEY_USED                    = 738, /**< HCI: Protocol error 0x26 */
+    OI_HCIERR_QOS_NOT_SUPPORTED                = 739, /**< HCI: Protocol error 0x27 */
+    OI_HCIERR_INSTANT_PASSED                   = 740, /**< HCI: Protocol error 0x28 */
+    OI_HCIERR_UNIT_KEY_PAIRING_UNSUPPORTED     = 741, /**< HCI: Protocol error 0x29 */
+    OI_HCIERR_DIFFERENT_TRANS_COLLISION        = 742, /**< HCI: Protocol error 0x2A */
+    OI_HCIERR_RESERVED_2B                      = 743, /**< HCI: Protocol error 0x2B */
+    OI_HCIERR_QOS_UNACCEPTABLE_PARAMETER       = 744, /**< HCI: Protocol error 0x2C */
+    OI_HCIERR_QOS_REJECTED                     = 745, /**< HCI: Protocol error 0x2D */
+    OI_HCIERR_CHANNEL_CLASSIFICATION_NS        = 746, /**< HCI: Protocol error 0x2E */
+    OI_HCIERR_INSUFFICIENT_SECURITY            = 747, /**< HCI: Protocol error 0x2F */
+    OI_HCIERR_PARM_OUT_OF_MANDATORY_RANGE      = 748, /**< HCI: Protocol error 0x30 */
+    OI_HCIERR_RESERVED_31                      = 749, /**< HCI: Protocol error 0x31 */
+    OI_HCIERR_ROLE_SWITCH_PENDING              = 750, /**< HCI: Protocol error 0x32 */
+    OI_HCIERR_RESERVED_33                      = 751, /**< HCI: Protocol error 0x33 */
+    OI_HCIERR_RESERVED_SLOT_VIOLATION          = 752, /**< HCI: Protocol error 0x34 */
+    OI_HCIERR_ROLE_SWITCH_FAILED               = 753, /**< HCI: Protocol error 0x35 */
+    OI_HCIERR_EIR_TOO_LARGE                    = 754, /**< HCI: Protocol error 0x36 */
+    OI_HCIERR_SSP_NOT_SUPPORTED_BY_HOST        = 755, /**< HCI: Protocol error 0x37 */
+    OI_HCIERR_HOST_BUSY_PAIRING                = 756, /**< HCI: Protocol error 0x38 */
+    OI_HCIERR_NO_SUITABLE_CHANNEL              = 757, /**< HCI: Protocol error 0x39 */
+    OI_HCIERR_CONTROLLER_BUSY                  = 758, /**< HCI: Protocol error 0x3A */
+    
+    OI_HCIERR_UNKNOWN_ERROR                    = 759, /**< HCI: Unknown error code */
+    OI_HCIERR_LAST_ERROR_VALUE                 = 759, /**< Marker for last HCI protocol error */
+
+    OI_SDP_SPEC_ERROR                    = 800, /**< SDP: Base error status for mapping OI_STATUS codes to SDP errors */
+    OI_SDP_INVALID_SERVICE_RECORD_HANDLE = 802, /**< SDP: Protocol error invalid service record handle */
+    OI_SDP_INVALID_REQUEST_SYNTAX        = 803, /**< SDP: Protocol error invalid Request syntax */
+    OI_SDP_INVALID_PDU_SIZE              = 804, /**< SDP: Protocol error invalid PDU size */
+    OI_SDP_INVALID_CONTINUATION_STATE    = 805, /**< SDP: Protocol error invalid continuation state */
+    OI_SDP_INSUFFICIENT_RESOURCES        = 806, /**< SDP: Protocol error insufficient resources */
+    OI_SDP_ERROR                         = 807, /**< SDP: Server returned an error code */
+    OI_SDP_CORRUPT_DATA_ELEMENT          = 808, /**< SDP: Invalid or corrupt data element representation */
+    OI_SDP_SERVER_NOT_CONNECTED          = 810, /**< SDP: Attempt to disconnect from an unconnected server */
+    OI_SDP_ACCESS_DENIED                 = 811, /**< SDP: Server denied access to the server */
+    OI_SDP_ATTRIBUTES_OUT_OF_ORDER       = 812, /**< SDP: Attributes in attribute list not in ascending order */
+    OI_SDP_DEVICE_DOES_NOT_SUPPORT_SDP   = 813, /**< SDP: Tried to connect to a device that does not support SDP */
+    OI_SDP_NO_MORE_DATA                  = 815, /**< SDP: Server does not have more continuation data */
+    OI_SDP_REQUEST_PARAMS_TOO_LONG       = 816, /**< SDP: Parameters for a request exceed the L2CAP buffer size */
+    OI_SDP_REQUEST_PENDING               = 817, /**< SDP: Cannot make a request when another request is being processed */
+    OI_SDP_SERVER_CONNECT_FAILED         = 819, /**< SDP: Failed attempt to connect to an SDP server */
+    OI_SDP_SERVER_TOO_MANY_CONNECTIONS   = 821, /**< SDP: Exceeded maximum number of simultaneous server connections */
+    OI_SDP_NO_MATCHING_SERVICE_RECORD    = 823, /**< SDP: No service record matched the UUID list */
+    OI_SDP_PARTIAL_RESPONSE              = 824, /**< SDP: Internal use only */
+    OI_SDP_ILLEGAL_ARGUMENT              = 825, /**< SDP: Illegal argument passed to an SDP function */
+    OI_SDP_ATTRIBUTE_NOT_FOUND           = 826, /**< SDP: Requested attribute was not found in a service record */
+    OI_SDP_DATABASE_OUT_OF_RESOURCES     = 827, /**< SDP: Server database is out of memory */
+    OI_SDP_SHORT_PDU                     = 829, /**< SDP: Not enough bytes in the packet */
+    OI_SDP_TRANSACTION_ID_MISMATCH       = 830, /**< SDP: Transaction ID was not as expected */
+    OI_SDP_UNEXPECTED_RESPONSE_PDU_ID    = 831, /**< SDP: Did not expect this response PDU */
+    OI_SDP_REQUEST_TIMEOUT               = 832, /**< SDP: Did not get a response within the timeout period */
+    OI_SDP_INVALID_RESPONSE_SYNTAX       = 833, /**< SDP: Response is not correctly formatted */
+    OI_SDP_CONNECTION_TIMEOUT            = 834, /**< SDP: Connection attempt timed out at a lower layer */
+    OI_SDP_RESPONSE_DATA_ERROR           = 835, /**< SDP: Response to a service request appears to be corrupt */
+    OI_SDP_TOO_MANY_ATTRIBUTE_BYTES      = 836, /**< SDP: Response contained more bytes than requested. */
+    OI_SDP_TOO_MANY_SERVICE_RECORDS      = 837, /**< SDP: Response contained more service records than requested. */
+    OI_SDP_INVALID_CONNECTION_ID         = 838, /**< SDP: Invalid connection ID in an SDP request */
+    OI_SDP_CANNOT_SET_ATTRIBUTE          = 839, /**< SDP: Attempt to set a dynamic attribute value failed */
+    OI_SDP_BADLY_FORMED_ATTRIBUTE_VALUE  = 840, /**< SDP: An attribute value has the wrong type or structure */
+    OI_SDP_NO_ATTRIBUTE_LIST_TO_REMOVE   = 841, /**< SDP: Attempt to remove a nonexistent attribute list from a service record */
+    OI_SDP_ATTRIBUTE_LIST_ALREADY_ADDED  = 842, /**< SDP: An attribute list has already been added to the service record */
+    OI_SDP_DATA_ELEMENT_TRUNCATED        = 843, /**< SDP: Data element truncated (too few bytes) */
+
+    OI_RFCOMM_WRITE_IN_PROGRESS          = 901, /**< RFCOMM: Write in progress */
+    OI_RFCOMM_INVALID_BAUDRATE           = 903, /**< RFCOMM: Invalid baudrate */
+    OI_RFCOMM_INVALID_DATABIT            = 904, /**< RFCOMM: Invalid databit */
+    OI_RFCOMM_INVALID_STOPBIT            = 905, /**< RFCOMM: Invalid stopbit */
+    OI_RFCOMM_INVALID_PARITY             = 906, /**< RFCOMM: Invalid parity */
+    OI_RFCOMM_INVALID_PARITYTYPE         = 907, /**< RFCOMM: Invalid paritytype */
+    OI_RFCOMM_INVALID_FLOWCONTROL        = 908, /**< RFCOMM: Invalid flowcontrol */
+    OI_RFCOMM_SESSION_EXISTS             = 909, /**< RFCOMM: Session exists */
+    OI_RFCOMM_INVALID_CHANNEL            = 910, /**< RFCOMM: Invalid channel */
+    OI_RFCOMM_DLCI_EXISTS                = 911, /**< RFCOMM: DLCI exists */
+    OI_RFCOMM_LINK_NOT_FOUND             = 912, /**< RFCOMM: Link not found */
+    OI_RFCOMM_REMOTE_REJECT              = 913, /**< RFCOMM: Remote reject */
+    OI_RFCOMM_TEST_IN_PROGRESS           = 915, /**< RFCOMM: Test in progress */
+    OI_RFCOMM_SESSION_NOT_FOUND          = 916, /**< RFCOMM: Session not found */
+    OI_RFCOMM_INVALID_PACKET             = 917, /**< RFCOMM: Invalid packet */
+    OI_RFCOMM_FRAMESIZE_EXCEEDED         = 918, /**< RFCOMM: Framesize exceeded */
+    OI_RFCOMM_INVALID_DLCI               = 920, /**< RFCOMM: Invalid DLCI */
+    OI_RFCOMM_SERVER_NOT_REGISTERED      = 921, /**< RFCOMM: Server not registered */
+    OI_RFCOMM_CREDIT_ERROR               = 922, /**< RFCOMM: Credit error */
+    OI_RFCOMM_NO_CHANNEL_NUMBER          = 923, /**< RFCOMM: No channel number */
+    OI_RFCOMM_QUERY_IN_PROGRESS          = 924, /**< RFCOMM: Query in progress */
+    OI_RFCOMM_SESSION_SHUTDOWN           = 925, /**< RFCOMM: Session shutdown */
+    OI_RFCOMM_LOCAL_DEVICE_DISCONNECTED  = 926, /**< RFCOMM: Local device disconnected */
+    OI_RFCOMM_REMOTE_DEVICE_DISCONNECTED = 927, /**< RFCOMM: Remote device disconnected */
+    OI_RFCOMM_OUT_OF_SERVER_CHANNELS     = 928, /**< RFCOMM: Out of server channels */
+
+    OI_DISPATCH_INVALID_CB_HANDLE        = 1001, /**< Dispatcher was handed an invalid callback handle */
+    OI_DISPATCH_TABLE_OVERFLOW           = 1002, /**< Dispatcher table is full */
+
+    OI_TEST_UNKNOWN_TEST                 = 1101, /**< TEST: Unknown test */
+    OI_TEST_FAIL                         = 1102, /**< TEST: Fail */
+
+    OI_HCITRANS_CANNOT_CONNECT_TO_DEVICE   = 1201, /**< TRANSPORT: Cannot connect to the device */
+    OI_HCITRANS_BUFFER_TOO_SMALL           = 1203, /**< TRANSPORT: Buffer too small */
+    OI_HCITRANS_NULL_DEVICE_HANDLE         = 1204, /**< TRANSPORT: Null device handle */
+    OI_HCITRANS_IO_ERROR                   = 1205, /**< TRANSPORT: IO error */
+    OI_HCITRANS_DEVICE_NOT_READY           = 1206, /**< TRANSPORT: Device not ready */
+    OI_HCITRANS_FUNCTION_NOT_SUPPORTED     = 1207, /**< TRANSPORT: Function not supported */
+    OI_HCITRANS_ACCESS_DENIED              = 1209, /**< TRANSPORT: win32 */
+    OI_HCITRANS_ACL_DATA_ERROR             = 1210, /**< TRANSPORT: ACL data error */
+    OI_HCITRANS_SCO_DATA_ERROR             = 1211, /**< TRANSPORT: SCO data error */
+    OI_HCITRANS_EVENT_DATA_ERROR           = 1212, /**< TRANSPORT: HCI event data error */
+    OI_HCITRANS_INTERNAL_ERROR             = 1214, /**< TRANSPORT: Internal error in the transport */
+    OI_HCITRANS_LINK_NOT_ACTIVE            = 1215, /**< TRANSPORT: Link to the device is not currently active */
+    OI_HCITRANS_INITIALIZING               = 1216, /**< TRANSPORT: Transport is initializing */
+    OI_HCITRANS_TOO_MANY_DEVICES           = 1217, /**< TRANSPORT: Too many open devices */
+    OI_HCITRANS_INVALID_HANDLE             = 1218, /**< TRANSPORT: Invalid transport handle specified */
+    OI_HCITRANS_INVALID_DATA               = 1219, /**< TRANSPORT: Invalid data packet specified */
+    OI_HCITRANS_TOO_MANY_PHYS_LINKS        = 1220, /**< TRANSPORT: Too many physical links for device */
+    OI_HCITRANS_TOO_MANY_LOGICAL_LINKS     = 1221, /**< TRANSPORT: Too many logical links for device */
+    OI_HCITRANS_ALREADY_OPEN               = 1222, /**< TRANSPORT: Can't open transport, already open */
+
+    OI_DEVMGR_NO_CONNECTION                = 1301, /**< DEVMGR: No connection */
+    OI_DEVMGR_HARDWARE_ERROR               = 1305, /**< DEVMGR: Error reported by HCI */
+    OI_DEVMGR_PENDING_CONNECT_LIST_FULL    = 1307, /**< DEVMGR: Pending connect list full */
+    OI_DEVMGR_CONNECTION_LIST_FULL         = 1309, /**< DEVMGR: Connection list full */
+    OI_DEVMGR_NO_SUCH_CONNECTION           = 1310, /**< DEVMGR: No such connection */
+    OI_DEVMGR_INQUIRY_IN_PROGRESS          = 1311, /**< DEVMGR: Inquiry in progress */
+    OI_DEVMGR_PERIODIC_INQUIRY_ACTIVE      = 1312, /**< DEVMGR: Periodic inquiry active */
+    OI_DEVMGR_NO_INQUIRIES_ACTIVE          = 1313, /**< DEVMGR: Cannot cancel/exit if not active */
+    OI_DEVMGR_DUPLICATE_CONNECTION         = 1314, /**< DEVMGR: Internal error */
+    OI_DEVMGR_DUPLICATE_EVENT_CALLBACK     = 1316, /**< DEVMGR: Attempt to register same callback twice */
+    OI_DEVMGR_EVENT_CALLBACK_LIST_FULL     = 1317, /**< DEVMGR: Can not register event callback, list is full */
+    OI_DEVMGR_EVENT_CALLBACK_NOT_FOUND     = 1318, /**< DEVMGR: Attempt to unregister callback failed */
+    OI_DEVMGR_BUSY                         = 1319, /**< DEVMGR: Some operations can only execute one at a time */
+    OI_DEVMGR_ENUM_UNEXPECTED_INQ_COMPLETE = 1320, /**< DEVMGR: Inquiry complete event in inappropriate enumeration state */
+    OI_DEVMGR_ENUM_UNEXPECTED_INQ_RESULT   = 1321, /**< DEVMGR: Inquiry result event in inappropriate enumeration state */
+    OI_DEVMGR_ENUM_DATABASE_FULL           = 1322, /**< DEVMGR: Device enumeration, database is full, could not add a new device */
+    OI_DEVMGR_ENUM_INQUIRIES_OVERLAP       = 1323, /**< DEVMGR: Device enumeration, periodic inquiries occurring too close together */
+    OI_DEVMGR_UNKNOWN_LINK_TYPE            = 1324, /**< DEVMGR: HCI connect request with unknown link type */
+    OI_DEVMGR_PARAM_IO_ACTIVE              = 1325, /**< DEVMGR: Request for parameter read/write while parameter read/write is active */
+    OI_DEVMGR_UNKNOWN_IAC_LAP              = 1326, /**< DEVMGR: Unrecognized IAC LAP */
+    OI_DEVMGR_SCO_ALREADY_REGISTERED       = 1327, /**< DEVMGR: Only one application can use SCO */
+    OI_DEVMGR_SCO_NOT_REGISTERED           = 1328, /**< DEVMGR: SCO applications must register before using the API */
+    OI_DEVMGR_SCO_WITHOUT_ACL              = 1329, /**< DEVMGR: Got SCO connection but there is no underlying ACL connection */
+    OI_DEVMGR_NO_SUPPORT                   = 1330, /**< DEVMGR: Request is not supported by the device */
+    OI_DEVMGR_WRITE_POLICY_FAILED          = 1331, /**< DEVMGR: Connection attempt failed - unable to write the link policy */
+    OI_DEVMGR_NOT_IN_MASTER_MODE           = 1332, /**< DEVMGR: OI_DEVMGR EndMasterMode without prior OI_DEVMGR_BeginMasterMode */
+    OI_DEVMGR_POLICY_VIOLATION             = 1333, /**< DEVMGR: Low-power request is rejected - link policy does not allow it */
+    OI_DEVMGR_BUSY_TIMEOUT                 = 1334, /**< DEVMGR: Queued operation timed out while in the queue; \n
+        timeout is configurable via @ref OI_CONFIG_DEVMGR::connectQueueTimeoutSecs "connectQueueTimeoutSecs" */
+    OI_DEVMGR_REENCRYPT_FAILED             = 1335, /**< DEVMGR: Failed to re-encrypt the link after role switch */
+    OI_DEVMGR_ROLE_POLICY_CONFLICT         = 1336, /**< DEVMGR: Requested role conflicts with the current policy */
+    OI_DEVMGR_BAD_INTERVAL                 = 1337, /**< DEVMGR: Current linkTO outside range of requested min/max interval */
+    OI_DEVMGR_INVALID_SCO_HANDLE           = 1338, /**< DEVMGR: HCI SCO event, invalid handle */
+    OI_DEVMGR_CONNECTION_OVERLAP           = 1339, /**< DEVMGR: Connection failed due to a race condition with the remote side */
+    OI_DEVMGR_ORPHAN_SUBRATE_COMPLETE      = 1340, /**< DEVMGR: Sniff subrate complete, but no callback */
+    OI_DEVMGR_EIR_RESPONSE_2_LARGE         = 1341, /**< DEVMGR: EIR builder, response length would exceed maximum specification  */
+    OI_DEVMGR_NOT_PAGING                   = 1342, /**< DEVMGR: OI_DEVMGR_CancelPaging(), no paging in progress */
+
+    OI_SECMGR_NO_POLICY                    = 1401, /**< SECMGR: No security policy has been established */
+    OI_SECMGR_INTERNAL_ERROR               = 1402, /**< SECMGR: Internal inconsistency */
+    OI_SECMGR_ORPHANED_CALLBACK            = 1403, /**< SECMGR: We've been called back, but CB context is gone */
+    OI_SECMGR_BUSY                         = 1404, /**< SECMGR: Configure and access request cannot be concurrent */
+    OI_SECMGR_DEVICE_NOT_TRUSTED           = 1405, /**< SECMGR: L2CAP access denied - device is not trusted */
+    OI_SECMGR_DEVICE_ENCRYPT_FAIL          = 1407, /**< SECMGR: L2CAP access denied - failed to start encryption */
+    OI_SECMGR_DISCONNECTED_FAIL            = 1408, /**< SECMGR: L2CAP access denied - disconnected */
+    OI_SECMGR_ACCESS_PENDING               = 1409, /**< SECMGR: L2CAP access request is still pending  */
+    OI_SECMGR_PIN_CODE_TOO_SHORT           = 1410, /**< SECMGR: Higher layer process gave us a pin code that is too short */
+    OI_SECMGR_UNKNOWN_ENCRYPT_VALUE        = 1411, /**< SECMGR: Got EncryptionChange event, unknown encryption enable value */
+    OI_SECMGR_INVALID_POLICY               = 1412, /**< SECMGR: Specified security policy is not valid for the security mode */
+    OI_SECMGR_AUTHORIZATION_FAILED         = 1413, /**< SECMGR: Device authorization failed */
+    OI_SECMGR_ENCRYPTION_FAILED            = 1414, /**< SECMGR: Device encryption failed */
+    OI_SECMGR_UNIT_KEY_UNSUPPORTED         = 1415, /**< SECMGR: Authentication failed due to non-support of unit keys */
+    OI_SECMGR_NOT_REGISTERED               = 1416, /**< SECMGR: Required registrations have not yet occurred */
+    OI_SECMGR_ILLEGAL_WRITE_SSP_MODE       = 1417, /**< SECMGR: 2.1 HCI spec does not allow SSP mode to be disabled */
+    OI_SECMGR_INVALID_SEC_LEVEL            = 1418, /**< SECMGR: Security level for a service is not a valid value */
+    OI_SECMGR_INSUFFICIENT_LINK_KEY        = 1419, /**< SECMGR: Link key type is not sufficient to meet the service requirements */
+    OI_SECMGR_INVALID_KEY_TYPE             = 1420, /**< SECMGR: Link key type is not a valid value */
+    OI_SECMGR_SSP_NOT_ENCRYPTED            = 1421, /**< SECMGR: SSP required encryption on the incoming link */
+    OI_SECMGR_ORPHAN_EVENT                 = 1422, /**< SECMGR: Some HCI security event unrelated to current processes */
+    OI_SECMGR_NOT_BONDABLE                 = 1423, /**< SECMGR: Not in bondable mode */
+    OI_SECMGR_NO_CONNECT_REC               = 1424, /**< SECMGR: Missing connection record */ 
+    OI_SECMGR_INSUFFCIENT_ENCRYPT_KEY      = 1425, /**< SECMGR: Encryption key length does not satisfy policy requirements */ 
+    OI_SECMGR_UNKNOWN_ENCRYPT_KEY_LEN      = 1426, /**< SECMGR: Encryption key length cannot be retrieved */
+    OI_SECMGR_AUTH_REQ_NOT_AVAIL           = 1427, /**< SECMGR: authentication requirements not available */
+
+    OI_TCS_INVALID_ELEMENT_TYPE            = 1602, /**< TCS: Element type is invalid */
+    OI_TCS_INVALID_PACKET                  = 1603, /**< TCS: Packet is invalid */
+    OI_TCS_CALL_IN_PROGRESS                = 1604, /**< TCS: Call is in progress */
+    OI_TCS_NO_CALL_IN_PROGRESS             = 1605, /**< TCS: No call in progress */
+
+    OI_OBEX_CONTINUE                       = 1701, /**< OBEX: Continue processing OBEX request */
+    OI_OBEX_COMMAND_ERROR                  = 1702, /**< OBEX: An unrecognized OBEX command opcode */
+    OI_OBEX_CONNECTION_TIMEOUT             = 1703, /**< OBEX: Timeout waiting for a response to a request */
+    OI_OBEX_CONNECT_FAILED                 = 1704, /**< OBEX: An OBEX connection request did not succeed */
+    OI_OBEX_DISCONNECT_FAILED              = 1705, /**< OBEX: A disconnect failed probably because the connection did not exist */
+    OI_OBEX_ERROR                          = 1706, /**< OBEX: Unspecified OBEX error */
+    OI_OBEX_INCOMPLETE_PACKET              = 1707, /**< OBEX: Packet too short or corrupt */
+    OI_OBEX_LENGTH_REQUIRED                = 1708, /**< OBEX: Length header required in OBEX command */
+    OI_OBEX_NOT_CONNECTED                  = 1709, /**< OBEX: No connection to OBEX server */
+    OI_OBEX_NO_MORE_CONNECTIONS            = 1710, /**< OBEX: Reached maximum connections limit */
+    OI_OBEX_OPERATION_IN_PROGRESS          = 1711, /**< OBEX: Another operation is still in progress on a connection */
+    OI_OBEX_PUT_RESPONSE_ERROR             = 1712, /**< OBEX: An error in the response to a PUT command */
+    OI_OBEX_GET_RESPONSE_ERROR             = 1713, /**< OBEX: An error in the response to a GET command */
+    OI_OBEX_REQUIRED_HEADER_NOT_FOUND      = 1714, /**< OBEX: Packet was missing a required header */
+    OI_OBEX_SERVICE_UNAVAILABLE            = 1715, /**< OBEX: Unknown OBEX target or required service */
+    OI_OBEX_TOO_MANY_HEADER_BYTES          = 1716, /**< OBEX: Headers will not fit in single OBEX packet */
+    OI_OBEX_UNKNOWN_COMMAND                = 1717, /**< OBEX: Unrecognized OBEX command */
+    OI_OBEX_UNSUPPORTED_VERSION            = 1718, /**< OBEX: Version mismatch */
+    OI_OBEX_CLIENT_ABORTED_COMMAND         = 1719, /**< OBEX: Server received abort command */
+    OI_OBEX_BAD_PACKET                     = 1720, /**< OBEX: Any malformed OBEX packet */
+    OI_OBEX_BAD_REQUEST                    = 1721, /**< OBEX: Maps to OBEX response of the same name */
+    OI_OBEX_OBJECT_OVERFLOW                = 1723, /**< OBEX: Too many bytes received. */
+    OI_OBEX_NOT_FOUND                      = 1724, /**< OBEX: Maps to OBEX response of the same name */
+    OI_OBEX_ACCESS_DENIED                  = 1735, /**< OBEX: Object could not be read or written. */
+    OI_OBEX_VALUE_NOT_ACCEPTABLE           = 1736, /**< OBEX: Value in a command was not in the acceptable range. */
+    OI_OBEX_PACKET_OVERFLOW                = 1737, /**< OBEX: Buffer will not fit in a single OBEX packet. */
+    OI_OBEX_NO_SUCH_FOLDER                 = 1738, /**< OBEX: Error returned by a setpath operation. */
+    OI_OBEX_NAME_REQUIRED                  = 1739, /**< OBEX: Name must be non-null and non-empty. */
+    OI_OBEX_PASSWORD_TOO_LONG              = 1740, /**< OBEX: Password exceeds implementation imposed length limit. */
+    OI_OBEX_PRECONDITION_FAILED            = 1741, /**< OBEX: Response precondition failed */
+    OI_OBEX_UNAUTHORIZED                   = 1742, /**< OBEX: Authentication was not successful. */
+    OI_OBEX_NOT_IMPLEMENTED                = 1743, /**< OBEX: Unimplemented feature. */
+    OI_OBEX_INVALID_AUTH_DIGEST            = 1744, /**< OBEX: An authentication digest was bad. */
+    OI_OBEX_INVALID_OPERATION              = 1745, /**< OBEX: Operation not allowed at this time. */
+    OI_OBEX_DATABASE_FULL                  = 1746, /**< OBEX: Sync database full. */
+    OI_OBEX_DATABASE_LOCKED                = 1747, /**< OBEX: Sync database locked. */
+    OI_OBEX_INTERNAL_SERVER_ERROR          = 1748, /**< OBEX: Response internal Server Error */
+    OI_OBEX_UNSUPPORTED_MEDIA_TYPE         = 1749, /**< OBEX: Response unsupported media type */
+    OI_OBEX_PARTIAL_CONTENT                = 1750, /**< OBEX: Response partial content */
+    OI_OBEX_METHOD_NOT_ALLOWED             = 1751, /**< OBEX: Response method not allowed */
+    OI_OBEXSRV_INCOMPLETE_GET              = 1752, /**< OBEX: Indicates to a GET handler that the request phase is still in progress */
+    OI_OBEX_FOLDER_BROWSING_NOT_ALLOWED    = 1753, /**< OBEX: Indicates that an FTP server does not allow folder browsing */
+    OI_OBEX_SERVER_FORCED_DISCONNECT       = 1754, /**< OBEX: Connection was forcibly terminated by the server */
+    OI_OBEX_OFS_ERROR                      = 1755, /**< OBEX: OPP object file system error occurred */
+    OI_OBEX_FILEOP_ERROR                   = 1756, /**< OBEX: FTP/PBAP file operation system error occurred */
+    OI_OBEX_USERID_TOO_LONG                = 1757, /**< OBEX: User ID length exceeds the specification limit. */
+    OI_OBEX_CONFLICT                       = 1758, /**< OBEX: Maps to OBEX response of the same name. */
+    OI_OBEX_NOT_READY                      = 1759, /**< OBEX: Bulk PUT operation is busy, no more puts allowed at this time. */
+    OI_OBEX_NOT_MODIFIED                   = 1760, /**< OBEX: Maps to OBEX response of the same name */
+    OI_OBEX_FORBIDDEN                      = 1761, /**< OBEX: Maps to OBEX response of the same name */
+    OI_OBEX_CLEANUP                        = 1762, /**< OBEX: Indicates to upper layer that data can be cleaned up */
+    OI_OBEX_CONNECT_IN_PROGRESS            = 1763, /**< OBEX: In the process of establishing service connection to remote device */
+
+    OI_HANDSFREE_EVENT_REPORTING_DISABLED  = 1801, /**< HANDSFREE: Event reporting disabled */
+    OI_HANDSFREE_NOT_CONNECTED             = 1802, /**< HANDSFREE: Not connected */
+    OI_HANDSFREE_SERVICE_NOT_STARTED       = 1803, /**< HANDSFREE: Cannot connect to handsfree AG if handsfree service is not started */
+    OI_HANDSFREE_AG_SERVICE_NOT_STARTED    = 1804, /**< HANDSFREE: Cannot connect to handsfree device if handsfree AG service is not started */
+    OI_HANDSFREE_COMMAND_IN_PROGRESS       = 1805, /**< HANDSFREE: Cannot accept a command at this time */
+    OI_HANDSFREE_AUDIO_ALREADY_CONNECTED   = 1806, /**< HANDSFREE: Audio is already connected */
+    OI_HANDSFREE_AUDIO_NOT_CONNECTED       = 1807, /**< HANDSFREE: Audio is not connected */
+    OI_HANDSFREE_FEATURE_NOT_SUPPORTED     = 1808, /**< HANDSFREE: Local or remote feature is not supported for the requested command */
+    OI_HANDSFREE_QUERY_NO_RECORD           = 1809, /**< HANDSFREE: info_query, failed to find remote SDP service record */
+    OI_HANDSFREE_QUERY_NO_VERSION          = 1810, /**< HANDSFREE: info_query, remote service record was missing profile version attribute */
+    OI_HANDSFREE_QUERY_NO_FEATURES         = 1811, /**< HANDSFREE: info_query, remote service record was missing supported features attribute */
+
+    OI_HEADSET_SERVICE_NOT_STARTED         = 1901, /**< HEADSET: Cannot connect to headset AG if the headset service is not started */
+    OI_HEADSET_AG_SERVICE_NOT_STARTED      = 1902, /**< HEADSET: Cannot connect to headset device if the headset AG service is not started */
+    OI_HEADSET_COMMAND_IN_PROGRESS         = 1903, /**< HEADSET: Cannot accept a command at this time */
+
+    OI_BNEP_INVALID_MTU                             = 2001, /**< BNEP: The remote device cannot support the minimum BNEP MTU */
+    OI_BNEP_SETUP_TIMEOUT                           = 2002, /**< BNEP: The setup request timed out. */
+    OI_BNEP_SERVICE_NOT_REGISTERED                  = 2003, /**< BNEP: The requested service was not found. */
+    OI_BNEP_INVALID_HANDLE                          = 2004, /**< BNEP: The specified connection handle is not valid. */
+    OI_BNEP_RESPONSE_TIMEOUT                        = 2005, /**< BNEP: The timer for receiving a response has expired. */
+    OI_BNEP_INVALID_CONNECTION                      = 2006, /**< BNEP: Invalid connection */
+    OI_BNEP_INVALID_FILTER                          = 2007, /**< BNEP: The supplied filter was invalid. */
+    OI_BNEP_CONNECTION_EXISTS                       = 2008, /**< BNEP: An attempt was made to create a duplicate connection. */
+    OI_BNEP_NOT_INITIALIZED                         = 2009, /**< BNEP: Init has not been called */
+    OI_BNEP_CONNECT_BASE                            = 2010, /**< BNEP: Connection response codes */
+    OI_BNEP_CONNECT_FAILED_INVALID_DEST_UUID        = 2011, /**< BNEP: Connect response code - invalid destination UUID */
+    OI_BNEP_CONNECT_FAILED_INVALID_SOURCE_UUID      = 2012, /**< BNEP: Connect response code - invalid source UUID */
+    OI_BNEP_CONNECT_FAILED_INVALID_UUID_SIZE        = 2013, /**< BNEP: Connect response code - invalid UUID size */
+    OI_BNEP_CONNECT_FAILED_NOT_ALLOWED              = 2014, /**< BNEP: Connect response code - not allowed */
+    OI_BNEP_FILTER_NET_BASE                         = 2020, /**< BNEP: Filter response codes */
+    OI_BNEP_FILTER_NET_UNSUPPORTED_REQUEST          = 2021, /**< BNEP: Filter response code - unsupported request */
+    OI_BNEP_FILTER_NET_FAILED_INVALID_PROTOCOL_TYPE = 2022, /**< BNEP: Filter response code - invalid protocol type */
+    OI_BNEP_FILTER_NET_FAILED_MAX_LIMIT_REACHED     = 2023, /**< BNEP: Filter response code - maximum limit reached */
+    OI_BNEP_FILTER_NET_FAILED_SECURITY              = 2024, /**< BNEP: Filter response code - security */
+    OI_BNEP_FILTER_MULTI_BASE                       = 2030, /**< BNEP: Multicast response codes */
+    OI_BNEP_FILTER_MULTI_UNSUPPORTED_REQUEST        = 2031, /**< BNEP: Multicast response code - unsupported request */
+    OI_BNEP_FILTER_MULTI_FAILED_INVALID_ADDRESS     = 2032, /**< BNEP: Multicast response code - invalid address */
+    OI_BNEP_FILTER_MULTI_FAILED_MAX_LIMIT_REACHED   = 2033, /**< BNEP: Multicast response code - maximum limit reached */
+    OI_BNEP_FILTER_MULTI_FAILED_SECURITY            = 2034, /**< BNEP: Multicast response code - security */
+    OI_BNEP_LOCAL_DEVICE_MUST_BE_MASTER             = 2040, /**< BNEP: Device must be master of the piconet for this function */
+    OI_BNEP_PACKET_FILTERED_OUT                     = 2041, /**< BNEP: Packet did not pass current filters */
+
+    OI_NETIFC_UP_FAILED                    = 2101, /**< NETIFC: Could not bring up network interface */
+    OI_NETIFC_COULD_NOT_CREATE_THREAD      = 2102, /**< NETIFC: Network interface could not create a read thread */
+    OI_NETIFC_INITIALIZATION_FAILED        = 2103, /**< NETIFC: Error in network interface initialization */
+    OI_NETIFC_INTERFACE_ALREADY_UP         = 2104, /**< NETIFC: Network interface is already up */
+    OI_NETIFC_INTERFACE_NOT_UP             = 2105, /**< NETIFC: Network interface is not up */
+    OI_NETIFC_PACKET_TOO_BIG               = 2106, /**< NETIFC: The packet is too big */
+
+    OI_PAN_ROLE_ALREADY_REGISTERED         = 2201, /**< PAN: This PAN role was already registered */
+    OI_PAN_ROLE_NOT_ALLOWED                = 2202, /**< PAN: The PAN role is not currently allowed */
+    OI_PAN_INCOMPATIBLE_ROLES              = 2203, /**< PAN: Only certain local and remote role combinations are permitted */
+    OI_PAN_INVALID_ROLE                    = 2204, /**< PAN: Role specified is not one the defined PAN roles */
+    OI_PAN_CONNECTION_IN_PROGRESS          = 2205, /**< PAN: A PAN connection is currently being established */
+    OI_PAN_USER_ALREADY_CONNECTED          = 2206, /**< PAN: PAN user role only allows a single connection */
+    OI_PAN_DEVICE_CONNECTED                = 2207, /**< PAN: A PAN connection already exists to the specified device */
+
+    OI_CODEC_SBC_NO_SYNCWORD               = 2301, /**< CODEC: Could not find an SBC SYNCWORD */
+    OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA    = 2302, /**< CODEC: Not enough data provided to decode an SBC header */
+    OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA      = 2303, /**< CODEC: Decoded the header, but not enough data to contain the rest of the frame */
+    OI_CODEC_SBC_NOT_ENOUGH_AUDIO_DATA     = 2304, /**< CODEC: Not enough audio data for this frame */
+    OI_CODEC_SBC_CHECKSUM_MISMATCH         = 2305, /**< CODEC: The frame header did not match the checksum */
+    OI_CODEC_SBC_PARTIAL_DECODE            = 2306, /**< CODEC: Decoding was successful but frame data still remains; \n
+                                                        the next call will provide audio without consuming input data */
+
+    OI_FIFOQ_QUEUE_NOT_ALIGNED             = 2401, /**< FIFOQ: Queue must be 32-bit aligned */
+    OI_FIFOQ_INVALID_Q                     = 2402, /**< FIFOQ: Queue parameter is not a valid queue */
+    OI_FIFOQ_BUF_TOO_LARGE                 = 2403, /**< FIFOQ: Attempt to queue a buffer which is too large */
+    OI_FIFOQ_FULL                          = 2404, /**< FIFOQ: enqueue() failed, queue is full */
+    OI_FIFOQ_NOT_ALLOCATED                 = 2405, /**< FIFOQ: Enqueue QBuf() failed, buffer not allocated */
+    OI_FIFOQ_INVALID_DATA_PTR              = 2406, /**< FIFOQ: Enqueue QBuf() failed, data pointer does not match */
+
+    OI_HID_HOST_SERVICE_NOT_STARTED        = 2601, /**< HID: Cannot connect to an HID device unless the HID host is started */
+    OI_HID_DEVICE_SERVICE_NOT_STARTED      = 2602, /**< HID: Cannot connect to an HID host unless the HID device is started */
+
+    OI_AT_ERROR                            = 2701, /**< AT: ERROR response */
+    OI_AT_NO_CARRIER                       = 2702, /**< AT: NO CARRIER response */
+    OI_AT_BUSY                             = 2703, /**< AT: BUSY response */
+    OI_AT_NO_ANSWER                        = 2704, /**< AT: NO ANSWER response */
+    OI_AT_DELAYED                          = 2705, /**< AT: DELAYED response */
+    OI_AT_BLACKLISTED                      = 2706, /**< AT: BLACKLISTED response */
+    OI_AT_CME_ERROR                        = 2707, /**< AT: +CME ERROR response */
+    OI_AT_CMS_ERROR                        = 2708, /**< AT: +CMS ERROR response */
+
+    OI_AVDTP_CONNECTION_SEQ_ERROR          = 2901, /**< AVDTP: Sequencing of signaling/media channel connections are broken. */
+    OI_AVDTP_OUT_OF_RESOURCES              = 2902, /**< AVDTP: Tried to allocate too many endpoints or signaling channels. */
+    OI_AVDTP_CONNECTED                     = 2903, /**< AVDTP: Cannot perform operation while connected to remote device. */
+    OI_AVDTP_CONNECT_IN_PROGRESS           = 2904, /**< AVDTP: Cannot perform operation while connect in progress. */
+
+    OI_PBAP_REPOSITORY_NOT_SET             = 3001, /**< PBAP: Phonebook repository must be set for the operation to complete. */
+    OI_PBAP_PHONEBOOK_NOT_SET              = 3002, /**< PBAP: Phonebook must be set for the operation to complete. */
+
+    OI_AADP_BAD_ENDPOINT                   = 3101, /**< AADP: Invalid local endpoint specified */
+    OI_AADP_BAD_STATE                      = 3102, /**< AADP: AADP state is not correct for this operation. */
+
+    OI_UNICODE_INVALID_SOURCE              = 3200, /**< Unicode Conversion: Source string has invalid character encoding. */
+    OI_UNICODE_SOURCE_EXHAUSTED            = 3201, /**< Unicode Conversion: Incomplete Unicode character at end of source buffer. */
+    OI_UNICODE_DESTINATION_EXHAUSTED       = 3202, /**< Unicode Conversion: Destination buffer not large enough to hold resulting Unicode string. */
+
+    OI_AVRCP_TOO_MANY_CONNECTIONS          = 3300, /**< AVRCP: Exceeded maximum number of simultaneous AVCTP connections. */
+    OI_AVRCP_NOT_IMPLEMENTED               = 3301, /**< AVRCP: The target does not implement the command specified by the opcode and operand. */
+    OI_AVRCP_REJECTED                      = 3302, /**< AVRCP: The target cannot respond because of invalid operands in command packet. */
+    OI_AVRCP_INVALID_RESPONSE              = 3303, /**< AVRCP: The controller received the response with invalid parameters */
+    OI_AVRCP_RESPONSE_PACKET_OVERFLOW      = 3304, /**< AVRCP: The response message does not fit in one AVRCP packet (512 bytes), has to be fragmented. */
+    OI_AVRCP_RESPONSE_INVALID_PDU          = 3305, /**< AVRCP: Command rejected: target received a PDU that it did not understand. */
+    OI_AVRCP_RESPONSE_INVALID_PARAMETER    = 3306, /**< AVRCP: Command rejected: target received a PDU with a parameter ID that it did not understand. */
+    OI_AVRCP_RESPONSE_PARAMETER_NOT_FOUND  = 3307, /**< AVRCP: Command rejected: specified parameter not found, sent if the parameter ID is understood, but content is wrong or corrupted.*/
+    OI_AVRCP_RESPONSE_INTERNAL_ERROR       = 3308, /**< AVRCP: Command rejected: target detected other error conditions. */
+    OI_AVRCP_NO_CONTROL_CONNECTION         = 3309, /**< AVRCP: Browsing connection rejected: control connection should be established first. */
+    OI_AVRCP_PARTIAL_RESPONSE              = 3310, /**< AVRCP: The browsing response message larger than L2CAP MTU, only partial response has been sent. */
+    OI_AVRCP_BROWSING_COMMAND_TOO_LONG     = 3311, /**< AVRCP: The browsing command larger than L2CAP outMTU. */
+
+    OI_AMP_NO_LOCAL_AMP_DEVICES            = 3400, /**< AMP: AMP operations not possible with no local AMP devices. */
+    OI_AMP_EVENT_TIMEOUT                   = 3401, /**< AMP: Expected event never received */
+    OI_AMP_RECV_LENGTH                     = 3402, /**< AMP: Received signaling message with incorrect number of bytes. */
+    OI_AMP_BAD_RECV                        = 3403, /**< AMP: Received improperly formatted signaling message */
+    OI_AMP_UNEXPECTED_RECV                 = 3404, /**< AMP: Recieved a signaling response for non-existent request */
+    OI_AMP_RESPONSE_TIMEOUT                = 3405, /**< AMP: Time out waiting for signaling response */
+    OI_AMP_TOO_MANY_DEVICES                = 3406, /**< AMP: Attempt to register more than max number of local AMPs */
+    OI_AMP_NO_CONTROLLER                   = 3407, /**< AMP: AMP controller for bdAddr was not found or deleted */
+    OI_AMP_REQUEST_FAILED                  = 3408, /**< AMP: AMP request failed */
+    OI_AMP_INTERNAL_ERROR                  = 3409, /**< AMP: Failed consistency check */
+    OI_AMP_NO_MANAGER                      = 3410, /**< AMP: Remote device does not support AMP Manager protocol */
+    OI_AMP_NO_DEVICE                       = 3411, /**< AMP: Invalid or no AMP device found */
+    OI_AMP_BAD_ASSOC_LENGTH                = 3412, /**< AMP: Local and Remote AMP ASSOC lengths differ */
+    OI_AMP_ORPHANED_RESPONSE               = 3413, /**< AMP: Received HCI response/event that has no context */
+    OI_AMP_TYPE_MISMATCH                   = 3414, /**< AMP: Attempt to connect AMP devices of different types */
+    OI_AMP_ACCEPT_FAILED                   = 3415, /**< AMP: Attempt to accept a physical connection failed */
+    OI_AMP_NO_PHYS_LINK                    = 3416, /**< AMP: Attempt to create logical link on device with no physical link */
+    OI_AMP_TOO_MANY_LOGICAL_LINKS          = 3417, /**< AMP: Attempt to create more logical links than are supported */
+    OI_AMP_DISCONNECT                      = 3418, /**< AMP: Request failed due to disconnection of AMP or BR/EDR link */
+    OI_AMP_CONNECT_ABORTED                 = 3419, /**< AMP: Phys Link request was aborted */
+    OI_AMP_ILLEGAL_L2CAP_MODE              = 3420, /**< AMP: L2CAP mode is illegal for AMP */
+    OI_AMP_PHYS_LINK_EXISTS                = 3421, /**< AMP: Phys Link already exists to AMP device */
+    OI_AMP_SAME_STATUS                     = 3422, /**< AMP: Current enable/disable status is same as requested */
+    OI_AMP_IN_PROGRESS                     = 3423, /**< AMP: Enable/disable already in progress */
+    OI_AMP_NO_LOGICAL_LINK                 = 3424, /**< AMP: No logical link found on disconnect */
+    OI_AMP_CONNECT_COLLISION               = 3425, /**< AMP: Phys Link request failed due to collision */
+    OI_AMP_ILLEGAL_LMP_VERSION             = 3426, /**< AMP: BR/EDR controller must be 2.1 or better for AMP */
+    OI_AMP_ILLEGAL_KEY_TYPE                = 3427, /**< AMP: Bluetooth link key must 2.1 or better for AMP */
+    OI_AMP_ALREADY_REGISTERED              = 3428, /**< AMP: An AMP policy is already regsitered for this CID */
+    OI_AMP_CONNECT_INCOMING                = 3429, /**< AMP: Create Phys Link failed, incoming request arrived first */
+    OI_AMP_NO_GETINFO                      = 3430, /**< AMP: Get AMP Info not performed */
+    
+    OI_ATM_ALREADY_ENABLED                 = 3501, /**< AMP Test Manager */
+    OI_ATM_NOT_ENABLED                     = 3502, /**< AMP Test Manager */
+    OI_ATM_NO_AMP_DEVICE                   = 3503, /**< AMP Test Manager */
+    OI_ATM_LOCAL_TESTER_ACTIVE             = 3504, /**< AMP Test Manager - can't accept command from remote tester */
+    OI_ATM_REMOTE_TESTER_ACTIVE            = 3505, /**< AMP Test Manager - can't accept command from local tester */
+    OI_ATM_INVALID_PKT_FORMAT              = 3506, /**< AMP Test Manager - improperly formatted command packet */
+        
+    OI_BTLE_ROLE_NOT_ALLOWED               = 3600, /**< BTLE: The combination of profile roles is not allowed */
+    OI_BTLE_MODE_NOT_ALLOWED               = 3601, /**< BTLE: The operation for current device role is not allowed */
+    
+    OI_MAP_OBEX_AUTH_FORBIDDEN             = 3602, /**< MAP - specification forbids obex authentication */
+    
+    OI_GATT_NOTHING_TO_WRITE               = 3701, /**< GATT */
+    OI_GATT_NO_SUCH_CLIENT                 = 3702, /**< GATT */
+    OI_GATT_TOO_MANY_ENTRIES               = 3703, /**< GATT */
+    OI_GATT_TOO_BIG                        = 3704, /**< GATT */
+    OI_GATT_OUT_OF_RANGE                   = 3705, /**< GATT */
+    OI_GATT_TOO_SMALL                      = 3706, /**< GATT */
+    OI_GATT_NO_SUCH_ATTRIBUTE              = 3707, /**< GATT */
+    OI_GATT_ASYNC                          = 3708, /**< GATT */
+    OI_GATT_NO_RESULTS                     = 3709, /**< GATT */
+    OI_GATT_ASYNC_REQUIRED                 = 3710, /**< GATT */
+    OI_GATT_WRITE_ONLY                     = 3711, /**< GATT */
+    OI_GATT_BUFFER_EXCEEDED                = 3712, /**< GATT */
+    OI_GATT_INVALID_RESULTS                = 3713, /**< GATT */
+
+    OI_ATT_STATUS_ERROR_BASE                = 3800,
+    OI_ATT_INVALID_HANDLE                   = 3801, /**< ATT - Maps to 0x01 OI_ATT_ERR_INVALID_HANDLE */
+    OI_ATT_READ_NOT_PERMITTED               = 3802, /**< ATT - Maps to 0x02 OI_ATT_ERR_READ_NOT_PERMITTED */
+    OI_ATT_WRITE_NOT_PERMITTED              = 3803, /**< ATT - Maps to 0x03 OI_ATT_ERR_WRITE_NOT_PERMITTED */
+    OI_ATT_INVALID_PDU                      = 3804, /**< ATT - Maps to 0x04 OI_ATT_ERR_INVALID_PDU */
+    OI_ATT_INSUFFICIENT_AUTHENTICATION      = 3805, /**< ATT - Maps to 0x05 OI_ATT_ERR_INSUFFICIENT_AUTHENTICATION */
+    OI_ATT_REQUEST_NOT_SUPPORTED            = 3806, /**< ATT - Maps to 0x06 OI_ATT_ERR_REQUEST_NOT_SUPPORTED */
+    OI_ATT_INVALID_OFFSET                   = 3807, /**< ATT - Maps to 0x07 OI_ATT_ERR_INVALID_OFFSET */
+    OI_ATT_INSUFFICIENT_AUTHORIZATION       = 3808, /**< ATT - Maps to 0x08 OI_ATT_ERR_INSUFFICIENT_AUTHORIZATION */
+    OI_ATT_PREPARE_QUEUE_FULL               = 3809, /**< ATT - Maps to 0x09 OI_ATT_ERR_PREPARE_QUEUE_FULL */
+    OI_ATT_ATTRIBUTE_NOT_FOUND              = 3810, /**< ATT - Maps to 0x0A OI_ATT_ERR_ATTRIBUTE_NOT_FOUND */
+    OI_ATT_ATTRIBUTE_NOT_LONG               = 3811, /**< ATT - Maps to 0x0B OI_ATT_ERR_ATTRIBUTE_NOT_LONG */
+    OI_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE = 3812, /**< ATT - Maps to 0x0C OI_ATT_ERR_INSUFFICIENT_ENCRYPTION_KEY_SIZE */
+    OI_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH   = 3813, /**< ATT - Maps to 0x0D OI_ATT_ERR_INVALID_ATTRIBUTE_VALUE_LENGTH */
+    OI_ATT_INVALID_UNLIKELY_ERROR           = 3814, /**< ATT - Maps to 0x0E OI_ATT_ERR_UNLIKELY_ERROR */
+    OI_ATT_INVALID_INSUFFICIENT_ENCRYPTION  = 3815, /**< ATT - Maps to 0x0F OI_ATT_ERR_INSUFFICIENT_ENCRYPTION */
+    OI_ATT_INVALID_UNSUPPORTED_GROUP_TYPE   = 3816, /**< ATT - Maps to 0x10 OI_ATT_ERR_UNSUPPORTED_GROUP_TYPE */
+    OI_ATT_INVALID_INSUFFICIENT_RESOURCES   = 3817, /**< ATT - Maps to 0x11 OI_ATT_ERR_INSUFFICIENT_RESOURCES */
+    OI_ATT_STATUS_ERROR_END                 = 3818, /**< ATT - End of Error Mappings for ATT */
+
+    OI_BTLE_SECMGR_STATUS_ERROR_BASE        = 3900,
+    OI_BTLE_SECMGR_PASSKEY_ENTRY_FAILED     = 3901, /**< BTLE SECMGR - Maps to 0x01 OI_BTLE_ERR_PASSKEY_ENTRY_FAILED */
+    OI_BTLE_SECMGR_OOB_NOT_AVAILABLE        = 3902, /**< BTLE SECMGR - Maps to 0x02 OI_BTLE_ERR_OOB_NOT_AVAILABLE */
+    OI_BTLE_SECMGR_AUTH_REQUIREMENTS        = 3903, /**< BTLE SECMGR - Maps to 0x03 OI_BTLE_ERR_AUTH_REQUIREMENTS */
+    OI_BTLE_SECMGR_CONFIRM_VALUE_FAILED     = 3904, /**< BTLE SECMGR - Maps to 0x04 OI_BTLE_ERR_CONFIRM_VALUE_FAILED */
+    OI_BTLE_SECMGR_PAIRING_NOT_SUPPORTED    = 3905, /**< BTLE SECMGR - Maps to 0x05 OI_BTLE_ERR_PAIRING_NOT_SUPPORTED */
+    OI_BTLE_SECMGR_ENCRYPTION_KEY_SIZE      = 3906, /**< BTLE SECMGR - Maps to 0x06 OI_BTLE_ERR_ENCRYPTION_KEY_SIZE */
+    OI_BTLE_SECMGR_COMMAND_NOT_SUPPORTED    = 3907, /**< BTLE SECMGR - Maps to 0x07 OI_BTLE_ERR_COMMAND_NOT_SUPPORTED */
+    OI_BTLE_SECMGR_UNSPECIFIED_REASON       = 3908, /**< BTLE SECMGR - Maps to 0x08 OI_BTLE_ERR_UNSPECIFIED_REASON */
+    OI_BTLE_SECMGR_INVALID_PARAMETERS       = 3909, /**< BTLE SECMGR - Maps to 0x09 OI_BTLE_ERR_INVALID_PARAMETERS */
+    OI_BTLE_SECMGR_STATUS_ERROR_END         = 3910, /**< BTLE SECMGR - End of Error Mappings for BTLE SECMGR */
+        
+
+    OI_MAX_BM3_STATUS_VAL,                         /**< Maximum BLUEmagic 3.0 status code */
+
+    OI_STATUS_RESERVED_FOR_BCOT            = 9000, /**< Status code values reserved for BLUEmagic 3.0 SDK platform-specific implementations */
+    OI_STATUS_RESERVED_FOR_SOUNDABOUT      = 9400, /**< Status code values reserved for Soundabout products */    
+    OI_STATUS_RESERVED_FOR_BT_SLEEP        = 9500, /**< 9500-9599 Status code values reserved for BT Sleep */    
+
+    OI_STATUS_RESERVED_FOR_APPS            = 10000, /**< Status code values greater than or equal to this value are reserved for use by applications; \n
+                                                         however, because of differences between compilers, and differences between 16-bit and 32-bit \n
+                                                         platforms, custom status codes should be in the 16-bit range, so status codes can range from 0 \n
+                                                         to 65534, inclusive (65535 is reserved) */
+    OI_STATUS_NONE                         = 0xffff /**< Special status code to indicate that there is no status; only to be used for special \n
+                                                         cases involving OI_SLOG_ERROR() and OI_SLOG_WARNING(). */
+
+} OI_STATUS;
+
+
+/* Remember to update the #define below when new reserved blocks are added to
+ * the list above. */
+#define OI_NUM_RESERVED_STATUS_BLOCKS 4 /**< Number of status code blocks reserved, including user apps */
+
+
+/**
+ * Test for success
+ */
+#define OI_SUCCESS(x)    ((x) == OI_OK)
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_STATUS_H */
+
diff --git a/obex_profiles/sdk/include/oi_statustext.h b/obex_profiles/sdk/include/oi_statustext.h
new file mode 100644
index 0000000..f5d3022
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_statustext.h
@@ -0,0 +1,109 @@
+#ifndef _OI_STATUSTEXT_H
+#define _OI_STATUSTEXT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * This file provides the API for a single debugging function, which provides the
+ * text string for OI_STATUS values.
+ * This function is only defined in the debug version of the stack library.
+ *
+ *
+ */
+
+#include "oi_status.h"
+
+/** \addtogroup Debugging Debugging APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Map a status code into a text string for printing out error statuses in
+ * the SDK samples and in application test programs.
+ *
+ * Application error messages are returned by a status text filter registered via
+ * OI_RegisterAppStatusTextFilter().
+ *
+ * @param value a status code.
+ *
+ * @return a pointer to text string.
+ */
+
+OI_CHAR* OI_StatusText(OI_STATUS value);
+
+#ifdef OI_DEBUG
+
+/**
+ * A function of this type may be registered with the status text module in order
+ * for the application to provide a text string for application defined status values.
+ *
+ * @param value an application defined status code.
+ *
+ * @return a pointer to a text string.  This may be NULL, in which case the value
+ *         is unknown to the filter and may be handled by another filter.
+ */
+typedef OI_CHAR* (*OI_APP_STATUS_TEXT_FILTER)(OI_STATUS value);
+
+/**
+ * This registers an application function that formats application defined status
+ * codes into text strings.  The registered function will be called whenever a status
+ * code in the application range is to be printed.
+ *
+ * Several filters can be registered. They will be called in order until one returns
+ * a text string.
+ *
+ * @param filter the function called when an application defined status code is
+ *               being displayed.
+ */
+void OI_RegisterAppStatusTextFilter(OI_APP_STATUS_TEXT_FILTER filter);
+
+#else
+
+/*
+ * This function does nothing in a non-debug build
+ */
+#define OI_RegisterAppStatusTextFilter(filter)
+
+#endif
+
+/*****************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_STATUSTEXT_H */
+
diff --git a/obex_profiles/sdk/include/oi_stddefs.h b/obex_profiles/sdk/include/oi_stddefs.h
new file mode 100644
index 0000000..5c6f8a6
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_stddefs.h
@@ -0,0 +1,254 @@
+#ifndef OI_STDDEFS_H
+#define OI_STDDEFS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * This file contains BM3 standard type definitions.
+ *
+ */
+
+#include "oi_cpu_dep.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef FALSE
+#define FALSE 0         /**< This define statement sets FALSE as a preprocessor alias for 0. */
+#endif
+
+#ifndef TRUE
+#define TRUE (!FALSE)  /**< This define statement sets TRUE as a preprocessor alias for !FALSE. */
+#endif
+
+#ifndef NULL
+    #define NULL ((void*)0) /**< This define statement sets NULL as a preprocessor alias for (void*)0 */
+#endif
+
+/**
+ *  OI_OFFSETOF has the same usage and semantics as stddef.h offsetof, but is implemented
+ *  with a non-zero address to avoid warnings from QTI's SuperLint program which complained 
+ *  about the previous version of this macro
+ *      Error (Warning) 413: Likely use of null pointer 'unknown-name'
+ *  The use of 0x100 as base address 'fixes' Lint
+ */
+
+#define OI_OFFSETOF(type, field)   (((int)&(((type *)0x100)->field)) - 0x100)
+
+/**
+ * @name  Maximum and minimum values for basic types
+ * @{
+ */
+#define OI_INT8_MIN   ((OI_INT8)0x80)          /**< Decimal value: -128 */
+#define OI_INT8_MAX   ((OI_INT8)0x7F)          /**< Decimal value: 127 */
+#define OI_INT16_MIN  ((OI_INT16)0x8000)       /**< Decimal value: -32768 */
+#define OI_INT16_MAX  ((OI_INT16)0x7FFF)       /**< Decimal value: 32767 */
+#define OI_INT32_MIN  ((OI_INT32)0x80000000)   /**< Decimal value: -2,147,483,648 */
+#define OI_INT32_MAX  ((OI_INT32)0x7FFFFFFF)   /**< Decimal value: 2,147,483,647 */
+#define OI_UINT8_MIN  ((OI_UINT8)0)            /**< Decimal value: 0 */
+#define OI_UINT8_MAX  ((OI_UINT8)0xFF)         /**< Decimal value: 255 */
+#define OI_UINT16_MIN ((OI_UINT16)0)           /**< Decimal value: 0 */
+#define OI_UINT16_MAX ((OI_UINT16)0xFFFF)      /**< Decimal value: 65535 */
+#define OI_UINT32_MIN ((OI_UINT32)0)           /**< Decimal value: 0 */
+#define OI_UINT32_MAX ((OI_UINT32)0xFFFFFFFF)  /**< Decimal value: 4,294,967,295 */
+
+/**
+ * @}
+ */
+
+/**
+ * @name  Integer types required by the Service Discovery Protocol
+ * @{
+ */
+
+/** This structure is an unsigned 64-bit integer as a structure
+    of two unsigned 32-bit integers. */
+typedef struct {
+    OI_UINT32 I1; /**< Most significant 32 bits */
+    OI_UINT32 I2; /**< Least significant 32 bits */
+} OI_UINT64;
+
+#define OI_UINT64_MIN { (OI_UINT32)0x00000000, (OI_UINT32)0x00000000 }
+#define OI_UINT64_MAX { (OI_UINT32)0XFFFFFFFF, (OI_UINT32)0XFFFFFFFF }
+
+/** This structure is a signed 64-bit integer as a structure of
+    one unsigned 32-bit integer and one signed 32-bit
+    integer. */
+typedef struct {
+    OI_INT32  I1; /**< Most significant 32 bits as a signed integer */
+    OI_UINT32 I2; /**< Least significant 32 bits as an unsigned integer */
+} OI_INT64;
+
+#define OI_INT64_MIN { (OI_INT32)0x80000000, (OI_UINT32)0x00000000 }
+#define OI_INT64_MAX { (OI_INT32)0X7FFFFFFF, (OI_UINT32)0XFFFFFFFF }
+
+/** This structure is an unsigned 128-bit integer as a structure
+    of four unsigned 32-bit integers. */
+typedef struct {
+    OI_UINT32 I1; /**< Most significant 32 bits */
+    OI_UINT32 I2; /**< Second-most significant 32 bits */
+    OI_UINT32 I3; /**< Third-most significant 32 bits */
+    OI_UINT32 I4; /**< Least significant 32 bits */
+} OI_UINT128;
+
+#define OI_UINT128_MIN { (OI_UINT32)0x00000000, (OI_UINT32)0x00000000,  (OI_UINT32)0x00000000, (OI_UINT32)0x00000000 }
+#define OI_UINT128_MAX { (OI_UINT32)0XFFFFFFFF, (OI_UINT32)0XFFFFFFFF,  (OI_UINT32)0XFFFFFFFF, (OI_UINT32)0XFFFFFFFF }
+
+/** This structure is a signed 128-bit integer as a structure of
+    three unsigned 32-bit integers and one signed 32-bit
+    integer. */
+typedef struct {
+    OI_INT32  I1;  /**< Most significant 32 bits as a signed integer */
+    OI_UINT32 I2;  /**< Second-most significant 32 bits as an unsigned integer */
+    OI_UINT32 I3;  /**< Third-most significant 32 bits as an unsigned integer */
+    OI_UINT32 I4;  /**< Least significant 32 bits as an unsigned integer */
+} OI_INT128;
+
+#define OI_INT128_MIN { (OI_UINT32)0x80000000, (OI_UINT32)0x00000000,  (OI_UINT32)0x00000000, (OI_UINT32)0x00000000 }
+#define OI_INT128_MAX { (OI_UINT32)0X7FFFFFFF, (OI_UINT32)0XFFFFFFFF,  (OI_UINT32)0XFFFFFFFF, (OI_UINT32)0XFFFFFFFF }
+
+/**
+ * @}
+ */
+
+
+/**
+ * Type for ASCII character data items
+ */
+typedef char OI_CHAR;
+
+/**
+ * Type for double-byte character data items
+ */
+typedef OI_UINT16 OI_CHAR16;
+
+/**
+ * Types for UTF encoded strings.
+ */
+typedef OI_UINT8  OI_UTF8;
+typedef OI_UINT16 OI_UTF16;
+typedef OI_UINT32 OI_UTF32;
+
+/**
+ * A generic opaque handle type. Some profiles derive their handles from this type.
+ */
+typedef void* OI_HANDLE;
+
+
+/**
+ * @name Single-bit operation macros
+ * @{
+ * In these macros, x is the data item for which a bit is to be tested or set and y specifies which bit
+ * is to be tested or set.
+ */
+
+/** This macro's value is TRUE if the bit specified by y is set in data item x. */
+#define OI_BIT_TEST(x,y)   ((x) & (y))
+
+/** This macro's value is TRUE if the bit specified by y is not set in data item x. */
+#define OI_BIT_CLEAR_TEST(x,y)  (((x) & (y)) == 0)
+
+/** This macro sets the bit specified by y in data item x. */
+#define OI_BIT_SET(x,y)    ((x) |= (y))
+
+/** This macro clears the bit specified by y in data item x. */
+#define OI_BIT_CLEAR(x,y)  ((x) &= ~(y))
+
+/** @} */
+
+/**
+ * The OI_ARRAYSIZE macro is set to the number of elements in an array
+ * (instead of the number of bytes, which is returned by sizeof()).
+ */
+
+#ifndef OI_ARRAYSIZE
+#define OI_ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
+#endif
+
+/**
+ * @name Preprocessor aliases for individual bit positions
+ *      Bits are defined here only if they are not already defined.
+ * @{
+ */
+
+#ifndef OI_BIT0
+
+#define OI_BIT0   0x00000001  /**< Preprocessor alias for 32-bit value with bit 0 set, used to specify this single bit */
+#define OI_BIT1   0x00000002  /**< Preprocessor alias for 32-bit value with bit 1 set, used to specify this single bit */
+#define OI_BIT2   0x00000004  /**< Preprocessor alias for 32-bit value with bit 2 set, used to specify this single bit */
+#define OI_BIT3   0x00000008  /**< Preprocessor alias for 32-bit value with bit 3 set, used to specify this single bit */
+#define OI_BIT4   0x00000010  /**< Preprocessor alias for 32-bit value with bit 4 set, used to specify this single bit */
+#define OI_BIT5   0x00000020  /**< Preprocessor alias for 32-bit value with bit 5 set, used to specify this single bit */
+#define OI_BIT6   0x00000040  /**< Preprocessor alias for 32-bit value with bit 6 set, used to specify this single bit */
+#define OI_BIT7   0x00000080  /**< Preprocessor alias for 32-bit value with bit 7 set, used to specify this single bit */
+#define OI_BIT8   0x00000100  /**< Preprocessor alias for 32-bit value with bit 8 set, used to specify this single bit */
+#define OI_BIT9   0x00000200  /**< Preprocessor alias for 32-bit value with bit 9 set, used to specify this single bit */
+#define OI_BIT10  0x00000400  /**< Preprocessor alias for 32-bit value with bit 10 set, used to specify this single bit */
+#define OI_BIT11  0x00000800  /**< Preprocessor alias for 32-bit value with bit 11 set, used to specify this single bit */
+#define OI_BIT12  0x00001000  /**< Preprocessor alias for 32-bit value with bit 12 set, used to specify this single bit */
+#define OI_BIT13  0x00002000  /**< Preprocessor alias for 32-bit value with bit 13 set, used to specify this single bit */
+#define OI_BIT14  0x00004000  /**< Preprocessor alias for 32-bit value with bit 14 set, used to specify this single bit */
+#define OI_BIT15  0x00008000  /**< Preprocessor alias for 32-bit value with bit 15 set, used to specify this single bit */
+#define OI_BIT16  0x00010000  /**< Preprocessor alias for 32-bit value with bit 16 set, used to specify this single bit */
+#define OI_BIT17  0x00020000  /**< Preprocessor alias for 32-bit value with bit 17 set, used to specify this single bit */
+#define OI_BIT18  0x00040000  /**< Preprocessor alias for 32-bit value with bit 18 set, used to specify this single bit */
+#define OI_BIT19  0x00080000  /**< Preprocessor alias for 32-bit value with bit 19 set, used to specify this single bit */
+#define OI_BIT20  0x00100000  /**< Preprocessor alias for 32-bit value with bit 20 set, used to specify this single bit */
+#define OI_BIT21  0x00200000  /**< Preprocessor alias for 32-bit value with bit 21 set, used to specify this single bit */
+#define OI_BIT22  0x00400000  /**< Preprocessor alias for 32-bit value with bit 22 set, used to specify this single bit */
+#define OI_BIT23  0x00800000  /**< Preprocessor alias for 32-bit value with bit 23 set, used to specify this single bit */
+#define OI_BIT24  0x01000000  /**< Preprocessor alias for 32-bit value with bit 24 set, used to specify this single bit */
+#define OI_BIT25  0x02000000  /**< Preprocessor alias for 32-bit value with bit 25 set, used to specify this single bit */
+#define OI_BIT26  0x04000000  /**< Preprocessor alias for 32-bit value with bit 26 set, used to specify this single bit */
+#define OI_BIT27  0x08000000  /**< Preprocessor alias for 32-bit value with bit 27 set, used to specify this single bit */
+#define OI_BIT28  0x10000000  /**< Preprocessor alias for 32-bit value with bit 28 set, used to specify this single bit */
+#define OI_BIT29  0x20000000  /**< Preprocessor alias for 32-bit value with bit 29 set, used to specify this single bit */
+#define OI_BIT30  0x40000000  /**< Preprocessor alias for 32-bit value with bit 30 set, used to specify this single bit */
+#define OI_BIT31  0x80000000  /**< Preprocessor alias for 32-bit value with bit 31 set, used to specify this single bit */
+
+#endif  /* OI_BIT0 et al */
+
+
+/** @} */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* OI_STDDEFS_H */
diff --git a/obex_profiles/sdk/include/oi_string.h b/obex_profiles/sdk/include/oi_string.h
new file mode 100644
index 0000000..11311c9
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_string.h
@@ -0,0 +1,259 @@
+#ifndef OI_STRING_H
+#define OI_STRING_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * This file contains BLUEmagic 3.0 supplied portable string.h functions.
+ *
+ */
+
+#include "oi_cpu_dep.h"
+#include "oi_stddefs.h"
+
+#if defined(OI_USE_NATIVE_MEMCPY) || defined(OI_USE_NATIVE_MALLOC)
+#include <string.h>
+#endif
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * If we are using Native malloc(), we must also use
+ * native ANSI string.h functions for memory manipulation.
+ */
+#ifdef OI_USE_NATIVE_MALLOC
+#ifndef OI_USE_NATIVE_MEMCPY
+#define OI_USE_NATIVE_MEMCPY
+#endif
+#endif
+
+#ifdef OI_USE_NATIVE_MEMCPY
+
+#define OI_MemCopy(to, from, size)    memcpy((to), (from), (size))
+#define OI_MemSet(block, val, size)   memset((block), (val), (size))
+#define OI_MemZero(block, size)       memset((block), 0, (size))
+#define OI_MemCmp(s1, s2, n)          memcmp((s1), (s2), (n))
+#define OI_StrLen(str)                strlen((str))
+#define OI_Strcmp(s1, s2)             strcmp((s1), (s2))
+#define OI_Strncmp(s1, s2, n)         strncmp((s1), (s2), (n))
+
+#else
+
+/*
+ * OI_MemCopy
+ *
+ * Copy an arbitrary number of bytes from one memory address to another.
+ * The underlying implementation is the ANSI memmove() or equivalant, so
+ * overlapping memory copies will work correctly.
+ */
+void OI_MemCopy(void *To,
+                void const *From,
+                OI_UINT32 Size);
+
+
+/*
+ * OI_MemSet
+ *
+ * Sets all bytes in a block of memory to the same value
+ */
+void OI_MemSet(void *Block,
+               OI_UINT8 Val,
+               OI_UINT32 Size);
+
+
+/*
+ * OI_MemZero
+ *
+ * Sets all bytes in a block of memory to zero
+ */
+void OI_MemZero(void *Block,
+                OI_UINT32 Size);
+
+
+/*
+ * OI_MemCmp
+ *
+ * Compare two blocks of memory
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_MemCmp(void const *s1, void const *s2, OI_UINT32 n);
+
+
+/*
+ * OI_StrLen
+ *
+ * Calculates the number of OI_CHARs in pStr (not including
+ * the Null terminator) and returns the value.
+ */
+OI_UINT OI_StrLen(OI_CHAR const *pStr);
+
+/*
+ * OI_Strcmp
+ *
+ * Compares two Null terminated strings
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_Strcmp(OI_CHAR const *s1,
+                 OI_CHAR const *s2);
+
+/*
+ * OI_Strcmp
+ *
+ * Compares two Null terminated strings
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_Strcmp(OI_CHAR const *s1,
+                 OI_CHAR const *s2);
+
+/*
+ * OI_Strncmp
+ *
+ * Compares the first "len" OI_CHARs of strings s1 and s2.
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_Strncmp(OI_CHAR const *s1,
+                  OI_CHAR const *s2,
+                  OI_UINT32      len);
+
+
+#endif /* OI_USE_NATIVE_MEMCPY */
+
+/*
+ * OI_Strlcpy
+ *
+ * Safely copies the pStr string to pDest. Copies at most (len - 1) characters from pStr,
+ * NUL-terminating the result. The caller can compare the return value against the len parameter to
+ * determine if the string was truncated.
+ *
+ * @param pDest   A pointer to the destination string buffer which should be long enough to hold
+ *                (len + 1) characters.
+ *
+ * @param pStr    A pointer to the string to be copied to pDest.
+ *
+ * @param len     A value that is less than the size of the destination buffer referenced by pDest.
+ *
+ * @return   The length of the resultant string in pDest or the length that string would have had if
+ *           there was room. In the latter case the return value with be >= len.
+ */
+
+OI_UINT OI_Strlcpy(OI_CHAR *pDest,
+                   OI_CHAR const *pStr,
+                   OI_UINT len);
+
+
+/*
+ * OI_Strlcat
+ *
+ * Safely concatenates the pStr string to the end of pDest. Appends at most (len - OI_Strlen(pDest) - 1)
+ * characters from pStr, NUL-terminating the result. The caller can compare the return value against
+ * the len parameter to determine if the string was truncated.
+ *
+ * @param pDest   A pointer to the destination string buffer which should be long enough to hold
+ *                (len + 1) characters.
+ *
+ * @param pStr    A pointer to the string to be appended to pDest.
+ *
+ * @param len     A value that is less than the size of the destination buffer referenced by pDest.
+ *
+ * @return   The length of the resultant string in pDest or the length that string would have had if
+ *           there was room. In the latter case the return value with be >= len.
+ */
+
+OI_UINT OI_Strlcat(OI_CHAR *pDest,
+                   OI_CHAR const *pStr,
+                   OI_UINT len);
+
+
+/*
+ * OI_StrcmpInsensitive
+ *
+ * Compares two Null terminated strings, treating
+ * the Upper and Lower case of 'A' through 'Z' as
+ * equivilent.
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_StrcmpInsensitive(OI_CHAR const *s1,
+                            OI_CHAR const *s2);
+
+/*
+ * OI_StrncmpInsensitive
+ *
+ * Compares the first "len" OI_CHARs of strings s1 and s2,
+ * treating the Upper and Lower case of 'A' through 'Z' as
+ * equivilent.
+ *
+ *
+ * Returns:
+ *        0, if s1 == s2
+ *      < 0, if s1 < s2
+ *      > 0, if s2 > s2
+ */
+OI_INT OI_StrncmpInsensitive(OI_CHAR const *s1,
+                             OI_CHAR const *s2,
+                             OI_UINT        len);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/** @} */
+
+/*****************************************************************************/
+#endif /* OI_STRING_H */
+
diff --git a/obex_profiles/sdk/include/oi_support_init.h b/obex_profiles/sdk/include/oi_support_init.h
new file mode 100644
index 0000000..6585758
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_support_init.h
@@ -0,0 +1,149 @@
+#ifndef _OI_SUPPORT_INIT_H
+#define _OI_SUPPORT_INIT_H
+
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * Initialization functions for memory manager and core support functions.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This global variable allows any BM3 function to verify that the current process does
+ * in fact own the stack token.
+ */
+extern OI_BOOL OI_StackTokenHeld;
+
+/**
+ * This function initializes the core support library.
+ * @ingroup Misc
+ */
+extern OI_STATUS OI_Support_Init(void);
+
+
+/** \addtogroup MemMgr Memory Manager APIs */
+/**@{*/
+
+
+#ifdef OI_USE_NATIVE_MALLOC
+
+#define OI_MEMMGR_Init(x) (OI_OK)
+
+#else
+
+/*****************************************************
+ * Memory Manager configuration parameters
+ *****************************************************/
+
+/**
+    This structure configures one memory pool, including the
+    number and size of blocks in the pool. Structures of this
+    type are used as elements in an array that indicates how the
+    Memory Manager will partition the portion of the heap from
+    which it dynamically allocates memory. A memory pool is a
+    linked list of memory blocks of the same size. The pool
+    table is an array of memory pools.
+
+    This structure configures one memory pool. The first field
+    indicates the number of blocks that will be allotted in a
+    pool; the second field indicates the size of the blocks in
+    this pool. For example, the entry {100, 64} indicates that a
+    pool of 100 64-byte blocks will be set aside. The block
+    sizes must be multiples of 4.
+ */
+typedef struct {
+    OI_UINT16 numBlocks;                /**< Number of blocks that will be allocated in this pool */
+    OI_UINT32 blockSize;                /**< Size of each block in this pool */
+} OI_MEMMGR_POOL_CONFIG;
+
+
+/**
+   This structure configures the heap, setting a pointer to the
+   heap and establishing the heap size. All memory allocated by
+   the Memory Manager for a particular application comes from a
+   single heap. This includes statically allocated memory and
+   the memory pools. The structure is eventually sent to
+   OI_MEMMGR_Init() by way of OI_CONFIG_MEMMGR.
+ */
+typedef struct  {
+    void        *heap ;         /**< Pointer to the heap */
+    OI_UINT32   heapSize ;      /**< Size of the heap in bytes */
+} OI_MEMMGR_HEAP_CONFIG ;
+
+/** A single structure of this type is used for passing all memory configuration
+ *  information to OI_MEMMGR_Init().
+ */
+typedef struct {
+    const OI_MEMMGR_POOL_CONFIG  *poolConfig ;       /**< Pointer to zero-terminated list of pool-configuration pairs */
+    const OI_MEMMGR_HEAP_CONFIG  *heapConfig ;       /**< Pointer to heap configuration information */
+} OI_CONFIG_MEMMGR ;
+
+/**
+ * This function initializes the Memory Manager. See the @ref memMgr_docpage section
+ * for more details.
+ *
+ * This function will fail if the actual memory required by the Memory Manager is
+ * greater than the defined heapSize (@ref OI_MEMMGR_HEAP_CONFIG) or if there are too
+ * many pools declared (more than MEMMGR_MAX_POOL_COUNT, which is defined internal
+ * to the protocol stack and is currently 1000).
+ *
+ *   @param pConfig     a pointer to the Memory Manager configuration parameters
+ *
+ *   @return            status of Memory Manager configuration:
+ *                      - OI_OK: successful
+ *                      - Any other value indicates initialization failure and
+ *                        is likely to be a fatal error that will prevent the
+ *                        memory manager from operating properly.
+ */
+extern OI_STATUS OI_MEMMGR_Init(const OI_CONFIG_MEMMGR *pConfig);
+
+#endif
+
+
+/*****************************************************************************/
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _OI_SUPPORT_INIT_H */
+
diff --git a/obex_profiles/sdk/include/oi_test.h b/obex_profiles/sdk/include/oi_test.h
new file mode 100644
index 0000000..5d715cf
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_test.h
@@ -0,0 +1,98 @@
+#ifndef _TEST_H
+#define _TEST_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+@internal
+
+ This file defines internal module test APIs.
+*/
+
+#include "oi_status.h"
+#include "oi_assert.h"
+
+/** \addtogroup Debugging_Internal */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef OI_TEST_HARNESS
+
+/**
+ * Pass a test command to core stack module.
+ * All modules take same arguments and return same values.
+ *
+ * @param cmd  Pointer to character string for the command
+ *
+ * @return OI_OK or
+ *         OI_STATUS_PARSE_ERROR if the command is recognized but invalid
+ */
+OI_STATUS OI_L2CAP_Test(const OI_CHAR *cmd);
+OI_STATUS OI_SDPSRV_Test(const OI_CHAR *cmd);
+OI_STATUS OI_HCI_Test(const OI_CHAR *cmd);
+
+#endif /* OI_TEST_HARNESS */
+
+/**
+ *  Test function type for dynamically-registered tests
+ *  Same calling conventions as core stack test modules above
+ */
+
+typedef OI_STATUS (*OI_TEST_COMMAND_HANDLER)(const OI_CHAR *cmd);
+
+
+/**
+ *  Register a test command handler
+ *
+ *  @param  cmdHandler  the callback to be called for input "test <moduleId> ....."
+ *
+ *  @param  moduleId    string uniquely identifying the command handler, typically
+ *                      same as module name.
+ *
+ *  @return OI_OK if handler was registered successfully.
+ */
+
+OI_STATUS OI_TEST_RegisterHandler(OI_TEST_COMMAND_HANDLER   cmdHandler,
+                                  const OI_CHAR             *moduleId);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _TEST_H */
+
diff --git a/obex_profiles/sdk/include/oi_text.h b/obex_profiles/sdk/include/oi_text.h
new file mode 100644
index 0000000..4618cb2
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_text.h
@@ -0,0 +1,89 @@
+#ifndef _OI_TEXT_H
+#define _OI_TEXT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides an API to functions for generation of text representations.
+ *
+ */
+
+#include "oi_common.h"
+
+/** \addtogroup Debugging Debugging APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This function generates a text string for a BDADDR for printing out Bluetooth addresses in
+ * the SDK samples and in application test programs.
+ *
+ * @param addr  Pointer to a Bluetooth address.
+ *
+ * @return Pointer to text string in the form nn:nn:nn:nn:nn:nn.
+ *
+ * @note The buffer for the text string is statically allocated and should not be
+ * freed. There is only one buffer so the following will not work:
+ @code
+   printf("addr1=%s adddr2=%s", OI_BDAddrText(&addr1), OI_BDAddrText(&addr2));
+ @endcode
+ */
+
+OI_CHAR* OI_BDAddrText(const OI_BD_ADDR *addr);
+
+
+/**
+ * This function generates a text string for a number of bytes.
+ *
+ * @param bytes  Starting address of the bytes for which a text string is generated.
+ * @param len  Number of bytes to output.
+ *
+ * @return Pointer to a text representation of the bytes.
+ */
+
+OI_CHAR* OI_HexText(const OI_BYTE* bytes,
+                    OI_UINT16 len);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_TEXT_H */
+
diff --git a/obex_profiles/sdk/include/oi_thread.h b/obex_profiles/sdk/include/oi_thread.h
new file mode 100644
index 0000000..ecfd9b2
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_thread.h
@@ -0,0 +1,208 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/** @file
+ * This file contains a platform-independent interface for
+ * synchronization and thread creation.
+ */
+
+#ifndef _OI_THREAD_H
+#define _OI_THREAD_H
+
+#include "oi_thread_platform.h"
+#include "oi_status.h"
+#include "oi_time.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*** Mutexes ***/
+
+/** Initializes a mutex.
+ * @param mut   Mutex to initialize
+ */
+OI_BOOL OI_Mutex_Init(OI_MUTEX *mut);
+
+/** Deinitializes a mutex.
+ * @param mut   Mutex to be destroyed
+ */
+OI_BOOL OI_Mutex_Destroy(OI_MUTEX *mut);
+
+/**
+ * This function locks a mutex. If the calling thread already
+ * owns the mutex, this function will return immediately.
+ * @param mut   Mutex to lock
+ */
+OI_BOOL OI_Mutex_Lock(OI_MUTEX *mut);
+
+/**
+ * This function unlocks a mutex.
+ * @param mut   Mutex to unlock
+ */
+OI_BOOL OI_Mutex_Unlock(OI_MUTEX *mut);
+
+/*** Threads ***/
+
+/**
+ * Function prototype for a thread start routine
+ */
+typedef void* (*OI_THREAD_START_ROUTINE)(void *);
+
+
+/**
+ * This function creates a new thread.
+ *
+ * @param t             Pointer to a thread type
+ * @param startRoutine  Start routine for the thread
+ * @param arg           Argument passed to the start routine
+ */
+OI_BOOL OI_Thread_Create(OI_THREAD *t,
+                         OI_THREAD_START_ROUTINE startRoutine,
+                         void *arg);
+
+/**
+ * This function waits for the thread specified by thread
+ *     to terminate
+ *
+ * @param t            thread type
+ */
+void OI_Thread_Join(OI_THREAD t);
+
+/**
+ * Exits the current thread
+ *
+ * @param retval  Return code for the thread
+ */
+void OI_Thread_Exit(void *retval);
+
+/*** Condition variables ***/
+
+/**
+ * This function initializes a condition variable.
+ *
+ * @param cond Condition variable to initialize
+ */
+OI_BOOL OI_Cond_Init(OI_COND *cond);
+
+/**
+ * This function wakes a single thread waiting on the specified
+ * condition variable.
+ *
+ * @param cond Condition variable on which the thread is waiting
+ */
+OI_BOOL OI_Cond_Signal(OI_COND *cond);
+
+/**
+ * This function wakes all threads waiting on the specified
+ * condition variable.
+ *
+ * @param cond Condition variable on which the threads are
+ *             waiting
+ */
+OI_BOOL OI_Cond_Broadcast(OI_COND *cond);
+
+/**
+ * This function waits for the specified condition variable to
+ * become signalled. The mutex parameter must be locked before
+ * calling this function.
+ *
+ * @param cond   Condition variable
+ * @param mutex  Mutex
+ */
+OI_BOOL OI_Cond_Wait(OI_COND *cond,
+                     OI_MUTEX *mutex);
+
+/**
+ * This function waits for the specified condition variable to
+ * become signalled or until the specified time has been
+ * exceeded. The mutex parameter must be locked before calling
+ * this function.
+ *
+ * @param cond   Condition variable
+ * @param mutex  Mutex
+ * @param msec   Number of milliseconds to wait
+ *
+ * @return  OI_OK if signaled, OI_TIMEOUT if a timeout occured, or another value if an error ocurred
+ */
+OI_STATUS OI_Cond_TimedWait(OI_COND *cond,
+                            OI_MUTEX *mutex,
+                            OI_UINT32 msec);
+
+/**
+ * This function destroys the specified condition variable
+ *
+ * @param cond Condition variable to be destroyed
+ */
+OI_BOOL OI_Cond_Destroy(OI_COND *cond);
+
+/**
+ * This function returns a free-running 32-bit ms counter which
+ * rolls over about once every 50 days. The count may not
+ * represent any particular time, and should only be used to
+ * measure time differences between two different calls.
+ *
+ * @return The ms count
+ */
+OI_UINT32 OI_Milliseconds(void);
+
+
+/**
+ * This function enters a critical region that must not be
+ * interrupted. This function may be nested.
+ *
+ * @return Value to be passed to matching OI_ExitCritical()
+ */
+OI_UINT32 OI_EnterCritical(void);
+
+/**
+ * This function exits a critical region that must not be
+ * interrupted. This function must be called to match a previous
+ * OI_EnterCritical().
+ *
+ * @param saved_state  Restores the previous critical region
+ *                      state prior to matching
+ *                      OI_EnterCritical()
+ */
+void OI_ExitCritical(OI_UINT32 saved_state);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_THREAD_H */
+
diff --git a/obex_profiles/sdk/include/oi_time.h b/obex_profiles/sdk/include/oi_time.h
new file mode 100644
index 0000000..143622a
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_time.h
@@ -0,0 +1,216 @@
+#ifndef _OI_TIME_H
+#define _OI_TIME_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @file
+ *
+ * This file provides time type definitions and interfaces to time-related functions.
+ *
+ * The stack maintains a 64-bit real-time millisecond clock. The choice of
+ * milliseconds is for convenience, not accuracy.
+ *
+ * Timeouts are specified as tenths of seconds in a 32-bit value. Timeout values
+ * specified by the Bluetooth specification are usually muliple seconds, so
+ * accuracy to a tenth of a second is more than adequate.
+ *
+ * This file also contains macros to convert between seconds and the Link
+ * Manager's 1.28-second units.
+ *
+ */
+
+#include "oi_stddefs.h"
+
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/**
+ * Within the core stack, timeouts are specified in intervals of tenths of seconds.
+ */
+
+typedef OI_UINT16 OI_INTERVAL;
+#define OI_INTERVALS_PER_SECOND     10
+#define MSECS_PER_OI_INTERVAL       (1000 / OI_INTERVALS_PER_SECOND)
+
+/** Maximum interval (54 min 36.7 sec) */
+#define OI_MAX_INTERVAL   0x7fff
+
+
+/**
+ * The granularity of timeouts is OI_INTERVAL this macro rounds up timout values that are specified
+ * as milliseconds to the nearest OI_INTERVAL equivalent. For example this will round up 90ms
+ * to 100ms which is the smallest OI_INTERVAL value.
+ */
+#define OI_MILLISECONDS_ROUND_UP(n)   ((((n) + MSECS_PER_OI_INTERVAL - 1) / MSECS_PER_OI_INTERVAL) * MSECS_PER_OI_INTERVAL)
+
+/**
+ * Macro to convert seconds to OI_INTERVAL time units
+ */
+
+#define OI_SECONDS(n)    ((OI_INTERVAL) ((n) * OI_INTERVALS_PER_SECOND))
+
+/**
+ * Macro to convert milliseconds to OI_INTERVAL time units (Rounded Up)
+ */
+
+#define OI_MSECONDS(n)   ((OI_INTERVAL) (((n) + MSECS_PER_OI_INTERVAL - 1) / MSECS_PER_OI_INTERVAL))
+
+/**
+ * Macro to convert minutes to OI_INTERVAL time units
+ */
+
+#define OI_MINUTES(n)    ((OI_INTERVAL) ((n) * OI_SECONDS(60)))
+
+/** Convert an OI_INTERVAL to milliseconds. */
+#define OI_INTERVAL_TO_MILLISECONDS(i) ((i) * MSECS_PER_OI_INTERVAL)
+
+/**
+   This structure defines the time. The stack depends on
+   relative not absolute time. Any mapping between the stack's
+   real-time clock and absolute time and date is
+   implementation-dependent.
+ */
+
+typedef struct {
+    OI_INT32 seconds;
+    OI_INT16 mseconds;
+} OI_TIME;
+
+/**
+ * This function converts an OI_TIME to milliseconds.
+ *
+ * @param t  Specifies the time to convert
+ *
+ * @return Time in milliseconds
+ */
+OI_UINT32 OI_Time_ToMS(OI_TIME *t);
+
+
+/**
+ * This function compares two time values.
+ *
+ * @param T1 First time to compare.
+ *
+ * @param T2 Second time to compare.
+ *
+ * @return
+ @verbatim
+     -1 if t1 < t2
+      0 if t1 = t2
+     +1 if t1 > t2
+ @endverbatim
+ */
+
+OI_INT16 OI_Time_Compare(OI_TIME *T1,
+                         OI_TIME *T2);
+
+
+/**
+ * This function returns the interval between two times to a granularity of 0.1 seconds.
+ *
+ * @param Sooner Specifies a time value more recent that Later.
+ *
+ * @param Later Specifies a time value later than Sooner.
+ *
+ * @note The result is an OI_INTERVAL value so this function only works for time intervals
+ * that are less than about 71 minutes.
+ *
+ * @return Time interval between the two times = (Later - Sooner)
+ */
+
+OI_INTERVAL OI_Time_Interval(OI_TIME *Sooner,
+                             OI_TIME *Later);
+
+
+
+/**
+ * This function returns the interval between two times to a granularity of milliseconds.
+ *
+ * @param Sooner Specifies a time value more recent that Later.
+ *
+ * @param Later Specifies a time value later than Sooner.
+ *
+ * @note The result is an OI_UINT32 value so this function only works for time intervals
+ * that are less than about 50 days.
+ *
+ * @return Time interval between the two times = (Later - Sooner)
+ */
+
+OI_UINT32 OI_Time_IntervalMsecs(OI_TIME *Sooner,
+                                OI_TIME *Later);
+
+
+
+/**
+ * This function answers the question, Have we reached or gone past the target time?
+ *
+ * @param pTargetTime   Target time
+ *
+ * @return  TRUE means that the time now is at or past target time;
+ *          FALSE means that the target time is still some time in the future
+ */
+
+OI_BOOL  OI_Time_NowReachedTime(OI_TIME *pTargetTime);
+
+/**
+ *  Convert seconds to the Link Manager 1.28-second units; approximate by using 1.25 conversion factor.
+ */
+
+#define OI_SECONDS_TO_LM_TIME_UNITS(lmUnits) ((lmUnits)<4?(lmUnits):(lmUnits)-((lmUnits)>>2))
+
+
+/**
+ *  Convert Link Manager 1.28-second units to seconds;
+ *  approximate by using 1.25 conversion factor.
+ */
+
+#define OI_LM_TIME_UNITS_TO_SECONDS(lmUnits) ((lmUnits) + ((lmUnits)>>2))
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+/* Include for OI_Time_Now() prototype;
+ * must be included at end to obtain OI_TIME typedef.
+ */
+#include "oi_osinterface.h"
+
+/*****************************************************************************/
+#endif /* _OI_TIME_H */
+
diff --git a/obex_profiles/sdk/include/oi_unicode.h b/obex_profiles/sdk/include/oi_unicode.h
new file mode 100644
index 0000000..31b6f9d
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_unicode.h
@@ -0,0 +1,289 @@
+#ifndef _OI_UNICODE_H
+#define _OI_UNICODE_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides utilities for handling unicode strings.
+ *
+ */
+
+#include "oi_status.h"
+#include "oi_stddefs.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * A de facto standard for unicode strings is to prefix the string with a
+ * non-printing space character to indicate the endian-ness of the string.
+ *
+ * When used in this way the non-printing space is referred to as the byte order
+ * indicator. The unicode conversion and comparison functions below check (and
+ * possibly ignore) the byte order indicator.
+ */
+
+#define OI_UNICODE_BYTE_ORDER_INDICATOR_BE  ((OI_CHAR16) 0xFFFE)
+#define OI_UNICODE_BYTE_ORDER_INDICATOR_LE  ((OI_CHAR16) 0xFEFF)
+
+/**
+ * This function converts a UTF-8 string to UTF-16. It is recommended that
+ * the destination buffer be at least twice as many bytes in size as the
+ * source string. Due to multi-byte encoding schemes of UTF-8 the number of
+ * 16-bit words in the resulting UTF-16 string will not necessarily correspond
+ * to the number of bytes in the UTF-8 source string. Note that the
+ * destination string is guaranteed to be null terminated even if the source is
+ * not.
+ *
+ * @param src       Pointer to a UTF-8 string.
+ *
+ * @param srcLen    Number of bytes to convert from the source string.
+ *
+ * @param dst       Pointer to a buffer for holding the resulting UTF-16
+ *                  string.
+ *
+ * @param dstLen    Size of the destination buffer in 16-bit words.
+ *
+ * @return          OI_OK on success, OI_UNICODE_* on error.
+ *
+ */
+OI_STATUS OI_Utf8ToUtf16(const OI_UTF8 *src, OI_INT srcLen,
+                         OI_UTF16 *dst, OI_INT dstLen);
+
+
+/**
+ * This function converts a UTF-16 string to UTF-8. It is recommended that
+ * the destination buffer be approximately twice as many bytes as the number
+ * of 16-bit words in the source string. Due to multi-byte encoding schemes
+ * of UTF-8 the number of bytes in the resulting UTF-8 string will not
+ * necessarily correspond to the number of 16-bit words in the UTF-16 source
+ * string. Note that the destination string is guaranteed to be null
+ * terminated even if the source is not.
+ *
+ * @param src       Pointer to a UTF-16 string.
+ *
+ * @param srcLen    Number of 16-bit words to convert from the source string.
+ *
+ * @param dst       Pointer to a buffer for holding the resulting UTF-18
+ *                  string.
+ *
+ * @param dstLen    Size of the destination buffer in bytes.
+ *
+ * @return          OI_OK on success, OI_UNICODE_* on error.
+ *
+ */
+OI_STATUS OI_Utf16ToUtf8(const OI_UTF16 *src, OI_INT srcLen,
+                         OI_UTF8 *dst, OI_INT dstLen);
+
+
+/**
+ * This function returns the number of 16-bit words used by the string, not
+ * the number of Unicode characters as some Unicode characters may occupy
+ * multiple 16-bit words. In other words, it operates the same way that the
+ * standard C function strlen() would on UTF-8 strings (which also have
+ * multibyte characters).
+ *
+ * @param str    Specifies a UTF-16 string to measure.
+ *
+ * @return       Number of 16-bit words in the UTF-16 string.
+ *
+ */
+OI_UINT OI_StrLenUtf16(const OI_UTF16 *str);
+
+
+/**
+ * This function compares two UTF-16 strings in the same manner that the
+ * standard C function strcmp() would compare UTF-8 strings. It does
+ * an exact 16-bit word for 16-bit word compare rather than check for possible
+ * eqivalent character encodings for those characters that may have different,
+ * but equivalent encodings.
+ *
+ * @param str1   Specifies the first UTF-16 string for comparison.
+ *
+ * @param str2   Specifies the second UTF-16 string for comparison.
+ *
+ * @return       0 if identical, -1 if str1 < str2, 1 if str1 > str2.
+ *
+ */
+OI_INT OI_StrcmpUtf16(const OI_UTF16 *str1,
+                      const OI_UTF16 *str2);
+
+
+/**
+ * This function compares two UTF-16 strings in the same manner that the
+ * standard C function strncmp() would compare UTF-8 strings. It
+ * compares a specified number of 16-bit words. As with OI_StrcmpUtf16(), it does not check for
+ * possible eqivalent character encodings for those characters that may have
+ * different, but equivalent encodings.
+ *
+ * @param str1   A UTF-16 string for comparison.
+ *
+ * @param str2   A UTF-16 string for comparison.
+ *
+ * @param len    Max number of 16-bit words to compare.
+ *
+ * @return       0 if identical, -1 if str1 < str2, 1 if str1 > str2.
+ *
+ */
+OI_INT OI_StrncmpUtf16(const OI_UTF16 *str1,
+                       const OI_UTF16 *str2,
+                       OI_UINT16 len);
+
+
+/**
+ * The unicode encodings that this implementation understands.  UCS-2 is stored in
+ * OI_CHAR16s and may specify OI_UNICODE_UTF16_LE or OI_UNICODE_UTF16_BE as the
+ * encoding if needed.
+ */
+typedef enum {
+    OI_UNICODE_UNKNOWN = 0,
+    OI_UNICODE_UTF8,
+    OI_UNICODE_UTF16_LE,
+    OI_UNICODE_UTF16_BE
+} OI_UNICODE_ENCODING;
+
+/**
+   This structure is used to represent Pascal-style strings.
+   This is used to hold UTF encoded unicode strings.
+ */
+typedef struct {
+    OI_BYTE *p;   /**< Pointer to an array of bytes containing the string. */
+    OI_INT sz;    /**< The number of bytes at p, not the number of characters. */
+} OI_PSTR;
+
+
+/*
+ * UTF encoded unicode string functions
+ */
+
+/**
+ * @param s1  A UTF encoded string
+ * @param e1  The encoding of s1
+ * @param s2  An ASCII string
+ */
+OI_INT OI_PStrcmp(const OI_PSTR *s1,
+                  OI_UNICODE_ENCODING e1,
+                  const OI_CHAR *s2);
+
+/*
+ * This is only valid for US-ASCII characters.  The case of other locales is
+ * not known.
+ */
+OI_INT OI_PStrcmpInsensitive(const OI_PSTR *s1,
+                             OI_UNICODE_ENCODING e1,
+                             const OI_CHAR *s2);
+
+/**
+ * Compare the first len characters of s2 against s1.
+ *
+ * @param s1  A UTF encoded string
+ * @param e1  The encoding of s1
+ * @param s2  An ASCII string
+ * @param len The number of characters in s2 to compare.
+ */
+OI_INT OI_PStrncmp(const OI_PSTR *s1,
+                   OI_UNICODE_ENCODING e1,
+                   const OI_CHAR *s2,
+                   OI_UINT16 len);
+
+/**
+ * @param s1  A UTF encoded string
+ * @param e1  The encoding of s1
+ * @param s2  A UTF encoded string
+ * @param e2  The encoding of s1
+ */
+OI_INT OI_PStrcmp2(const OI_PSTR *s1,
+                   OI_UNICODE_ENCODING e1,
+                   const OI_PSTR *s2,
+                   OI_UNICODE_ENCODING e2);
+
+/**
+ * Return the byte index of the beginning of s2 in s1 or -1 if not found.
+ *
+ * @param s1        The string to search.
+ * @param e1        The encoding of s1.
+ * @param s2        The string to search for.
+ * @param startPos  The character position in s1 to begin searching at.
+ *
+ * @return  The byte position in s1 of the match, or -1 if no match.
+ */
+OI_INT OI_PStrIndexOf(const OI_PSTR *s1,
+                      OI_UNICODE_ENCODING e1,
+                      const OI_CHAR *s2,
+                      OI_INT startPos);
+
+/**
+ * Return the byte index of the beginning of the last instance of s2 in s1
+ * or -1 if not found.
+ *
+ * @param s1        The string to search.
+ * @param e1        The encoding of s1.
+ * @param s2        The string to search for.
+ * @param startPos  The character position in s1 to begin searching at.
+ *
+ * @return  The byte position in s1 of the match, or -1 if no match.
+ */
+OI_INT OI_PStrLastIndexOf(const OI_PSTR *s1,
+                          OI_UNICODE_ENCODING e1,
+                          const OI_CHAR *s2,
+                          OI_INT startPos);
+
+/**
+ * Return the number of characters (not the number of bytes) in s1.
+ */
+OI_INT OI_PStrLen(const OI_PSTR *s1,
+                  OI_UNICODE_ENCODING e1);
+
+/**
+ * Convert a UTF encoded string to UCS-2.
+ *
+ * @param s1  The UCS-2 destination string
+ * @param s2  The UTF source string
+ * @param e2  The encoding of s2
+ */
+void OI_PStrToUStr(OI_CHAR16 *s1,
+                   const OI_PSTR *s2,
+                   OI_UNICODE_ENCODING e2);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_UNICODE_H */
diff --git a/obex_profiles/sdk/include/oi_utils.h b/obex_profiles/sdk/include/oi_utils.h
new file mode 100644
index 0000000..71022a5
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_utils.h
@@ -0,0 +1,407 @@
+#ifndef _OI_UTILS_H
+#define _OI_UTILS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *
+ * This file provides the interface for utility functions.
+ * Among the utilities are strlen (string length), strcmp (string compare), and
+ * other string manipulation functions. These are provided for those plaforms
+ * where this functionality is not available in stdlib.
+ */
+
+#include <stdarg.h>
+#include "oi_common.h"
+#include "oi_string.h"
+#include "oi_bt_spec.h"
+
+/** \addtogroup Misc Miscellaneous APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Opaque type for a callback function handle. See OI_ScheduleCallbackFunction().
+ */
+typedef OI_UINT32 OI_CALLBACK_HANDLE;
+
+
+/**
+ * Function prototype for a timed procedure callback.
+ *
+ * @param arg                 Value that was passed into the OI_ScheduleCallbackFunction() function
+ *
+ */
+typedef void (*OI_SCHEDULED_CALLBACK)(void *arg);
+
+
+/**
+ * This function registers a function to be called when a timeout expires. This API uses BLUEmagic's internal
+ * function dispatch mechanism, so applications that make extensive use of this facility may need to
+ * increase the value of DispatchTableSize in the configuration block for the dispatcher (see
+ * oi_bt_stack_config.h).
+ *
+ * @param callbackFunction    Specifies the function that will be called when the timeout expires.
+ *
+ * @param arg                 Value that will be returned as the parameter to the callback function.
+ *
+ * @param timeout             Timeout value expressed in OI_INTERVALs (tenths of seconds); can be
+ *                            zero in which case the callback function will be called as soon as
+ *                            possible.
+ *
+ * @param handle              NULL or a pointer to receive the callback handle.
+ *
+ * @return                    OI_OK if the function was reqistered, or an error status.
+ */
+OI_STATUS OI_ScheduleCallbackFunction(OI_SCHEDULED_CALLBACK callbackFunction,
+                                      void                 *arg,
+                                      OI_INTERVAL           timeout,
+                                      OI_CALLBACK_HANDLE   *handle);
+
+
+/**
+ * This function cancels a function registered with OI_ScheduleCallbackFunction() before its timer expires.
+ *
+ * @param handle              Handle returned by OI_ScheduleCallbackFunction().
+ *
+ * @return                    OI_OK if the function was cancelled, or an error status.
+ */
+OI_STATUS OI_CancelCallbackFunction(OI_CALLBACK_HANDLE handle);
+
+/**
+ * This function parses a Bluetooth device address from the specified string.
+ *
+ * @param str   String to parse
+ * @param addr  Parsed address, if successful
+ *
+ * @return TRUE if an address was successfully parsed, FALSE otherwise
+ */
+
+OI_BOOL OI_ParseBdAddr(const OI_CHAR *str,
+                       OI_BD_ADDR    *addr) ;
+
+/**
+ * Printf function for platforms which have no stdio or printf available.
+ * OI_Printf supports the basic formatting types, with the exception of
+ * floating point types. Additionally, OI_Printf supports several formats
+ * specific to BLUEmagic 3.0 software:
+ *
+ * \%!   Prints the string for an #OI_STATUS value.
+ *       @code OI_Printf("There was an error %!", status); @endcode
+ *
+ * \%@   Prints a hex dump of a buffer.
+ *       Requires a pointer to the buffer and a signed integer length
+ *       (0 for default length). If the buffer is large, only an excerpt will
+ *       be printed.
+ *       @code OI_Printf("Contents of buffer %@", buffer, sizeof(buffer)); @endcode
+ *
+ * \%:   Prints a Bluetooth address in the form "HH:HH:HH:HH:HH:HH".
+ *       Requires a pointer to an #OI_BD_ADDR.
+ *       @code OI_Printf("Bluetooth address %:", &bdaddr); @endcode
+ *
+ * \%^   Decodes and prints a data element as formatted XML.
+ *       Requires a pointer to an #OI_DATAELEM.
+ *       @code OI_Printf("Service attribute list is:\n%^", &attributes); @endcode
+ *
+ * \%=   Prints an OBEX header. 
+ *       Requires a pointer to an #OI_OBEX_HEADER
+ *       @code OI_Printf("OBEX header is:\n%=\n", &header); @endcode
+ *
+ * \%/   Prints the base file name of a path, that is, the final substring
+ *       following a '/' or '\\' character. Requires a pointer to a null
+ *       terminated string.
+ *       @code OI_Printf("File %/", "c:\\dir1\\dir2\\file.txt"); @endcode
+ *
+ * \%~   Prints a string, escaping characters as needed to display it in
+ *       ASCII. Requires a pointer to an #OI_PSTR and an #OI_UNICODE_ENCODING
+ *       parameter.
+ *       @code OI_Printf("Identifier %~", &id, OI_UNICODE_UTF16_BE); @endcode
+ *
+ * \%[   Inserts an ANSI color escape sequence. Requires a single character
+ *       identifying the color to select. Colors are red (r/R), green (g/G),
+ *       blue (b/B), yellow (y/Y), cyan (c/C), magenta (m/M), white (W),
+ *       light-gray (l/L), dark-gray (d/D), and black (0). The lower case is
+ *       dim, the upper case is bright (except in the case of light-gray and
+ *       dark-gray, where bright and dim are identical). Any other value will
+ *       select the default color.
+ *       @code OI_Printf("%[red text %[black %[normal\n", 'r', '0', 0); @endcode
+ *
+ * \%a   Same as \%s, except '\\r' and '\\n' are output as "<cr>" and "<lf>".
+ *       \%?a is valid, but \%la is not.
+ *
+ * \%b   Prints an integer in base 2.
+ *       @code OI_Printf("Bits are %b", I); @endcode
+ *
+ * \%lb  Prints a long integer in base 2.
+ *
+ * \%?b  Prints the least significant N bits of an integer (or long integer)
+ *       in base 2. Requires the integer and a length N.
+ *       @code OI_Printf("Bottom 4 bits are: %?b", I, 4); @endcode
+ *
+ * \%B   Prints an integer as boolean text, "TRUE" or "FALSE".
+ *       @code OI_Printf("The value 0 is %B, the value 1 is %B", 0, 1); @endcode
+ *
+ * \%?s  Prints a substring up to a specified maximum length.
+ *       Requires a pointer to a string and a length parameter.
+ *       @code OI_Printf("String prefix is %?s", str, 3); @endcode
+ *
+ * \%ls  Same as \%S.
+ *
+ * \%S   Prints a UTF16 string as UTF8 (plain ASCII, plus 8-bit char sequences
+ *       where needed). Requires a pointer to #OI_CHAR16. \%?S is valid. The
+ *       length parameter is in OI_CHAR16 characters.
+ *
+ * \%T   Prints time, formatted as "secs.msecs".
+ *       Requires pointer to #OI_TIME struct, NULL pointer prints current time.
+ *       @code OI_Printf("The time now is %T", NULL); @endcode
+ *
+ *  @param format   Specifies the format string
+ *
+ */
+void OI_Printf(const OI_CHAR *format, ...);
+
+
+/**
+ * Var-args version OI_Printf
+ *
+ * @param format   Same as for OI_Printf.
+ *
+ * @param argp     Var-args list.
+ */
+void OI_VPrintf(const OI_CHAR *format, va_list argp);
+
+
+/**
+ * This function writes a formatted string to a buffer. This function supports the same format specifiers as
+ * OI_Printf().
+ *
+ * @param buffer   Destination buffer for the formatted string.
+ *
+ * @param bufLen   Length of the destination buffer.
+ *
+ * @param format   Specifies the format string.
+ *
+ * @return   Number of characters written or -1 in the case of an error.
+ */
+OI_INT32 OI_SNPrintf(OI_CHAR *buffer,
+                    OI_UINT16 bufLen,
+                    const OI_CHAR* format, ...);
+
+
+/**
+ * Var-args version OI_SNPrintf
+ *
+ * @param buffer   Destination buffer for the formatted string.
+ *
+ * @param bufLen   Length of the destination buffer.
+ *
+ * @param format   Specifies the format string
+ *
+ * @param argp     Var-args list.
+ *
+ * @return   Number of characters written or -1 in the case of an error.
+ */
+OI_INT32 OI_VSNPrintf(OI_CHAR *buffer,
+                     OI_UINT16 bufLen,
+                     const OI_CHAR *format, va_list argp);
+
+
+/**
+ * This function converts a string to an integer.
+ *
+ * @param str  String to parse.
+ *
+ * @return Integer value of the string or 0 if the string could not be parsed.
+ */
+OI_INT OI_atoi(const OI_CHAR *str);
+
+
+/**
+ * This function parses a signed integer in a string.
+ *
+ * This function skips leading whitespace (space and tabs only) and parses a decimal or hex string. A hex string
+ * must be prefixed by "0x". A pointer to the first character following the integer is returned. If the string does 
+ * not describe an integer, the pointer passed in is returned.
+ *
+ * @param str    String to parse.
+ *
+ * @param val    Pointer to receive the parsed integer value.
+ *
+ * @return       Pointer to the first character following the integer or the pointer passed in.
+ */
+const OI_CHAR* OI_ScanInt(const OI_CHAR *str,
+                          OI_INT32 *val);
+
+
+/**
+ * This function parses an unsigned integer in a string.
+ *
+ * This function skips leading whitespace (space and tabs only) and parses a decimal or hex string. A hex string
+ * must be prefixed by "0x". A pointer to first character following the unsigned integer is returned. If the string does
+ * not describe an integer, the pointer passed in is returned.
+ *
+ * @param str    String to parse.
+ *
+ * @param val    Pointer to receive the parsed unsigned integer value.
+ *
+ * @return       Pointer to the first character following the unsigned integer or the pointer passed in.
+ */
+const OI_CHAR* OI_ScanUInt(const OI_CHAR *str,
+                           OI_UINT32 *val);
+
+/**
+ * This function parses a whitespace delimited substring out of a string.
+ *
+ * @param str     Input string to parse.
+ * @param outStr  Buffer to return the substring.
+ * @param len     Length of outStr.
+ *
+ *
+ * @return       Pointer to the first character following the substring or the pointer passed in.
+ */
+const OI_CHAR* OI_ScanStr(const OI_CHAR *str,
+                          OI_CHAR *outStr,
+                          OI_UINT16 len);
+
+
+/**
+ * This function parses a string for one of a set of alternative value. This function skips leading whitespace
+ * (space and tabs only) and parses text matching one of the alternative strings. A pointer to first character
+ * following the matched text is returned. This function does a case insensitive compare, and must only
+ * match the "|alt|" string (length need not match).
+ *
+ * I.E. "debugger" would match index 1 of "|str1|debug|str2"
+ *
+ * @param str    String to parse.
+ *
+ * @param alts   Alternative matching strings separated by '|'
+ *
+ * @param index  Pointer to receive the index of the matching alternative, return value is -1 if
+ *               there is no match.
+ *
+ * @return       Pointer to the first character following the matched value or the pointer passed in 
+ *               if there was no matching text.
+ */
+const OI_CHAR* OI_ScanAlt(const OI_CHAR *str,
+                          const OI_CHAR *alts,
+                          OI_INT *index);
+
+/**
+ * This function is identical to OI_ScanAlt, with the exception that the strings
+ * must additionally match both length and case in order to be judged a match.
+ *
+ * @param str    String to parse.
+ *
+ * @param alts   Alternative matching strings separated by '|'
+ *
+ * @param index  Pointer to receive the index of the matching alternative, return value is -1 if
+ *               there is no match.
+ *
+ * @return       Pointer to the first character following the matched value or the pointer passed in 
+ *               if there was no matching text.
+ */
+const OI_CHAR* OI_ScanAltExact(const OI_CHAR *str,
+                               const OI_CHAR *alts,
+                               OI_INT *index);
+
+/**
+ * This function parses a string for a BD Addr. This function skips leading whitespace (space and tabs only) and parses a
+ * Bluetooth device address with nibbles optionally separated by colons. A pointer to first
+ * character following the BD Addr is returned.
+ *
+ * @param str    String to parse.
+ *
+ * @param addr   Pointer to receive the Bluetooth device address.
+ *
+ * @return       Pointer to the first character following the BD Addr or the pointer passed in.
+ */
+const OI_CHAR* OI_ScanBdAddr(const OI_CHAR *str,
+                             OI_BD_ADDR *addr);
+
+
+/** Get a character from a digit integer value (0 - 9). */
+#define OI_DigitToChar(d) ((d) + '0')
+
+/**
+ * Determine the maximum and minimum between two arguments.
+ *
+ * @param a  1st value
+ * @param b  2nd value
+ *
+ * @return Maximum or minimum value between a and b
+ */
+#define OI_MAX(a, b) (((a) < (b)) ? (b) : (a) )
+#define OI_MIN(a, b) (((a) > (b)) ? (b) : (a) )
+
+/**
+ * Compare two BD_ADDRs
+ * SAME_BD_ADDR - Boolean: TRUE if they are the same address
+ */
+
+#define SAME_BD_ADDR(x, y)      (0 == OI_MemCmp((x),(y),OI_BD_ADDR_BYTE_SIZE) )
+
+/**
+ * Remove newlines from a string.  A newline on the end is replaced
+ * with a null.  Newlines elsewhere are replaced with spaces.
+ *
+ * @param str    String to parse.
+ */
+void OI_RemoveNewlines(OI_CHAR *str);
+
+/**
+ *  This function terminates or truncates a UTF8 string at a maximum length with a 
+ *  null-terminator. This function ensures that termination/truncation does not occur 
+ *  in the middle of a multi-byte sequence. As a result, the final length may be 
+ *  shorter than the requested maxLen.
+ *
+ *  @note Null-termination occurs in-place; termination alters the caller's string.
+ *
+ * @param pStr      Pointer to the UTF8 string
+ *
+ * @param maxLen    Requested maximum length of the string after truncation
+ *
+ * @return          Returns the actual length of the string after termination/truncation 
+ *                  (if any), i.e., returns strlen(str)
+ *
+ */
+OI_UINT OI_UTF8_Terminate(OI_UTF8 *pStr, OI_UINT maxLen);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_UTILS_H */
+
diff --git a/obex_profiles/sdk/include/oi_xml.h b/obex_profiles/sdk/include/oi_xml.h
new file mode 100644
index 0000000..35fbe7e
--- /dev/null
+++ b/obex_profiles/sdk/include/oi_xml.h
@@ -0,0 +1,306 @@
+#ifndef _OI_XML_H_
+#define _OI_XML_H_
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * Basic xML parser.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_unicode.h"
+
+/** \addtogroup XML */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * This structure defines an XML attribute.
+ */
+typedef struct OI_XML_ATTRIBUTE {
+    OI_PSTR name;                  /**< Name of this attribute */
+    OI_PSTR value;                 /**< Value of this attribute */
+    OI_CHAR quote;                 /**< Indicates if values was wrapped in single or double quotes */
+    struct OI_XML_ATTRIBUTE *next; /**< Next attribute in the list */
+} OI_XML_ATTRIBUTE;
+
+
+
+typedef enum {
+    OI_XML_ELEMENT,        /**<   <foo> .. </foo>         */
+    OI_XML_TEXT,           /**<   Text content            */
+    OI_XML_DECLARATION,    /**<   <?xml ... ?>            */
+    OI_XML_CDATA,          /**<   <![CDATA[ ... ]]>       */
+    OI_XML_PI,             /**<   <? ... ?>      */
+    OI_XML_COMMENT,        /**<   <!-- ... >              */
+    OI_XML_MISCELLANEOUS   /**<   <! ... >                */
+} OI_XML_NODE_TYPE;
+
+
+/**
+  * This structure defines an XML node. The content type indentifies if this is an XML element or one
+  * of the non-element entities. The content type of an XML element is OI_XML_TEXT, if the name is
+  * null (name.sz == 0) this is a textual content that is intermingled with other elements. For
+  * example in the following XML:
+  *
+  * <outer>
+  *      <inner1\>
+  *      text
+  *      <inner2>more text<\inner2>
+  * </outer>
+  *
+  * The node "outer" has three children, they all have content type OI_XML_TEXT, "inner1" has an
+  * empty content string, the second child has no name and a content string "text", the third child
+  * has the name "inner2 and content string "more text" this node has no children.
+  */
+typedef struct OI_XML_NODE {
+    OI_PSTR name;                     /**< The node tag - may be an empty string (size 0) */
+    OI_PSTR content;                  /**< Text content of the node */
+    OI_XML_NODE_TYPE nodeType;        /**< Type of this node */
+    OI_XML_ATTRIBUTE *attributes;     /**< Linked list of attributes for this node */
+    struct OI_XML_NODE *parent;       /**< Enclosing parent of this node */
+    struct OI_XML_NODE *children;     /**< Nodes nested within this node */
+    struct OI_XML_NODE *sibling;      /**< Next right-hand sibling of this node */
+    void *user;                       /**< This is available for use by the application. */
+} OI_XML_NODE;
+
+
+/**
+ * This structure defines an XML document.
+ */
+typedef struct {
+    OI_UNICODE_ENCODING encoding;
+    OI_XML_NODE root;
+} OI_XML_DOCUMENT;
+
+
+/*
+ * The following XML sequence:
+ *
+ *   <p>the quick <em>brown</em> dog jumped</p>
+ *
+ * will generate the following indicator sequence:
+ *
+ *   OI_XML_START_TAG_IND(p)
+ *   OI_XML_CONTENT_IND(the quick )
+ *   OI_XML_START_TAG_IND(em)
+ *   OI_XML_CONTENT_IND(brown)
+ *   OI_XML_END_TAG_IND(em)
+ *   OI_XML_CONTENT_IND( dog jumped)
+ *   OI_XML_END_TAG_IND(p)
+ */
+typedef void (*OI_XML_START_TAG_IND)(OI_XML_NODE *node);
+typedef void (*OI_XML_END_TAG_IND)(OI_XML_NODE *node);
+typedef void (*OI_XML_NON_ELEMENT_IND)(OI_XML_NODE *node);
+typedef void (*OI_XML_CONTENT_IND)(OI_PSTR *content, OI_XML_NODE_TYPE nodeType);
+
+/**
+  This structure defines the XML start, end, and content node
+  indicators.
+  */
+typedef struct {
+    OI_XML_START_TAG_IND startTagInd;
+    OI_XML_END_TAG_IND endTagInd;
+    OI_XML_NON_ELEMENT_IND nonElementInd;
+    OI_XML_CONTENT_IND contentInd;
+} OI_XML_PARSER_INDICATORS;
+
+/**
+ * Parses an XML stream and build a tree stored in the children of the @a document parameter. nodes
+ * are dynamically allocated and inserted into the tree as they are parsed, then the corresponding
+ * indicator is issued. When done with the tree OI_XML_FreeTree(document) must be called to release
+ * the memory.
+ *
+ * @param stream      The raw XML stream. This cannot point to
+ *                    the inside of a node, it must be at the
+ *                    beginning of a node or content section.
+ *
+ * @param indicators  These are called when nodes are opened, closed, or content is parsed.  The
+ *                    parameters to these functions are valid until OI_XML_FreeTree is called.
+ *
+ * @param maxDepth    The maximum number of XML layers to traverse before declaring failure.
+ *                    If maxDepth==0 parser will use the internal maximum.
+ *
+ * @param encoding    encoding of the XML stream (OI_UNICODE_UNKNOWN, OI_UNICODE_UTF8, OI_UNICODE_UTF16_LE, OI_UNICODE_UTF16_BE)
+ *
+ * @param document    [OUT] The parsed XML document
+ *
+ * @return      OI_OK If no errors encountered.
+ */
+OI_STATUS OI_XML_ParseTree(const OI_PSTR *stream,
+                           const OI_XML_PARSER_INDICATORS *indicators,
+                           OI_UINT maxDepth,
+                           OI_UNICODE_ENCODING encoding,
+                           OI_XML_DOCUMENT *document);
+
+/**
+ * Release any memory used in building a parse tree.
+ *
+ * @param document   The children of this node will be freed.
+ */
+void OI_XML_FreeTree(OI_XML_DOCUMENT *document);
+
+
+/**
+ * Get the type of a node.
+ *
+ * @param node    The node whose type we are interested in.
+ *
+ * @return      The type of the node.
+ */
+OI_XML_NODE_TYPE OI_XML_GetNodeType(const OI_XML_NODE *node);
+
+
+/**
+ * Retrieve a specified attribute from a node.
+ *
+ * @param document    The document containing the node
+ *
+ * @param node         The node whose attribute we are interested in.
+ *
+ * @param name        The name of the attribute.
+ *
+ * @return  The attribute or NULL if it is not found.
+ */
+const OI_XML_ATTRIBUTE* OI_XML_GetAttribute(const OI_XML_DOCUMENT *document,
+                                            const OI_XML_NODE *node,
+                                            const OI_CHAR *name);
+
+
+/**
+ * Gets the unicode name of an XML node
+ *
+ * @param node       The node whose name we want to get
+ *
+ * @return      Pointer to unicode string with the name or NULL if the node does not have a name.
+ */
+const OI_PSTR* OI_XML_GetNodeName(const OI_XML_NODE *node);
+
+
+/**
+ *  Returns a count of the number of children for a specific node. The count includes text and
+ *  nested markup nodes.
+ *
+ * @param node   The node whose children count we want.
+ *
+ * @return      The number of child nodes for the current node
+ */
+OI_UINT16 OI_XML_GetNumChildren(const OI_XML_NODE *node);
+
+
+/**
+ * Returns the first child node of the given node or NULL if the node has no children.
+ *
+ * @param node   The node whose first child we want.
+ *
+ *
+ *@return     The first child node or NULL if the node has no children.
+ */
+const OI_XML_NODE* OI_XML_GetFirstChildNode(const OI_XML_NODE *node);
+
+
+/**
+ * Returns the next sibling node of the given node or NULL if the node has no siblings.
+ *
+ * @param node   The node whose next sibling we want.
+ *
+ *@return     The sibling node or NULL if the node has no siblings.
+ */
+const OI_XML_NODE* OI_XML_GetNextSiblingNode(const OI_XML_NODE *node);
+
+
+/**
+ * Gets the unicode text content of an XML node. Note that if the text content is intermingled with
+ * nested nodes only the first content block, which may be empty, is returned. The remaining
+ * content is accsssed via name-less child nodes of this node.
+ *
+ * @param node       The node whose content we want to get
+ *
+ * @return     Pointer to unicode content string or NULL if the node has no content.
+ */
+const OI_PSTR* OI_XML_GetTextContent(const OI_XML_NODE *node);
+
+
+/**
+ *  Returns a count of the number of attributes for a specific node.
+ *
+ * @param node   The node whose attribute count we want.
+ *
+ * @return      The number of attributes for the current node
+ */
+OI_UINT16 OI_XML_GetNumAttributes(const OI_XML_NODE *node);
+
+
+/**
+ * Retrieve the first attribute from a node.
+ *
+ * @param node     The node whose attributes we are interested in.
+ *
+ * @return  The attribute or NULL if there are none.
+ */
+const OI_XML_ATTRIBUTE *OI_XML_GetFirstAttribute(const OI_XML_NODE *node);
+
+
+/**
+ * Retrieve the the next attribute from a node given the previous attribute
+ *
+ * @param node     The node whose attributes we are interested in.
+ *
+ * @param prev    The previous attribute
+ *
+ * @return  The attribute or NULL if there are no more.
+ */
+const OI_XML_ATTRIBUTE *OI_XML_GetNextAttribute(const OI_XML_NODE *node,
+                                                const OI_XML_ATTRIBUTE *prev);
+
+
+
+/*
+ * A few functions provided for printing the internal structures to standard out.
+ * These only print in debug builds.
+ */
+void OI_XML_DumpTree(OI_XML_DOCUMENT *document);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_XML_H_ */
diff --git a/obex_profiles/sdk/include/profiles/oi_bip_cli.h b/obex_profiles/sdk/include/profiles/oi_bip_cli.h
new file mode 100644
index 0000000..6ef76bf
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_bip_cli.h
@@ -0,0 +1,689 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/** @file
+ * This file provides the API for the client side of the Basic Imaging Profile.
+ *
+ * Most functions in this API involve a parameter block. These blocks are
+ * explained by oi_bip_spec.h.
+ *
+ * A note about object lifetimes:
+ *
+ * In keeping with the usual conventions of BM3, all indirectly referenced data
+ * passed to a BIP function must remain valid until the corresponding callback
+ * is invoked. This means, for example, that storage for parameters should not
+ * be allocated on the stack of the function calling into BIP.
+ *
+ * There is one specific class of exception to this rule for BIP. An
+ * OI_OBEX_UNICODE or OI_OBEX_BYTESEQ entry in a parameter block may be safely
+ * allocated on the stack because its entries are copied into an internal data
+ * structre by the BIP call. However, the data pointed to by these structures must obey
+ * the usual rules. If a programmer chooses to take advantage of this
+ * exception, it is very important that the entry NOT be referenced by the
+ * callback function because it will still contain a stale pointer to a stack
+ * variable that has since gone out of scope. The application must have another
+ * reference to the underlying data if it needs to free it or process it
+ * further.
+ */
+
+#ifndef _OI_BIPCLI_H
+#define _OI_BIPCLI_H
+
+#include "oi_bip_spec.h"
+#include "oi_obexspec.h"
+#include "oi_obexcli.h"
+
+/** \addtogroup BIP BIP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef OI_OBEXCLI_CONNECTION_HANDLE  OI_BIPCLI_HANDLE;
+
+/**
+ * Indicates an authentication request for a BIP connection
+ * @param connection    Connection handle associated with the request; the
+ * client should respond with OI_BIPCLI_AuthenticationResponse
+ */
+typedef void(*OI_BIPCLI_AUTH_IND)(OI_BIPCLI_HANDLE connection);
+
+/**
+ * Indicates a connection request has been completed
+ * @param connection    Connection handle
+ * @param status      Result of the connection: OI_OK or an error
+ */
+typedef void(*OI_BIPCLI_CONNECT_CFM)(OI_BIPCLI_HANDLE connection,
+                                     OI_STATUS status);
+
+/**
+ * Indicates that a connection is no longer in place
+ */
+typedef void(*OI_BIPCLI_DISCONNECT_IND)(OI_BIPCLI_HANDLE connection);
+
+
+
+/* *************
+ * ************* GetCapabilities
+ * *************
+ */
+
+
+/**
+ * This callback function indicates the result of a GET_CAPABILITIES operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_GET_CAPABILITIES_CFM)(OI_BIPCLI_HANDLE connection,
+                                              OI_BIP_GET_CAPABILITIES_PARAMS *params,
+                                              OI_STATUS result);
+
+/**
+ * This function performs a BIP GET_CAPABILITIES operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_GetCapabilities(OI_BIPCLI_HANDLE connection,
+                                    OI_BIPCLI_GET_CAPABILITIES_CFM cb,
+                                    OI_BIP_GET_CAPABILITIES_PARAMS *params);
+
+/* *************
+ * ************* PutImage
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a PUT_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_PUT_IMAGE_CFM)(OI_BIPCLI_HANDLE connection,
+                                       OI_BIP_PUT_IMAGE_PARAMS *params,
+                                       OI_STATUS result);
+/**
+ * This function performs a BIP PUT_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+
+OI_STATUS OI_BIPCLI_PutImage(OI_BIPCLI_HANDLE connection,
+                             OI_BIPCLI_PUT_IMAGE_CFM cb,
+                             OI_BIP_PUT_IMAGE_PARAMS *params);
+
+/* *************
+ * ************* PutLinkedThumbnail
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a PUT_LINKED_THUMBNAIL operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_PUT_LINKED_THUMBNAIL_CFM)(OI_BIPCLI_HANDLE connection,
+                                                  OI_BIP_PUT_LINKED_THUMBNAIL_PARAMS *params,
+                                                  OI_STATUS result);
+
+/**
+ * This function performs a BIP PUT_LINKED_THUMBNAIL operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_PutLinkedThumbnail(OI_BIPCLI_HANDLE connection,
+                                       OI_BIPCLI_PUT_LINKED_THUMBNAIL_CFM cb,
+                                       OI_BIP_PUT_LINKED_THUMBNAIL_PARAMS *params);
+
+/* *************
+ * ************* PutLinkedAttachment
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a PUT_LINKED_ATTACHMENT operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_PUT_LINKED_ATTACHMENT_CFM)(OI_BIPCLI_HANDLE connection,
+                                                   OI_BIP_PUT_LINKED_ATTACHMENT_PARAMS *params,
+                                                   OI_STATUS result);
+
+/**
+ * This function performs a BIP PUT_LINKED_ATTACHMENT operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_PutLinkedAttachment(OI_BIPCLI_HANDLE connection,
+                                        OI_BIPCLI_PUT_LINKED_ATTACHMENT_CFM cb,
+                                        OI_BIP_PUT_LINKED_ATTACHMENT_PARAMS *params);
+
+
+/* *************
+ * ************* RemoteDisplay
+ * *************
+ */
+
+/**
+ * This Callback function indicates the result of a REMOTE_DISPLAY operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_REMOTE_DISPLAY_CFM)(OI_BIPCLI_HANDLE connection,
+                                            OI_BIP_REMOTE_DISPLAY_PARAMS *params,
+                                            OI_STATUS result);
+
+
+/**
+ * This function performs a BIP REMOTE_DISPLAY operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_RemoteDisplay(OI_BIPCLI_HANDLE connection,
+                                  OI_BIPCLI_REMOTE_DISPLAY_CFM cb,
+                                  OI_BIP_REMOTE_DISPLAY_PARAMS *params);
+
+
+/* *************
+ * ************* GetImagesList
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a GET_IMAGES_LIST operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_GET_IMAGES_LIST_CFM)(OI_BIPCLI_HANDLE connection,
+                                             OI_BIP_GET_IMAGES_LIST_PARAMS *params,
+                                             OI_STATUS result);
+
+/**
+ * This function performs a BIP GET_IMAGES_LIST operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_GetImagesList(OI_BIPCLI_HANDLE connection,
+                                  OI_BIPCLI_GET_IMAGES_LIST_CFM cb,
+                                  OI_BIP_GET_IMAGES_LIST_PARAMS *params);
+
+/* *************
+ * ************* GetImageProperties
+ * *************
+ */
+
+
+/**
+ * This callback function indicates the result of a GET_IMAGE_PROPERTIES operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request.
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_GET_IMAGE_PROPERTIES_CFM)(OI_BIPCLI_HANDLE connection,
+                                                  OI_BIP_GET_IMAGE_PROPERTIES_PARAMS *params,
+                                                  OI_STATUS result);
+
+/**
+ * This function performs a BIP GET_IMAGE_PROPERTIES operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_GetImageProperties(OI_BIPCLI_HANDLE connection,
+                                       OI_BIPCLI_GET_IMAGE_PROPERTIES_CFM cb,
+                                       OI_BIP_GET_IMAGE_PROPERTIES_PARAMS *params);
+
+/* *************
+ * ************* GetImage
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a GET_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_GET_IMAGE_CFM)(OI_BIPCLI_HANDLE connection,
+                                       OI_BIP_GET_IMAGE_PARAMS *params,
+                                       OI_STATUS result);
+
+/**
+ * This function performs a BIP GET_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_GetImage(OI_BIPCLI_HANDLE connection,
+                             OI_BIPCLI_GET_IMAGE_CFM cb,
+                             OI_BIP_GET_IMAGE_PARAMS *params);
+
+
+/* *************
+ * ************* GetLinkedThumbnail
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a GET_LINKED_THUMBNAIL operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_GET_LINKED_THUMBNAIL_CFM)(OI_BIPCLI_HANDLE connection,
+                                                  OI_BIP_GET_LINKED_THUMBNAIL_PARAMS *params,
+                                                  OI_STATUS result);
+
+/**
+ * This function performs a BIP GET_LINKED_THUMBNAIL operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_GetLinkedThumbnail(OI_BIPCLI_HANDLE connection,
+                                       OI_BIPCLI_GET_LINKED_THUMBNAIL_CFM cb,
+                                       OI_BIP_GET_LINKED_THUMBNAIL_PARAMS *params);
+
+
+/* *************
+ * ************* GetLinkedAttachment
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a GET_LINKED_ATTACHMENT operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_GET_LINKED_ATTACHMENT_CFM)(OI_BIPCLI_HANDLE connection,
+                                                   OI_BIP_GET_LINKED_ATTACHMENT_PARAMS *params,
+                                                   OI_STATUS result);
+
+/**
+ * This function performs a BIP GET_LINKED_ATTACHMENT operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_GetLinkedAttachment(OI_BIPCLI_HANDLE connection,
+                                        OI_BIPCLI_GET_LINKED_ATTACHMENT_CFM cb,
+                                        OI_BIP_GET_LINKED_ATTACHMENT_PARAMS *params);
+
+/* *************
+ * ************* DeleteImage
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a DELETE_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_DELETE_IMAGE_CFM)(OI_BIPCLI_HANDLE connection,
+                                          OI_STATUS result);
+
+/**
+ * This function performs a BIP DELETE_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_DeleteImage(OI_BIPCLI_HANDLE connection,
+                                OI_BIPCLI_DELETE_IMAGE_CFM cb,
+                                OI_BIP_DELETE_IMAGE_PARAMS *params);
+
+/* *************
+ * ************* StartPrint
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a START_PRINT operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_START_PRINT_CFM)(OI_BIPCLI_HANDLE connection,
+                                         OI_BIP_START_PRINT_PARAMS *params,
+                                         OI_STATUS result);
+
+/**
+ * This function performs a BIP START_PRINT operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_StartPrint(OI_BIPCLI_HANDLE connection,
+                               OI_BIPCLI_START_PRINT_CFM cb,
+                               OI_BIP_START_PRINT_PARAMS *params);
+
+/* *************
+ * ************* GetPartialImage
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a GET_PARTIAL_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_GET_PARTIAL_IMAGE_CFM)(OI_BIPCLI_HANDLE connection,
+                                               OI_BIP_GET_PARTIAL_IMAGE_PARAMS *params,
+                                               OI_STATUS result);
+
+/**
+ * This function performs a BIP GET_PARTIAL_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses;t his must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_GetPartialImage(OI_BIPCLI_HANDLE connection,
+                                    OI_BIPCLI_GET_PARTIAL_IMAGE_CFM cb,
+                                    OI_BIP_GET_PARTIAL_IMAGE_PARAMS *params);
+
+/* *************
+ * ************* StartArchive
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a START_ARCHIVE operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_START_ARCHIVE_CFM)(OI_BIPCLI_HANDLE connection,
+                                           OI_STATUS result);
+
+/**
+ * This function performs a BIP START_ARCHIVE operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_StartArchive(OI_BIPCLI_HANDLE connection,
+                                 OI_BIPCLI_START_ARCHIVE_CFM cb,
+                                 OI_BIP_START_ARCHIVE_PARAMS *params);
+
+/* *************
+ * ************* GetMonitoringImage
+ * *************
+ */
+
+/**
+ * This callback function indicates the result of a GET_MONITORING_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param params        Pointer to the parameter block specified by the
+ * application during the request
+ * @param result        Response from the server; if this is anything other than
+ * OI_OBEX_CONTINUE then it is safe for the application to deallocate or
+ * otherwise destroy the parameter block
+ */
+typedef void(*OI_BIPCLI_GET_MONITORING_IMAGE_CFM)(OI_BIPCLI_HANDLE connection,
+                                                  OI_BIP_GET_MONITORING_IMAGE_PARAMS *params,
+                                                  OI_STATUS result);
+
+/**
+ * This function performs a BIP GET_MONITORING_IMAGE operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ * @param params        Pointer to a parameter block, allocated by the connection,
+ * to be used for any requests and responses; this must remain valid until the
+ * final confirmation callback
+ */
+OI_STATUS OI_BIPCLI_GetMonitoringImage(OI_BIPCLI_HANDLE connection,
+                                       OI_BIPCLI_GET_MONITORING_IMAGE_CFM cb,
+                                       OI_BIP_GET_MONITORING_IMAGE_PARAMS *params);
+
+/* *************
+ * ************* GetStatus
+ * *************
+ */
+/**
+ * This callback indicates the result of a GET_STATUS operation.
+ * @param connection    Connection handle for this request
+ * @param result        Status result from the server
+ */
+typedef void(*OI_BIPCLI_GET_STATUS_CFM)(OI_BIPCLI_HANDLE connection,
+                                        OI_STATUS result);
+/**
+ * This function performs a BIP GET_STATUS operation.
+ * @param connection    Connection handle for this request
+ * @param cb            Completion callback
+ */
+
+OI_STATUS OI_BIPCLI_GetStatus(OI_BIPCLI_HANDLE connection,
+                              OI_BIPCLI_GET_STATUS_CFM cb);
+
+
+
+/* *************  */
+
+
+/**
+ * This function connects to a BIP server.
+ *
+ * @param addr              BD_ADDR of the remote BIP server
+ * @param lowerProtocol     This identifies the RFCOMM channel number or the L2CAP PSM for the
+ *                          FTP server running on the remote device.  the remote device. The caller
+ *                          will normally perform service discovery on the remote device to obtain
+ *                          the required channel number or PSM.
+ * @param target            OBEX Target UUID of the server.  Constants for the UUID byte sequences are
+ *                              exposed in the oi_bip_spec.h header file; e.g. OI_BIP_ImagePushObexTargetUUID
+ * @param authentication    Specifies whether authentication is required when
+ *                          connecting to a server
+ * @param authInd           Callback handling server authentication challenges
+ * @param connectCfm        Callback indicating completion of the connection attempt
+ * @param disconnectInd     Callback indicating termination of the connection
+ * @param handle            An out parameter receiving the handle for this connection, to
+ *                          be used in subsequent function requests
+ */
+OI_STATUS OI_BIPCLI_Connect(OI_BD_ADDR *addr,
+                            OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                            OI_OBEX_BYTESEQ const *target,
+                            OI_OBEXCLI_AUTHENTICATION authentication,
+                            OI_BIPCLI_AUTH_IND authInd,
+                            OI_BIPCLI_CONNECT_CFM connectCfm,
+                            OI_BIPCLI_DISCONNECT_IND disconnectInd,
+                            OI_BIPCLI_HANDLE *handle);
+
+/**
+ * This function disconnects from a BIP server.
+ * @param connection    Handle of the connection to be dropped
+ */
+OI_STATUS OI_BIPCLI_Disconnect(OI_BIPCLI_HANDLE connection);
+
+
+/**
+ * This function responds to an authentication challenge.
+ * @param connection    Handle of the connection as specified by the
+ *                      authentication challenge callback
+ * @param pin           Pointer to a NULL-terminated pin, or NULL to refuse
+ * authentication
+ */
+void OI_BIPCLI_AuthenticationResponse(OI_BIPCLI_HANDLE connection,
+                                      const OI_CHAR *pin);
+
+
+/**
+ * This callback function is called when a cancel request completes.
+ *
+ * @param connection   Handle for the BIP connection
+ */
+typedef void (*OI_BIPCLI_CANCEL_CFM)(OI_BIPCLI_HANDLE connection);
+
+
+/**
+ * This function terminates the current BIP operation on this connection. If there is a
+ * command in progress this function returns OI_STATUS_PENDING and the operation
+ * will be canceled as soon as possible. If there is no command in progress
+ * the operation will be canceled immediately and the cancel confirm callback
+ * will be called when the cancel is complete. If there is no current BIP
+ * operation this function returns OI_STATUS_INVALID_STATE.
+ *
+ * @param connection      Unique ID that represents an
+ *                        established connection to an OBEX server
+ *
+ * @param cancelCfm       Function that will be invoked when the completes;
+ *                        this function is only called if the return value is
+ *                        OI_OK; if the return value is OI_STATUS_PENDING the
+ *                        callback for the current command will be called
+ *                        instead
+ *
+ * @return                - OI_OK if the operation was aborted
+ *                        - OI_STATUS_PENDING if the abort is deferred
+ *                        - OI_STATUS_INVALID_STATE if there is nothing to abort
+ */
+OI_STATUS OI_BIPCLI_Cancel(OI_BIPCLI_HANDLE connection,
+                           OI_BIPCLI_CANCEL_CFM cancelCfm);
+
+
+/**
+ * This function associates a caller defined context with an BIP client connection. This
+ * context can then be retrieved by calling OI_BIPCLI_GetContext().
+ *
+ * @param connection      Specifies the BIP connection with which to associate the context
+ *
+ * @param context         Value supplied by the caller
+ *
+ * @return                OI_OK if the context was set, OI_STATUS_NOT_FOUND if
+ *                        the connection handle is not valid
+ */
+OI_STATUS OI_BIPCLI_SetContext(OI_BIPCLI_HANDLE connection,
+                               void *context);
+
+
+/**
+ * This function gets a caller-defined context associated with an BIP client connection. This
+ * is a value that was previously set by a call to OI_BIPCLI_SetContext().
+ *
+ * @param connection      BIP client connection from which to get the context
+ *
+ * @return                Context pointer or NULL if the handle is invalid or
+ *                        there is no context associated with this connection
+ */
+void* OI_BIPCLI_GetContext(OI_BIPCLI_HANDLE connection);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+
+#endif /* _OI_BIP_CLI_H */
+
+
diff --git a/obex_profiles/sdk/include/profiles/oi_bip_spec.h b/obex_profiles/sdk/include/profiles/oi_bip_spec.h
new file mode 100644
index 0000000..35abf11
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_bip_spec.h
@@ -0,0 +1,465 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+@file
+
+This file provides the Basic Imaging Profile definitions.
+
+Each BIP function (except GET_STATUS) has an associated parameter
+block defined in this file. Although the parameter blocks differ for
+the various functions, they are substantially similar. A parameter
+block has a 'request' sub-struct, a 'response' sub-struct, or both. If
+a function involves the transfer of body data, one of these
+sub-structs will have 'data' and 'final' fields, depending on the
+direction of the data transfer.
+
+A BIP client implementation is responsible for setting the values in
+the request field. A server implementation sets the values in the
+response field.  If body data is present in a request or response, the
+'data' field points to an OI_OBEX_BYTESEQ describing the data, and
+'final' field indicates whether this is the final data packet.
+
+If body data entails a function with more than one request-response
+round-trip then the 'data' field (if present) should be the only
+request field present after the first request. Similarly, the 'data'
+field (if present) should be the only response field present before
+the final response.
+*/
+
+#ifndef _OI_BIP_SPEC_H
+#define _OI_BIP_SPEC_H
+
+#include "oi_bt_spec.h"
+#include "oi_stddefs.h"
+#include "oi_obexspec.h"
+
+/** \addtogroup BIP BIP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define OI_BIP_VERSION 0x0100
+
+
+
+#define OI_BIP_SDP_CAPABILITY_GENERIC_IMAGING       OI_BIT0 /**< BIP SDP constant for generic imaging capability.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_CAPABILITY_CAPTURING             OI_BIT1 /**< BIP SDP constant for capturing capability.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_CAPABILITY_PRINTING              OI_BIT2 /**< BIP SDP constant for printing capability.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_CAPABILITY_DISPLAYING            OI_BIT3 /**< BIP SDP constant for displaying capability.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+
+#define OI_BIP_SDP_FEATURE_IMAGE_PUSH               OI_BIT0 /**< BIP SDP constant for ImagePush feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_FEATURE_IMAGE_PUSH_STORE         OI_BIT1 /**< BIP SDP constant for ImagePush-Store feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_FEATURE_IMAGE_PUSH_PRINT         OI_BIT2 /**< BIP SDP constant for ImagePush-Print feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_FEATURE_IMAGE_PUSH_DISPLAY       OI_BIT3 /**< BIP SDP constant for ImagePush-Display feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_FEATURE_IMAGE_PULL               OI_BIT4 /**< BIP SDP constant for ImagePull feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_FEATURE_ADVANCED_IMAGE_PRINTING  OI_BIT5 /**< BIP SDP constant for AdvancedImagePrinting feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_FEATURE_AUTOMATIC_ARCHIVE        OI_BIT6 /**< BIP SDP constant for AutomaticArchive feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_FEATURE_REMOTE_CAMERA            OI_BIT7 /**< BIP SDP constant for RemoteCamera feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+#define OI_BIP_SDP_FEATURE_REMOTE_DISPLAY           OI_BIT8 /**< BIP SDP constant for RemoteDisplay feature.
+                                                              BIP specification version 1.0 final, section 6.1.1. */
+
+#define OI_BIP_SDP_FUNCTION_GET_CAPABILITIES        OI_BIT0 /**< GetCapabilities function.
+                                                              BIP specification version 1.0 final, section 4.5.1. */
+#define OI_BIP_SDP_FUNCTION_PUT_IMAGE               OI_BIT1 /**< PutImage function.
+                                                              BIP specification version 1.0 final, section 4.5.2. */
+#define OI_BIP_SDP_FUNCTION_PUT_LINKED_ATTACHMENT   OI_BIT2 /**< PutLinkedAttachment function.
+                                                              BIP specification version 1.0 final, section 4.5.4. */
+#define OI_BIP_SDP_FUNCTION_PUT_LINKED_THUMBNAIL    OI_BIT3 /**< PutLinkedThumbnail function.
+                                                              BIP specification version 1.0 final, section 4.5.3. */
+#define OI_BIP_SDP_FUNCTION_REMOTE_DISPLAY          OI_BIT4 /**< RemoteDisplay function.
+                                                              BIP specification version 1.0 final, section 4.5.5. */
+#define OI_BIP_SDP_FUNCTION_GET_IMAGES_LIST         OI_BIT5 /**< GetImagesList function.
+                                                              BIP specification version 1.0 final, section 4.5.6. */
+#define OI_BIP_SDP_FUNCTION_GET_IMAGE_PROPERTIES    OI_BIT6 /**< GetImageProperties function.
+                                                              BIP specification version 1.0 final, section 4.5.7. */
+#define OI_BIP_SDP_FUNCTION_GET_IMAGE               OI_BIT7 /**< GetImage function.
+                                                              BIP specification version 1.0 final, section 4.5.8. */
+#define OI_BIP_SDP_FUNCTION_GET_LINKED_THUMBNAIL    OI_BIT8 /**< GetLinkedThumbnail function.
+                                                              BIP specification version 1.0 final, section 4.5.9. */
+#define OI_BIP_SDP_FUNCTION_GET_LINKED_ATTACHMENT   OI_BIT9 /**< GetLinkedAttachment function.
+                                                              BIP specification version 1.0 final, section 4.5.10. */
+#define OI_BIP_SDP_FUNCTION_DELETE_IMAGE            OI_BIT10 /**< DeleteImage function.
+                                                               BIP specification version 1.0 final, section 4.5.11. */
+#define OI_BIP_SDP_FUNCTION_START_PRINT             OI_BIT11 /**< StartPrint function.
+                                                               BIP specification version 1.0 final, section 4.5.12. */
+#define OI_BIP_SDP_FUNCTION_GET_PARTIAL_IMAGE       OI_BIT12 /**< GetPartialImage function.
+                                                               BIP specification version 1.0 final, section 4.5.13. */
+#define OI_BIP_SDP_FUNCTION_START_ARCHIVE           OI_BIT13 /**< StartArchive function.
+                                                               BIP specification version 1.0 final, section 4.5.14. */
+#define OI_BIP_SDP_FUNCTION_GET_MONITORING_IMAGE    OI_BIT14 /**< GetMonitoringImage function.
+                                                               BIP specification version 1.0 final, section 4.5.16. */
+    /* RESERVED OI_BIT15, */
+#define OI_BIP_SDP_FUNCTION_GET_STATUS              OI_BIT16 /**< GetStatus function.
+                                                               BIP specification version 1.0 final, section 4.5.15. */
+
+/**
+RemoteDisplay screen control commands.
+See Bluetooth BIP specification version 1.0 final, section 4.5.5.
+*/
+typedef enum {
+    OI_BIP_REMOTE_DISPLAY_NEXT_IMAGE = 1,
+    OI_BIP_REMOTE_DISPLAY_PREVIOUS_IMAGE = 2,
+    OI_BIP_REMOTE_DISPLAY_SELECT_IMAGE = 3,
+    OI_BIP_REMOTE_DISPLAY_CURRENT_IMAGE = 4
+} OI_BIP_REMOTE_DISPLAY_COMMAND;
+
+
+/* BIP operation parameter structures */
+
+/** This structure defines the prameter block for the
+GetCapabilities function OI_BIPCLI_GetCapabilities(). See
+Bluetooth BIP specification version 1.0 final, section 4.5.1. */
+typedef struct {
+    struct {
+        /** See section 4.4.6.3 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } response;
+} OI_BIP_GET_CAPABILITIES_PARAMS;
+
+
+/** This structure defines the parameter block for the
+GetMonitoringImage function OI_BIPCLI_GetMonitoringImage(). See
+Bluetooth BIP specification version 1.0 final, section
+4.5.16. */
+typedef struct {
+    struct {
+        OI_BOOL storeImage;
+    } request;
+
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+        /** See section 4.4.6.5 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } response;
+} OI_BIP_GET_MONITORING_IMAGE_PARAMS;
+
+
+/** This structure defines the parameter block for the PutImage
+function OI_BIPCLI_PutImage(). See Bluetooth BIP specification
+version 1.0 final, section 4.5.2. */
+typedef struct {
+    struct {
+        OI_OBEX_UNICODE *imageName;
+        /** See section 4.4.7.2 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *imageDescriptor;
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } request;
+
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+    } response;
+} OI_BIP_PUT_IMAGE_PARAMS;
+
+
+/** This structure defines the parameter block for the
+PutLinkedAttachment function OI_BIPCLI_PutLinkedAttachment().
+See Bluetooth BIP specification version 1.0 final, section
+4.5.4. */
+typedef struct {
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+        /** See section 4.4.7.3 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *attachmentDescriptor;
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } request;
+} OI_BIP_PUT_LINKED_ATTACHMENT_PARAMS;
+
+
+/** This structure defines the prameter block for the
+PutLinkedThumbnail function OI_BIPCLI_PutLinkedThumbnail(). See
+Bluetooth BIP specification version 1.0 final, section 4.5.3. */
+typedef struct {
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+        /** See section 4.4.3 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } request;
+} OI_BIP_PUT_LINKED_THUMBNAIL_PARAMS;
+
+
+/** This structure defines the parameter block for the
+GetImagesList function OI_BIPCLI_GetImagesList(). See Bluetooth
+BIP specification version 1.0 final, section 4.5.6. */
+typedef struct {
+    struct {
+        OI_UINT16 handleCount;
+        OI_UINT16 handleOffset;
+        OI_UINT8 latest;
+        /** See section 4.4.7.1 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *handlesDescriptor;
+    } request;
+
+    struct {
+        OI_UINT16 nbReturnedHandles;
+        /** See section 4.4.7.1 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *imageHandlesDescriptor;
+        /** See section 4.4.6.1 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } response;
+} OI_BIP_GET_IMAGES_LIST_PARAMS;
+
+
+/** This structure defines the parameter block for the GetImage
+function OI_BIPCLI_GetImage(). See Bluetooth BIP specification
+version 1.0 final, section 4.5.8. */
+typedef struct {
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+        /** See section 4.4.7.2 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *imageDescriptor;
+    } request;
+
+    struct {
+        OI_UINT32 imageFileSize;
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } response;
+} OI_BIP_GET_IMAGE_PARAMS;
+
+
+/** This structure defines the prameter block for the
+GetLinkedThumbnail function OI_BIPCLI_GetLinkedThumbnail(). See
+Bluetooth BIP specification version 1.0 final, section 4.5.9. */
+typedef struct {
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+    } request;
+
+    struct {
+        /** See section 4.4.3 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } response;
+} OI_BIP_GET_LINKED_THUMBNAIL_PARAMS;
+
+
+/** This structure defines the prameter block for the
+GetLinkedAttachment function OI_BIPCLI_GetLinkedAttachment().
+See Bluetooth BIP specification version 1.0 final, section
+4.5.10. */
+typedef struct {
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+        OI_OBEX_UNICODE *attachmentName;
+    } request;
+
+    struct {
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } response;
+} OI_BIP_GET_LINKED_ATTACHMENT_PARAMS;
+
+
+/** This structure defines the parameter block for the
+StartPrint function OI_BIPCLI_StartPrint(). See Bluetooth BIP
+specification version 1.0 final, section 4.5.12. */
+typedef struct {
+    struct {
+        OI_UUID128 secondaryServiceId;
+        /** See section 4.4.6.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } request;
+} OI_BIP_START_PRINT_PARAMS;
+
+
+/** This structure defines the prameter block for the
+StartArchive function OI_BIPCLI_StartArchive(). See Bluetooth
+BIP specification version 1.0 final, section 4.5.14. */
+typedef struct {
+    struct {
+        OI_UUID128 secondaryServiceId;
+    } request;
+} OI_BIP_START_ARCHIVE_PARAMS;
+
+
+/** This structure defines the prameter block for the
+DeleteImage function OI_BIPCLI_DeleteImage(). See Bluetooth BIP
+specification version 1.0 final, section 4.5.11. */
+typedef struct {
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+    } request;
+} OI_BIP_DELETE_IMAGE_PARAMS;
+
+
+/** This structure defines the parameter block for the
+GetPartialImage function OI_BIPCLI_GetPartialImage(). See
+Bluetooth BIP specification version 1.0 final, section
+4.5.13. */
+typedef struct {
+    struct {
+        OI_OBEX_UNICODE *imageName;
+        OI_UINT32 partialLength;
+        OI_UINT32 partialOffset;
+    } request;
+
+    struct {
+        OI_UINT32 partialLength;
+        OI_UINT32 totalFileSize;
+        OI_BOOL endFlag;
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } response;
+} OI_BIP_GET_PARTIAL_IMAGE_PARAMS;
+
+
+/** This structure defines the prameter block for the
+GetImageProperties function OI_BIPCLI_GetImageProperties(). See
+Bluetooth BIP specification version 1.0 final, section 4.5.7. */
+typedef struct {
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+    } request;
+
+    struct {
+        /** See section 4.4.6.2 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_BYTESEQ *data;
+        OI_BOOL final;
+    } response;
+} OI_BIP_GET_IMAGE_PROPERTIES_PARAMS;
+
+
+/** This structure defines the prameter block for the
+RemoteDisplay function OI_BIPCLI_RemoteDisplay(). See Bluetooth
+BIP specification version 1.0 final, section 4.5.5. */
+typedef struct {
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+        OI_UINT8 displayCommand;
+    } request;
+
+    struct {
+        /** See section 4.4.4 of the Bluetooth BIP specification, version 1.0. */
+        OI_OBEX_UNICODE *imageHandle;
+    } response;
+} OI_BIP_REMOTE_DISPLAY_PARAMS;
+
+
+/** This structure is a union of all of the BIP parameter
+    blocks. */
+typedef union {
+    OI_BIP_GET_CAPABILITIES_PARAMS      getCapabilities;
+    OI_BIP_GET_MONITORING_IMAGE_PARAMS  getMonitoringImage;
+    OI_BIP_PUT_IMAGE_PARAMS             putImage;
+    OI_BIP_PUT_LINKED_ATTACHMENT_PARAMS putLinkedAttachment;
+    OI_BIP_PUT_LINKED_THUMBNAIL_PARAMS  putLinkedThumbnail;
+    OI_BIP_GET_IMAGES_LIST_PARAMS       getImagesList;
+    OI_BIP_GET_IMAGE_PARAMS             getImage;
+    OI_BIP_GET_LINKED_THUMBNAIL_PARAMS  getLinkedThumbnail;
+    OI_BIP_GET_LINKED_ATTACHMENT_PARAMS getLinkedAttachment;
+    OI_BIP_START_PRINT_PARAMS           startPrint;
+    OI_BIP_START_ARCHIVE_PARAMS         startArchive;
+    OI_BIP_DELETE_IMAGE_PARAMS          deleteImage;
+    OI_BIP_GET_PARTIAL_IMAGE_PARAMS     getPartialImage;
+    OI_BIP_GET_IMAGE_PROPERTIES_PARAMS  getImageProperties;
+    OI_BIP_REMOTE_DISPLAY_PARAMS        remoteDisplay;
+} OI_BIP_PARAM_UNION;
+
+
+/* *************** Primary target UUIDs *******************/
+
+extern const OI_OBEX_BYTESEQ OI_BIP_ImagePushObexTargetUUID;
+extern const OI_OBEX_BYTESEQ OI_BIP_ImagePullObexTargetUUID;
+extern const OI_OBEX_BYTESEQ OI_BIP_AdvancedImagePrintingObexTargetUUID;
+extern const OI_OBEX_BYTESEQ OI_BIP_AutomaticArchiveObexTargetUUID;
+extern const OI_OBEX_BYTESEQ OI_BIP_RemoteCameraObexTargetUUID;
+extern const OI_OBEX_BYTESEQ OI_BIP_RemoteDisplayObexTargetUUID;
+
+#define OI_BIP_IMAGE_PUSH_OBEX_TARGET_UUID \
+    { 0xE3, 0x3D, 0x95, 0x45, 0x83, 0x74, 0x4A, 0xD7, 0x9E, 0xC5, 0xC1, 0x6B, 0xE3, 0x1E, 0xDE, 0x8E }
+
+#define OI_BIP_IMAGE_PULL_OBEX_TARGET_UUID \
+    { 0x8E, 0xE9, 0xB3, 0xD0, 0x46, 0x08, 0x11, 0xD5, 0x84, 0x1A, 0x00, 0x02, 0xA5, 0x32, 0x5B, 0x4E }
+
+#define OI_BIP_ADVANCED_IMAGE_PRINTING_OBEX_TARGET_UUID \
+    { 0x92, 0x35, 0x33, 0x50, 0x46, 0x08, 0x11, 0xD5, 0x84, 0x1A, 0x00, 0x02, 0xA5, 0x32, 0x5B, 0x4E }
+
+#define OI_BIP_AUTOMATIC_ARCHIVE_OBEX_TARGET_UUID \
+    { 0x94, 0x01, 0x26, 0xC0, 0x46, 0x08, 0x11, 0xD5, 0x84, 0x1A, 0x00, 0x02, 0xA5, 0x32, 0x5B, 0x4E }
+
+#define OI_BIP_REMOTE_CAMERA_OBEX_TARGET_UUID \
+    { 0x94, 0x7E, 0x74, 0x20, 0x46, 0x08, 0x11, 0xD5, 0x84, 0x1A, 0x00, 0x02, 0xA5, 0x32, 0x5B, 0x4E }
+
+#define OI_BIP_REMOTE_DISPLAY_OBEX_TARGET_UUID \
+    { 0x94, 0xC7, 0xCD, 0x20, 0x46, 0x08, 0x11, 0xD5, 0x84, 0x1A, 0x00, 0x02, 0xA5, 0x32, 0x5B, 0x4E }
+
+/* *************** Secondary target UUIDs *******************/
+
+extern const OI_OBEX_BYTESEQ OI_BIP_ReferencedObjectsObexTargetUUID;
+extern const OI_OBEX_BYTESEQ OI_BIP_ArchivedObjectsObexTargetUUID;
+
+#define OI_BIP_REFERENCED_OBJECTS_OBEX_TARGET_UUID \
+    { 0x8E, 0x61, 0xF9, 0x5D, 0x1A, 0x79, 0x11, 0xD4, 0x8E, 0xA4, 0x00, 0x80, 0x5F, 0x9B, 0x98, 0x34 }
+
+#define OI_BIP_ARCHIVED_OBJECTS_OBEX_TARGET_UUID \
+    { 0x8E, 0x61, 0xF9, 0x5E, 0x1A, 0x79, 0x11, 0xD4, 0x8E, 0xA4, 0x00, 0x80, 0x5F, 0x9B, 0x98, 0x34 }
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_BIP_SPEC_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_bip_srv.h b/obex_profiles/sdk/include/profiles/oi_bip_srv.h
new file mode 100644
index 0000000..c9e268d
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_bip_srv.h
@@ -0,0 +1,743 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/** @file
+
+This is the Basic Imaging Profile server API.
+
+For more information on BIP functions, see the documentation for the
+file oi_bip_spec.h.
+
+ */
+
+#ifndef _OI_BIPSRV_SRV_H
+#define _OI_BIPSRV_SRV_H
+
+#include "oi_bip_spec.h"
+#include "oi_sdp.h"
+#include "oi_obexsrv.h"
+#include "oi_obexspec.h"
+
+/** \addtogroup BIP BIP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * A type of state parameter used in combination with the OI_STATUS code to indicate the phase of a
+ * BIP request. Depending on the request type the state transitions are as follows, where the
+ *
+ * For a multi-part request:
+ *
+ * OI_BIPSRV_REQUEST_INITIAL/OI_OBEX_CONTINUE -> OI_BIPSRV_REQUEST_CONTINUE/OI_OBEX_CONTINUE) -> OI_BIPSRV_REQUEST_CONTINUE/OI_OK -> OI_BIPSRV_REQUEST_CLEANUP/OI_OK
+ *
+ * For a 2-part request:
+ *
+ * OI_BIPSRV_REQUEST_INITIAL/OI_OBEX_CONTINUE -> OI_BIPSRV_REQUEST_CONTINUE/OI_OK -> OI_BIPSRV_REQUEST_CLEANUP/OI_OK
+ *
+ * For an atomic request:
+ *
+ * OI_BIPSRV_REQUEST_INITIAL/OI_OK -> OI_BIPSRV_REQUEST_CLEANUP/OI_OK
+ *
+ * In the case of an error OI_BIPSRV_REQUEST_CLEANUP/<error> can be indicated at any time and
+ * completes the request.
+ *
+ * For all state except OI_BIPSRV_REQUEST_CLEANUP the application must issues an explicit PUT
+ * or GET response or return an error status from the request indication.
+ *
+ * Some requests return request-specic status codes.
+ *
+ * Note that OI_BIPSRV_REQUEST_CLEANUP is always reported and completes the request.
+ */
+typedef enum {
+    OI_BIPSRV_REQUEST_INITIAL,  /**< Start of a request */
+    OI_BIPSRV_REQUEST_CONTINUE, /**< Continuation of a multi-part request */
+    OI_BIPSRV_REQUEST_CLEANUP,  /**< Indicates either an error or that the last response has been sent */
+} OI_BIPSRV_REQUEST_STATE;
+
+
+typedef OI_OBEXSRV_CONNECTION_HANDLE OI_BIPSRV_CONNECTION_HANDLE;
+
+
+/**
+ * Represents a registered FTP server
+ */
+typedef OI_OBEX_SERVER_HANDLE OI_BIP_SERVER_HANDLE;
+
+
+/**
+ * Indicates a request for a BIP connection. The server should call @ref
+ * OI_BIPSRV_AcceptConnection to allow the connection or to reject it.
+ *
+ * @param connectionId  Connection handle to be used in conjunction with this
+ * connection in future calls.
+ */
+typedef void (*OI_BIPSRV_CONNECT_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId);
+
+/**
+ * Indicates that a BIP client has terminated its connection to the server
+ *
+ * @param connection Connection handle to the connection which is being dropped.
+ */
+typedef void (*OI_BIPSRV_DISCONNECT_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId);
+
+/**
+ * This callback is invoked prior to a connection indication when the server has
+ * been configured to require authentication. The server should respond by
+ * calling OI_BIPSRV_AuthenticationResponse() with the pin to use for this
+ * connection.
+ @param connectionId Connection handle to the connection on which authentication is being performed.
+ */
+typedef void (*OI_BIPSRV_AUTH_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId);
+
+/**
+ * The server responds to an authentication request with this function.
+ * @param connectionId  Connection handle to the connection on which authentication is being performed.
+ */
+OI_STATUS OI_BIPSRV_AuthenticationResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                           OI_CHAR *pin);
+
+
+/* ************* GetCapabilities */
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_CAPABILITIES_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                    OI_BIP_GET_CAPABILITIES_PARAMS *params,
+                                                    OI_BIPSRV_REQUEST_STATE state,
+                                                    OI_STATUS status);
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetCapabilitiesResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                            OI_BIP_GET_CAPABILITIES_PARAMS *params,
+                                            OI_STATUS result);
+/* ************* PutImage */
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_PUT_IMAGE_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                             OI_BIP_PUT_IMAGE_PARAMS *params,
+                                             OI_BIPSRV_REQUEST_STATE state,
+                                             OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_PutImageResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                     OI_BIP_PUT_IMAGE_PARAMS *params,
+                                     OI_STATUS result);
+
+/* ************* PutLinkedThumbnail */
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_PUT_LINKED_THUMBNAIL_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                        OI_BIP_PUT_LINKED_THUMBNAIL_PARAMS *params,
+                                                        OI_BIPSRV_REQUEST_STATE state,
+                                                        OI_STATUS status);
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_PutLinkedThumbnailResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                               OI_BIP_PUT_LINKED_THUMBNAIL_PARAMS *params,
+                                               OI_STATUS result);
+
+
+/* ************* PutLinkedAttachment */
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_PUT_LINKED_ATTACHMENT_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                         OI_BIP_PUT_LINKED_ATTACHMENT_PARAMS *params,
+                                                         OI_BIPSRV_REQUEST_STATE state,
+                                                         OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_PutLinkedAttachmentResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                OI_BIP_PUT_LINKED_ATTACHMENT_PARAMS *params,
+                                                OI_STATUS result);
+
+
+/* ************* RemoteDisplay */
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_REMOTE_DISPLAY_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                  OI_BIP_REMOTE_DISPLAY_PARAMS *params,
+                                                  OI_BIPSRV_REQUEST_STATE state,
+                                                  OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_RemoteDisplayResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                          OI_BIP_REMOTE_DISPLAY_PARAMS *params,
+                                          OI_STATUS result);
+
+
+/* ************* GetImagesList */
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_IMAGES_LIST_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                   OI_BIP_GET_IMAGES_LIST_PARAMS *params,
+                                                   OI_BIPSRV_REQUEST_STATE state,
+                                                   OI_STATUS status);
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetImagesListResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                          OI_BIP_GET_IMAGES_LIST_PARAMS *params,
+                                          OI_STATUS result);
+
+/* ************* GetImageProperties */
+
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_IMAGE_PROPERTIES_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                        OI_BIP_GET_IMAGE_PROPERTIES_PARAMS *params,
+                                                        OI_BIPSRV_REQUEST_STATE state,
+                                                        OI_STATUS status);
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetImagePropertiesResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                               OI_BIP_GET_IMAGE_PROPERTIES_PARAMS *params,
+                                               OI_STATUS result);
+
+/* ************* GetImage */
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_IMAGE_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                             OI_BIP_GET_IMAGE_PARAMS *params,
+                                             OI_BIPSRV_REQUEST_STATE state,
+                                             OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetImageResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                     OI_BIP_GET_IMAGE_PARAMS *params,
+                                     OI_STATUS result);
+
+/* ************* GetLinkedThumbnail */
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_LINKED_THUMBNAIL_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                        OI_BIP_GET_LINKED_THUMBNAIL_PARAMS *params,
+                                                        OI_BIPSRV_REQUEST_STATE state,
+                                                        OI_STATUS status);
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetLinkedThumbnailResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                               OI_BIP_GET_LINKED_THUMBNAIL_PARAMS *params,
+                                               OI_STATUS result);
+
+
+/* ************* GetLinkedAttachment */
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_LINKED_ATTACHMENT_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                         OI_BIP_GET_LINKED_ATTACHMENT_PARAMS *params,
+                                                         OI_BIPSRV_REQUEST_STATE state,
+                                                         OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetLinkedAttachmentResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                OI_BIP_GET_LINKED_ATTACHMENT_PARAMS *params,
+                                                OI_STATUS result);
+
+/* ************* DeleteImage */
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_DELETE_IMAGE_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                OI_BIP_DELETE_IMAGE_PARAMS *params,
+                                                OI_BIPSRV_REQUEST_STATE state,
+                                                OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_DeleteImageResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                        OI_BIP_DELETE_IMAGE_PARAMS *params,
+                                        OI_STATUS result);
+
+/* ************* StartPrint */
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_START_PRINT_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                               OI_BIP_START_PRINT_PARAMS *params,
+                                               OI_BIPSRV_REQUEST_STATE state,
+                                               OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_StartPrintResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                       OI_BIP_START_PRINT_PARAMS *params,
+                                       OI_STATUS result);
+
+
+/* ************* GetPartialImage */
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_PARTIAL_IMAGE_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                     OI_BIP_GET_PARTIAL_IMAGE_PARAMS *params,
+                                                     OI_BIPSRV_REQUEST_STATE state,
+                                                     OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetPartialImageResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                            OI_BIP_GET_PARTIAL_IMAGE_PARAMS *params,
+                                            OI_STATUS result);
+
+
+/* ************* StartArchive */
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_START_ARCHIVE_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                 OI_BIP_START_ARCHIVE_PARAMS *params,
+                                                 OI_BIPSRV_REQUEST_STATE state,
+                                                 OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_StartArchiveResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                         OI_BIP_START_ARCHIVE_PARAMS *params,
+                                         OI_STATUS result);
+
+/* ************* GetMonitoringImage */
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param state The phase of the response
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_MONITORING_IMAGE_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                                        OI_BIP_GET_MONITORING_IMAGE_PARAMS *params,
+                                                        OI_BIPSRV_REQUEST_STATE state,
+                                                        OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param params Parameters specified by the BIP client.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetMonitoringImageResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                               OI_BIP_GET_MONITORING_IMAGE_PARAMS *params,
+                                               OI_STATUS result);
+
+
+/* ************* GetStatus  */
+
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param status Whether the client has more data (deferred result from last response sent)
+  @return OI_OK if the operation was successful.
+  */
+typedef OI_STATUS (*OI_BIPSRV_GET_STATUS_IND)(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                              OI_STATUS status);
+
+/**
+  @param connectionId Connection handle to the connection in question.
+  @param result Returned by callback function; always OI_OK except in case of catastrophic failure.
+  @return OI_OK if the operation was successful.
+  */
+OI_STATUS OI_BIPSRV_GetStatusResponse(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                      OI_STATUS result);
+
+
+
+/**
+ * A application calls thsi function to accept or reject an indicated
+ * connection.
+ *
+ * @param connectionId   handle representing the connection to an BIP client.
+ *
+ * @param accept         TRUE if the connection is being accepted, FALSE
+ *                       otherwise.
+ */
+
+OI_STATUS OI_BIPSRV_AcceptConnection(OI_BIPSRV_CONNECTION_HANDLE connectionId,
+                                     OI_BOOL accept);
+
+
+/* *************  */
+
+typedef struct {
+    OI_BIPSRV_CONNECT_IND connectInd;
+    OI_BIPSRV_DISCONNECT_IND disconnectInd;
+    OI_BIPSRV_AUTH_IND authInd;
+
+    OI_BIPSRV_GET_CAPABILITIES_IND getCapabilities;
+    OI_BIPSRV_PUT_IMAGE_IND putImage;
+    OI_BIPSRV_PUT_LINKED_ATTACHMENT_IND putLinkedAttachment;
+    OI_BIPSRV_PUT_LINKED_THUMBNAIL_IND putLinkedThumbnail;
+    OI_BIPSRV_REMOTE_DISPLAY_IND remoteDisplay;
+    OI_BIPSRV_GET_IMAGES_LIST_IND getImagesList;
+    OI_BIPSRV_GET_IMAGE_PROPERTIES_IND getImageProperties;
+    OI_BIPSRV_GET_IMAGE_IND getImage;
+    OI_BIPSRV_GET_LINKED_THUMBNAIL_IND getLinkedThumbnail;
+    OI_BIPSRV_GET_LINKED_ATTACHMENT_IND getLinkedAttachment;
+    OI_BIPSRV_DELETE_IMAGE_IND deleteImage;
+    OI_BIPSRV_START_PRINT_IND startPrint;
+    OI_BIPSRV_START_ARCHIVE_IND startArchive;
+    OI_BIPSRV_GET_STATUS_IND getStatus;
+    OI_BIPSRV_GET_MONITORING_IMAGE_IND getMonitoringImage;
+} OI_BIPSRV_IMAGING_RESPONDER_CALLBACKS;
+
+typedef struct {
+    OI_BIPSRV_CONNECT_IND connectInd;
+    OI_BIPSRV_DISCONNECT_IND disconnectInd;
+    OI_BIPSRV_AUTH_IND authInd;
+
+    OI_BIPSRV_GET_CAPABILITIES_IND getCapabilities;
+    OI_BIPSRV_GET_PARTIAL_IMAGE_IND getPartialImage;
+} OI_BIPSRV_REFERENCED_OBJECTS_CALLBACKS;
+
+typedef struct {
+    OI_BIPSRV_CONNECT_IND connectInd;
+    OI_BIPSRV_DISCONNECT_IND disconnectInd;
+    OI_BIPSRV_AUTH_IND authInd;
+
+    OI_BIPSRV_GET_CAPABILITIES_IND getCapabilities;
+    OI_BIPSRV_GET_IMAGES_LIST_IND getImagesList;
+    OI_BIPSRV_GET_IMAGE_PROPERTIES_IND getImageProperties;
+    OI_BIPSRV_GET_IMAGE_IND getImage;
+    OI_BIPSRV_GET_LINKED_THUMBNAIL_IND getLinkedThumbnail;
+    OI_BIPSRV_GET_LINKED_ATTACHMENT_IND getLinkedAttachment;
+    OI_BIPSRV_DELETE_IMAGE_IND deleteImage;
+} OI_BIPSRV_ARCHIVED_OBJECTS_CALLBACKS;
+
+typedef struct {
+    OI_UINT8 supportedCapabilities;
+    OI_UINT16 supportedFeatures;
+    OI_UINT32 supportedFunctions;
+    OI_UINT64 imagingCapacity;
+} OI_BIPSRV_IMAGING_RESPONDER_INFO;
+
+typedef struct {
+    OI_UUID128 serviceId;
+    OI_UINT32 supportedFunctions;
+} OI_BIPSRV_OBJECTS_SERVER_INFO;
+
+/**
+ * This function registers an imaging responder server.
+ *
+ * @param cb               pointer to a struct specifying callbacks for the functions
+ *                         implemented by this server
+ *
+ * @param info             pointer to a struct containing information about the server, to
+ *                         be published via SDP. The value of
+ *                         info->supportedFeatures determines which OBEX targets
+ *                         will be registered. At least one of its bits must be
+ *                         set, or registration will fail.
+ *
+ * @param strings          name to register in service record
+ * @param authentication   TRUE if authentication is to be required of clients,
+ *                         FALSE otherwise
+ *
+ * @param serverHandle     [OUT] returns the handle of the registered server
+ *
+ * @return                 OI_OK if registration completed successfully, an error otherwise
+ */
+OI_STATUS OI_BIPSRV_RegisterImagingResponder(const OI_BIPSRV_IMAGING_RESPONDER_CALLBACKS *cb,
+                                             OI_BIPSRV_IMAGING_RESPONDER_INFO *info,
+                                             const OI_SDP_STRINGS *strings,
+                                             OI_BOOL authentication,
+                                             OI_BIP_SERVER_HANDLE *serverHandle);
+
+/**
+ * Registers a referenced objects server.
+ *
+ * @param cb   Pointer to a struct specifying callbacks for the functions
+ * implemented by this server.
+ *
+ * @param info  Pointer to a struct containing information about the server, to
+ * be published via SDP.
+ *
+ * @param strings           name to register in service record
+ * @param authentication    TRUE if authentication is to be required of clients,
+ * FALSE otherwise
+ *
+ * @param serverHandle     [OUT] returns the handle of the registered server
+ *
+ * @return  OI_OK if registration completed successfully, an error otherwise.
+ */
+OI_STATUS OI_BIPSRV_RegisterReferencedObjects(const OI_BIPSRV_REFERENCED_OBJECTS_CALLBACKS *cb,
+                                              OI_BIPSRV_OBJECTS_SERVER_INFO *info,
+                                              const OI_SDP_STRINGS *strings,
+                                              OI_BOOL authentication,
+                                              OI_BIP_SERVER_HANDLE *serverHandle);
+
+/**
+ * Registers an archived objects server.
+ *
+ * @param cb   Pointer to a struct specifying callbacks for the functions
+ * implemented by this server.
+ *
+ * @param info  Pointer to a struct containing information about the server, to
+ * be published via SDP.
+ *
+ * @param strings           name to register in service record
+ *
+ * @param authentication    TRUE if authentication is to be required of clients,
+ * FALSE otherwise
+ *
+ * @param serverHandle   Out parameter assigned the handle of the registered server.
+ *
+ * @return  OI_OK if registration completed successfully, an error otherwise.
+ */
+OI_STATUS OI_BIPSRV_RegisterArchivedObjects(const OI_BIPSRV_ARCHIVED_OBJECTS_CALLBACKS *cb,
+                                            OI_BIPSRV_OBJECTS_SERVER_INFO *info,
+                                            const OI_SDP_STRINGS *strings,
+                                            OI_BOOL authentication,
+                                            OI_BIP_SERVER_HANDLE *serverHandle);
+
+/**
+ * Get the service record handle associated with this service.
+ * This can be used with e.g. OI_SDPDB_SetAttributeList to add
+ * vendor-specific SDP attributes to the profile.
+ *
+ * @param serverHandle   The handle of the server
+ *
+ * @param handle  return the service record's handle
+ */
+OI_STATUS OI_BIPSRV_GetServiceRecord(OI_BIP_SERVER_HANDLE serverHandle,
+                                     OI_UINT32 *handle);
+
+/**
+ * Deregisters a previously registered BIP server.
+ *
+ * @param serverHandle   The handle of the server to deregister.
+ *
+ * @return  OI_OK if registration completed successfully, an error otherwise.
+ */
+OI_STATUS OI_BIPSRV_DeregisterServer(OI_BIP_SERVER_HANDLE serverHandle);
+
+
+/**
+ * Associates a caller defined context with an BIP server connection. This
+ * context can then be retrieved by calling OI_BIPSRV_GetContext().
+ *
+ * @param connection     The connection to associate the context with.
+ *
+ * @param context         A value supplied by the caller.
+ *
+ * @return                OI_OK if the context was set, OI_STATUS_NOT_FOUND if
+ *                        the connection handle is not valid.
+ */
+OI_STATUS OI_BIPSRV_SetContext(OI_BIPSRV_CONNECTION_HANDLE connection,
+                               void *context);
+
+
+/**
+ * Gets a caller defined context associate with an BIP server connection. This
+ * is a value that was previously set by a call to OI_BIPSRV_SetContext().
+ *
+ * @param connection      The BIP server connection to get the context from.
+ *
+ * @return                A context pointer or NULL if the handle is invalid or
+ *                        there is no context associated with this connection.
+ */
+void* OI_BIPSRV_GetContext(OI_BIPSRV_CONNECTION_HANDLE connection);
+
+/**
+ * This function forcibly severs the connection from a BIP client to the OBEX
+ * server. The disconnect indication callback will be called when the disconnect
+ * is complete.
+ *
+ * An BIP server may need to forcibly terminate a connection during
+ * deregistration, since deregistration will fail if a connection is in place.
+ *
+ * @param connectionId     a unique identifier generated by the BIP server that
+ *                         identifies the connection.
+ *
+ * @return                 OI_OK if the connectionId is valid and the connection
+ *                         will be terminated.
+ */
+OI_STATUS OI_BIPSRV_ForceDisconnect(OI_BIPSRV_CONNECTION_HANDLE connectionId);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_BIPSRV_SRV_H */
+
+
diff --git a/obex_profiles/sdk/include/profiles/oi_bpp.h b/obex_profiles/sdk/include/profiles/oi_bpp.h
new file mode 100644
index 0000000..4039124
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_bpp.h
@@ -0,0 +1,76 @@
+#ifndef _OI_BPP_H
+#define _OI_BPP_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides the interface for a Basic Printing Profile appliation.
+ */
+
+#include "oi_common.h"
+#include "oi_obexspec.h"
+#include "oi_obexsrv.h"
+
+/** \addtogroup BPP BPP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define OI_BPP_VERSION 0x0100
+
+typedef OI_UINT32 OI_BPP_JOB_ID;
+
+typedef enum {
+    BPP_TARGET_DPS = 1, /**< Direct printing */
+    BPP_TARGET_PBR,     /**< Print by reference */
+    BPP_TARGET_RUI,     /**< Reflected user interface */
+    BPP_TARGET_STS,     /**< Status */
+    REF_TARGET_OBJ      /**< Referenced objects */
+} OI_BPP_TARGET;
+
+typedef enum {
+    OI_BPP_REF_SIMPLE = 1,
+    OI_BPP_REF_XML,
+    OI_BPP_REF_LIST
+} OI_BPP_REF_TYPE;
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_BPP_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_bpp_printer.h b/obex_profiles/sdk/include/profiles/oi_bpp_printer.h
new file mode 100644
index 0000000..057bcde
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_bpp_printer.h
@@ -0,0 +1,390 @@
+#ifndef _OI_BPP_PRINTER_H
+#define _OI_BPP_PRINTER_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides the interface for a Basic Printing Profile printer
+ * application.
+ */
+
+#include "oi_bpp.h"
+#include "oi_obexcli.h"
+#include "oi_sdp.h"
+#include "oi_connect_policy.h"
+
+/** \addtogroup BPP BPP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Type for a register BPP printer server
+ */
+typedef OI_OBEX_SERVER_HANDLE OI_BPP_PRINTER_SERVER_HANDLE;
+
+
+/* Printer indications */
+
+/** Indicates a connection request by a sender. The application should call
+ * OI_OBEXSRV_AcceptConnection if unauthorized is FALSE, or
+ * OI_OBEXSRV_AuthenticationRsp if unauthorized is TRUE.
+ *
+ * @param handle    handle identifying this connection
+ * @param unauthorized   If TRUE, the application should respond with OI_OBEXSRV_AuthenticationRsp
+ * @param userId    If unauthorized is TRUE, the client may have specified a
+ * userId.
+ * @param userIdLen length of the user Id (if present)
+ */
+typedef OI_STATUS (*OI_BPP_PRINTER_CONNECT_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                                OI_BOOL unauthorized,
+                                                OI_BYTE *userId,
+                                                OI_UINT8 userIdLen);
+
+/** Indicates a sender has disconneted from a printer server
+ * @param handle    handle identifying the dropped connection
+ */
+typedef void (*OI_BPP_PRINTER_DISCONNECT_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle);
+
+
+/** Indicates a file push operation request by a sender.
+ *  If the status code is OI_OBEX_CONTINUE, the application should
+ *  respond by invoking OI_BPP_PRINTER_FilePushResponse.
+ *
+ * @param handle    connection handle associated with the request
+ * @param type      MIME type of the pushed file
+ * @param description   description of the pushed file (may not be present)
+ * @param name      name of the pushed file (may not be present)
+ * @param jobId     pointer to a jobId (may not be present)
+ * @param data      body of the pushed file
+ * @param status    OI_OBEX_CONTINUE if more file data exists, OI_OK or an error
+ * otherwise.
+ * @returns OI_OK if a response is (or will be) invoked, otherwise an error to
+ * return to the client.
+ */
+typedef OI_STATUS (*OI_BPP_PRINTER_FILE_PUSH_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                                  OI_OBEX_BYTESEQ *type,
+                                                  OI_OBEX_UNICODE *description,
+                                                  OI_OBEX_UNICODE *name,
+                                                  OI_BPP_JOB_ID *jobId,
+                                                  OI_OBEX_BYTESEQ *data,
+                                                  OI_STATUS status);
+
+/** Responds to a file push indication.
+ *
+ * @param handle    connection handle associated with the request
+ * @param status    set equal to the status passed by the callback to continue
+ * the request, or specify an error to terminate.
+ */
+OI_STATUS OI_BPP_PRINTER_FilePushResponse(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                          OI_STATUS status);
+
+
+/** Indicates a reference push operation request by a sender.
+ * If the status code is OI_OBEX_CONTINUE, the application
+ * should respond with OI_BPP_PRINTER_ReferencePushResponse.
+ *
+ * @param handle    connection handle associated with the request
+ * @param type      an enumeration constant indicating the type of reference
+ * @param httpHeaders   http header with access credentials for referenced
+ * resource (may not be present)
+ * @param jobId     pointer to a jobId (may not be present)
+ * @param data      body of the pushed reference.
+ * @param status    OI_OBEX_CONTINUE if more file data exists, OI_OK or an error
+ * otherwise.
+ */
+typedef OI_STATUS (*OI_BPP_PRINTER_REF_PUSH_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                                 OI_BPP_REF_TYPE type,
+                                                 OI_OBEX_BYTESEQ *httpHeaders,
+                                                 OI_BPP_JOB_ID *jobId,
+                                                 OI_OBEX_BYTESEQ *data,
+                                                 OI_STATUS status);
+
+
+
+/** Responds to a reference push indication.
+ *
+ * @param handle    connection handle associated with the request
+ * @param url       Optional parameter. Should be NULL except possibly on the
+ * final invocation of this function during a given request. If present, it indicates a URL which was unable to
+ * be retrieved.
+ * @param httpHeaders   Optional paramter. Should be NULL except possibly on the
+ * final invocation of this function during a given request.  If present, it
+ * contains an authentication challenge which the sender must answer in order to
+ * access the referenced resource named in the url parameter.
+ * @param status    set equal to the status passed by the callback to continue
+ * the request, or specify an error to terminate.
+ */
+OI_STATUS OI_BPP_PRINTER_ReferencePushResponse(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                               OI_OBEX_BYTESEQ *url,
+                                               OI_OBEX_BYTESEQ *httpHeaders,
+                                               OI_STATUS status);
+
+/** Indicates a reflected user interface operation request by a sender.
+ * If the status code is OI_OBEX_CONTINUE, the application
+ * should respond with OI_BPP_PRINTER_GetRUI_Response.
+ *
+ * @param handle    connection handle associated with the request
+ * @param type      MIME type of the RUI request.
+ * @param name      Depends on the type of request. Might not be present.
+ * @param httpHeaders   Depends on the type of request. Might not be present.
+ * @param body  Depends on the type of request. Might not be present.
+ * @param status    OI_OBEXSRV_INCOMPLETE_GET indicates that more request dataOI_BPP_PRINTER_FilePushResponse.
+ * follows; the application should respond with
+ * OI_BPP_PRINTER_GetRUIResponse(handle, NULL, OI_OBEX_CONTINUE).
+ * OI_OBEX_CONTINUE inciates that the client is ready for more response data.
+ * OI_OK or an error indicates the end of the transaction.
+ */
+typedef OI_STATUS (*OI_BPP_PRINTER_GET_RUI_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                                OI_OBEX_BYTESEQ *type,
+                                                OI_OBEX_UNICODE *name,
+                                                OI_OBEX_BYTESEQ *httpHeaders,
+                                                OI_OBEX_BYTESEQ *body,
+                                                OI_STATUS status);
+
+/** Responds to a reflected user interface operation.
+ *
+ * @param handle    connection handle associated with the request
+ * @param body      content of the response
+ * @param status    OI_OBEX_CONTINUE if there is more data to be sent after this
+ * response, OI_OK or an error to finish the response.
+ */
+OI_STATUS OI_BPP_PRINTER_GetRUIResponse(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                        OI_OBEX_BYTESEQ *body,
+                                        OI_STATUS status);
+
+/** Indicates a SOAP request.
+ *
+ * @param handle    connection handle associated with the request
+ * @param soapRequest   body of the request
+ * @param status    OI_OBEXSRV_INCOMPLETE_GET indicates that more request data
+ * follows; the application should respond with
+ * @ref OI_BPP_PRINTER_SOAPResponse "OI_BPP_PRINTER_SOAPResponse(handle, NULL, NULL, OI_OBEX_CONTINUE)".
+ * OI_OBEX_CONTINUE indicates that the client is ready for more response data.
+ * OI_OK or an error indicates the end of the transaction.
+ */
+typedef OI_STATUS (*OI_BPP_PRINTER_SOAP_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                             OI_OBEX_BYTESEQ *soapRequest,
+                                             OI_STATUS status);
+
+/** Responds to a status-channel SOAP request.
+ *
+ * @param handle    connection handle associated with the request
+ * @param body      body of the response
+ * @param status    OI_OBEX_CONTINUE if there is more data to be sent after this
+ * response, OI_OK or an error to finish the response
+ */
+OI_STATUS OI_BPP_PRINTER_StatusSOAPResponse(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                            OI_OBEX_BYTESEQ *body,
+                                            OI_STATUS status);
+
+/** Responds to a job-channel SOAP request.
+ *
+ * @param handle    connection handle associated with the request
+ * @param optionalJobId Pointer to a job id value if this soap response results
+ * in the allocation of a job id, NULL otherwise.
+ * @param body      body of the response
+ * @param status    OI_OBEX_CONTINUE if there is more data to be sent after this
+ * response, OI_OK or an error to finish the response
+ */
+OI_STATUS OI_BPP_PRINTER_SOAPResponse(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                      OI_BPP_JOB_ID *optionalJobId,
+                                      OI_OBEX_BYTESEQ *body,
+                                      OI_STATUS status);
+
+/* Printer GetReferencedObjects operation */
+
+
+/** Indicates the completion of a connection attempt to a sender referenced
+ * objects server
+ *
+ * @param handle connection handle specified by OI_BPP_PRINTER_Connect
+ * @param status  OI_OK if the connection succeeded, an error otherwise.
+ */
+typedef void (*OI_BPP_PRINTER_CONNECT_CFM)(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                           OI_STATUS status);
+
+/** Requests a connection with a BPP sender's referenced objects service.
+ * @param senderAddr    pointer to sender's address
+
+ * @param lowerProtocol This identifies the RFCOMM channel number or the L2CAP PSM for the
+ *                      BPP printer server running on the remote device.  the remote device. The
+ *                      caller will normally perform service discovery on the remote device to
+ *                      obtain the required channel number or PSM.
+ *
+ * @param connectCfm    connection confirmation callback
+ * @param disconnectInd disconnection indication callback
+ * @param handle    out parameter specifying the handle associated with this
+ * connection request.
+ */
+OI_STATUS OI_BPP_PRINTER_Connect(OI_BD_ADDR *senderAddr,
+                                 OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                                 OI_BPP_PRINTER_CONNECT_CFM connectCfm,
+                                 OI_OBEXCLI_DISCONNECT_IND disconnectInd,
+                                 OI_OBEXCLI_CONNECTION_HANDLE *handle);
+
+
+/** Disconnects from a referenced objects service.
+ * @param handle    handle to the connection to drop.
+ */
+OI_STATUS OI_BPP_PRINTER_Disconnect(OI_OBEXCLI_CONNECTION_HANDLE handle);
+
+/** Cancels the current OBEX BPP operation.
+ *
+ * @param handle      handle to the connection to cancel
+ * @param cancelCfm   callback indicating completion of cancel (may be NULL)
+ */
+OI_STATUS OI_BPP_PRINTER_Cancel(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                OI_OBEXCLI_ABORT_CFM cancelCfm);
+
+/** Indicates the result of a call to OI_BPP_PRINTER_GetReferencedObjects.
+ *  If the status code is OI_OBEX_CONTINUE, the application should
+ *  respond by invoking OI_BPP_PRINTER_GetReferencedObjects again.
+ *
+ * @param handle    connection handle associated with the request
+ * @param body      body of the requested data, if available
+ * @param fileSize  total size of the requested file, or -1 if not requested or
+ *                  not known
+ * @param status    OI_OBEX_CONTINUE if more data follows this response; OI_OK
+ *                  or error otherwise
+ */
+typedef void (*OI_BPP_PRINTER_GET_REFERENCED_OBJECTS_CFM)(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                                          OI_OBEX_BYTESEQ *body,
+                                                          OI_INT32 fileSize,
+                                                          OI_STATUS status);
+
+/** Performs a get referenced objects operation.
+ * @param handle  handle to the connection to use for the request
+ * @param cb    confirmation callback function
+ * @param URI   URI of the object to request
+ * @param offset    offset into the object to start retreiving data
+ * @param count     maximum amount of data the sender should return
+ * @param requestFileSize   TRUE to request that the sender return the total
+ * size of the requested object, FALSE otherwise.
+ */
+OI_STATUS OI_BPP_PRINTER_GetReferencedObjects(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                              OI_BPP_PRINTER_GET_REFERENCED_OBJECTS_CFM cb,
+                                              OI_OBEX_UNICODE *URI,
+                                              OI_UINT32 offset,
+                                              OI_INT32 count,
+                                              OI_BOOL requestFileSize);
+
+/**
+  This structure is used to group together the callbacks
+  associated with a printer.
+  */
+typedef struct {
+    OI_BPP_PRINTER_CONNECT_IND connect;
+    OI_BPP_PRINTER_DISCONNECT_IND disconnect;
+    OI_BPP_PRINTER_FILE_PUSH_IND filePush;
+    OI_BPP_PRINTER_REF_PUSH_IND refPush;
+    OI_BPP_PRINTER_GET_RUI_IND getRui;
+    OI_BPP_PRINTER_SOAP_IND soap;
+    OI_BPP_PRINTER_SOAP_IND statusSoap;
+} OI_BPP_PRINTER_CALLBACKS;
+
+/**
+  This structure describes the printer capabilities.
+  */
+typedef struct {
+    OI_CHAR *documentFormats;           /*<< Supported document formats. Mandatory */
+    OI_UINT128 characterRepertoires;    /*<< Supported character repertoires. Mandatory */
+    OI_CHAR *xhtmlPrintImageFormats;    /*<< Supported image formats for XHTML-Print. Mandatory */
+    OI_BOOL fullColor;                  /*<< TRUE if full color is supported, FALSE otherwise */
+    OI_CHAR *id1284;                    /*<< IEEE-1284 ID string. Mandatory */
+    OI_CHAR *printerName;               /*<< User-friendly printer name string. Optional (specify NULL to omit). */
+    OI_CHAR *printerLocation;           /*<< User-friendly printer location string. Optional (specify NULL to omit). */
+    OI_BOOL duplex;                     /*<< TRUE if duplex printing is supported, FALSE otherwise */
+    OI_CHAR *mediaTypes;                /*<< Supported print media types. Optional (specify NULL to omit). */
+    OI_UINT16 maxMediaWidth;            /*<< Maximum print media width, in millimeters. Optional (specify 0 to omit). */
+    OI_UINT16 maxMediaLength;           /*<< Maximum print media length, in millimeters. Optional (specify 0 to omit). */
+    OI_BOOL enhancedLayout;             /*<< TRUE if enhanced layout is supported, FALSE otherwise */
+    OI_CHAR *ruiFormats;                /*<< Supported RUI formats, in order of preference. Optional (specify NULL to omit). */
+    OI_CHAR *referenceTopUrl;           /*<< Top URL for reference printing RUI if supported, NULL otherwise. */
+    OI_CHAR *directTopUrl;              /*<< Top URL for direct printing RUI if supported, NULL otherwise. */
+} OI_BPP_PRINTER_CAPS;
+
+/**
+ * Registers a BPP printer.
+ *
+ * @param caps              Pointer to printer cabailities struct. This must remain live as long as
+ *                          the printer is registered
+ * @param cb                Pointer to printer server callbacks
+ * @param sdpStrings        Pointer to localized service record strings
+ * @param authentication    enumeration value describing the type of
+ *                          authentication, if any, the printer requires
+ * @param serverHandle      Out parameter handle for the BPP printer server
+ */
+OI_STATUS OI_BPP_PRINTER_Register(const OI_BPP_PRINTER_CAPS *caps,
+                                  const OI_BPP_PRINTER_CALLBACKS *cb,
+                                  const OI_SDP_STRINGS *sdpStrings,
+                                  OI_OBEXSRV_AUTHENTICATION authentication,
+                                  OI_BPP_PRINTER_SERVER_HANDLE *serverHandle);
+
+/**
+ * Deregisters a BPP printer.
+ *
+ * @param serverHandle   The handle returned when the BPP printer server was registered.
+ *
+ * @returns     OI_OK if deregistration was successful, an error otherwise.
+ */
+OI_STATUS OI_BPP_PRINTER_Deregister(OI_BPP_PRINTER_SERVER_HANDLE serverHandle);
+
+
+/**
+ * This function forcibly severs either the JOB or STATUS connection from a
+ * BPP client to the OBEX server. The disconnect indication callback will be
+ * called when the disconnect is complete.
+ *
+ * A BPP server may need to forcibly terminate a connection during
+ * deregistration, since deregistration will fail if a connection is in place.
+ *
+ * @param handle     a unique identifier generated by the BIP server that
+ *                   identifies the connection.
+ *
+ * @return           OI_OK if the connectionId is valid and the connection
+ *                   will be terminated.
+ */
+OI_STATUS OI_BPP_PRINTER_ForceDisconnect(OI_OBEXSRV_CONNECTION_HANDLE handle);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_BPP_PRINTER_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_bpp_sender.h b/obex_profiles/sdk/include/profiles/oi_bpp_sender.h
new file mode 100644
index 0000000..8483193
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_bpp_sender.h
@@ -0,0 +1,391 @@
+#ifndef _OI_BPP_SENDER_H
+#define _OI_BPP_SENDER_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides the interface for a Basic Printing Profile sender
+ * application.
+ */
+
+#include "oi_bpp.h"
+#include "oi_sdp.h"
+#include "oi_connect_policy.h"
+#include "oi_obexcli.h"
+
+/** \addtogroup BPP BPP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Type for a register BPP sender server
+ */
+typedef OI_OBEX_SERVER_HANDLE OI_BPP_SENDER_SERVER_HANDLE;
+
+
+/** This function indicates a connection request by a printer for a referenced objects service.
+ * The sender application should check to see if the connecting printer is
+ * currently or has recently been the target of a printing operation before
+ * deciding to accept the connection.
+ *
+ * @param handle    Connection handle for this session
+ * @param addr      Address of printer requesting access
+ * @return  OI_OK to accept the connection, OI_OBEX_ACCESS_DENIED or another
+ * error status to refuse
+ */
+typedef OI_STATUS (*OI_BPP_SENDER_CONNECT_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                               OI_BD_ADDR *addr);
+
+/** This function indicates that a printer has disconnected.
+ *
+ * @param handle    Handle of the dropped connection
+ */
+typedef void (*OI_BPP_SENDER_DISCONNECT_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle);
+
+/** This function indicates a request by a connected printer for an object.
+ * @param handle        Connection handle on which the request is being made
+ * @param name          URI of the requested object
+ * @param offset        Offset into the requested object
+ * @param count         Number of bytes, starting at the offset, being requested
+ * @param getFileSize   TRUE if the printer is requesting the total size of the
+ * indicated object
+ */
+typedef OI_STATUS (*OI_BPP_SENDER_GET_REFERENCED_OBJECTS_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                                              OI_OBEX_UNICODE *name,
+                                                              OI_UINT32 offset,
+                                                              OI_INT32 count,
+                                                              OI_BOOL getFileSize,
+                                                              OI_STATUS status);
+/** This function responds to a get referenced objects request.
+ * @param handle    Connection handle on which the request is being made
+ * @param data      Body of the reply
+ * @param fileSize  Pointer to file size if requested, NULL if not
+ * @param status    OI_OBEX_CONTINUE if more data follows this response, OI_OK or
+ * an error otherwise.
+ */
+OI_STATUS OI_BPP_SENDER_GetReferencedObjectsResponse(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                                     OI_OBEX_BYTESEQ *data,
+                                                     OI_INT32 *fileSize,
+                                                     OI_STATUS status);
+
+
+
+/** Connection establishment */
+
+/** This function provides confirmation of a connection attempt.
+ * @param handle    Connection handle, as returned by OI_BPP_SENDER_Connect
+ * @param status    OI_OK if connection was established, error otherwise
+ */
+typedef void (*OI_BPP_SENDER_CONNECT_CFM)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                          OI_STATUS status);
+
+/** This function provides an authentication challenge during connection attempt. The application should
+ * respond with OI_OBEXCLI_Authentication.
+ * @param handle    Connection handle, as returned by OI_BPP_SENDER_Connect
+ * @param userIdRequired    Indicates whether the authentication response should
+ * include a user ID
+ */
+typedef void (*OI_BPP_SENDER_AUTH_CHALLENGE_IND)(OI_OBEXSRV_CONNECTION_HANDLE handle,
+                                                 OI_BOOL userIdRequired);
+
+/** This function connects to a BPP printer. At most, one job-channel connection, one
+ * rui-channel connection, and one status connection may be in progress at any given time.
+ *
+ * @param addr          Address of the remote BPP printer server.
+ *
+ * @param lowerProtocol This identifies the RFCOMM channel number or the L2CAP PSM for the
+ *                      BPP printer server running on the remote device.  the remote device. The
+ *                      caller will normally perform service discovery on the remote device to
+ *                      obtain the required channel number or PSM.
+ *
+ * @param target        Enumeration constant specifying the type of service to
+ *                      which to connect
+ *
+ * @param authentication Specifies whether authentication is required when
+ *                       connecting to a server
+
+ * @param connectCfm    Callback invoked indicating the success or failure of
+ *                      the connection request
+ *
+ * @param disconnectInd Callback to be invoked when this connection terminates
+ *
+ * @param authInd       Callback to be invoked to get authentication data; may be
+ *                      NULL if authentication is not to be used
+ *
+ * @param handle        Out parameter specifying the connection handle associated
+ *                      with the new connection
+ *
+ * @return  OI_OK if connection request was successful, error otherwise; the connection is not
+ *          complete until the connectCfm callback is called with OI_OK
+ */
+OI_STATUS OI_BPP_SENDER_Connect(OI_BD_ADDR *addr,
+                                OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                                OI_BPP_TARGET target,
+                                OI_OBEXCLI_AUTHENTICATION authentication,
+                                OI_BPP_SENDER_CONNECT_CFM connectCfm,
+                                OI_BPP_SENDER_DISCONNECT_IND disconnectInd,
+                                OI_BPP_SENDER_AUTH_CHALLENGE_IND authInd,
+                                OI_OBEXCLI_CONNECTION_HANDLE *handle);
+
+/** This function disconnects the specified BPP connection.
+ * @param handle    Handle of the connection to drop
+ */
+OI_STATUS OI_BPP_SENDER_Disconnect(OI_OBEXCLI_CONNECTION_HANDLE handle);
+
+
+/** This callback function is invoked in response to OI_BPP_SENDER_SendFile. If the status code
+ * is OI_OBEX_CONTINUE, the client should respond by invoking
+ * OI_BPP_SENDER_SendFile(handle, [callback], NULL, NULL, NULL, NULL, [pdata],
+ * [final]);
+ *
+ * @param handle    Handle to the connection over which the file was sent
+ *
+ * @param status    OI_OBEX_CONTINUE if the server expects more data, OI_OK if
+ * the transaction completed without error, otherwise an error code
+ */
+typedef void (*OI_BPP_SENDER_SEND_FILE_CFM)(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                            OI_STATUS status);
+
+/** This function performs the FilePush or SendDocument BPP operations.
+ *
+ * @param handle    Handle to the connection over which to send the file
+ *
+ * @param putCfm    Callback indicating the result of the operation
+ *
+ * @param type      MIME type of the file being sent
+ *
+ * @param description   Optional document-type specific information
+ *
+ * @param name      Optional document name
+ *
+ * @param jobId     Pointer to the job ID if using job-based data transfer, NULL for
+ * simple push operation
+ *
+ * @param data      File data to send
+ *
+ * @param final     TRUE if this is the final block of data in this operation,
+ * FALSE otherwise.
+ */
+OI_STATUS OI_BPP_SENDER_SendFile(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                 OI_BPP_SENDER_SEND_FILE_CFM putCfm,
+                                 OI_OBEX_BYTESEQ *type,
+                                 OI_OBEX_UNICODE *description,
+                                 OI_OBEX_UNICODE *name,
+                                 OI_BPP_JOB_ID *jobId,
+                                 OI_OBEX_BYTESEQ *data,
+                                 OI_BOOL final);
+
+/** This callback function is invoked in response to OI_BPP_SENDER_SendReference.
+ *
+ * @param handle    Handle to the connection over which the reference was sent
+ * @param url       In the event that not all references could be retrieved, the URL is
+ * the first to fail
+ * @param httpChallenge If the URL failed due to an authentication challenge, this
+ * parameter includes the authentication challenge HTTP header
+ * @param status    OI_OBEX_CONTINUE if the server expects more data, OI_OK if
+ * the transaction completed without error, otherwise an error code
+ */
+typedef void (*OI_BPP_SENDER_SEND_REFERENCE_CFM)(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                                 OI_OBEX_BYTESEQ *url,
+                                                 OI_OBEX_BYTESEQ *httpChallenge,
+                                                 OI_STATUS status);
+
+/** This function performs the SimpleReferencePush or SendReference operation.
+ *
+ * @param handle    Handle to the connection over which to send the reference
+ * @param cb        Callback receiving the result of the operation
+ * @param type      Enumeration value indicating the type of reference (simple,
+ * list, or xml)
+ * @param httpHeaders Authentication credentials (optional)
+ * @param jobId Pointer to the job ID if using job-based transfer, NULL for simple
+ * reference push
+ * @param data  Reference data to send
+ * @param final TRUE if this is the final block of data for this operation,
+ * FALSE otherwise.
+ */
+OI_STATUS OI_BPP_SENDER_SendReference(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                      OI_BPP_SENDER_SEND_REFERENCE_CFM cb,
+                                      OI_BPP_REF_TYPE type,
+                                      OI_OBEX_BYTESEQ *httpHeaders,
+                                      OI_BPP_JOB_ID *jobId,
+                                      OI_OBEX_BYTESEQ *data,
+                                      OI_BOOL final);
+
+/** This callback function is invoked in response to SOAP and RUI requests.
+ *
+ * @param handle    Handle to the connection over which the request was made
+ * @param reply     Body of the reply
+ * @param jobId     If a job ID was sent as part of the SOAP response, this
+ * value will point to it; otherwise, it is NULL
+ * @param status    OI_OBEX_CONTINUE if there is more response data, OI_OK if
+ * the transaction completed without error, otherwise an error code
+ * @param final     TRUE if the get response contains end-of-body header.
+ */
+typedef void (*OI_BPP_SENDER_GET_CFM)(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                      OI_OBEX_BYTESEQ *reply,
+                                      OI_BPP_JOB_ID *jobId,
+                                      OI_STATUS status,
+                                      OI_BOOL final);
+
+/** This function sends a SOAP message to a BPP printer.
+ * @param handle    Handle to the connection over which to send the request
+ * @param cb    Callback invoked with the result of the request
+ * @param body  Body of the request
+ * @param final TRUE if this is the final (or only) portion of the request
+ */
+OI_STATUS OI_BPP_SENDER_SOAPRequest(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                    OI_BPP_SENDER_GET_CFM cb,
+                                    OI_OBEX_BYTESEQ *body,
+                                    OI_BOOL final);
+
+/** This function sends a Get RUI request to a BPP printer.
+ * @param handle       Handle to the connection over which to send the request
+ * @param cb           Callback invoked with the result of the request
+ * @param type         MIME type of the request
+ * @param name         Name
+ * @param httpHeaders  HTTP headers
+ * @param body         Body of the request
+ * @param final        TRUE if this is the final (or only) portion of the request
+ */
+OI_STATUS OI_BPP_SENDER_GetRUI(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                               OI_BPP_SENDER_GET_CFM cb,
+                               OI_OBEX_BYTESEQ *type,
+                               OI_OBEX_UNICODE *name,
+                               OI_OBEX_BYTESEQ *httpHeaders,
+                               OI_OBEX_BYTESEQ *body,
+                               OI_BOOL final);
+
+
+/** This callback function is invoked when a cancel is complete.
+ *
+ * @param handle      Handle to the connection with the recently canceled operation
+ */
+typedef void (*OI_BPP_SENDER_CANCEL_CFM)(OI_OBEXCLI_CONNECTION_HANDLE handle);
+
+/** This function cancels the current OBEX BPP operation.
+ *
+ * @param handle      Handle to the connection to cancel
+ * @param cancelCfm   Callback indicating completion of cancel (may be NULL)
+ */
+OI_STATUS OI_BPP_SENDER_Cancel(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                               OI_BPP_SENDER_CANCEL_CFM cancelCfm);
+
+/**
+ * OI_BPP_SENDER_AuthenticationRsp()
+ *
+ * This function provides authentication information to the BPP printer.
+ *
+ * @param connectionId Handle representing the connection to the BPP printer
+ *
+ * @param userId       User ID for the connecting sender; this parameter is
+ *                     required if the printer indicated that the user ID is
+ *                     required; otherwise is can be NULL; the client can
+ *                     provide a user ID even if the printer does not require
+ *                     one
+ *
+ * @param userIdLen    Length of the userId
+ *
+ * @param password     NULL-terminated client password
+ */
+OI_STATUS OI_BPP_SENDER_AuthenticationRsp(OI_OBEXCLI_CONNECTION_HANDLE handle,
+                                          const OI_BYTE *userId,
+                                          OI_UINT8 userIdLen,
+                                          const OI_CHAR *password);
+
+/**
+  This structure groups together the callbacks associated with a
+  sender.
+  */
+typedef struct {
+    OI_BPP_SENDER_CONNECT_IND connectInd;
+    OI_BPP_SENDER_DISCONNECT_IND disconnectInd;
+    OI_BPP_SENDER_GET_REFERENCED_OBJECTS_IND getObj;
+} OI_BPP_SENDER_CALLBACKS;
+
+/** This function registers the BPP sender, optionally registering referenced objects servers.
+ * This call must be made even if no servers are to be registered.
+ *
+ * @param strings         SDP strings for the service record created if servers are to
+ *                        be registered; this may be NULL
+ *
+ * @param objectCallbacks Pointer to server callbacks for referenced objects service; if this
+ *                        pointer is NULL, then no referenced objects service will be registered
+ *
+ * @param ruiRefCallbacks Pointer to server callbacks for RUI referenced objects service; if this
+ *                        pointer is NULL, then no RUI referenced objcets service will be registered
+ *
+ * @param serverHandle    Out parameter handle for the BPP sender server
+ */
+OI_STATUS OI_BPP_SENDER_Register(const OI_SDP_STRINGS *strings,
+                                 const OI_BPP_SENDER_CALLBACKS *objectCallbacks,
+                                 const OI_BPP_SENDER_CALLBACKS *ruiRefCallbacks,
+                                 OI_BPP_SENDER_SERVER_HANDLE *serverHandle);
+
+/**
+ * This function deregisters the BPP sender.
+ *
+ * @param serverHandle   The handle returned when the BPP printer server was registered.
+ *
+ * @returns     OI_OK if deregistration was successful, an error otherwise.
+ */
+OI_STATUS OI_BPP_SENDER_Deregister(OI_BPP_SENDER_SERVER_HANDLE serverHandle);
+
+
+/**
+ * This function forcibly severs the connection from a BPP client to the OBEX
+ * server. The disconnect indication callback will be called when the
+ * disconnect is complete.
+ *
+ * A BPP server may need to forcibly terminate a connection during
+ * deregistration, since deregistration will fail if a connection is in place.
+ *
+ * @param handle     Unique identifier generated by the BIP server that
+ *                   identifies the connection
+ *
+ * @return           OI_OK if the connectionId is valid and the connection
+ *                   will be terminated
+ */
+OI_STATUS OI_BPP_SENDER_ForceDisconnect(OI_OBEXSRV_CONNECTION_HANDLE handle);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_BPP_SENDER_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_ftp_client.h b/obex_profiles/sdk/include/profiles/oi_ftp_client.h
new file mode 100644
index 0000000..a9fd572
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_ftp_client.h
@@ -0,0 +1,546 @@
+#ifndef _OI_FTP_CLIENT_H
+#define _OI_FTP_CLIENT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+  @file
+
+  File Transfer Profile client API
+
+  The File Transfer Profile provides functions for establishing a connection to
+  a remote device that support the File Transfer Profile over RFCOMM and
+  functions for putting and getting files. This implementation currently only
+  allows one connection at a time. A Bluetooth device address and an RFCOMM channel
+  number are required for setting up the connection. Unless the application
+  already knows the RFCOMM channel number, the application will need to perform
+  service discovery to obtain the channel number.
+
+  Once a connection has been established, the application can call
+  OI_FTPClient_Put() to write files to the server and OI_FTPClient_Get() to read files
+  from the server. If folder navigation is supported by the remote server, the
+  application can call OI_FTPClient_SetPath() to navigate the folder hierarchy on
+  the remote server. FTPClient_GetFolderList() queries the remote server for
+  information about the files and folder in the current folder.
+
+  The file system support on the local device is defined by oi_ftp_file.c and is
+  implementation-dependent. On a client platform with a native file system,
+  oi_ftp_file.c will likely be a thin wrapper on the native file system APIs. On
+  other platforms, oi_ftp_file.c might implement a simple in-memory object manager.
+
+ */
+
+#include "oi_obexspec.h"
+#include "oi_obex.h"
+#include "oi_obexcli.h"
+#include "oi_ftp_sys.h"
+
+/** \addtogroup FTP FTP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/**
+ * This enumeration is of completion and notification events returned to the application via the
+ * @ref OI_FTP_CLIENT_EVENT_CB callback function. The event indicates completion, the
+ * accompanying status code indictates if the operation succeeded or failed. The
+ * completion of a get folder listing operation, OI_FTPClient_GetFolderListing(),
+ * is not signalled by and event, rather a @ref OI_FTP_CLIENT_FOLDER_LIST_CB
+ * function is called with the retrieved folder list.
+ */
+typedef enum {
+    OI_FTP_CLIENT_CONNECTED,               /**< An event of this type indicates that a connection request has completed. */
+    OI_FTP_CLIENT_CONNECTED_READ_ONLY,     /**< An event of this type indicates that a connection request has completed. */
+    OI_FTP_CLIENT_DISCONNECT,              /**< An event of this type indicates that a connection has been terminated. */
+    OI_FTP_CLIENT_GET_COMPLETE,            /**< A Put operation has completed. */
+    OI_FTP_CLIENT_PUT_COMPLETE,            /**< A Get operation has completed. */
+    OI_FTP_CLIENT_DELETE_COMPLETE,         /**< A file or folder delete operation has completed. */
+    OI_FTP_CLIENT_SETPATH_COMPLETE,        /**< A Set path operation has completed. */
+    OI_FTP_CLIENT_NEW_SUBFOLDER_COMPLETE,  /**< New sub-folder created on the remote server */
+    OI_FTP_CLIENT_TREE_PUT_COMPLETE,       /**< A Put of a complete folder tree has completed. */
+    OI_FTP_CLIENT_TREE_GET_COMPLETE,       /**< A Get of a complete folder tree has completed. */
+    OI_FTP_CLIENT_RENAME_COMPLETE,         /**< A remote file or foler rename has completed */
+    OI_FTP_CLIENT_COPY_COMPLETE,           /**< A remote file or folder copy has completed */
+    OI_FTP_CLIENT_SET_PERMISSIONS_COMPLETE,/**< Permissions have been set on a remote file or folder */
+    OI_FTP_CLIENT_PUT_STARTED,             /**< A New PUT file transfer has started */
+    OI_FTP_CLIENT_GET_STARTED,             /**< A New GET file transfer has started */
+    OI_FTP_CLIENT_PUT_PROGRESS,            /**< Periodic event delivered during FTP file transfer */
+    OI_FTP_CLIENT_GET_PROGRESS,            /**< Periodic event delivered during FTP file transfer */
+} OI_FTP_CLIENT_EVENT;
+
+/**
+ * Structure containing event code, and any related data
+ */
+typedef struct {
+    OI_FTP_CLIENT_EVENT     event;
+    union {
+        struct {
+            OI_OBEX_UNICODE *fileName;    /**< File name being pushed */
+            OI_UINT32        totalBytes;  /**< Total bytes in file being sent (if known) */
+        } putStarted;                     /**< Union structure valid for @ref OI_FTP_CLIENT_PUT_STARTED */
+        struct {
+            OI_OBEX_UNICODE *fileName;    /**< File name being pushed */
+            OI_UINT32        totalBytes;  /**< Total bytes in file being received (if known) */
+        } getStarted;                     /**< Union structure valid for @ref OI_FTP_CLIENT_GET_STARTED */
+        struct {
+            OI_UINT32        bytesTransferred; /**< Total bytes sent so far for this file */
+        } putProgress;                    /**< Union structure valid for @ref OI_FTP_CLIENT_PUT_PROGRESS */
+        struct {
+            OI_UINT32        bytesTransferred; /**< Total bytes received so far for this file */
+        } getProgress;                    /**< Union structure valid for @ref OI_FTP_CLIENT_GET_PROGRESS */
+        struct {
+            OI_UINT32        finalSize;   /**< Final bytes sent for this file */
+        } putComplete;                    /**< Union structure valid for @ref OI_FTP_CLIENT_PUT_COMPLETE */
+        struct {
+            OI_UINT32        finalSize;   /**< Final bytes received for this file */
+        } getComplete;                    /**< Union structure valid for @ref OI_FTP_CLIENT_GET_COMPLETE */
+    } data;
+} OI_FTP_CLIENT_EVENT_DATA;
+
+
+/**
+ * This value controls whether a set path request is setting the folder path to a specific
+ * folder, to the parent of the current folder, or to the root folder as defined
+ * by the remote server.
+ */
+typedef enum {
+    OI_FTP_CLIENT_SETPATH_TO_FOLDER,
+    OI_FTP_CLIENT_SETPATH_TO_PARENT,
+    OI_FTP_CLIENT_SETPATH_TO_ROOT
+} OI_FTP_CLIENT_SETPATH_CONTROL;
+
+
+/**
+ *  Represents an active connection between an FTP client and a remote FTP server
+ */
+
+typedef OI_FTP_CONNECTION OI_FTP_CLIENT_CONNECTION_HANDLE;
+
+
+/**
+ * The application must provide a function with this profile to OI_FTPClient_Connect()
+ * when initializing the file transfer client. This function is called to signal
+ * to the application when various operations completed, see @ref
+ * OI_FTP_EVENT_DATA.
+ *
+ * @param connectionId handle representing the connection to the FTP server.
+ *
+ * @param event   identifies an event
+ *
+ * @param status  OI_OK if the operation succeeded, or an error code if the operation failed
+ */
+typedef void (*OI_FTP_CLIENT_EVENT_CB)(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                                       const OI_FTP_CLIENT_EVENT_DATA *event,
+                                       OI_STATUS                       status);
+
+
+/**
+ * A callback function of this type asks the client to provide a password to authenticate the connection.
+ * The client must provide a function with this profile to OI_FTPClient_Connect() if the client
+ * supports OBEX authentication.
+ *
+ * @param connectionId handle representing the connection to the FTP server.
+ *
+ * @param userIdRequired  indicates that the server requires the client to
+ *                        provide a user id in the authentication call.
+ *
+ * @param realm           The realm for the authentication or NULL if there is no realm specified
+ */
+
+typedef void (*OI_FTP_CLIENT_AUTHENTICATION_CB)(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                                                OI_BOOL userIdRequired,
+                                                OI_OBEX_REALM *realm);
+
+
+/**
+ * The applicatiom must provide a function with this profile to
+ * OI_FTPClient_GetFolderListing() so that FTP client can return the folder listing
+ * results.
+ *
+ * @param connectionId handle representing the connection to the FTP server.
+ *
+ * @param folderData This points to a chunk of folder data. Folder data is sent
+ *                   by the server as XML text in one or more packets.  This
+ *                   parameter is NULL if this is the end of the folder data.
+ *
+ * @param status    Indicates if there was an error receiving the folder data.
+ */
+typedef void (*OI_FTP_CLIENT_FOLDER_LIST_CB)(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                                             OI_OBEX_BYTESEQ *folderData,
+                                             OI_STATUS status);
+
+/**
+ * This function establishes an OBEX connection over RFCOMM to a
+ * remote FTP server.  The client must provide callback functions of
+ * types OI_FTP_CLIENT_EVENT_CB and OI_FTP_CLIENT_AUTHENTICATION_CB to
+ * this function if the client supports OBEX authentication.
+ *
+ * @param addr              the address of a remote Bluetooth device that supports FTP
+ *
+ * @param lowerProtocol     This identifies the RFCOMM channel number or the L2CAP PSM for the
+ *                          FTP server running on the remote device.  the remote device. The caller
+ *                          will normally perform service discovery on the remote device to obtain
+ *                          the required channel number or PSM.
+ *
+ * @param connectionId      [OUT] returns a handle representing the connection to the FTP server
+ *
+ * @param authentication    Specifies whether authentication is required when
+ *                          connecting to a server.  Use OI_OBEXCLI_AUTH_NONE
+ *                          when no authentication is required.
+ *
+ * @param eventCB           callback function with which FTP client events will be returned
+ *
+ * @param authenticationCB  authentication callback function
+ *
+ * @param fileOperations    pointer to a structure of platform-specific file operations
+ *
+ * @return                  OI_OK if the connection request can be issued
+ */
+OI_STATUS OI_FTPClient_Connect(OI_BD_ADDR *addr,
+                               OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                               OI_FTP_CLIENT_CONNECTION_HANDLE *connectionId,
+                               OI_OBEXCLI_AUTHENTICATION authentication,
+                               OI_FTP_CLIENT_EVENT_CB eventCB,
+                               OI_FTP_CLIENT_AUTHENTICATION_CB authenticationCB,
+                               const OI_FTP_FILESYS_FUNCTIONS *fileOperations);
+
+/**
+ * This function terminate the current OBEX connection to a remote FTP server.
+ *
+ * @param connectionId handle representing the connection to the FTP server.
+ *
+ */
+OI_STATUS OI_FTPClient_Disconnect(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId);
+
+/**
+ * This function is called by the application in response to a password
+ * indication to provide a password for OBEX authentication.
+ *
+ * @param connectionId handle representing the connection to the FTP server.
+ *
+ * @param userId       the user id for the connecting user. This parameter is
+ *                     required if the server indicated that user id is
+ *                     required. Otherwise is can be NULL. The client can
+ *                     provide a user id even if the server does not require
+ *                     one.
+ *
+ * @param userIdLen    Length of the userId.
+ *
+ * @param password     is a NULL terminated password.
+ */
+OI_STATUS OI_FTPClient_AuthenticationRsp(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                                         const OI_BYTE *userId,
+                                         OI_UINT8 userIdLen,
+                                         const OI_CHAR *password);
+
+
+/**
+ * This function copies a file from the local client to a remote server.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param localName     the identifying name of the file on the local client that is
+ *                      being sent to the server
+ *
+ * @param remoteName    the name of the file that will be created or written on the
+ *                      remote server
+ *
+ * @return
+ *                      - OI_OK if the put operation was started
+ *                      - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                      - OI_OBEX_OPERATION_IN_PROGRESS if another put or get operation is in progress
+ *                      - or other errors
+ */
+OI_STATUS OI_FTPClient_Put(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                           OI_OBEX_UNICODE *localName,
+                           OI_OBEX_UNICODE *remoteName);
+
+/**
+ * This function deletes a file or folder on a remote server. Only empty folders can be deleted.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param name          the identifying name of a file or foldder on the remote server.
+ *
+ * @return
+ *                - OI_OK if the delete operation was sent
+ *                - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                - OI_OBEX_OPERATION_IN_PROGRESS if another get operation is in progress
+ *                - or other errors
+ */
+OI_STATUS OI_FTPClient_Delete(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                              OI_OBEX_UNICODE *name);
+
+
+/**
+ * This function copies a file from a remote server to the local client.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param localName     the name of the file that will be created or written on the local client
+ *
+ * @param remoteName    the identifying name of the file that is being requested from the remote server
+ *
+ * @return
+ *                    - OI_OK if the get operation was started
+ *                    - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                    - OI_OBEX_OPERATION_IN_PROGRESS if another put or get operation is in progress
+ *                    - or other errors
+ */
+OI_STATUS OI_FTPClient_Get(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                           OI_OBEX_UNICODE *localName,
+                           OI_OBEX_UNICODE *remoteName);
+
+/**
+ * This callback is invoked when the cancellation of an operation has completed.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ */
+typedef void (*OI_FTP_CLIENT_CANCEL_CFM)(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId);
+
+/**
+ * This function terminates the current put or get operation.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param cancelCfm     Callback to indicate completion of the cancellation (may be NULL).
+ *
+ * @return an error status if there is no operation to abort.
+ */
+OI_STATUS OI_FTPClient_Cancel(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                              OI_FTP_CLIENT_CANCEL_CFM cancelCfm);
+
+
+/**
+ * This function sets the current folder on the remote server for subsequent put and get
+ * operations.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param folder        the name of a child folder of the current folder if the second
+ *                      parameter is OI_FTP_CLIENT_SETPATH_TO_FOLDER; NULL otherwise
+ *
+ * @param setPathCtrl   determines the behavior of the setpath command, see @ref
+ *                      OI_FTP_CLIENT_SETPATH_CONTROL for more information.
+ *
+ * @return
+ *                    - OI_OK if the set path request was sent
+ *                    - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                    - OI_OBEX_OPERATION_IN_PROGRESS if another operation is in progress
+ *                    - or other errors
+ */
+OI_STATUS OI_FTPClient_SetPath(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                               OI_OBEX_UNICODE *folder,
+                               OI_FTP_CLIENT_SETPATH_CONTROL setPathCtrl);
+
+/**
+ * This function creates a subfolder beneath the current folder on the remote
+ * server if the server supports this function.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param folder        the name of the new sub-folder
+ *
+ * @return
+ *                    - OI_OK if the set path request was sent
+ *                    - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                    - OI_OBEX_OPERATION_IN_PROGRESS if another operation is in progress
+ *                    - or other errors
+ */
+OI_STATUS OI_FTPClient_NewSubfolder(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                                    OI_OBEX_UNICODE *folder);
+
+
+/**
+ * This function gets information about files and folders in the current folder or in a
+ * specific subfolder of the current folder.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param folder        a subfolder of the current folder, or NULL
+ *
+ * @param folderListCB  The callback function specified by this parameter is the function
+ *                      called with the folder listing results. This function may be called
+ *                      mutiple times if the results are sent as multiple packets.
+ *
+ * @return
+ *                        - OI_OK if the folder listing request was sent
+ *                        - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                        - OI_OBEX_OPERATION_IN_PROGRESS if another operation is in progress
+ *                        - or other errors
+ */
+OI_STATUS OI_FTPClient_GetFolderListing(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                                        OI_OBEX_UNICODE *folder,
+                                        OI_FTP_CLIENT_FOLDER_LIST_CB folderListCB);
+
+
+/**
+ * This function recursively copies a folder and all its subfolders and files
+ * from the local client to a remote server.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param localName     the identifying name of the folder on the local client that is
+ *                      being sent to the server. This can be a path name that
+ *                      is interpreted by the local file system.
+ *
+ * @param remoteName    the name of the folder that will be created or written on the
+ *                      remote server
+ *
+ * @return
+ *                      - OI_OK if the put operation was started
+ *                      - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                      - OI_OBEX_OPERATION_IN_PROGRESS if another put or get operation is in progress
+ *                      - or other errors
+ *
+ * @note   This function operates by recursively browsing folders on the server
+ *         and client. In the event of an error the application must assume that
+ *         the current local and remote folders are no longer known. It is
+ *         therefore the repsonsibility of the  application to set the remote
+ *         folder to the root folder and browese back to the desired folder. The
+ *         local folder should be similarly reset to a starting point.
+ */
+OI_STATUS OI_FTPClient_TreePut(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                               OI_OBEX_UNICODE *localName,
+                               OI_OBEX_UNICODE *remoteName);
+
+
+/**
+ * This function recursively copies a folder and all its subfolders and files
+ * from a remote server to the local client.
+ *
+ * @param connectionId  handle representing the connection to the FTP server.
+ *
+ * @param localName     the name of the folder that will be created or written
+ *                      on the local client
+ *
+ * @param remoteName    the identifying name of the folder that is being
+ *                      requested from the remote server
+ *
+ * @return
+ *                    - OI_OK if the get operation was started
+ *                    - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                    - OI_OBEX_OPERATION_IN_PROGRESS if another put or get operation is in progress
+ *                    - or other errors
+ *
+ * @note   This function operates by recursively browsing folders on the server
+ *         and client. In the event of an error the application must assume that
+ *         the current local and remote folders are no longer known. It is
+ *         therefore the repsonsibility of the  application to set the remote
+ *         folder to the root folder and browese back to the desired folder. The
+ *         local folder should be similarly reset to a starting point.
+ */
+OI_STATUS OI_FTPClient_TreeGet(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                               OI_OBEX_UNICODE *localName,
+                               OI_OBEX_UNICODE *remoteName);
+
+
+/**
+ * This function renames a file or folder on the remote device. The new name may specify an absolute
+ * or relative file name in which case the file or folder will be moved to the new location.
+ *
+ * @param connectionId  Handle representing the connection to the FTP server.
+ *
+ * @param currentName   The name of thee remote file or folder to be renamed or moved.
+ *
+ * @param newName       The new name for the remote file or folder which may include a relative or
+ *                      absolute path prefix if the file or folder is to be moved to another
+ *                      location within the server folder tree.
+ *
+ * @return
+ *                    - OI_OK if the rename operation was started
+ *                    - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                    - OI_OBEX_OPERATION_IN_PROGRESS if another operation is in progress
+ *                    - or other errors
+ *
+ */
+OI_STATUS OI_FTPClient_Rename(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                              OI_OBEX_UNICODE *currentName,
+                              OI_OBEX_UNICODE *newName);
+
+
+/**
+ * This function copies a file or folder on the remote device to another file or location on the
+ * remote device. In the case of a folder the contents of the folder are copied recursively.
+ *
+ * @param connectionId  Handle representing the connection to the FTP server.
+ *
+ * @param srcName       The name of the remote file or folder to be copied.
+ *
+ * @param destName      The destination name for the copied file or folder.
+ *
+ * @return
+ *                    - OI_OK if the copy operation was started
+ *                    - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                    - OI_OBEX_OPERATION_IN_PROGRESS if another operation is in progress
+ *                    - or other errors
+ *
+ */
+OI_STATUS OI_FTPClient_Copy(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                            OI_OBEX_UNICODE *srcName,
+                            OI_OBEX_UNICODE *destName);
+
+
+/**
+ * This function sets the permissions on a remote file or folder.
+ *
+ * @param connectionId     Handle representing the connection to the FTP server.
+ *
+ * @param name             The name of a remote file or folder
+ *
+ * @param groupPermission  Group permission bits as defined in oi_obexpec.h
+ *
+ * @param userPermission   User permission bits as defined in oi_obexpec.h
+ *
+ * @param otherPermission  Other permission bits as defined in oi_obexpec.h
+ *
+ * @return
+ *                    - OI_OK if the set permission operation was started
+ *                    - OI_OBEX_NOT_CONNECTED if the client is not connected to an OBEX server
+ *                    - OI_OBEX_OPERATION_IN_PROGRESS if another operation is in progress
+ *                    - or other errors
+ *
+ */
+OI_STATUS OI_FTPClient_SetPermissions(OI_FTP_CLIENT_CONNECTION_HANDLE connectionId,
+                                      OI_OBEX_UNICODE *name,
+                                      OI_UINT8 groupPermission,
+                                      OI_UINT8 userPermission,
+                                      OI_UINT8 otherPermissions);
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_FTP_CLIENT_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_ftp_file.h b/obex_profiles/sdk/include/profiles/oi_ftp_file.h
new file mode 100644
index 0000000..4790ba7
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_ftp_file.h
@@ -0,0 +1,61 @@
+#ifndef _OI_FTP_FILE_H
+#define _OI_FTP_FILE_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ @file
+
+ File system abstraction layer used by the the File Transfer Profile client and
+ server.
+
+*/
+
+#include "oi_ftp_sys.h"
+
+/** \addtogroup FTP FTP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+void OI_FTP_FileSystemFunctions(OI_FTP_FILESYS_FUNCTIONS *fops);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_FTP_FILE_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_ftp_server.h b/obex_profiles/sdk/include/profiles/oi_ftp_server.h
new file mode 100644
index 0000000..dbaf4d6
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_ftp_server.h
@@ -0,0 +1,357 @@
+#ifndef _OI_FTP_SERVER_H
+#define _OI_FTP_SERVER_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+  @file
+
+  This file provides the API for the server side of the File Transfer Profile.
+
+  The File Transfer Profile provides functions for establishing a connection to
+  a remote device that support the File Transfer Profile over RFCOMM and
+  functions for putting and getting files. This implementation currently only
+  allows one client connection at a time.
+
+  The file system support on the local device is defined by oi_ftp_file.c and is
+  implementation-dependent. On server platforms with a native file system,
+  oi_ftp_file.c will likely be a thin wrapper on the native file system APIs. On
+  other platforms, oi_ftp_file.c might implement a simple in-memory object manager.
+ */
+
+#include "oi_obex.h"
+#include "oi_obexsrv.h"
+#include "oi_status.h"
+#include "oi_sdp.h"
+#include "oi_ftp_sys.h"
+
+/** \addtogroup FTP FTP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Represents an active connection between the FTP server and a remote FTP
+ * client
+ */
+typedef OI_FTP_CONNECTION OI_FTP_SERVER_CONNECTION_HANDLE;
+
+
+/**
+ * Represents a registered FTP server
+ */
+typedef OI_OBEX_SERVER_HANDLE OI_FTP_SERVER_HANDLE;
+
+/*
+ * List of events the FTP Server can notify the Server Application about
+ */
+typedef enum {
+    OI_FTP_SERVER_EVENT_PUT,
+    OI_FTP_SERVER_EVENT_GET,
+    OI_FTP_SERVER_EVENT_PUT_PROGRESS,
+    OI_FTP_SERVER_EVENT_GET_PROGRESS,
+    OI_FTP_SERVER_EVENT_PUT_COMPLETE,
+    OI_FTP_SERVER_EVENT_GET_COMPLETE
+} OI_FTP_SERVER_EVENT_TYPE;
+
+typedef struct {
+    OI_FTP_SERVER_EVENT_TYPE    event;
+    union {
+        struct {
+            const OI_OBEX_UNICODE *localName;   /* if known, else NULL */
+            OI_UINT32              totalSize;   /* if known, else 0 */
+            const OI_CHAR         *objType;     /* if known, else 0 */
+        } put;
+        struct {
+            const OI_OBEX_UNICODE *localName;   /* if known, else NULL */
+            OI_UINT32              totalSize;   /* if known, else 0 */
+            const OI_CHAR         *objType;     /* if known, else 0 */
+        } get;
+        struct {
+            OI_UINT32              bytesTransferred;
+        } putProgress;
+        struct {
+            OI_UINT32              bytesTransferred;
+        } getProgress;
+        struct {
+            OI_UINT32              finalSize;
+            OI_STATUS              status;      /**< Status of the transfer upon completion */
+
+        } putComplete;
+        struct {
+            OI_UINT32              finalSize;
+            OI_STATUS              status;      /**< Status of the transfer upon completion */
+        } getComplete;
+    } data;
+} OI_FTP_SERVER_EVENT_DATA;
+
+/**
+ * A callback function of this type is called to indicate a connection request.
+ * The server application provides a function with this profile to
+ * OI_FTPServer_Register()
+ *
+ * @param clientAddr     The Bluetooth device address of the client requesting
+ *                       the connection.
+ *
+ * @param unauthorized   Indicates if the connection requires authentication. If
+ *                       this parameter is TRUE, the server application must call
+ *                       OI_FTPServer_AuthenticationRsp() to provide a password.
+ *                       After successful authentication, this function will be
+ *                       called again with unauthorized == FALSE indicating that
+ *                       the connection has been established. If authentication
+ *                       was attempted but failed, this unauthorized parameter
+ *                       will still be TRUE.
+ *
+ * @param userId         The user ID of the user requesting the connection.
+ *                       This parameter is only set for authenticated
+ *                       connections and may be NULL in any case.
+ *                       The application server may use this value to choose a
+ *                       root directory or select a previously stored password.
+ *
+ * @param connectionId   Handle representing the connection to an FTP client.
+ *
+ * @param userIdLen      Length of the user ID.
+ */
+
+typedef void (*OI_FTP_CONNECTION_IND)(OI_BD_ADDR *clientAddr,
+                                      OI_BOOL unauthorized,
+                                      OI_BYTE *userId,
+                                      OI_UINT8 userIdLen,
+                                      OI_FTP_SERVER_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * A callback function of this type is called to indicate that a client has
+ * disconnected from the FTP server. The server application provides a function
+ * with this profile to OI_FTPServer_Register()
+ *
+ * @param connectionId   Handle representing the connection to an FTP client
+ */
+
+typedef void (*OI_FTP_DISCONNECTION_IND)(OI_FTP_SERVER_CONNECTION_HANDLE connectionId);
+
+/**
+ * A callback function of this type is called to indicate a variety of events
+ * have occured that the Server Application may be interested in. This pointer
+ * may be NULL in which case no event delivery will be attempted.
+ *
+ * @param connectionId   Handle representing the connection to an FTP client
+ *
+ * @param event          Tagged Structure including the event, and whatever data
+ *                       that needs to be delivered with it.
+ */
+typedef void (*OI_FTP_SERVER_EVENT_IND)(OI_FTP_SERVER_CONNECTION_HANDLE connectionId,
+                                        const OI_FTP_SERVER_EVENT_DATA *event);
+
+typedef struct {
+    OI_FTP_CONNECTION_IND    connectInd;
+    OI_FTP_DISCONNECTION_IND disconnectInd;
+    OI_FTP_SERVER_EVENT_IND  eventInd;
+} OI_FTP_SERVER_CALLBACKS;
+
+/**
+ * This function is called by the application in response to a connnection
+ * indication that requires authentication.
+ *
+ * @param connectionId   Handle representing the connection to an FTP client
+ *
+ * @param password       NULL-terminated password
+ *
+ * @param readOnly       Indicates if the client is only being allowed read
+ *                       access; a client that is only granted read access cannot
+ *                       create, put, or delete files and folders
+ *
+ * @param allowBrowse    Indicates if the client is allowed to browse the file
+ *                       system; a client that is not permitted to browse can
+ *                       still get and put files from the root folder
+ *
+ */
+
+OI_STATUS OI_FTPServer_AuthenticationRsp(OI_FTP_SERVER_CONNECTION_HANDLE connectionId,
+                                         const OI_CHAR *password,
+                                         OI_BOOL readOnly,
+                                         OI_BOOL allowBrowse);
+
+
+ /**
+ * An application calls this function to accept or reject an indicated
+ * connection.
+ *
+ * @param connectionId   Handle representing the connection to an FTP client
+ *
+ * @param accept         TRUE if the connection is being accepted, FALSE
+ *                       otherwise; if FALSE, the values of the remaining
+ *                       parameters are ignored
+ *
+ * @param rootFolder     Implementation-dependent root folder for this
+ *                       connection
+ *
+ */
+
+OI_STATUS OI_FTPServer_AcceptConnection(OI_FTP_SERVER_CONNECTION_HANDLE connectionId,
+                                        OI_BOOL accept,
+                                        const OI_OBEX_UNICODE *rootFolder);
+
+
+/**
+ * This function forcibly severs the connection from an FTP client to the FTP server. This
+ * function should be called for all active connections before terminating the
+ * FTP server.
+ *
+ * @param connectionId  Handle representing the connection between a remote
+ *                      client and the local FTP server
+ *
+ * @return              OI_OK if the connection will be terminated
+ */
+
+OI_STATUS OI_FTPServer_ForceDisconnect(OI_FTP_SERVER_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * This function initialzes the FTP server to accept connections and registers
+ * it with the SDP database so that the service becomes discoverable.
+ *
+ * @param authentication Indicates whether connections to this
+ *                       server must be authenticated using OBEX authentication;
+ *                       if this parameter is FALSE, clients connecting to the
+ *                       server may demand authentication
+ *
+ * @param readOnly       Default access for unauthenticated clients; applies to
+ *                       all clients in authenticated == FALSE
+ *
+ * @param allowBrowse    Default browse permission for unauthenticated clients;
+ *                       applies to all clients if authentication == FALSE
+ *
+ * @param callbacks      Callback function pointers for Connect, Disconnect and
+ *                       Event Indication to server application
+ *
+ * @param fileOperations Interface to file system operations
+ *
+ * @param strings        Strings to register in the service record
+ *
+ * @param serverInstance [OUT] returns a handle for the FTP server instance. This handle
+ *                       is required to deregsiter the FTP server, see OI_FTPServer_Deregister().
+ *
+ * @return               OI_OK if the service was successfully registered
+ */
+
+OI_STATUS OI_FTPServer_Register(OI_OBEXSRV_AUTHENTICATION       authentication,
+                                OI_BOOL                         readOnly,
+                                OI_BOOL                         allowBrowse,
+                                const OI_FTP_SERVER_CALLBACKS  *callbacks,
+                                const OI_FTP_FILESYS_FUNCTIONS *fileOperations,
+                                const OI_SDP_STRINGS           *strings,
+                                OI_FTP_SERVER_HANDLE           *serverInstance);
+
+
+/**
+ * This function gets the service record handle associated with this service.
+ * For example, this can be used with OI_SDPDB_SetAttributeList to add
+ * vendor-specific SDP attributes to the profile.
+ *
+ * @param serverInstance   Identifies the registered server instance.
+ *
+ * @param handle           Returns the service record's handle
+ */
+OI_STATUS OI_FTPServer_GetServiceRecord(OI_FTP_SERVER_HANDLE serverInstance,
+                                        OI_UINT32 *handle);
+
+/**
+ * This function deregisters an FTP server.
+ *
+ * @param serverInstance  Specifies he server instance handle returned when the server was
+ *                        registered.
+ *
+ * @return                OI_OK if the service was successfully deregistered
+ *
+ */
+OI_STATUS OI_FTPServer_Deregister(OI_FTP_SERVER_HANDLE serverInstance);
+
+/**
+ * Accept/Reject incoming (PUT) object
+ *
+ * @param connectionId    The server connection handle that was returned when the server
+ *                        connection was opened.
+ *
+ * @param filename        pointer to obex filename to save incoming file to,
+ *                        or NULL to accept default incoming filename.
+ *
+ * @param accept          TRUE - Accept incoming file, FALSE - Reject
+ *
+ * @return                OI_OK if the rcvObject was successfuly opened for
+ *                        writing (or if rejecting).
+ *
+ */
+OI_STATUS OI_FTPServer_AcceptPut(OI_FTP_SERVER_CONNECTION_HANDLE connectionId,
+                                 OI_OBEX_UNICODE                *filename,
+                                 OI_BOOL                         accept);
+
+/**
+ * Request current directory level of the specified Server connection.
+ * This function is intended for the use of the File System Abstration.
+ *
+ * @param connectionId    The server connection handle that of the server-client
+ *                        connection being registered.
+ *
+ * @param folderLevel     [OUT] Location to return current folder level (0 == root)
+ *
+ * @return                OI_OK if connectionId is valid, and parameters are good
+ *                        OI_STATUS_INVALID_PARAMETERS otherwise
+ */
+OI_STATUS OI_FTPServer_GetFolderLevel(OI_FTP_SERVER_CONNECTION_HANDLE connectionId,
+                                      OI_UINT8                       *folderLevel);
+
+/**
+ * Request Root directory path of the specified Server connection.
+ * This function is intended for the use of the File System Abstration.
+ *
+ * @param connectionId    The server connection handle that was returned when the server
+ *                        connection was opened.
+ *
+ * @param rootFolder      [OUT] Location to return the pointer to the root Folder.
+ *
+ * @return                OI_OK if connectionId is valid, and parameters are good
+ *                        OI_STATUS_INVALID_PARAMETERS otherwise
+ *
+ */
+OI_STATUS OI_FTPServer_GetRootFolder(OI_FTP_SERVER_CONNECTION_HANDLE connectionId,
+                                     OI_OBEX_UNICODE               **rootFolder);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_FTP_SERVER_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_ftp_sys.h b/obex_profiles/sdk/include/profiles/oi_ftp_sys.h
new file mode 100644
index 0000000..6fa731f
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_ftp_sys.h
@@ -0,0 +1,489 @@
+#ifndef _OI_FTP_SYS_H
+#define _OI_FTP_SYS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ @file
+
+ File system abstraction layer used by the the File Transfer Profile client and
+ server.
+
+ This interface is described entirely as callback functions. The application
+ must provide the appropriate sets of functions to the FTP client and FTP server
+ when initializing these two services. An Bluetooth compliant implementation of
+ an FTP server must return certain specific error codes to report various
+ operation failure modes. Please refer to the Windows and/or Linux
+ implementations of these functions for more information.
+
+
+ Callbacks and errors are mutually exclusive.  If you invoke a
+ callback from one of the functions below, that function must return
+ OI_OK.  If you do not invoke a callback, the function must return an
+ error message.  Note that if you wish your application to be
+ BQB-compliant, you should generate error codes consistent with
+ BLUEmagic 3.0 best practices; see the sample code for examples.
+
+*/
+
+#include "oi_status.h"
+#include "oi_stddefs.h"
+#include "oi_obex.h"
+#include "oi_obexspec.h"
+
+/** \addtogroup FTP FTP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+typedef OI_OBEX_CONNECTION_HANDLE OI_FTP_CONNECTION;
+
+typedef enum {
+    OI_FTP_MODE_READ,  /**< open a file for reading */
+    OI_FTP_MODE_WRITE  /**< open a file for writing */
+} OI_FTP_MODE;
+
+
+typedef void* OI_FTP_HANDLE;
+
+
+/* ********************************************************************************
+ * The file and folder functions are all asynchronous. However implementations
+ * are permitted to call the callback function from within the function if the
+ * file operation can be completed quickly. This will be the case for many
+ * implementations.
+ * ********************************************************************************/
+
+
+
+
+/**
+ * A function of this type is called to confirm the success or failure of a
+ * folder browse operation and return a handle that can be used to read the
+ * folder contents. The folder contents can be read as a file and the handle
+ * will be closed when the contents have been read.
+ *
+ * @param handle         A handle that can be used to read the folder contents.
+ *                       The folder contents are returned as XML as defined by
+ *                       the OBEX specification.  The handle must not be NULL.
+ *
+ * @param size           The total size of the XML representation of the folder contents
+ *
+ * @param status         OI_OK if the folder could be opened for browsing or an
+ *                       error if the folder could not be opened.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ */
+
+typedef void (*OI_FTP_BROWSE_FOLDER_CFM)(OI_FTP_HANDLE handle,
+                                         OI_UINT32 size,
+                                         OI_STATUS status,
+                                         OI_FTP_CONNECTION ftpConnection);
+
+/**
+ * This function and corresponding callback is only needed by an FTP server.
+ *
+ * Open a handle to read the contents of a folder.
+ *
+ * The folder contents can read from the handle like a file.
+ * The handle will be closed when the contents have been read.
+ *
+ * @param name             The unicode name for the folder or NULL. If not null
+ *                         the folder must be a subfolder of the current folder.
+ *
+ * @param folderBrowseCfm  The function that will be called when the folder
+ *                         contents are available to be read.
+ *
+ * @param ftpConnection    identifies which FTP client or server connection is
+ *                         performing this operation.
+ */
+
+typedef OI_STATUS (*OI_FTP_BROWSE_FOLDER)(const OI_OBEX_UNICODE *name,
+                                          OI_FTP_BROWSE_FOLDER_CFM folderBrowseCfm,
+                                          OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * A function of this type is called to confirm the success or failure of a file
+ * open.
+ *
+ * @param handle        A handle that can be used to read the file contents.
+ *                      The handle must not be NULL.
+ *
+ * @param size          If the file was opened for reading size is the number of
+ *                      bytes that can be read from the file. If the file was
+ *                      opened for writing the value is undefined.
+ *
+ * @param status         OI_OK if the folder could be opened with the required
+ *                       mode or an error if the file could not be opened.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ */
+
+typedef void (*OI_FTP_OPEN_CFM)(OI_FTP_HANDLE handle,
+                                OI_UINT32 size,
+                                OI_STATUS status,
+                                OI_FTP_CONNECTION ftpConnection);
+
+/**
+ * This function and corresponding callback is needed by an FTP client and server.
+ *
+ * @param name           a unicode string name of the file to be opened.
+ *
+ * @param mode           indicates if the file is being opened for read or write
+ *                       access.
+ *
+ * @param openCfm        the function that will be called when the open
+ *                       completes.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ */
+
+typedef OI_STATUS (*OI_FTP_OPEN)(const OI_OBEX_UNICODE *name,
+                                 OI_FTP_MODE mode,
+                                 OI_FTP_OPEN_CFM openCfm,
+                                 OI_FTP_CONNECTION ftpConnection);
+
+/**
+ * This function does not use a callback function. It is assumed that file
+ * close will complete asynchronously or in the case of a failure will report or
+ * log an error with the application.
+ *
+ * @param handle         a handle for an open file.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ *
+ * @param status         OI_OK if the file operation completed succesfully. An
+ *                       error status if the file operation terminated before it
+ *                       was complete.
+ */
+
+typedef void (*OI_FTP_CLOSE)(OI_FTP_HANDLE handle,
+                             OI_FTP_CONNECTION ftpConnection,
+                             OI_STATUS status);
+
+/**
+ * A function of this type is called to confirm the success or failure of a file
+ * read.
+ *
+ * @param data           a pointer to a buffer containing the data read.
+ *
+ * @param len            the number of bytes read.
+ *
+ * @param status         a status code indicating if the read was succesful:
+ *                       - OI_OK if the read completed
+ *                       - OI_STATUS_END_OF_FILE if the read was successful and the
+ *                         end of file has been reached.
+ *                       - An error status indicating that the read failed.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ *
+ */
+
+typedef void (*OI_FTP_READ_CFM)(OI_FTP_HANDLE handle,
+                                OI_BYTE *data,
+                                OI_UINT16 len,
+                                OI_STATUS status,
+                                OI_FTP_CONNECTION ftpConnection);
+
+/**
+ * This function and corresponding callback is needed by an FTP client and server.
+ *
+ * @param handle         a handle previously returned by an OI_FTP_OPEN_CFM
+ *                       function
+ *
+ * @param maxRead        the maximum number of bytes to read from the file on
+ *                       this call.
+ *
+ * @param readCfm        the function that will be called when the read
+ *                       completes.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ */
+
+typedef OI_STATUS (*OI_FTP_READ)(OI_FTP_HANDLE handle,
+                                 OI_UINT16 maxRead,
+                                 OI_FTP_READ_CFM readCfm,
+                                 OI_FTP_CONNECTION ftpConnection);
+
+/**
+ * A function of this type is called to confirm the success or failure of a
+ * file write operation.
+ *
+ * @param handle         a handle previously returned by an OI_FTP_OPEN_CFM
+ *                       function
+ *
+ * @param status         indicates the success or failure of the write
+ *                       operation.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ */
+
+typedef void (*OI_FTP_WRITE_CFM)(OI_FTP_HANDLE handle,
+                                 OI_STATUS status,
+                                 OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * This function and corresponding callback is needed by an FTP client and server.
+ *
+ * @param handle         a handle previously returned by an OI_FTP_OPEN_CFM
+ *                       function
+ *
+ * @param buffer         a pointer to a buffer containing the data to be written
+ *                       to the file
+ *
+ * @param bufLen         the number of bytes to write to the file on this call.
+ *
+ * @param writeCfm       the function that will be called when the write
+ *                       completes.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ */
+
+typedef OI_STATUS (*OI_FTP_WRITE)(OI_FTP_HANDLE handle,
+                                  const OI_BYTE *buffer,
+                                  OI_UINT16 bufLen,
+                                  OI_FTP_WRITE_CFM writeCfm,
+                                  OI_FTP_CONNECTION ftpConnection);
+
+/**
+ * A function of this type is called to confirm the success or failure of a file
+ * or folder delete operation.
+ *
+ * @param status         a status code indicating if the delete was successful.
+ *                       If the delete was for a folder and the folder could not
+ *                       be deleted because it was not empty the status returned
+ *                       should be OI_OBEX_PRECONDITION_FAILED.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ */
+
+
+typedef void (*OI_FTP_DELETE_CFM)(OI_STATUS status,
+                                  OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * This function and corresponding callback is only needed by an FTP server.
+ *
+ * @param name           a unicode string name of the file or folder to be
+ *                       deleted.
+
+ * @param deleteCfm      the function that will be called when the open
+ *                       completes.
+ *
+ * @param ftpConnection  identifies which FTP client or server connection is
+ *                       performing this operation.
+ */
+typedef OI_STATUS (*OI_FTP_DELETE)(const OI_OBEX_UNICODE *name,
+                                   OI_FTP_DELETE_CFM deleteCfm,
+                                   OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * A function of this type is called to confirm the success or failure of a set
+ * folder operation.
+ *
+ * @param status Indicates the success or failure of the set folder operation.
+ *
+ * @param ftpConnection    identifies which FTP client or server connection is
+ *                         performing this operation.
+ */
+typedef void (*OI_FTP_SET_FOLDER_CFM)(OI_STATUS status,
+                                      OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * This function sets the current folder.
+ *
+ * @param folder        Unicode folder name or NULL. If the folder name is NULL
+ *                      the folder is set to the parent folder of the current
+ *                      folder.
+ *
+ * @param level         Level in the folder hierarchy, 0 means the root folder.
+ *
+ * @param create        If TRUE and the folder does not exist create a new
+ *                      folder with that name. Then change to that directory.
+ *
+ * @param ftpConnection identifies which FTP client or server connection is
+ *                      performing this operation.
+ */
+typedef OI_STATUS (*OI_FTP_SET_FOLDER)(const OI_OBEX_UNICODE *folder,
+                                       OI_UINT8 level,
+                                       OI_BOOL create,
+                                       OI_FTP_SET_FOLDER_CFM setFolderCfm,
+                                       OI_FTP_CONNECTION ftpConnection);
+
+
+
+/**
+ * A function of this type is called to confirm the success or failure of a rename
+ *
+ * @param status Indicates the success or failure of the rename operation.
+ */
+typedef void (*OI_FTP_RENAME_CFM)(OI_STATUS status,
+                                  OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * This function renames or moves a file or folder
+ *
+ * @param name     The unicode name of the file or folder to rename.
+ *
+ * @param newName  The new name of the file or folder.
+ *
+ */
+typedef OI_STATUS (*OI_FTP_RENAME)(const OI_OBEX_UNICODE *name,
+                                   const OI_OBEX_UNICODE *newName,
+                                   OI_FTP_RENAME_CFM renameCfm,
+                                   OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * A function of this type is called to confirm the success or failure of a file or folder copy.
+ *
+ * @param status Indicates the success or failure of the copy operation.
+ */
+typedef void (*OI_FTP_COPY_CFM)(OI_STATUS status,
+                                OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * This function copies a file or recursively copies a folder and its contents.
+ *
+ * @param srcName     The unicode name of the file or folder to copy.
+ *
+ * @param destName    The destination file or folder.
+ */
+typedef OI_STATUS (*OI_FTP_COPY)(const OI_OBEX_UNICODE *srcName,
+                                 const OI_OBEX_UNICODE *destName,
+                                 OI_FTP_COPY_CFM copyCfm,
+                                 OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * A function of this type is called to confirm the success or failure of setting permissions.
+ *
+ * @param status Indicates the success or failure of the set permission operation.
+ */
+typedef void (*OI_FTP_SET_PERMISSION_CFM)(OI_STATUS status,
+                                          OI_FTP_CONNECTION ftpConnection);
+
+
+/**
+ * This function sets the access permissions on a file or folder.
+ *
+ * @param name             The unicode name of the file or folder to set permissions on.
+ *
+ * @param groupPermission  Group permission bits as defined in oi_obexpec.h
+ *
+ * @param userPermission   User permission bits as defined in oi_obexpec.h
+ *
+ * @param otherPermission  Other permission bits as defined in oi_obexpec.h
+ */
+typedef OI_STATUS (*OI_FTP_SET_PERMISSION)(const OI_OBEX_UNICODE *name,
+                                           OI_UINT8 groupPermission,
+                                           OI_UINT8 userPermission,
+                                           OI_UINT8 otherPermission,
+                                           OI_FTP_SET_PERMISSION_CFM setPermissionCfm,
+                                           OI_FTP_CONNECTION ftpConnection);
+
+
+
+/**
+ * Structure for returning option information for the file system abstraction layer
+ */
+typedef struct {
+    OI_CHAR16 folderSeparator; /**< Folder separator character */
+    OI_BOOL setpathDoesChdir;  /**< TRUE if the setpath operation does a chdir */
+} OI_FTP_FILESYS_OPTIONS;
+
+
+/**
+ * This function get the option information from the file system layer. If this functio is not
+ * present the default options are:
+ *
+ *    folderSeparator = <undefined>
+ *    numServer = 1
+ *    numClients = 1
+ *    setpathDoesChdir = TRUE
+ *
+ * @param options  Pointer to a options structure
+ */
+typedef void (*OI_FTP_GET_OPTIONS)(OI_FTP_FILESYS_OPTIONS *options);
+
+
+/* ********************************************************************************
+ *
+ *                             File operations
+ *
+ * ********************************************************************************/
+
+/**
+  This structure defines the file system functions.
+  */
+typedef struct {
+
+    OI_FTP_BROWSE_FOLDER   browseFolder;
+    OI_FTP_OPEN            open;
+    OI_FTP_CLOSE           close;
+    OI_FTP_READ            read;
+    OI_FTP_WRITE           write;
+    OI_FTP_DELETE          deleteItem;
+    OI_FTP_SET_FOLDER      setFolder;
+    OI_FTP_RENAME          rename;
+    OI_FTP_COPY            copy;
+    OI_FTP_SET_PERMISSION  setPermission;
+    OI_FTP_GET_OPTIONS     getOptions;
+
+} OI_FTP_FILESYS_FUNCTIONS;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_FTP_SYS_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_obex.h b/obex_profiles/sdk/include/profiles/oi_obex.h
new file mode 100644
index 0000000..308090c
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_obex.h
@@ -0,0 +1,115 @@
+#ifndef _OI_OBEX_H
+#define _OI_OBEX_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ @file
+ This file contains typedefs required by all OBEX profiles..
+ */
+
+#include "oi_bt_assigned_nos.h"
+#include "oi_stddefs.h"
+#include "oi_debug.h"
+#include "oi_status.h"
+#include <hardware/bluetooth.h>
+#include <hardware/bt_sock.h>
+
+/** \addtogroup OBEX */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Opaque type for an OBEX connection (client or server)
+ */
+typedef OI_HANDLE OI_OBEX_CONNECTION_HANDLE;
+
+
+/**
+ * Opaque type for an OBEX server instance
+ */
+typedef OI_HANDLE OI_OBEX_SERVER_HANDLE;
+
+
+/**
+ * Lower layer protocols identifiers for OBEX (mapped to the 16 bit UUID values)
+ */
+typedef enum {
+    OI_OBEX_LOWER_NONE   = 0,
+    OI_OBEX_LOWER_RFCOMM = OI_UUID_RFCOMM,
+    OI_OBEX_LOWER_L2CAP  = OI_UUID_L2CAP,
+    OI_OBEX_LOWER_TCPIP  = OI_UUID_TCP
+} OI_OBEX_LOWER_PROTOCOL_ID;
+
+
+/**
+ * Options to be used for an OBEX connection
+ */
+typedef struct {
+    OI_BOOL enableSRM;       /**< TRUE is single response mode is to be enabled for this connection */
+} OI_OBEX_CONNECTION_OPTIONS;
+
+
+/**
+ * Tagged union for the different lower layer protocol service identifiers.
+ */
+typedef struct {
+    OI_OBEX_LOWER_PROTOCOL_ID protocol; /**< The lower layer protocol for the OBEX service */
+    union {
+        OI_UINT8 rfcommChannel;         /**< The channel number if the lower protocol is RFCOMM */
+        OI_UINT16 l2capPSM;             /**< The PSM if the lower protocol is L2CAP */
+        void *ipAddress;                /**< The IP address and port is the lower protocol is TCP/IP */
+    } svcId;
+} OI_OBEX_LOWER_PROTOCOL;
+
+#ifdef OI_DEBUG
+/**
+ * Returns a string describing the lower protocol for an OBEX server
+ */
+OI_CHAR* OI_OBEX_LowerProtocolTxt(OI_OBEX_LOWER_PROTOCOL *lowerProtocol);
+#else
+#define OI_OBEX_Lower_ProtocolTxt "lower-protocol"
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* _OI_OBEX_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_obex_sd.h b/obex_profiles/sdk/include/profiles/oi_obex_sd.h
new file mode 100644
index 0000000..114d85d
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_obex_sd.h
@@ -0,0 +1,118 @@
+#ifndef _OI_OBEX_SD_H
+#define _OI_OBEX_SD_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides the API for a service discovery helper function that gets the information
+ * required by an OBEX client to establish a connection to a remote OBEX server.
+ *
+ */
+
+#include "oi_common.h"
+#include "oi_status.h"
+#include "oi_obex.h"
+
+/** \addtogroup OBEX OBEX APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+#define OI_OBEX_SD_QUERY_MAX_PROTOCOLS         3
+
+/**
+ * This structure includes the device address and service UUID fields that are filled in by the
+ * caller, then OI_OBEX_SD_Query() is called. When the query completes successfully, the protocols
+ * list is filled in.
+ */
+
+typedef struct {
+    OI_BD_ADDR devAddr;                                               /**< Bluetooth device address of the device with the SDP database */
+    OI_UUID32 serviceUUID;                                            /**< UUID identifying the service to query for */
+    OI_OBEX_LOWER_PROTOCOL protocols[OI_OBEX_SD_QUERY_MAX_PROTOCOLS]; /**< A list of protocols and protocol specific link information */
+    OI_UINT8 numProtocols;                                            /**< The number of protocols supported */
+    OI_UINT16 profileVersion;                                         /**< The profile version number */
+} OI_OBEX_SD_INFO;
+
+
+/**
+ * A callback function of this type is called to return the result of the service database query.
+ *
+ * @param query        Pointer to the structure containing return parameters.  This is the same structure
+ *                      that was originally passed to OI_OBEX_SD_Query().
+ *
+ * @param status       OI_OK if query successful; failure code otherwise
+ */
+
+typedef void (*OI_OBEX_SD_QUERY_RESPONSE_CB)(OI_OBEX_SD_INFO *query,
+                                            OI_STATUS status);
+
+/**
+ * This function issues a query to an Service Discovery Protocol database of services
+ * in order to obtain information about an OBEX service.
+ *
+ * To use an OBEX service registered in the SDP database, a client application needs to know lower
+ * layer protocol (RFCOMM, L2CAP, etc) information for the service. This helper function composes
+ * the appropriate SDP request to obtain this information for a service identified by its UUID. The
+ * service name and service description are also retrieved by this function.
+ *
+ * @param preferred     The preferred protocol. The query reponses will be sorted so that the
+ *                      preferred protocol entries appear first in the list.
+ *
+ * @param query         Pointer to the structure containing the inquiry parameters
+ *                      (Bluetooth device address and service UUID)
+ *                      @note   Since the query process fills in structure elements, this
+ *                              structure must persist at least until the queryRsp callback is called.
+ *
+ * @param queryRsp      The callback function that will be called when the inquiry has completed
+ *
+ * @return              OI_OK if the query was sumbitted successfully; failure code otherwise
+ *
+ */
+OI_STATUS OI_OBEX_SD_Query(OI_OBEX_LOWER_PROTOCOL_ID preferred,
+                           OI_OBEX_SD_INFO *query,
+                           OI_OBEX_SD_QUERY_RESPONSE_CB queryRsp);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_OBEX_SD_H */
+
diff --git a/obex_profiles/sdk/include/profiles/oi_obexcli.h b/obex_profiles/sdk/include/profiles/oi_obexcli.h
new file mode 100644
index 0000000..eb5ebda
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_obexcli.h
@@ -0,0 +1,614 @@
+#ifndef _OI_OBEXCLI_H
+#define _OI_OBEXCLI_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @file
+ This file provides the API for the OBEX (GOEP) client
+*/
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_obex.h"
+#include "oi_obexspec.h"
+#include "oi_connect_policy.h"
+#include "oi_bt_profile_config.h"
+
+/** \addtogroup OBEX */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/**
+ *  represents an active connection to a remote OBEX server
+ */
+
+typedef OI_OBEX_CONNECTION_HANDLE OI_OBEXCLI_CONNECTION_HANDLE;
+
+
+/**
+ * OBEX client required authentication
+ */
+
+typedef enum {
+    OI_OBEXCLI_AUTH_NONE = 0,
+    OI_OBEXCLI_AUTH_PASSWORD,
+    OI_OBEXCLI_AUTH_USERID_AND_PASSWORD
+} OI_OBEXCLI_AUTHENTICATION;
+
+/**
+ * A callback function of this type is called when an OBEX connection request completes.
+ * The status code indicates if the connection was established.
+ *
+ * @param connectionId   a unique ID that represents a connection to an OBEX server
+ *
+ * @param readOnly       if TRUE, indicates that the server is only granting read access
+ *                       to the server's resources to this client. Access rights
+ *                       are only passed  on authenticated connections so this
+ *                       parameter will only ever be TRUE for authenticated
+ *                       connections. A FALSE value does not necessarily mean
+ *                       that the client has write access to the server.
+ *
+ * @param status         OI_OK if successful; error status if the connection attempt failed
+ *
+ */
+
+typedef void (*OI_OBEXCLI_CONNECT_CFM)(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                       OI_BOOL readOnly,
+                                       OI_STATUS status);
+
+/**
+ * A callback function of this type is called when an OBEX disconnect request completes,
+ * whether requested by a call to OI_OBEXCLI_Disconnect() or because the connection was dropped.
+ *
+ * @param connectionId  the (now invalid) connection to an OBEX server
+ */
+
+typedef void (*OI_OBEXCLI_DISCONNECT_IND)(OI_OBEXCLI_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * A callback function of this type is registered by OI_OBEXCLI_Put() and called when OBEX is ready for
+ * more data to put.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param rspHeaders      This parameter is a pointer to a list of OBEX headers received from the
+ *                        OBEX server. Storage for rspHeaders is allocated by OBEX and must not be
+ *                        freed by the caller. The caller should copy any data that is needed after
+ *                        this function returns into a local buffer.
+ *
+ * @param status          OI_OK if the put transaction is complete.
+ *                        OI_OBEX_CONTINUE if the application is being asked for more data to put;
+ *                        OI_OBEX_NOT_READY if the put is incomplete and OBEX is not ready for
+ *                        more data.
+ *                        or an error status indicating that the transaction has been canceled and why
+ */
+
+typedef void (*OI_OBEXCLI_PUT_CFM)(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                   OI_OBEX_HEADER_LIST *rspHeaders,
+                                   OI_STATUS status);
+
+
+/**
+ * A callback function of this type is registered by OI_OBEXCLI_BulkPut() and called when OBEX has
+ * put one or more bulk data buffers and is no longer using these buffers.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param numBuffers      The number of buffers being confirmed by this call.
+ *
+ * @param bulkDataBuffer  This parameter is an array of pointers to data buffers that are not longer
+ *                        being used by OBEX. Memory for these buffers was allocated by the caller
+ *                        to OI_OBEXCLI_BulkPut() and can now be freed or reused by the caller.
+ *
+ * @param bufferLen       This parameter is an array of lengths of data buffers being returned.
+ *
+ * @param status        - OI_OK if the PUT transaction has sucesfully completed.
+ *                      - OI_OBEX_CONTINUE if the PUT transaction is incomplete and the
+ *                        application is permitted to put more data immediately.
+ *                      - Error status code indicating that the PUT transaction is canceled.
+ */
+
+typedef void (*OI_OBEXCLI_BULK_PUT_CFM)(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                        OI_UINT8 numBuffers,
+                                        OI_UINT8 *bulkDataBuffer[],
+                                        OI_UINT32 bufferLen[],
+                                        OI_STATUS status);
+
+/**
+ * A callback function of this type is called when an OBEX get request returns data.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param rspHeaders      This parameter is a pointer to a list of OBEX headers received from the
+ *                        OBEX server. Storage for rspHeaders is allocated by OBEX and must not be
+ *                        freed by the caller. The caller should copy any data that is needed after
+ *                        this function returns into a local buffer.
+ *
+ * @param status          OI_OK if the put transaction is complete (if this is the last block of data);
+ *                        OI_OBEX_CONTINUE if the application is being asked for more data to put;
+ *                        or an error status indicating that the transaction has been canceled and why
+ */
+
+typedef void (*OI_OBEXCLI_GET_RECV_DATA)(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                         OI_OBEX_HEADER_LIST *rspHeaders,
+                                         OI_STATUS status);
+
+
+/**
+ * A callback function of this type is called when a setpath command completes.
+ *
+ * @param connectionId   This parameter is a unique ID that represents an established connection
+ *                       to an OBEX server.
+ *
+ * @param status         OI_OK if the setpath operation succeeded; otherwise, error status indicating why the operation failed
+ */
+
+typedef void (*OI_OBEXCLI_SETPATH_CFM)(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                       OI_STATUS status);
+
+
+/**
+ * A callback function of this type is called when an action command completes.
+ *
+ * @param connectionId   This parameter is a unique ID that represents an established connection
+ *                       to an OBEX server.
+ *
+ * @param status         OI_OK if the action operation succeeded; otherwise, error status indicating why the operation failed
+ */
+
+typedef void (*OI_OBEXCLI_ACTION_CFM)(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                      OI_STATUS status);
+
+
+/**
+ * A callback function of this type is made to the application to request a password and optional user id
+ * if OBEX authentication is required on connections from this client.
+ *
+ * @param connectionId     a unique ID that represents the in-progress connection
+ *
+ * @param userIdRequired   depending on the calling context indicates either:
+ *                          - that the server requested a user id as well
+ *                            as a password. The client can provide a user id even
+ *                            if the server does not require one. Whether the server
+ *                            actually makes use of the user id in this case
+ *                            depends entirely on the server implementation.
+ *                          or
+ *                          - that the client requires a user id to authorize the server
+ *                            in client-initiated authentication scenario.
+ *
+ * @param realm            Indicates the OBEX server's realm for the password or NULL
+ */
+typedef void (*OI_OBEXCLI_AUTH_CHALLENGE_IND)(OI_OBEXCLI_CONNECTION_HANDLE  connectionId,
+                                              OI_BOOL                       userIdRequired,
+                                              OI_OBEX_REALM                 *realm);
+
+
+/**
+ * A callback function of this type can be registered when a connection is establishe to allow an
+ * upper layer to monitor progress of PUT and GET operations.
+ *
+ * @param connectionId     a unique ID that rep2Yesents the in-progress connection
+ *
+ * @param obexCmd          Indicates if this is a put (OI_OBEX_CMD_PUT) or a get (OI_OBEX_CMD_GET)
+ *
+ * @param progressBytes    A running count of the number or bytes transferred.
+ */
+typedef void (*OI_OBEXCLI_PROGRESS_IND)(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                        OI_UINT8 obexCmd,
+                                        OI_UINT32 progressBytes);
+
+
+
+
+/**
+ * A callback function of this type is called when an OBEX abort request completes.
+ *
+ * @param connectionId  a unique ID that represents the in-progress connection
+ */
+typedef void (*OI_OBEXCLI_ABORT_CFM)(OI_OBEXCLI_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * This function handles authentication data to generate authentication challenge and/or response
+ * in connection request. A NULL password indicates that the application is rejecting the authentication challenge.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param userId          A user id must be provided if the server indicated
+ *                        that user ids are required in the authentication
+ *                        challenge. A client can provide a user id even if the
+ *                        server does not required one.
+ *
+ * @param userIdLen       The actual length of the user id.
+ *
+ * @param password        a NULL-terminated password string.
+ *
+ * @param realm           Indicates the Client's realm to be sent to server in Client's
+ *                        authentication challenge or NULL
+ *
+ * @return                OI_OK if successful or error status if this function
+ *                        failed or was called at the wrong time.
+ */
+OI_STATUS OI_OBEXCLI_Authentication(OI_OBEXCLI_CONNECTION_HANDLE    connectionId,
+                                    const OI_BYTE                   *userId,
+                                    OI_UINT8                        userIdLen,
+                                    const OI_CHAR                   *password,
+                                    const OI_OBEX_REALM             *realm);
+
+typedef struct {
+    OI_OBEXCLI_CONNECT_CFM connectCfmCB;              /**< Callback function called when the connection has been established */
+    OI_OBEXCLI_DISCONNECT_IND disconnectIndCB;        /**< Callback function called when the OBEX connection is disconnected */
+    OI_OBEXCLI_AUTH_CHALLENGE_IND authChallengeIndCB; /**< callback function called if a response to an authentication challenge is required */
+    OI_OBEXCLI_PROGRESS_IND progressIndCB;            /**< Callback function called to monitor progress of PUTs and GETS, can be NULL */
+    OI_OBEXCLI_BULK_PUT_CFM bulkPutCfm;               /**< Callback function called to confirm one or more bulk puts. */
+} OI_OBEXCLI_CB_LIST;
+
+
+
+/**
+ * This function establishes a connection to an OBEX server. This includes setting up a lower layer
+ * connection to the OBEX server.
+ *
+ * @param addr            Pointer to the Bluetooth device address of the OBEX server device
+ *
+ * @param loweProtocol    Specifies the lower layer protocol for the OBEX server and the
+ *                        information required to connect to that server.
+ *
+ * @param authentication  Specifies whether authentication is required when
+ *                        connecting to a server
+ *
+ * @param connectOptions  OBEX options for this connection. Can be NULL if no options are being
+ *                        specified.
+ *
+ * @param cmdHeaders      This is a pointer to a list of optional OBEX headers to be included in the
+ *                        connect request. This parameter can be NULL if there are no optional headers.
+ *                        The caller must not free any data referenced by these headers until the
+ *                        receiving the connect confirmation callback.
+ *
+ * @param callbacks       Callback functions for the OBEX client connection.
+ *
+ * @param connectionId    (OUT) pointer to the location to which a handle to the OBEX connection will be written
+ *                         once the connection is established
+ *
+ * @param policy          The connection policy required by the OBEX client, NULL is not permitted
+ *
+ * @return                OI_OK if successful or error status if the connect request failed
+ */
+OI_STATUS OI_OBEXCLI_Connect(OI_BD_ADDR *addr,
+                             OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                             OI_OBEX_CONNECTION_OPTIONS *connectOptions,
+                             OI_OBEXCLI_AUTHENTICATION authentication,
+                             const OI_OBEX_HEADER_LIST *cmdHeaders,
+                             const OI_OBEXCLI_CB_LIST *callbacks,
+                             OI_OBEXCLI_CONNECTION_HANDLE *connectionId,
+                             const OI_CONNECT_POLICY *policy);
+
+
+/**
+ * This function disconnects from an OBEX server.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param cmdHeaders      This is a pointer to a list of optional OBEX headers to be included in the
+ *                        command. This parameter can be NULL if there are no optional headers.
+ *                        The caller must not free any data referenced by these headers until the
+ *                        receiving the response callback.
+ *
+ * @return                OI_OK if the disconnect request could be sent
+ */
+OI_STATUS OI_OBEXCLI_Disconnect(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                const OI_OBEX_HEADER_LIST    *cmdHeaders);
+
+
+/**
+ * Put OBEX headers to an OBEX server. The putCfm() callback indicates that the server
+ * has received and acknowledged receipt of the headers.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param cmdHeaders      the headers being put. The memory allocated by the caller for these
+ *                        headers cannot be freed until the putCfm callback is called.
+ *
+ * @param putCfm          callback function called to confirm that the put operation has
+ *                        completed and the server has acknowedged receipt of the headers
+ *
+ * @param status          Status code to tell obex what is being put.
+ *                        - OI_OK indicates this is the final put,
+ *                        - OI_OBEX_CONTINUE if there are more puts to come
+ *                        - OI_STATUS_INVALID_STATE if OI_OBEXCLI_BulkPut() has been called.
+ *                        - An error status to terminate the put operation.
+ *
+ * @return                OI_OK if put complete, OI_OBEX_OPERATION_IN_PROGRESS if the last request has not
+ *                        completed, or other errors from lower protocol layers.
+ */
+OI_STATUS OI_OBEXCLI_Put(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                         OI_OBEX_HEADER_LIST const *cmdHeaders,
+                         OI_OBEXCLI_PUT_CFM putCfm,
+                         OI_STATUS status);
+
+
+/**
+ * Send bulk data to an OBEX server. If used, this function is called following an initial
+ * OI_OBEXCLI_Put() to send the body data for the put transaction. Unlike OI_OBEXCLI_Put() which
+ * does not permit another Put until the putCfm callback is called, multiple OI_OBEXCLI_BulkPut()
+ * calls an be made and OBEX will queue the data internally. This is of most value when the
+ * connection has been configured for single response mode because it allows OBEX to keep data
+ * flowing. The bulkPutCfm() callback is called as each bulk data buffer has been sent to the
+ * server. For a specific PUT transaction, once OI_OBEXCLI_BulkPut() has been called, the
+ * transaction must be completed using OI_OBEXCLI_BulkPut() calls.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection to
+ *                        a remote OBEX server.
+ *
+ * @param numBuffers      The number of buffer to put.
+ *
+ * @param bulkDataBuffer  An array of bulk data buffers to be put. The data buffers must not be freed
+ *                        until the buffer pointers are individually returned in the bulkPutCfm callback.
+ *
+ * @param bufferLength    An array of sizes for the bulk data buffers. The bulk data buffers are combined and
+ *                        segmented internally into appropriately sized OBEX packets so this value
+ *                        can be arbitrarily large or small.
+ *
+ * @param status          Status code to tell obex what is being put.
+ *                        - OI_OK indicates this is the final put call,
+ *                        - OI_OBEX_CONTINUE if there are more bulk data puts to come
+ *                        - An error status to terminate the bulk put operation.
+ *
+ * @return                OI_OK if put was successful but no more puts are permitted at this time.
+ *                        OI_OBEX_CONTINUE if the put was successful and more puts are permitted.
+ *
+ *                        or other errors indicating that the put operation failed and that the
+ *                        caller should cleanup and disconnect the link.
+ */
+OI_STATUS OI_OBEXCLI_BulkPut(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                             OI_UINT8 numBuffers,
+                             OI_UINT8 *bulkDataBuffer[],
+                             OI_UINT32 bufferLength[],
+                             OI_STATUS status);
+
+
+/**
+ * Get data from an OBEX server. This will cause one or more packets to be
+ * retrieved from an OBEX server.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param cmdHeaders      description of the object being requested.
+ *
+ * @param getRecvData     function that will be invoked when data is received from the server
+ *
+ * @param final           TRUE if this is the last packet in the get request,
+ *                        FALSE otherwise. Most get requests are only one packet long, and should have
+ *                        this parameter set to TRUE.
+ *
+ * @return                OI_OK if get successful, OI_OBEX_OPERATION_IN_PROGRESS
+ *                        if the last request has not completed, or other errors from lower layers.
+ */
+OI_STATUS OI_OBEXCLI_Get(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                         OI_OBEX_HEADER_LIST const *cmdHeaders,
+                         OI_OBEXCLI_GET_RECV_DATA getRecvData,
+                         OI_BOOL final);
+
+
+/**
+ * Terminates the current put or get operation on this connection. If there is no current GET/PUT
+ * operation this function returns OI_STATUS_INVALID_STATE. If a PUT/GET transaction is in progress,
+ * i.e. the calling layer has called OI_OBEXCLI_Get, OI_OBEXCLI_Put, or OI_OBEXCLI_BulkPut, and is
+ * waiting for a confirm callback, when the transaction completes the appropriate callback is called
+ * with status OI_OBEX_CLIENT_ABORTED_COMMAND. The abort confirm callback will be called when the
+ * remote OBEX server confirms that the abort is complete.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an
+ *                        established connection to an OBEX server.
+ *
+ * @param abortCfm        function that will be invoked when the abort completes.
+ *
+ * @retval                OI_OK if the operation was aborted.
+ * @retval                OI_STATUS_INVALID_STATE if there is nothing to abort
+ */
+OI_STATUS OI_OBEXCLI_Abort(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                           OI_OBEXCLI_ABORT_CFM         abortCfm);
+
+
+/**
+ * Set the response timeout for an OBEX connection overriding the internal
+ * default timeout. The timeout value indicates how long the OBEX client will
+ * wait for a response from an OBEX server before aborting a PUT, GET or other
+ * OBEX operation.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an
+ *                        established connection to an OBEX server.
+ *
+ * @param timeout         The timeout is specified in 1/10's of seconds. A
+ *                        timeout of 0 is not allowed.
+ *
+ * @return                OI_OK if the connectionId and timeout value was valid.
+ */
+OI_STATUS OI_OBEXCLI_SetResponseTimeout(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                        OI_INTERVAL timeout);
+
+/**
+ * Setpath can be used to set the current folder for getting and putting
+ * objects and can be used to create new folders.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param folder          This parameter is a unicode name specifying the new folder.
+ *                        This must be NULL if upLevel is TRUE. A NULL folder
+ *                        (and upLevel == FALSE) sets the folder to the FTP
+ *                        server's root folder.
+ *
+ * @param dontCreate      This parameter indicates whether a new folder should be created if it does not already exist.
+ *                        A value of TRUE indicates that the specified folder should not be created if it does not already exist.
+ *
+ * @param upLevel         This parameter indicates that the path is to be set to the parent folder of
+ *                        the current folder. If upLevel is TRUE, folder must be NULL.
+ *
+ * @param                 setpathCfm is the callback function called with the server's response to the setpath command.
+ *
+ * @param cmdHeaders      This is a pointer to a list of optional OBEX headers to be included in the
+ *                        command. This parameter can be NULL if there are no optional headers.
+ *                        The caller must not free any data referenced by these headers until the
+ *                        receiving the response callback.
+ *
+ * @return                OI_OK if successful; error if the command could not be sent
+ */
+OI_STATUS OI_OBEXCLI_SetPath(OI_OBEXCLI_CONNECTION_HANDLE   connectionId,
+                             OI_OBEX_UNICODE const          *folder,
+                             OI_BOOL                        dontCreate,
+                             OI_BOOL                        upLevel,
+                             OI_OBEXCLI_SETPATH_CFM         setpathCfm,
+                             const OI_OBEX_HEADER_LIST      *cmdHeaders);
+
+
+
+/**
+ * This function sends an action command to the remote OBEX server.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param actionId        Identifies the action to perform.
+ *
+ * @param remoteObject    This parameter is a unicode name specifying the remote object to perform
+ *                        the action on.
+ *
+ * @param actionHdrs      This is a list of action-specific command headers.
+ *
+ * @param                 actionCfm is the callback function called with the server's response to the action command.
+ *
+ * @return                OI_OK if successful; error if the command could not be sent
+ */
+OI_STATUS OI_OBEXCLI_DoAction(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                              OI_UINT8 actionId,
+                              OI_OBEX_UNICODE const *object,
+                              OI_OBEX_HEADER_LIST const *actionHdrs,
+                              OI_OBEXCLI_ACTION_CFM actionCfm);
+
+
+/**
+ * This function returns the optimal size for a body header for a connection.
+ * Sending body headers that are smaller than this size or not an integer
+ * multiple of this size will result in slower data transfer rates.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @returns               best body payload size or 0 if there is no connection
+ */
+OI_UINT16 OI_OBEXCLI_OptimalBodyHeaderSize(OI_OBEXCLI_CONNECTION_HANDLE connectionId);
+
+/**
+ * Associates a caller defined context with an OBEX client connection. This
+ * context can then be retrieved by calling OI_OBEXCLI_GetConnectionContext().
+ *
+ * @param connectionId   The connection to associate the context with.
+ *
+ * @param context         A value supplied by the caller.
+ *
+ * @return                OI_OK if the context was set, OI_STATUS_NOT_FOUND if
+ *                        the connection id is not valid.
+ */
+OI_STATUS OI_OBEXCLI_SetConnectionContext(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                          void *context);
+
+
+/**
+ * Gets a caller defined context associate with an OBEX client connection. This is a value
+ * that we previously set by a call to OI_OBEXCLI_SetConnectionContext().
+ *
+ * @param connectionId    The OBEX client connection to get the context from.
+ *
+ * @return                A context pointer or NULL if the handle is invalid or
+ *                        there is no context associated with this connection.
+ */
+void* OI_OBEXCLI_GetConnectionContext(OI_OBEXCLI_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * Given an OBEX client connection handle this function returns the L2CAP channel for this
+ * connection. In the case of OBEX/RFCOMM this is the L2CAP channel for the underlying RFCOMM
+ * session. In the case of OBEX/L2CAP this is the L2CAP channel for the OBEX connection.
+ *
+ * @param connectionId  The OBEX client connection to get the L2CAP channel for
+ * @param cid           Pointer to out parameter for the L2CAP CID
+ *
+ * @return      - OI_OK if the context was set,
+ *              - OI_STATUS_NOT_FOUND if the connection id is not valid.
+ *              - OI_STATUS_NOT_CONNECTED if the connection is not up or is disconnecting
+ *
+ *
+ */
+OI_STATUS OI_OBEXCLI_GetL2capCID(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                 OI_L2CAP_CID *cid);
+
+/**
+ * This function returns the raw header list associated with a callback.  This function
+ * must only be called from within a callback, otherwise results are unpredictable.
+ *
+ * Some OBEX commands have optional headers (e.g. realm information in an authentication challenge);
+ * this API makes those headers available to applications.
+ *
+ * @param connectionId  The OBEX connection
+
+ * @param pRawHeaderList    Pointer where OBEX will store pointers to the raw header list.
+ *
+ * @return      - OI_OK, pRawHeaderList contains pointer to header list, may be NULL.
+ *              - any other status, pRawHeaderList returned is undefined
+ */
+OI_STATUS OI_OBEXCLI_GetRawHeaderList(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
+                                      OI_OBEX_HEADER_LIST          **pRawHeaderList);
+
+
+/*****************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_OBEXCLI_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_obexspec.h b/obex_profiles/sdk/include/profiles/oi_obexspec.h
new file mode 100644
index 0000000..636dbac
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_obexspec.h
@@ -0,0 +1,564 @@
+#ifndef _OI_OBEXSPEC_H
+#define _OI_OBEXSPEC_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ @file
+ This file contains definitions for commands, responses, and data structures as specified
+ in the OBEX standard.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+
+
+/** \addtogroup OBEX */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name OBEX Version Constant
+ * @{
+ * This is the OBEX protocol version not the OBEX specification version. The
+ * current OBEX protocol version is 1.0
+ */
+#define OI_OBEX_MAJOR_VERSION    1
+#define OI_OBEX_MINOR_VERSION    0
+
+#define OI_OBEX_VERSION_NUMBER   ((OI_OBEX_MAJOR_VERSION << 4) | OI_OBEX_MINOR_VERSION)
+
+#define OI_OBEX_MAJOR_VERSION_NUMBER(v)  (((v) >> 4) & 0x0F)
+#define OI_OBEX_MINOR_VERSION_NUMBER(v)  ((v) & 0x0F)
+
+
+/**@}*/
+
+/**
+ * @name OBEX Header types
+ * OBEX headers consist of a single-byte header ID followed by zero or more bytes
+ * of header value. The most significant 2 bits of the header ID identify
+ * one of four different kinds of header.
+ * @{
+ */
+#define OI_OBEX_HDR_ID_UNICODE   0x00  /**< null-terminated Unicode text, length prefixed with 2-byte unsigned integer */
+#define OI_OBEX_HDR_ID_BYTESEQ   0x40  /**< byte sequence, length prefixed with 2-byte unsigned integer */
+#define OI_OBEX_HDR_ID_UINT8     0X80  /**< 1-byte quantity */
+#define OI_OBEX_HDR_ID_UINT32    0xC0  /**< 4-byte quantity, transmitted in network byte order (big endian) */
+
+#define OI_OBEX_HDR_KIND(h)      ((h) & 0xC0)
+
+
+#define OI_OBEX_VAR_LEN_HDR(h)   (((h) & 0x80) == 0)
+
+
+/**@}*/
+
+/**
+ * @name Standard OBEX header IDs
+ * @{
+ */
+#define OI_OBEX_HDR_COUNT                      0xC0 /**< number of objects (used by Connect) */
+#define OI_OBEX_HDR_NAME                       0x01 /**< name of the object (often a file name) */
+#define OI_OBEX_HDR_TYPE                       0x42 /**< type of object (e.g., text, HTML, binary, manufacturer-specific) */
+#define OI_OBEX_HDR_LENGTH                     0xC3 /**< the length of the object in bytes */
+#define OI_OBEX_HDR_TIME                       0x44 /**< date/time stamp (ISO 8601) */
+#define OI_OBEX_HDR_DESCRIPTION                0x05 /**< text description of the object */
+#define OI_OBEX_HDR_TARGET                     0x46 /**< name of service to which operation is targeted */
+#define OI_OBEX_HDR_HTTP                       0x47 /**< HTTP 1.x header */
+#define OI_OBEX_HDR_BODY                       0x48 /**< a chunk of the object body. */
+#define OI_OBEX_HDR_END_OF_BODY                0x49 /**< the final chunk of the object body */
+#define OI_OBEX_HDR_WHO                        0x4A /**< identifies the OBEX application; used to tell if talking to a peer */
+#define OI_OBEX_HDR_CONNECTION_ID              0xCB /**< an identifier used for OBEX connection multiplexing */
+#define OI_OBEX_HDR_APPLICATION_PARAMS         0x4C /**< extended application request and response information */
+#define OI_OBEX_HDR_AUTHENTICATION_CHALLENGE   0x4D /**< authentication digest-challenge */
+#define OI_OBEX_HDR_AUTHENTICATION_RESPONSE    0x4E /**< authentication digest-response */
+#define OI_OBEX_HDR_CREATOR_ID                 0xCF /**< identifies the creator of object */
+#define OI_OBEX_HDR_OBJECT_CLASS               0x51 /**< OBEX object class of object */
+#define OI_OBEX_HDR_SESSION_PARAMS             0x52 /**< Byte sequence of TLV session parameters */
+#define OI_OBEX_HDR_ACTION_ID                  0x94 /**< Specifies the action to be performed (used in ACTION operation) */
+#define OI_OBEX_HDR_DEST_NAME                  0x15 /**< The destination object name (used in certain ACTION operations) */
+#define OI_OBEX_HDR_SINGLE_RESPONSE_MODE       0x97 /**< 1-byte value to setup Single Response Mode (SRM) */
+#define OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS 0x98 /**< 1-byte value for setting parameters used during Single Response Mode (SRM) */
+#define OI_OBEX_HDR_PERMISSIONS                0xD6 /**< 4-byte value for setting access permissions on an object */
+
+/**@}*/
+
+
+/**
+ * @name OBEX Final bit
+ * The most significant bit in a command or response is called the 'final bit'. If
+ * set, it indicates that the command or response is complete; otherwise it indicates
+ * that more of the present command or response is coming. For example, a put request may need to be
+ * broken into a sequence of put commands; the final bit will only be set on the last
+ * put command in the sequence. Many commands and responses always have the final bit set.
+ * @{
+ */
+#define OI_OBEX_FINAL_BIT                         0x80
+
+#define OI_OBEX_FINAL(n)       ((OI_UINT8) ((n) | OI_OBEX_FINAL_BIT))
+#define OI_OBEX_IS_FINAL(n)    (((n) & OI_OBEX_FINAL_BIT) == OI_OBEX_FINAL_BIT)
+
+
+/**@}*/
+
+/**
+ * @name OBEX Opcodes
+ * @{
+ */
+#define OI_OBEX_CMD_CONNECT                       0x80 /**< connect and negotiate capabilities */
+#define OI_OBEX_CMD_DISCONNECT                    0x81 /**< signal the end of the session */
+#define OI_OBEX_CMD_PUT                           0x02 /**< send an object */
+#define OI_OBEX_CMD_GET                           0x03 /**< get an object */
+#define OI_OBEX_CMD_SET_PATH                      0x85 /**< modifies the current path on the receiving side */
+#define OI_OBEX_CMD_ACTION                        0x06 /**< sends an action command */
+#define OI_OBEX_CMD_SESSION                       0x87 /**< sends a session command */
+#define OI_OBEX_CMD_ABORT                         0xFF /**< abort the current operation. */
+
+/**@}*/
+
+
+/**
+ * @name OBEX Response codes
+ * @{
+ */
+typedef OI_UINT8 OI_OBEX_RSP_CODE;
+
+#define OI_OBEX_RSP_CONTINUE                      0x10
+#define OI_OBEX_RSP_OK                            0x20
+#define OI_OBEX_RSP_CREATED                       0x21
+#define OI_OBEX_RSP_ACCEPTED                      0x22
+#define OI_OBEX_RSP_NON_AUTHORITATIVE_INFORMATION 0x23
+#define OI_OBEX_RSP_NO_CONTENT                    0x24
+#define OI_OBEX_RSP_RESET_CONTENT                 0x25
+#define OI_OBEX_RSP_PARTIAL_CONTENT               0x26
+#define OI_OBEX_RSP_MULTIPLE_CHOICES              0x30
+#define OI_OBEX_RSP_MOVED_PERMANENTLY             0x31
+#define OI_OBEX_RSP_MOVED_TEMPORARILY             0x32
+#define OI_OBEX_RSP_SEE_OTHER                     0x33
+#define OI_OBEX_RSP_NOT_MODIFIED                  0x34
+#define OI_OBEX_RSP_USE_PROXY                     0x35
+#define OI_OBEX_RSP_BAD_REQUEST                   0x40 /**< Server could not understand request. */
+#define OI_OBEX_RSP_UNAUTHORIZED                  0x41
+#define OI_OBEX_RSP_PAYMENT_REQUIRED              0x42
+#define OI_OBEX_RSP_FORBIDDEN                     0x43 /**< Operation is understood but refused. */
+#define OI_OBEX_RSP_NOT_FOUND                     0x44
+#define OI_OBEX_RSP_METHOD_NOT_ALLOWED            0x45
+#define OI_OBEX_RSP_NOT_ACCEPTABLE                0x46
+#define OI_OBEX_RSP_PROXY_AUTHENTICATION_REQUIRED 0x47
+#define OI_OBEX_RSP_REQUEST_TIME_OUT              0x48
+#define OI_OBEX_RSP_CONFLICT                      0x49
+#define OI_OBEX_RSP_GONE                          0x4A
+#define OI_OBEX_RSP_LENGTH_REQUIRED               0x4B
+#define OI_OBEX_RSP_PRECONDITION_FAILED           0x4C
+#define OI_OBEX_RSP_REQUESTED_ENTITY_TOO_LARGE    0x4D
+#define OI_OBEX_RSP_REQUEST_URL_TOO_LARGE         0x4E
+#define OI_OBEX_RSP_UNSUPPORTED_MEDIA_TYPE        0x4F
+#define OI_OBEX_RSP_INTERNAL_SERVER_ERROR         0x50
+#define OI_OBEX_RSP_NOT_IMPLEMENTED               0x51
+#define OI_OBEX_RSP_BAD_GATEWAY                   0x52
+#define OI_OBEX_RSP_SERVICE_UNAVAILABLE           0x53
+#define OI_OBEX_RSP_GATEWAY_TIMEOUT               0x54
+#define OI_OBEX_RSP_HTTP_VERSION_NOT_SUPPORTED    0x55
+#define OI_OBEX_RSP_DATABASE_FULL                 0x60
+#define OI_OBEX_RSP_DATABASE_LOCKED               0x61
+
+/**@}*/
+
+
+/**
+ * @name OBEX UUIDs
+ * @{
+ */
+
+#define OI_OBEX_UUID_SIZE  16
+
+#define OI_OBEX_FILE_BROWSING_UUID { 0xF9,0xEC,0x7B,0xC4,0x95,0x3C,0x11,0xD2,0x98,0x4E,0x52,0x54,0x00,0xDC,0x9E,0x09 }
+
+
+/**@}*/
+
+
+/**
+ * @name Single Response Mode (SRM) constants used by OBEX
+ * @{
+ */
+
+#define OI_OBEX_SRM_DISABLED            0x00
+#define OI_OBEX_SRM_ENABLED             0x01
+#define OI_OBEX_SRM_SUPPORTED           0x02
+
+#define OI_OBEX_SRM_PARAM_RSVP          0x00 /**< Requests a response or additional request from the remote server or client */
+#define OI_OBEX_SRM_PARAM_WAIT          0x01 /**< Requests remote server or client to stop sending */
+#define OI_OBEX_SRM_PARAM_RSVP_AND_WAIT 0x02 /**< Requests a single packet from the remote server or client */
+
+/**@}*/
+
+
+/**@}*/
+
+
+/**
+ * @name Session Command constants used by OBEX
+ * @{
+ */
+
+#define OI_OBEX_SESSION_CREATE             0x00
+#define OI_OBEX_SESSION_CLOSE              0x01
+#define OI_OBEX_SESSION_SUSPEND            0x02
+#define OI_OBEX_SESSION_RESUME             0x03
+#define OI_OBEX_SESSION_SET_TIMEOUT        0x04
+
+
+#define OI_OBEX_SESSION_PARAM_DEVICE_ADDR  0x00
+#define OI_OBEX_SESSION_PARAM_NONCE        0x01
+#define OI_OBEX_SESSION_PARAM_ID           0x02
+#define OI_OBEX_SESSION_PARAM_NEXT_SEQ_NUM 0x03
+#define OI_OBEX_SESSION_PARAM_TIMEOUT      0x04
+#define OI_OBEX_SESSION_PARAM_OPCODE       0x06
+
+/**@}*/
+
+/**
+ * @name Action Operation action identifiers
+ * @{
+ */
+
+#define OI_OBEX_ACTION_COPY_OBJECT             0x00  /**< Copy Object Action  */
+#define OI_OBEX_ACTION_RENAME_OBJECT           0x01  /**< Move/Rename Object Action  */
+#define OI_OBEX_ACTION_SET_OBJECT_PERMISSIONS  0x02  /**< Set Object Permissions Action */
+#define OI_OBEX_ACTION_VENDOR_EXTENSION        0x80  /**< Values 0x80 .. 0xFF are reserved for vendor user */
+
+/**@}*/
+
+
+/**
+ * @name MIME types used by OBEX
+ * @{
+ */
+
+#define OI_OBEX_FOLDER_LISTING_TYPE "x-obex/folder-listing"
+#define OI_OBEX_ICALENDAR_TYPE      "text/calendar"
+#define OI_OBEX_VCALENDAR_TYPE      "text/x-vcalendar"
+#define OI_OBEX_VCARD_TYPE          "text/x-vcard" /* OPP and PBAP docs specify all lower case for vCard Type Header */
+#define OI_OBEX_VNOTE_TYPE          "text/x-vnote"
+#define OI_OBEX_VMESSAGE_TYPE       "text/x-vmsg"
+#define OI_OBEX_UPF_TYPE            "image/x-upf"
+#define OI_OBEX_JPEG_TYPE           "image/jpeg"
+#define OI_OBEX_TEXT_TYPE           "text/plain"
+
+#define OI_OBEX_ICALENDAR_SUFFIX    ".ics"
+#define OI_OBEX_VCALENDAR_SUFFIX    ".vcs"
+#define OI_OBEX_VCARD_SUFFIX        ".vcf"
+#define OI_OBEX_VNOTE_SUFFIX        ".vnt"
+#define OI_OBEX_VMESSAGESUFFIX      ".vmg"
+
+/**
+ * OBEX object push types
+ */
+
+#define OI_OBEX_OBJ_FORMAT_VCARD_2_1   0x01
+#define OI_OBEX_OBJ_FORMAT_VCARD_3_0   0x02
+#define OI_OBEX_OBJ_FORMAT_VCAL_1_0    0x03
+#define OI_OBEX_OBJ_FORMAT_ICAL_2_0    0x04
+#define OI_OBEX_OBJ_FORMAT_VNOTE       0x05
+#define OI_OBEX_OBJ_FORMAT_VMESSAGE    0x06
+#define OI_OBEX_OBJ_FORMAT_ANY         0xFF
+
+/**@}*/
+
+
+/**
+ * Other OBEX constants
+ */
+
+#define OI_OBEX_INVALID_CONNECTION_ID  0xFFFFFFFF
+
+#define OI_OBEX_CONNECT_FLAGS     0  /**< Must be zero for OBEX 1.0 */
+
+
+#define OI_OBEX_SETPATH_UP_LEVEL  OI_BIT0  /**< Backup before applying name */
+#define OI_OBEX_SETPATH_NO_CREATE OI_BIT1  /**< Don't create directory if it doesn't exist */
+
+#define OI_OBEX_MAX_PACKET_SIZE   OI_MAX_UINT16
+#define OI_OBEX_MIN_PACKET_SIZE   255
+
+/**
+ * minimum size of an OBEX packet
+ */
+
+#define OI_OBEX_SMALLEST_PKT    (sizeof(OI_UINT8) + sizeof(OI_UINT16))
+
+/**
+ * Header prefix for a variable-length header is the 1-byte header ID followed
+ * by a 2-byte length.
+ */
+
+#define OI_OBEX_HEADER_PREFIX_LEN  (sizeof(OI_UINT8) + sizeof(OI_UINT16))
+
+/**
+ * Header prefix for an application parameter value is a 1-byte tag followed by
+ * a 1-byte length.
+ */
+
+#define OI_OBEX_APPLICATION_PARAMETER_PREFIX_LEN (sizeof(OI_UINT8) + sizeof(OI_UINT8))
+
+/**
+ * packet overhead for a packet containing a single body header
+ */
+
+#define OI_OBEX_BODY_PKT_OVERHEAD (OI_OBEX_SMALLEST_PKT + OI_OBEX_HEADER_PREFIX_LEN)
+
+/**
+ * size of a connection id header
+ * 1-byte tag plus 4-byte value
+ */
+#define OI_OBEX_CONNECTION_ID_LEN (sizeof(OI_UINT8) + sizeof(OI_UINT32))
+
+/**
+ * constants for OBEX authentication
+ */
+
+#define OI_OBEX_CHALLENGE_DIGEST_NONCE_TAG   0
+#define OI_OBEX_CHALLENGE_DIGEST_OPTIONS_TAG 1
+#define OI_OBEX_CHALLENGE_DIGEST_REALM_TAG   2
+
+#define OI_OBEX_RESPONSE_DIGEST_REQUEST_TAG  0
+#define OI_OBEX_RESPONSE_DIGEST_USERID_TAG   1
+#define OI_OBEX_RESPONSE_DIGEST_NONCE_TAG    2
+
+#define OI_OBEX_AUTH_USERID_OPTION           OI_BIT0
+#define OI_OBEX_AUTH_READONLY_OPTION         OI_BIT1
+
+/**
+ * size of an OBEX authentication message digest
+ */
+
+#define OI_OBEX_AUTH_DIGEST_LEN   16
+
+/**
+ * maximum user id length as specified in the OBEX specification.
+ */
+
+#define OI_OBEX_MAX_USERID_LEN    20
+
+/**
+ * maximum length of an LUID per IrMC specification
+ */
+
+#define OI_OBEX_MAX_LUID_LEN      50
+
+
+/**
+ * maximum password length supported by this implementation
+ */
+
+#define OI_OBEX_MAX_PASSWORD_LEN  16
+
+/**
+ * Utility macro for testing if an OBEX header is one of the two "body" headers.
+ */
+
+#define OI_OBEX_IS_A_BODY_HEADER(h) (((h) == OI_OBEX_HDR_BODY) || ((h) == OI_OBEX_HDR_END_OF_BODY))
+
+/**
+ * OBEX uses network (big-endian) byte order.
+ */
+
+#define OI_OBEX_BO   NETWORK_BYTE_ORDER
+
+
+/**
+ * Maximum length for a realm string
+ */
+#define OI_OBEX_MAX_REALM_LN  254
+
+/**
+ * This structure describes a realm
+ */
+typedef struct {
+    OI_UINT8    charSet;                        /**< The character set for the realm. See the IrDA spec for details */
+    OI_BYTE     realm[OI_OBEX_MAX_REALM_LN];    /**< The realm string Not that depending on the character set this may contain embedded NULs */
+    OI_UINT8    len;                            /**< The number of bytes in the realm string (must be <= 254) */
+} OI_OBEX_REALM;
+
+/**
+   This structure is used for a Unicode (UCS-16) character
+   string.
+ */
+
+typedef struct {
+    OI_UINT16 len;  /**< length of string in units of OI_CHAR16 */
+    OI_CHAR16 *str;
+} OI_OBEX_UNICODE;
+
+/**
+   This structure is used for an OBEX header of byte sequence
+   type.
+ */
+
+typedef struct {
+    OI_UINT16 len;
+    OI_BYTE *data;
+} OI_OBEX_BYTESEQ;
+
+/**
+   This structure describes an OBEX application parameter header
+   entry.
+ */
+
+typedef struct {
+    OI_UINT8 tag;   /**< Type of application parameter */
+    OI_UINT8 len;   /**< Length of tag data */
+    OI_BYTE *data;  /**< Pointer to tag data */
+} OI_OBEX_APP_PARAM;
+
+/**
+   This structure is used  for passing a list of OBEX
+   application parameter entries
+ */
+
+typedef struct {
+    OI_UINT8 count;            /**< Number of application parameters */
+    OI_OBEX_APP_PARAM *list;   /**< Pointer to list of application parameters */
+} OI_OBEX_APP_PARAM_LIST;
+
+
+/**
+ *
+ * Helper macros for extracting permissions
+ */
+#define OI_OBEX_OTHER_PERMISSIONS(permMask)     ((OI_UINT8)(((permMask) >> 0) & 0x17))
+#define OI_OBEX_GROUP_PERMISSIONS(permMask)     ((OI_UINT8)(((permMask) >> 8) & 0x17))
+#define OI_OBEX_USER_PERMISSIONS(permMask)      ((OI_UINT8)(((permMask) >> 16) & 0x17))
+
+#define OI_OBEX_READ_PERMISSION    OI_BIT0  /**< When this bit is set READ permission is granted */
+#define OI_OBEX_WRITE_PERMISSION   OI_BIT1  /**< When this bit is set WRITE permission is granted */
+#define OI_OBEX_DELETE_PERMISSION  OI_BIT2  /**< When this bit is set DELETE permission is granted */
+#define OI_OBEX_MODIFY_PERMISSION  OI_BIT7  /**< When this bit is set object/file access permissions may be changed */
+
+#define OI_OBEX_PERMISSION_MASK(group, user, other)  (((other) << 0) | ((group) << 8) | ((user) << 16))
+
+/**
+   This structure is used for an OBEX header.
+ */
+
+typedef struct {
+    OI_UINT8 id;
+    union {
+        /**
+         * generic header types
+         */
+        OI_UINT8 uInt8;
+        OI_UINT32 uInt32;
+        OI_OBEX_BYTESEQ byteseq;
+        OI_OBEX_UNICODE unicode;
+        /**
+         * specific header types
+         */
+        OI_UINT8 srm;
+        OI_UINT8 srmParam;
+        OI_UINT8 actionId;
+        OI_UINT32 count;
+        OI_UINT32 length;
+        OI_UINT32 connectionId;
+        OI_UINT32 permissions;
+        OI_OBEX_BYTESEQ type;
+        OI_OBEX_BYTESEQ time;
+        OI_OBEX_BYTESEQ target;
+        OI_OBEX_BYTESEQ http;
+        OI_OBEX_BYTESEQ body;
+        OI_OBEX_BYTESEQ endOfBody;
+        OI_OBEX_BYTESEQ who;
+        OI_OBEX_BYTESEQ applicationParams;
+        OI_OBEX_BYTESEQ authenticationChallenge;
+        OI_OBEX_BYTESEQ authenticationResponse;
+        OI_OBEX_BYTESEQ objectClass;
+        OI_OBEX_BYTESEQ sessionParams;
+        OI_OBEX_UNICODE name;
+        OI_OBEX_UNICODE description;
+        OI_OBEX_UNICODE destName;
+    } val;
+
+} OI_OBEX_HEADER;
+
+
+/**
+   This structure is used for passing lists of OBEX headers.
+ */
+
+typedef struct {
+    OI_OBEX_HEADER *list;
+    OI_UINT8 count;
+} OI_OBEX_HEADER_LIST;
+
+
+/**
+ * Scan an OBEX header list for a specific obex header.
+ *
+ * @param headers    An OBEX header list
+ *
+ * @param headerId   The header to search for
+ *
+ * @return  The required header or NULL if the header is not in the list.
+ */
+OI_OBEX_HEADER* OI_OBEX_FindHeader(OI_OBEX_HEADER_LIST const *headers,
+                                   OI_UINT8 headerId);
+
+/**
+ * Parses an application parameters header into its individual components.
+ * The caller is responsible for calling OI_Free(params->list) when it is
+ * finished with this information. The underlying byteseq data is not affected
+ * by this operation, but the generated param list's data pointers refer back to
+ * the byteseq data, which must therefore remain live for the lifetime of the
+ * params array.
+ *
+ * @param data      An OBEX byte sequence
+ *
+ * @param params    A pointer to a params list
+ */
+OI_STATUS OI_OBEX_ParseAppParamsHeader(const OI_OBEX_BYTESEQ *data,
+                                       OI_OBEX_APP_PARAM_LIST *params);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+/**@}*/
+
+/*****************************************************************************/
+#endif /* _OI_OBEXSPEC_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_obexsrv.h b/obex_profiles/sdk/include/profiles/oi_obexsrv.h
new file mode 100644
index 0000000..2299788
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_obexsrv.h
@@ -0,0 +1,867 @@
+#ifndef _OI_OBEXSRV_H
+#define _OI_OBEXSRV_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @file
+  This file provides the API for the server side of the Generic Object Exchange Profile.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_obex.h"
+#include "oi_obexspec.h"
+#include "oi_connect_policy.h"
+#include "oi_bt_profile_config.h"
+
+/** \addtogroup OBEX */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * OBEX registered server required authentication
+ */
+typedef enum {
+    OI_OBEXSRV_AUTH_NONE = 0,
+    OI_OBEXSRV_AUTH_PASSWORD,
+    OI_OBEXSRV_AUTH_USERID_AND_PASSWORD
+} OI_OBEXSRV_AUTHENTICATION;
+
+
+/**
+ *  represents an active connection to a remote OBEX client
+ */
+typedef OI_OBEX_CONNECTION_HANDLE OI_OBEXSRV_CONNECTION_HANDLE;
+
+
+/**
+ * A callback function of this type indicates that a client is attempting to connect to this server.
+ * The application must call OI_OBEXSRV_AcceptConnect() to accept or reject the incoming connection.
+ *
+ * @param connectionId     A unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param unauthorized     If TRUE indicates that this connection requires
+ *                         authentication and the application must call back
+ *                         with a password.
+ *
+ * @param userId           If unauthorized is TRUE the client may have provided
+ *                         a user id. In case of client-initiated authentication
+ *                         the value of user id is NULL.
+ *
+ * @param userIdLen        length of the user id.
+ *
+ * @param realm            Indicates the realm received in Client's challenge or NULL
+ *
+ */
+
+typedef void (*OI_OBEXSRV_CONNECT_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                       OI_BOOL                      unauthorized,
+                                       OI_BYTE                      *userId,
+                                       OI_UINT8                     userIdLen,
+                                       OI_OBEX_REALM                *realm);
+
+/**
+ * A callback function of this type indicates that a client is disconnecting from this server.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ */
+
+typedef void (*OI_OBEXSRV_DISCONNECT_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * A callback function of this type indicates that a GET command has been received
+ * from a connected OBEX client.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param cmdHeaders       This parameter is a pointer to a list of OBEX headers
+ *                         accompanying the get command.  This list may be NULL
+ *                         if the GET command is simply requesting the next
+ *                         packet.
+ *
+ * @param status           OI_OBEX_CONTINUE indicates the client is ready for
+ *                         data; the upper layer server should respond with
+ *                         OI_OBEXSRV_GetResponse(connectionId, <ARG>, OI_OK).
+ *
+ *                         OI_OBEXSRV_INCOMPLETE_GET indicates that the client
+ *                         will respond with more information about the request
+ *                         in a subsequent packet; the server should respond
+ *                         with OI_OBEXSRV_GetResponse(connectionId, <ARG>,
+ *                         OI_OBEX_CONTINUE)
+ *
+ *                         Any other status indicates that the transaction is
+ *                         complete, successfully or otherwise.
+ *
+ * @return                a status code to indicate whether the get request is accepted or
+ *                        rejected
+ */
+
+typedef OI_STATUS (*OI_OBEXSRV_GET_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                        OI_OBEX_HEADER_LIST *cmdHeaders,
+                                        OI_STATUS status);
+
+/**
+ * A callback function of this type returns buffers to the upper layer and indicates that OBEX is
+ * requesting bulk data to send in response to a GET request.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection
+ *                        to an OBEX server.
+ *
+ * @param numBuffers      The number of buffers being releases by this call. This parameter will be
+ *                        zero if this is the first bulk data get indication.
+ *
+ * @param bulkDataBuffer  This parameter is an array of pointers to data buffers that are not longer
+ *                        being used by OBEX. Memory for these buffers was allocated by the caller
+ *                        to OI_OBEXSRV_BulkGetResponse() and can now be freed or reused by the caller.
+ *
+ * @param bufferLen       This parameter is an array of lengths of data buffers being returned.
+ *
+ * @param status        - OI_OK if the GET transaction has completed successfuly.
+ *                      - OI_OBEX_CONTINUE indicates that OBEX is ready for more data, the upper
+ *                        layer server should call OI_OBEXSRV_GetBulkResponse().
+ *                      - Error status code indicating that the GET transaction is canceled.
+ */
+
+typedef OI_STATUS (*OI_OBEXSRV_BULK_GET_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                             OI_UINT8 numBuffers,
+                                             OI_UINT8 *bulkDataBuffer[],
+                                             OI_UINT32 bufferLen[],
+                                             OI_STATUS status);
+
+/**
+ *
+ * A callback function of this type indicates that a PUT request has been
+ * received from a connected OBEX client.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param headers          This parameter is a pointer to a list of OBEX headers
+ *                         in the put request. This will be NULL if the put
+ *                         operation has been aborted by the client or if the
+ *                         final cleanup callback is being invoked.
+ *
+ * @param status           OI_OK if this is the final put request and to signal the
+ *                         cleanup callback; OI_OBEX_CONTINUE if there is more
+ *                         data to come; or an error status.
+ *
+ * @return                a status code to indicate whether the put request is
+ *                        accepted or rejected.
+ */
+
+typedef OI_STATUS (*OI_OBEXSRV_PUT_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                        OI_OBEX_HEADER_LIST *headers,
+                                        OI_STATUS status);
+
+
+/**
+ * A callback function of this type indicates the path set for get and put operations.
+ *
+ * @param connectionId   a unique identifier generated by the OBEX server that
+ *                       identifies the connection
+ *
+ * @param folder         a unicode string for the folder that be NULL
+ *
+ * @param upLevel        indicates that the path is being set to the parent folder of
+ *                       the current folder (equivalent to '..')
+ *
+ * @param create         indicates that a new folder should be created if required and
+ *                       access permissions allow
+ *
+ * @return              a status code to indicate if the setpath request is
+ *                      accepted or rejected.
+ */
+
+typedef OI_STATUS (*OI_OBEXSRV_SET_PATH_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                             OI_OBEX_UNICODE *folder,
+                                             OI_BOOL upLevel,
+                                             OI_BOOL create);
+
+
+/**
+ *
+ * A callback function of this type indicates that an ACTION request has been
+ * received from a connected OBEX client.
+ *
+ * @param connectionId     A unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param actionId         Identifies the action to be performed.
+ *
+ * @param objectName       Name of the object to perform the action on.
+ *
+ * @param headers          This parameter is a pointer to a list of OBEX headers
+ *                         in the Action request.
+ *
+ * @param status           OI_OK if this is the final put request and to signal the
+ *                         cleanup callback; OI_OBEX_CONTINUE if there is more
+ *                         data to come; or an error status.
+ *
+ * @return                a status code to indicate whether the Action request is
+ *                        accepted or rejected.
+ */
+
+typedef OI_STATUS (*OI_OBEXSRV_ACTION_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                           OI_UINT8 actionId,
+                                           OI_OBEX_UNICODE *name,
+                                           OI_OBEX_HEADER_LIST *headers);
+
+/**
+ * A callback function of this type can be provided when a server is registered to allow an
+ * upper layer to monitor progress of PUT and GET operations.
+ *
+ * @param connectionId     a unique ID that represents the in-progress connection
+ *
+ * @param obexCmd          Indicates if this is a put (OI_OBEX_CMD_PUT) or a get (OI_OBEX_CMD_GET)
+ *
+ * @param progressBytes    A running count of the number or bytes transferred.
+ */
+typedef void (*OI_OBEXSRV_PROGRESS_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                        OI_UINT8 obexCmd,
+                                        OI_UINT32 progressBytes);
+
+
+/**
+ * A callback function of this type indicates that authentication is required on an inbound
+ * connection. The application must call OI_OBEXSRV_AuthAccept() to accept or reject the connect
+ * request.
+ *
+ * @param connectionId     A unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param addr             The Bluetooth device address of the connecting client
+ *
+ */
+
+typedef void (*OI_OBEXSRV_AUTH_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                    OI_BD_ADDR *addr);
+
+/**
+ * A callback function of this type indicates that the server has received an abort
+ * command from the client.  Application must call OBEXSRV_AbortResponse to send
+ * response to the abort command.
+ *
+ * @note    Note that this callback should only concern itself with sending a response
+ *          to the abort.  Specifically, the callback should NOT concern itself with the
+ *          operation in progress.  The BM3 OBEX server will manage the termination of
+ *          current operation, calling all the appropriate callbacks with failed status.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param cmdHeaders       This parameter is a pointer to a list of OBEX headers
+ *
+ */
+typedef void (*OI_OBEXSRV_ABORT_IND)(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                     OI_OBEX_HEADER_LIST          *cmdHeaders);
+
+
+/**
+  This structure lists callback functions for handling server
+  requests.
+  */
+typedef struct {
+    OI_OBEXSRV_CONNECT_IND connectInd;       /**< Client is attempting to connect. */
+    OI_OBEXSRV_DISCONNECT_IND disconnectInd; /**< Client is disconnecting. */
+    OI_OBEXSRV_GET_IND getInd;               /**< GET request received from client. */
+    OI_OBEXSRV_PUT_IND putInd;               /**< PUT request received from client. */
+    OI_OBEXSRV_SET_PATH_IND setPathInd;      /**< SETPATH request received from client. */
+    OI_OBEXSRV_BULK_GET_IND bulkGetInd;      /**< GET request received from client. May be NULL if bulk get
+                                               responses are not supported by the upper layer profile */
+    OI_OBEXSRV_ACTION_IND actionInd;         /**< ACTION request received from client. May be NULL if action
+                                               operations are not supported by upper layer profile. */
+    OI_OBEXSRV_PROGRESS_IND progressInd;     /**< Reports progress of PUTs and GETs. May be NULL */
+    OI_OBEXSRV_AUTH_IND authInd;             /**< Indicates an incoming connect request to a server
+                                               that requires authentication. This function is
+                                               optional and is supplied gives the application an
+                                               early opportunity to reject an incoming connect
+                                               request or provide realm information required for the
+                                               authentication phase. */
+    OI_OBEXSRV_ABORT_IND abortInd;          /**< Client has requested to abort the current operation;
+                                               may be NULL. */
+} OI_OBEXSRV_CB_LIST;
+
+
+
+/**
+ * Function called by upper layer to accept or reject a connect request.
+ *
+ * @param connectionHandle OBEX server connection handle for the connection
+ *                         being accepted.
+ *
+ * @param accept           TRUE if the upper layer accepts the connect request.
+ *
+ * @param status           Reason for the refusal, e.g "out of resources".
+ *
+ * @param optHeaders       Optional headers to include in the connect response.
+ *                         NULL indicates there are no optional headers.
+ *
+ * @return                 OI_OK if the confirmation was appropriate and the
+ *                         connection handle is still valid.
+ */
+
+OI_STATUS OI_OBEXSRV_AcceptConnect(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle,
+                                   OI_BOOL                      accept,
+                                   OI_STATUS                    status,
+                                   const OI_OBEX_HEADER_LIST    *optHeaders);
+
+
+/**
+ * Function called to confirm that the path has been set in response to a
+ * setpath indication.
+ *
+ * @param connectionHandle OBEX server connection handle for the service request
+ *                         being acknowledged.
+ *
+ * @param status           Status code indicating if the request was accepted
+ *                         and completed, was rejected, or failed.
+ *
+ * @param optHeaders       Optional headers to include in the confirm response.
+ *                         NULL indicates there are no optional headers.
+ *
+ * @return                 OI_OK if the confirmation was appropriate and could
+ *                         be sent.
+ */
+
+OI_STATUS OI_OBEXSRV_ConfirmSetpath(OI_OBEXSRV_CONNECTION_HANDLE    connectionHandle,
+                                    OI_STATUS                       status,
+                                    const OI_OBEX_HEADER_LIST        *optHeaders);
+
+/**
+ * This functions gets the connection target associated with an OBEX server
+ * connection handle. If no target was used to connect, target->data is set to
+ * NULL and target->len to zero.
+ *
+ * @param connectionHandle OBEX server connection handle for which the current
+ *                         target is desired
+ *
+ * @param target    pointer to caller's variable where information about the
+ *                  target will be stored.
+ *
+ * @return
+ *      - OI_OK: A connection exists. The target has been placed into the
+ *        caller's variable.
+ *      - OI_OBEX_NOT_CONNECTED: connectionHandle is not associated with a valid
+ *        OBEX connection. The callers' variable is unchanged.
+ */
+
+OI_STATUS OI_OBEXSRV_GetTarget(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle,
+                               OI_OBEX_BYTESEQ *target);
+
+
+/**
+ * This function gets the Bluetooth Device Address (BD_ADDR) associated with an
+ * OBEX server connection handle.
+ *
+ * @param connectionHandle OBEX server connection handle for which a BD_ADDR is desired
+ *
+ * @param pBdAddr pointer to caller's variable where the BD_ADDR will be stored
+ *
+ * @return
+ *      - OI_OK: A connection exists. The BD_ADDR has been placed into the
+ *        caller's variable.
+ *      - OI_OBEX_NOT_CONNECTED: connectionHandle is not associated with a valid
+ *        OBEX connection. The callers' variable is unchanged.
+ *
+ */
+OI_STATUS OI_OBEXSRV_GetClientAddr(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle,
+                                   OI_BD_ADDR *pBdAddr);
+
+/**
+ * This function gets the lower layer protocol info associated with an OBEX server connection handle.
+ *
+ * @param connectionHandle OBEX server connection handle for which a lower layer
+ *                         service id is desired
+ *
+ * @param lowerProtocol    Pointer to caller's variable where the protocol information
+ *                         will be stored
+ *
+ * @return
+ *      - OI_OK: A connection exists. The service is has been placed into
+ *        the caller's variable.
+ *      - OI_OBEX_NOT_CONNECTED: connectionHandle is not associated with a valid
+ *        OBEX connection. The callers' variable is unchanged.
+ */
+OI_STATUS OI_OBEXSRV_GetLowerProtocolInfo(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle,
+                                          OI_OBEX_LOWER_PROTOCOL *lowerProtocol);
+
+
+/**
+ * Accept or reject and authenticated connection. This function must be called in response to an
+ * OI_OBEXSRV_AUTH_IND callback.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param realm            The realm for authentication - may be NULL.
+ *
+ * @param accept           TRUE to accept the connection, FALSE to reject the connection.
+ *
+ * @return                 OI_OK or an error status if this function was called
+ *                         at an inappropriate wrong time.
+ */
+OI_STATUS OI_OBEXSRV_AuthAccept(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                const OI_OBEX_REALM          *realm,
+                                OI_BOOL                      accept);
+
+/**
+ * Response to an connect indication that reported that the connection was
+ * unauthorized. If the password is correct and authentication completes another
+ * connect indication will be issued.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param userId           the user id for the connecting user. If the routine is called in response
+ *                         to a authentication challenge from a client, this parameter should be set
+ *                         to a User Id provided by the server.
+ *                         If the routine is called to handle authentication response from a client,
+ *                         this parameter would hold a User Id provided by the client.
+ *
+ * @param userIdLen        Length of the userId.
+ *
+ * @param password         This parameter is a pointer to a NULL-terminated
+ *                         password.  A NULL value indicates that the
+ *                         application is rejecting the authentication
+ *                         challenge.
+ *
+ * @param readOnly         indicates that the application is granting read-only
+ *                         access only.
+ *
+ * @return                 OI_OK or an error status if this function was called
+ *                         at an inappropriate wrong time.
+ */
+OI_STATUS OI_OBEXSRV_AuthenticationResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                            const OI_BYTE *userId,
+                                            OI_UINT8 userIdLen,
+                                            const OI_CHAR *password,
+                                            OI_BOOL readOnly);
+/**
+ * Respond to a GET command by sending data to a connected OBEX client.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param rspHeaders       This parameter is a pointer to a list of OBEX headers
+ *                         that contain the response to the get command. If the
+ *                         return status is OI_OK, the application must not free
+ *                         any memory referenced by the headers until the next
+ *                         get indication callback is invoked
+ *
+ * @param rspStatus        OI_OBEX_CONTINUE if there is more data to get; OI_OK
+ *                         if this is no more data; or an error status.
+ *
+ * @return                OI_OK or an error status if the response could not be sent.
+ */
+OI_STATUS OI_OBEXSRV_GetResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                 OI_OBEX_HEADER_LIST *rspHeaders,
+                                 OI_STATUS rspStatus);
+
+
+/**
+ * Send bulk data to an OBEX client in response to a get request. This function is only called if
+ * the upper layer registered support for bulk data gets by registering a OI_OBEXSRV_BULK_GET_IND
+ * callback. The OBEX server will segment the bulk data provided by the caller into appropriately
+ * sized OBEX packets. Unlike OI_OBEXCLI_GetReponse() which requires a get indication for each call,
+ * multiple OI_OBEXCLI_BulkGetResponse() calls can be made in response to a single
+ * OI_OBEXSRV_BulkGetInd() and OBEX will queue the data internally. This is of most value when the
+ * connection has been configured for single response mode because it allows OBEX to keep data
+ * flowing. A OI_OBEXSRV_BULK_GET_IND callback is called as each bulk data buffer has been
+ * sent to the client For a specific GET transaction, once this function has been called, the
+ * transaction must be completed using this function.
+ *
+ * Note that the OBEX server segments bulk data blocks to fit within the negotiation OBEX packet
+ * size but will not aggregate small blocks into a larger OBEX packet.
+ *
+ * @param connectionId    This parameter is a unique ID that represents an established connection to
+ *                        a remote OBEX client.
+ *
+ * @param numBuffers      The number of buffer to put.
+ *
+ * @param bulkDataBuffer  An array of bulk data buffers to be sent. The data buffers must not be
+ *                        freed until the buffer pointers are individually returned in subsequent
+ *                        OI_OBEXSRV_BULK_GET_IND calls.
+ *
+ * @param bufferLength    An array of sizes for the bulk data buffers. The bulk data buffers are
+ *                        combined and segmented internally into appropriately sized OBEX packets so
+ *                        this value can be arbitrarily large or small.
+ *
+ * @param status          Response status code:
+ *                        - OI_OK indicates there is no more data to get.
+ *                        - OI_OBEX_CONTINUE if there is more data to get
+ *                        - An error status terminates the get transaction.
+ *
+ * @return                - OI_OK if data was successful but no more BulkGetResponses() are permitted at this time.
+ *                        - OI_OBEX_CONTINUE if the get response was successful and more gets are permitted.
+ *
+ *                        - Other errors indicate that the get operation failed and that the caller
+ *                          should cleanup and if necessary disconnect the link.
+ */
+OI_STATUS OI_OBEXSRV_BulkGetResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                     OI_UINT8 numBuffers,
+                                     OI_UINT8 *bulkDataBuffer[],
+                                     OI_UINT32 bufferLength[],
+                                     OI_STATUS rspStatus);
+
+/**
+ * Acknowledge a PUT command, optionally sending response headers to a connected
+ * OBEX client.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param rspHeaders       This parameter is a pointer to a list of OBEX headers
+ *                         that contain the response to the put command.  If the
+ *                         server has no response headers to send, it should set
+ *                         rspHeaders to NULL. Otherwise, if the return status
+ *                         is OI_OK, then the application must not free any
+ *                         memory referenced by the headers until the response
+ *                         confirmation callback is invoked.
+ *
+ * @param rspStatus        should be the same as the status passed to
+ *                         the server's PUT callback (OI_OK or OI_OBEX_CONTINUE)
+ *                         if the operation was successful, or an error message
+ *                         otherwise.
+ */
+OI_STATUS OI_OBEXSRV_PutResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                 OI_OBEX_HEADER_LIST *rspHeaders,
+                                 OI_STATUS rspStatus);
+
+
+/**
+ * Function called to report the result of an Action operation.
+ *
+ * @param connectionHandle OBEX server connection handle for the Action operation
+ *                         being acknowledged.
+ *
+ * @param actionId         The action that the response is for.
+ *
+ * @param status           Status code indicating if the action operation was accepted
+ *                         and completed, was rejected, or failed.
+ *
+ * @param optHeaders       Optional headers to include in the connect response.
+ *                         NULL indicates there are no optional headers.
+ *
+ * @return                 OI_OK if the response was appropriate and could
+ *                         be sent.
+ */
+
+OI_STATUS OI_OBEXSRV_ActionResponse(OI_OBEXSRV_CONNECTION_HANDLE    connectionHandle,
+                                    OI_UINT8                        actionId,
+                                    OI_STATUS                       status,
+                                    const OI_OBEX_HEADER_LIST       *optHeaders);
+
+/**
+ * Acknowledge a Abort command, optionally sending response headers to OBEX client.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection
+ *
+ * @param rspHeaders       This parameter is a pointer to a list of OBEX headers
+ *                         that contain the response to the abort command.
+ *                         If the server has no response headers to send,
+ *                         it should set rspHeaders to NULL.
+ *
+ * @param                  rspStatus - per spec, should be OI_OK.
+ */
+
+OI_STATUS OI_OBEXSRV_AbortResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                   OI_OBEX_HEADER_LIST          *rspHeaders,
+                                   OI_STATUS                    rspStatus);
+
+/**
+ * This function returns the optimal size for a body header for a connection.
+ * Sending body headers that are smaller than this size or not an integer
+ * multiple of this size will result in slower data transfer rates.
+ *
+ * @param connectionId    a unique identifier generated by the OBEX server that
+ *                        identifies the connection
+ *
+ * @return                best  payload size or 0 if there is no connection
+ */
+
+OI_UINT16 OI_OBEXSRV_OptimalBodyHeaderSize(OI_OBEXSRV_CONNECTION_HANDLE connectionId);
+
+/**
+ * This function forcibly severs the connection from an OBEX client to the OBEX
+ * server. The disconnect indication callback will be called when the disconnect
+ * is complete.
+ *
+ * An OBEX server may need to forcibly terminate a connection during
+ * deregistration, since deregistration will fail if a connection is in place.
+ *
+ * @param connectionId     a unique identifier generated by the OBEX server that
+ *                         identifies the connection.
+ *
+ * @return                 OI_OK if the connectionId is valid and the connection
+ *                         will be terminated.
+ */
+
+OI_STATUS OI_OBEXSRV_ForceDisconnect(OI_OBEXSRV_CONNECTION_HANDLE connectionId);
+
+/**
+ * This function registers an OBEX server to accept put and/or get requests from OBEX clients.
+ *
+ * @param target           a byte sequence that idenfifies the OBEX target for the
+ *                         service being registered; may be NULL.
+ *
+ * @param CBList           pointer to a list of the application functions that
+ *                         will be called when the OBEX server receives a get or
+ *                         put request
+ *
+ *
+ * @param authentication   specifies whether authentication is required on
+ *                         connections to this server, with TRUE indicating that
+ *                         authentication is required
+ *
+ * @param connectOptions   OBEX options for this connection. Can be NULL if no options are being
+ *                         specified.
+ *
+ * @param lowerProtocolList [In/Out] This parameter is a pointer to a list of lower layer protocols
+ *                          for which the server is to be registered. The caller must initialize the
+ *                          protocol field of each serviceId structure, OBEX will write the lower
+ *                          layer service identifier into the the list.  The upper layer will use the
+ *                          this information when registering the service record for this server in
+ *                          the SDP database. If a requested lower layer protocol is not supported
+ *                          the protocol field with be set to OI_OBEX_LOWER_NONE.
+ *
+ * @param numProtocols      The length of the lowerProtocolList.
+ *
+ * @param policy            The connection policy to use.  Policy may not be null.
+ *
+ * @param serverHandle      [Out] Returns a handle for the server instance. This handle is used when
+ *                          deregistering the server or when registering secondary targets.
+ *
+ * @return                 OI_OK if successful or an error status if the target
+ *                         could not be registered
+ */
+OI_STATUS OI_OBEXSRV_RegisterServer(const OI_OBEX_BYTESEQ *target,
+                                    const OI_OBEXSRV_CB_LIST *CBList,
+                                    OI_OBEXSRV_AUTHENTICATION authentication,
+                                    OI_OBEX_CONNECTION_OPTIONS *connectOptions,
+                                    OI_OBEX_LOWER_PROTOCOL *lowerProtocolList,
+                                    OI_UINT8 numProtocols,
+                                    const OI_CONNECT_POLICY *policy,
+                                    OI_OBEX_SERVER_HANDLE *serverHandle);
+
+/**
+ * This function registers an additional target on an existing OBEX server.
+ *
+ * @param target            a byte sequence that identifies the OBEX target for
+ *                          the service being registered; must not be NULL.
+ *
+ * @param CBList           pointer to a list of the application functions that
+ *                         will be called when the OBEX server receives a get or
+ *                         put request
+ *
+ *
+ * @param authentication   specifies whether authentication is required on
+ *                         connections to this server, with TRUE indicating that
+ *                         authentication is required
+ *
+ * @param serverHandle     specifies a server handle for an already-registered OBEX server to which
+ *                         the secondary target will be attached.
+ *
+ * @return                 OI_OK if successful or an error status if the target
+ *                         could not be registered
+ */
+
+OI_STATUS OI_OBEXSRV_RegisterSecondaryTarget(const OI_OBEX_BYTESEQ *target,
+                                             const OI_OBEXSRV_CB_LIST *CBList,
+                                             OI_OBEXSRV_AUTHENTICATION authentication,
+                                             OI_OBEX_SERVER_HANDLE serverHandle);
+
+/**
+ * This function deregisters an OBEX server so that it will no longer accept put
+ * and/or get requests from OBEX clients for the specified target. This will
+ * also deregister any secondary targets associated with this server.
+ *
+ * To deregister a server that has active connections, terminate the connections
+ * using OI_OBEXSRV_ForceDisconnect() first; then deregister the server.
+ *
+ * @param serverHandle   the handle for the server
+ *
+ * @return    status code indicating the result of the command to deregister the server:
+ *            - OI_OK if the target was deregistered;
+ *            - OI_OBEX_SERVICE_UNAVAILABLE if the server handle is invalid
+ *            - OI_OBEX_OPERATION_IN_PROGRESS if a client is connected to the
+ *              service. To deregister a server that is in use, the application
+ *              should call OI_OBEXSRVE_ForceDisconnect() and then call
+ *              OI_OBEXSRV_DeregisterServer() again after the disconnect
+ *              indication is reported.
+ */
+
+OI_STATUS OI_OBEXSRV_DeregisterServer(OI_OBEX_SERVER_HANDLE serverHandle);
+
+
+/**
+ * This function returns TRUE if any client is currently connected to the server
+ * associated with the specified server handle. If it returns FALSE, the server
+ * is not in use, and deregistration will be successful.
+ *
+ * @param serverHandle   the handle for the server to deregister.
+ *
+ * @return                TRUE if the server is busy.
+ */
+OI_BOOL OI_OBEXSRV_IsServerBusy(OI_OBEX_SERVER_HANDLE serverHandle);
+
+
+/**
+ * Associates a caller defined context with an OBEX server connection. This
+ * context can then be retrieved by calling OI_OBEXSRV_GetConnectionContext().
+ *
+ * @param connectionId   The connection to associate the context with.
+ *
+ * @param context         A value supplied by the caller.
+ *
+ * @return                OI_OK if the context was set, OI_STATUS_NOT_FOUND if
+ *                        the connection id is not valid.
+ */
+OI_STATUS OI_OBEXSRV_SetConnectionContext(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                          void *context);
+
+
+/**
+ * Gets a caller defined context associate with an OBEX server connection. This is a value
+ * that we previously set by a call to OI_OBEXSRV_SetConnectionContext().
+ *
+ * @param connectionId    The OBEX server connection to get the context from.
+ *
+ * @return                A context pointer or NULL if the handle is invalid or
+ *                        there is no context associated with this connection.
+ */
+void* OI_OBEXSRV_GetConnectionContext(OI_OBEXSRV_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * Associates a caller defined context with an OBEX server instance. This
+ * context can then be retrieved by calling OI_OBEXSRV_GetServerContext().
+ *
+ * @param serverHandle    the handle for the server
+ *
+ * @param context         A value supplied by the caller.
+ *
+ * @return                OI_OK if the context was set, OI_STATUS_NOT_FOUND if
+ *                        the connection id is not valid.
+ */
+OI_STATUS OI_OBEXSRV_SetServerContext(OI_OBEX_SERVER_HANDLE serverHandle,
+                                      void *context);
+
+
+/**
+ * Gets a caller defined context associate with an OBEX server. This is a value
+ * that we previously set by a call to OI_OBEXSRV_SetServerContext().
+ *
+ * @param serverHandle   the handle for the server
+ *
+ * @return               A context pointer or NULL if the handle is invalid or
+ *                       there is no context associated with this connection.
+ */
+void* OI_OBEXSRV_GetServerContext(OI_OBEX_SERVER_HANDLE serverHandle);
+
+
+/**
+ * @param connectionHandle  The OBEX server connection to get the server handle from.
+ *
+ * @return    The server handle for this connection or NULL if the connection handle is invalid.
+ */
+OI_OBEX_SERVER_HANDLE OI_OBEXSRV_GetServerHandle(OI_OBEXSRV_CONNECTION_HANDLE connectionHandle);
+
+
+/**
+ * Returns a count of the number of clients connected to this server.
+ *
+ * @param serverHandle   the handle for the server
+ *
+ * @return  The number of connected clients
+ */
+OI_UINT OI_OBEXSRV_GetNumConnections(OI_OBEX_SERVER_HANDLE serverHandle);
+
+
+/**
+ * Returns a text string corresponding to authentication enum value
+ */
+const OI_CHAR* OI_OBEXSRV_AuthenticationText(OI_OBEXSRV_AUTHENTICATION authentication);
+
+
+/**
+ * Given an OBEX server connection handle this function returns the L2CAP channel for this
+ * connection. In the case of OBEX/RFCOMM this is the L2CAP channel for the underlying RFCOMM
+ * session. In the case of OBEX/L2CAP this is the L2CAP channel for the OBEX connection.
+ *
+ * @param connectionId  The OBEX server connection to get the L2CAP channel for
+ * @param cid           Pointer to out parameter for the L2CAP CID
+ *
+ * @return      - OI_OK if the context was set,
+ *              - OI_STATUS_NOT_FOUND if the connection id is not valid.
+ *              - OI_STATUS_NOT_CONNECTED if the connection is not up or is disconnecting
+ *
+ *
+ */
+OI_STATUS OI_OBEXSRV_GetL2capCID(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                 OI_L2CAP_CID *cid);
+
+/**
+ * This function returns the raw header list associated with a server callback.  This function
+ * must only be called from within a server callback, otherwise results are unpredictable.
+ *
+ * Some OBEX commands have optional headers (e.g. realm information in an authentication challenge);
+ * this API makes those headers available to applications.
+ *
+ * @param connectionId  The OBEX server connection
+
+ * @param pRawHeaderList    Pointer where OBEX will store pointers to the raw header list.
+ *
+ * @return      - OI_OK, pRawHeaderList contains pointer to header list, may be NULL.
+ *              - any other status, pRawHeaderList returned is undefined
+ */
+OI_STATUS OI_OBEXSRV_GetRawHeaderList(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
+                                      OI_OBEX_HEADER_LIST          **pRawHeaderList);
+
+/*****************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_OBEXSRV_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_opp_client.h b/obex_profiles/sdk/include/profiles/oi_opp_client.h
new file mode 100644
index 0000000..18d0b15
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_opp_client.h
@@ -0,0 +1,305 @@
+#ifndef _OI_OPP_CLIENT_H_
+#define  _OI_OPP_CLIENT_H_
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @file
+
+  This file provides the API for the client side of the Object Push Profile.
+
+  The Object Push Profile provides functions for establishing a connection to a
+  remote device over RFCOMM and functions for pushing and pulling objects, such
+  as vCard (business card) and vCal (calendar entry) objects. A Bluetooth device
+  address and an RFCOMM channel number are required for setting up the
+  connection. Unless the application already knows the RFCOMM channel number,
+  the application will need to perform service discovery to obtain the channel
+  number.
+
+  After a connection has been established, the application can call
+  OI_OPPClient_Push() to send objects to the server and OI_OPPClient_Pull() to
+  retrieve the default object from the server. The default object is the owner's
+  vCard business card.
+ */
+
+#include "oi_obexspec.h"
+#include "oi_obex.h"
+#include "oi_opp_sys.h"
+
+/** \addtogroup OPP OPP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/**
+ * Completion or notification events returned to the application via the @ref
+ * OI_OPP_CLIENT_EVENT_CB callback function. The event indicates completion, the
+ * accompanying status code indicates if the operation succeeded or failed. The
+ * completion of a pull operation, OI_OPPClient_Pull(), is not signalled by and
+ * event, rather a callback function is called with the pulled object.
+ */
+typedef enum {
+    OI_OPP_CLIENT_CONNECTED,     /**< The client has connected to an OPP server */
+    OI_OPP_CLIENT_DISCONNECT,    /**< The client is now disconnected from an OPP server */
+    OI_OPP_CLIENT_PUSH_STARTED,  /**< A push operation was started. (Must call OI_OPPClient_NameOverride if enabled) */
+    OI_OPP_CLIENT_PULL_STARTED,  /**< A pull operation was started. (Must call OI_OPPClient_NameOverride if enabled) */
+    OI_OPP_CLIENT_PUSH_PROGRESS, /**< Push operation Progress Report */
+    OI_OPP_CLIENT_PULL_PROGRESS, /**< Pull operation Progress Report */
+    OI_OPP_CLIENT_PUSH_COMPLETE, /**< A push operation is complete */
+    OI_OPP_CLIENT_PULL_COMPLETE  /**< A pull operation is complete */
+} OI_OPP_CLIENT_EVENT;
+
+/**
+ * Structure for passing OPP Client events to application. This is a
+ * tagged/typed structure which includes a union of structures who's meaning is
+ * dependant on the actual OI_OPP_CLIENT_EVENT code.
+ */
+
+typedef struct {
+    OI_OPP_CLIENT_EVENT         event;           /**< Event being posted */
+    /// @cond
+    union {
+        struct {
+            const OI_OBEX_UNICODE *fileName;        /**< File name being pushed */
+            OI_UINT32              totalBytes;      /**< Total bytes in file being pushed (if known) */
+        } pushStarted;                              /**< Union structure valid for @ref OI_OPP_CLIENT_PUSH_STARTED */
+        struct {
+            const OI_OBEX_UNICODE *fileName;        /**< File name being pulled */
+            OI_UINT32              totalBytes;      /**< Total bytes in file being pulled (if known) */
+        } pullStarted;                              /**< Union structure valid for @ref OI_OPP_CLIENT_PULL_STARTED */
+        struct {
+            OI_UINT32              bytesTransferred;/**< Total bytes pushed so far for this object */
+        } pushProgress;                             /**< Union structure valid for @ref OI_OPP_CLIENT_PUSH_PROGRESS */
+        struct {
+            OI_UINT32              bytesTransferred;/**< Total bytes pulled so far for this object */
+        } pullProgress;                             /**< Union structure valid for @ref OI_OPP_CLIENT_PULL_PROGRESS */
+        struct {
+            OI_UINT32              finalSize;       /**< Final bytes pulled for this object */
+        } pushComplete;                             /**< Union structure valid for @ref OI_OPP_CLIENT_PUSH_COMPLETE */
+        struct {
+            OI_UINT32              finalSize;       /**< Final bytes pushed for this object */
+        } pullComplete;                             /**< Union structure valid for @ref OI_OPP_CLIENT_PULL_COMPLETE */
+    } data;
+    /// @endcond
+} OI_OPP_CLIENT_EVENT_DATA;
+
+/**
+ *  Represents an active connection between a OPP client and a remote OPP server
+ */
+typedef OI_OPP_CONNECTION OI_OPP_CLIENT_CONNECTION_HANDLE;
+
+
+/**
+ * The application must provide a function with this profile to
+ * OI_OPPClient_Connect() when starting the object push client. This function
+ * is called to signal to the application when various operations completed; see
+ * @ref OI_OPP_CLIENT_EVENT_DATA.
+ *
+ * @param connectionId  handle representing the connection to the OPP server.
+
+ * @param evtPtr        identifies the completion or notification event that is
+ *                      being signalled.
+ *
+ * @param status        indicates if the operation succeeded, OI_OK, or failed
+ *                      with an error.
+ */
+typedef void (*OI_OPP_CLIENT_EVENT_CB)(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                                       const OI_OPP_CLIENT_EVENT_DATA *evtPtr,
+                                       OI_STATUS                       status);
+
+/**
+ * Connect to remote OBEX object push profile server.
+ *
+ * @param addr             the address of a remote Bluetooth device that supports OPP.
+ *
+ * @param lowerProtocol    This is identifies the RFCOMM channel number or the L2CAP PSM for the
+ *                         FTP server running on the remote device.  the remote device. The caller
+ *                         will normally perform service discovery on the remote device to obtain
+ *                         the required channel number or PSM.
+ *
+ * @param connectionId    (OUT) pointer to return the OPP connection handle.
+ *
+ * @param eventCB         a callback function that is called when OPP client
+ *                        operations complete.
+ *
+ * @param objectFunctions A set of functions that provide an interface to an
+ *                        object management system that supports opening,
+ *                        reading, writing of objects.
+ *
+ * @returns OI_OK if the connection request was sent.
+ */
+OI_STATUS OI_OPPClient_Connect(OI_BD_ADDR *addr,
+                               OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                               OI_OPP_CLIENT_CONNECTION_HANDLE *connectionId,
+                               OI_OPP_CLIENT_EVENT_CB eventCB,
+                               const OI_OPP_OBJSYS_FUNCTIONS *objectFunctions);
+
+/**
+ * Terminate the current OBEX connection to a remote OPP server.
+ *
+ * @param connectionId  handle representing the connection to the OPP server.
+ */
+OI_STATUS OI_OPPClient_Disconnect(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * Push an object to an OBEX server. The object type must be one of the object
+ * types supported by the server. The list of supported object types is obtained
+ * from the service record for the server.
+ *
+ * @param connectionId  handle representing the connection to the OPP server.
+ *
+ * @param name          a NULL-terminated unicode name of the object to be pushed.
+ *
+ * @param type          object type
+ *
+ * @return OI_OK if the push command was sent, OI_OBEX_NOT_CONNECTED if a
+ *               connection has not yet been established.
+ */
+OI_STATUS OI_OPPClient_Push(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                            const OI_OBEX_UNICODE *name,
+                            const OI_CHAR *type);
+
+
+/**
+ * Pull the default object from an OBEX server. The default object is the
+ * owner's business card which is an OBEX object of type @ref
+ * OI_OBEX_VCARD_TYPE.
+ *
+ * @param connectionId  handle representing the connection to the OPP server.
+ *
+ * @return OI_OK if the pull request was sent, OI_OBEX_NOT_CONNECTED if a
+ *               connection has not yet been established.
+ */
+OI_STATUS OI_OPPClient_Pull(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId);
+
+
+
+
+/**
+ * Callback invoked when the cancellation of an operation is completed.
+ *
+ * @param connectionId  handle representing the connection to the OPP server.
+ */
+typedef void (*OI_OPP_CLIENT_CANCEL_CFM)(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId);
+
+/**
+ * Terminate the current push or pull operation.
+ *
+ * @param connectionId  handle representing the connection to the OPP server.
+ *
+ * @param cancelCfm     Callback to call when cancellation is complete (may be NULL)
+ *                      May or may not be called, depending on return value (see below)
+ *
+ * @return      OI_OK - The OBEX ABORT transaction has been initiated and the
+ *                      cancelCfm callback will be called when the ABORT completes.
+ *
+ *              OI_STATUS_PENDING - There is an OPP PUSH or PULL in progress which must
+ *                      complete before the OBEX ABORT can be sent.  When the ABORT
+ *                      completes, the OI_OPP_CLIENT_EVENT_CB will be called with
+ *                      PUSH (or PULL) COMPLETE event, status OI_OBEX_CLIENT_ABORTED_COMMAND.
+ *                      Note that in this case, the cancelCfm callback is *NOT* called.
+ *
+ *              Any other value indicates error, no callbacks will be called.
+ */
+OI_STATUS OI_OPPClient_Cancel(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                              OI_OPP_CLIENT_CANCEL_CFM cancelCfm);
+
+/**
+ * This function sets name overriding. If name Overriding is set to TRUE, the
+ * OI_OPPClient_NameOverride() function MUST be called upon delivery of the
+ * OI_OPP_CLIENT_PULL_STARTED or OI_OPP_CLIENT_PUSH_STARTED event.
+ *
+ * NOTE: Until called for each connection, nameOverrideEnabled defaults to FALSE
+ *       to maintain legacy functionality.
+ *
+ * @param connectionId         Handle representing the connection to the OPP server.
+ *
+ * @param nameOverrideEnabled  TRUE - This client connection requires the App to call
+ *                                    OI_OPPClient_NameOverride to specify or confirm
+ *                                    the name used locally (for PULLs) or remotely (for PUSHs).
+ *                             FALSE - Default name will always be used.
+ *
+ * @return                     OI_OK - This command always succeeds if connected to
+ *                                     a server, and fails otherwise.
+ *
+ */
+OI_STATUS OI_OPPClient_EnableNameOverride(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                                          OI_BOOL                         nameOverrideEnabled);
+
+/**
+ * Supply Object Name. This call must be made after receiving the
+ * OI_OPP_CLIENT_PULL_STARTED or OI_OPP_CLIENT_PUSH_STARTED event, if application
+ * has previously specified Name Overriding with OI_OPPClient_EnableNameOverride().
+ *
+ * This call will fail if in an invalid state, or Name Override not enabled.
+ *
+ * On PULL, the name provided by this function is used to save the object in the
+ * local storage system.
+ *
+ * On PUSH, the name provided is used in the OI_OBEX_HDR_NAME for the outgoing
+ * object.
+ *
+ * @param connectionId  handle representing the connection to the OPP server.
+ *
+ * @param name          NULL to confirm name provided by OI_OPPClient_Push
+ *                      or the incoming OBEX packet. Or a legal UNICODE name to
+ *                      override the default.
+ *
+ * @return      OI_OK - If this command succeeds. Any other return indicates a
+ *                      failure.
+ *
+ */
+OI_STATUS OI_OPPClient_NameOverride(OI_OPP_CLIENT_CONNECTION_HANDLE connectionId,
+                                    const OI_OBEX_UNICODE          *name);
+
+/*************************************************************
+
+    Debug print helpers
+
+        Returns null string when compiled for release mode
+
+*************************************************************/
+
+extern OI_CHAR  *OI_OPPClient_eventText(OI_OPP_CLIENT_EVENT event) ;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OPP_CLIENT_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_opp_ofs.h b/obex_profiles/sdk/include/profiles/oi_opp_ofs.h
new file mode 100644
index 0000000..a77c8f6
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_opp_ofs.h
@@ -0,0 +1,62 @@
+#ifndef _OI_OPP_OFS_H
+#define _OI_OPP_OFS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ @file
+
+ Object management system abstraction layer used by the the object push profile
+ client and server.
+
+*/
+
+#include "oi_opp_sys.h"
+
+/** \addtogroup OPP OPP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+void OI_OPP_Objsys_Functions(OI_OPP_OBJSYS_FUNCTIONS *objops);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_OPP_OFS_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_opp_server.h b/obex_profiles/sdk/include/profiles/oi_opp_server.h
new file mode 100644
index 0000000..e2a3594
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_opp_server.h
@@ -0,0 +1,311 @@
+#ifndef _OI_OPP_SERVER_H
+#define _OI_OPP_SERVER_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @file
+  This file provides the API for the server side of the Object Push Profile.
+  The Object Push Profile provides functions for establishing a connection to a
+  remote device that support the Object Push Profile over RFCOMM and
+  functions for pushing and pulling objects. This implementation currently only
+  allows one connection at a time.
+ */
+
+#include "oi_status.h"
+#include "oi_opp_sys.h"
+#include "oi_obexspec.h"
+#include "oi_sdp.h"
+#include "oi_dataelem.h"
+
+/** \addtogroup OPP OPP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * represents an active connection between the local OPP server and a remote
+ * OPP client
+ */
+typedef OI_OPP_CONNECTION OI_OPP_SERVER_CONNECTION_HANDLE;
+
+
+/**
+ * Represents a registered OPP server
+ */
+typedef OI_OBEX_SERVER_HANDLE OI_OPP_SERVER_HANDLE;
+
+
+/*
+ * OBEX object types that might be supported by an OPP server.
+ * Bits not specified below are reserved.
+ */
+#define OI_OPP_SERVER_OBJ_FORMAT_ANY       0xFFFFFFFF /**< Any format is supported */
+#define OI_OPP_SERVER_OBJ_FORMAT_VCARD_2_1 OI_BIT0
+#define OI_OPP_SERVER_OBJ_FORMAT_VCARD_3_0 OI_BIT1
+#define OI_OPP_SERVER_OBJ_FORMAT_VCAL_1_0  OI_BIT2
+#define OI_OPP_SERVER_OBJ_FORMAT_ICAL_2_0  OI_BIT3
+#define OI_OPP_SERVER_OBJ_FORMAT_VNOTE     OI_BIT4
+#define OI_OPP_SERVER_OBJ_FORMAT_VMESSAGE  OI_BIT5
+
+
+/**
+ * Supported formats are ORed together and passed in to OI_OPPServer_Register().
+ */
+typedef OI_UINT32 OI_OPP_SERVER_OBJECT_FORMATS;
+
+/**
+ * List of events which may be generated by Server when triggered by remote
+ * client activity.
+ */
+typedef enum {
+    OI_OPP_SERVER_EVENT_PUSH = 0,
+    OI_OPP_SERVER_EVENT_PULL,
+    OI_OPP_SERVER_EVENT_PUSH_PROGRESS,
+    OI_OPP_SERVER_EVENT_PULL_PROGRESS,
+    OI_OPP_SERVER_EVENT_PUSH_COMPLETE,
+    OI_OPP_SERVER_EVENT_PULL_COMPLETE
+} OI_OPP_SERVER_EVENT;
+
+typedef struct {
+    OI_OPP_SERVER_EVENT     event;
+    /// @cond
+    union {
+        struct {
+            const OI_OBEX_UNICODE *localName;   /* if known, else NULL */
+            OI_UINT32              totalSize;   /* if known, else 0 */
+            const OI_CHAR         *objType;     /* if known, else 0 */
+        } push;
+        struct {
+            const OI_OBEX_UNICODE *localName;   /* if named, else NULL for default object */
+            OI_UINT32              totalSize;   /* if known, else 0 */
+            const OI_CHAR         *objType;     /* if known, else 0 */
+        } pull;
+        struct {
+            OI_UINT32              bytesTransferred;
+        } pushProgress;
+        struct {
+            OI_UINT32              bytesTransferred;
+        } pullProgress;
+        struct {
+            OI_UINT32              finalSize;
+            OI_STATUS              status;           /**< Status of the transfer upon completion */
+        } pushComplete;
+        struct {
+            OI_UINT32              finalSize;
+            OI_STATUS              status;           /**< Status of the transfer upon completion */
+        } pullComplete;
+    } data;
+    /// @endcond
+
+} OI_OPP_SERVER_EVENT_DATA;
+
+
+
+/**
+ * The application must provide a function of this type to OI_OPPServer_Register()
+ * to be called when a client attempts to connect to the OPP server. The
+ * application must call OI_OPP_AcceptConnect() to accept or reject the
+ * connection request.
+ *
+ * @param clientAddr    The Bluetooth device address of the client that is
+ *                      attempting to connect.
+ *
+ * @param connectionId  handle representing the connection between a remote
+ *                      client and the local OPP server.
+ *
+ */
+typedef void (*OI_OPP_SERVER_CONNECT_IND)(OI_BD_ADDR *clientAddr,
+                                          OI_OPP_SERVER_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * The application must provide a function of this type to OI_OPPServer_Register()
+ * to be called when a client disconnects from the OPP server.
+ *
+ * @param connectionId  handle representing the connection between a remote
+ *                      client and the local OPP server.
+ *
+ */
+typedef void (*OI_OPP_SERVER_DISCONNECT_IND)(OI_OPP_SERVER_CONNECTION_HANDLE connectionId);
+
+/**
+ * The application *may* provide an event handler to receive various indications
+ * of activity. Some event indications such as PUSH start indications require an
+ * acceptance of the incoming file. This callback may be NULL, in which case the
+ * default action if required will be performed automatically.
+ *
+ * @param connectionId  handle representing the connection between a remote
+ *                      client and the local OPP server.
+ *
+ * @param eventPtr      pointer to structure indicating what event occured.
+ *
+ */
+typedef void (*OI_OPP_SERVER_EVENT_IND)(OI_OPP_SERVER_CONNECTION_HANDLE connectionId,
+                                        OI_OPP_SERVER_EVENT_DATA       *eventPtr);
+
+typedef struct {
+    OI_OPP_SERVER_CONNECT_IND    connectInd;        /* Mandatory */
+    OI_OPP_SERVER_DISCONNECT_IND disconnectInd;     /* Mandatory */
+    OI_OPP_SERVER_EVENT_IND      eventInd;          /* Optional (may be NULL) */
+} OI_OPP_SERVER_CALLBACKS;
+
+
+/**
+ * The OPP application must call this function to accept or reject a connect
+ * request from a client.
+ *
+ * @param connectionId  handle representing the connection between a remote
+ *                      client and the local OPP server.
+ *
+ * @param  allowPush   If TRUE the connection is accepted and the client will
+ *                     be allowed to push objects to the server. If allowPush
+ *                     and allowPull are both FALSE the connection is rejected.
+ *
+ * @param  allowPull   If TRUE the connection is accepted and the client will be
+ *                     allowed to pull objects from the server. If allowPull and
+ *                     allowPush are both FALSE the connection is rejected.
+ */
+
+OI_STATUS OI_OPP_AcceptConnect(OI_OPP_SERVER_CONNECTION_HANDLE connectionId,
+                               OI_BOOL allowPush,
+                               OI_BOOL allowPull);
+
+/**
+ * Forcibly severs the connection from an OPP client to the OPP server. This
+ * function should be called for all active connections before terminating the
+ * OPP server.
+ *
+ * @param connectionId  handle representing the connection between a remote
+ *                      client and the local OPP server.
+ *
+ * @return              OI_OK if the connection will be terminated.
+ */
+
+OI_STATUS OI_OPPServer_ForceDisconnect(OI_OPP_SERVER_CONNECTION_HANDLE connectionId);
+
+
+/**
+ * Initialize the Object Push server and register it in the service discovery
+ * database.
+ *
+ * @param callbacks            This structure pointer contains list of all
+ *                             callbacks which may come from the server due to
+ *                             remote client activity.
+ *
+ * @param supportedFormats     OPP object formats supported by this server,
+ *                             composed by OR'ing together the various format flags.
+ *
+ * @param objectOperations     the set of operations that interface to the
+ *                             application's object management system.
+ *
+ * @param strings              name to register in service record
+ *
+* @param serverInstance        [OUT] returns a handle for the OPP server instance. This handle
+ *                             is required to deregsiter the OPP server, see OI_OPPServer_Deregister().
+ *
+ * @return                     OI_OK if the service was initialized and registered succesfully with SDP
+ */
+
+OI_STATUS OI_OPPServer_Register(const OI_OPP_SERVER_CALLBACKS *callbacks,
+                                const OI_OPP_OBJSYS_FUNCTIONS *objectOperations,
+                                OI_OPP_SERVER_OBJECT_FORMATS   supportedFormats,
+                                const OI_SDP_STRINGS          *strings,
+                                OI_OPP_SERVER_HANDLE          *serverInstance);
+
+
+/**
+ * Get the service record handle associated with this service.
+ * This can be used with e.g. OI_SDPDB_SetAttributeList to add
+ * vendor-specific SDP attributes to the profile.
+ *
+ * @param serverInstance   identifies the registered server instance.
+ *
+ * @param handle           return the service record's handle
+ */
+OI_STATUS OI_OPPServer_GetServiceRecord(OI_OPP_SERVER_HANDLE serverInstance,
+                                        OI_UINT32 *handle);
+
+/**
+ * Deregisters an OPP server.
+ *
+ * @param serverInstance  The server instance handle that was returned when the server was
+ *                        registered.
+ *
+ * @return                OI_OK if the service was successfully deregistered.
+ *
+ */
+OI_STATUS OI_OPPServer_Deregister(OI_OPP_SERVER_HANDLE serverInstance);
+
+/**
+ * Accept/Reject incoming (PUSH) object. This function must be called by the
+ * App upon reception of the OI_OPP_SERVER_EVENT_PUSH event, to allow storage
+ * of the incoming object in the local object storage system.
+ *
+ * Note: For legacy purposes, this function is required only if OI_OPP_SERVER_EVENT_IND
+ *       has been registered as part of the OI_OPP_SERVER_CALLBACKS.
+ *
+ * @param connectionId    The server connection handle that was returned when the server
+ *                        connection was opened.
+ *
+ * @param objname         File or Object name to store incoming object to, or
+ *                        NULL to keep/confirm default incoming object name.
+ *
+ * @param accept          TRUE - Accept incoming file, FALSE - Reject
+ *
+ * @return                OI_OK if the rcvObject was successfuly opened for
+ *                        writing (or if rejecting).
+ *
+ */
+OI_STATUS OI_OPPServer_AcceptPush(OI_OPP_SERVER_CONNECTION_HANDLE connectionId,
+                                  OI_OBEX_UNICODE                *objname,
+                                  OI_BOOL                         accept);
+
+/*************************************************************
+
+    Debug print helpers
+
+        Returns null string when compiled for release mode
+
+*************************************************************/
+
+extern OI_CHAR  *OI_OPPServer_eventText(OI_OPP_SERVER_EVENT event) ;
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_OPP_SERVER_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_opp_sys.h b/obex_profiles/sdk/include/profiles/oi_opp_sys.h
new file mode 100644
index 0000000..80a8319
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_opp_sys.h
@@ -0,0 +1,376 @@
+#ifndef _OI_OPP_SYS_H
+#define _OI_OPP_SYS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ @file
+
+ This file provides the object system abstraction layer used by
+ the  Object Push Profile client and server.
+
+ This interface is described entirely as callback functions. The application
+ must provide the sets of functions to the OPP client and OPP server
+ when initializing these two services.
+
+ Callbacks and errors are mutually exclusive.
+    If a function below returns OI_OK, the callback must be called,
+    either from within the function or on a later thread of execution.
+
+    If a function below returns anything other than OI_OK, the callback
+    must NOT be called.
+
+ Note that if you wish your application to be
+ BQB-compliant, you should generate error codes consistent with
+ BLUEmagic 3.0 best practices; see the sample code for examples.
+
+*/
+
+#include "oi_status.h"
+#include "oi_stddefs.h"
+#include "oi_obex.h"
+#include "oi_obexspec.h"
+
+
+/** \addtogroup OPP OPP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This type represents an opaque object that uniquely identifies an object that
+ * has been opened for either reading or writing.
+ */
+typedef void* OI_OPP_HANDLE;
+
+
+/**
+ * This type represents a connection id for an OPP client or server connection
+ * that is making calls into the object system abstraction layer.
+ */
+typedef OI_OBEX_CONNECTION_HANDLE OI_OPP_CONNECTION;
+
+
+/* ********************************************************************************
+ * The object functions are all asynchronous. However implementations are
+ * permitted to call the callback function from within the function if the
+ * operation can be completed quickly. This will be the case for many
+ * implementations.
+ * ********************************************************************************/
+
+
+
+/**
+ * A function of this type is called to confirm the success or failure opening
+ * an object for reading
+ *
+ * @param objHandle   A handle that can be used to read the object contents.
+ *
+ * @param name        A null-terminated unicode string name of the object that was opened.
+ *
+ * @param type        A null-terminated ascii string for the object type. For example
+ *                    for a vCard the type string is "text/x-vCard"
+ *
+ * @param size        If the object was opened for reading, size is the number
+ *                    of bytes that can be read from the object. If the object
+ *                    was opened for writing the value is undefined.
+ *
+ * @param data           A pointer to a buffer containing the data read.
+ *
+ * @param len            The number of bytes read.
+ *
+ * @param status      OI_OK if the object could be opened, an error if the object
+ *                    could not be opened.
+ *
+ * @param oppConnection identifies which OPP client or server connection is
+ *                   performing this operation.
+ */
+typedef void (*OI_OPP_OPEN_READ_CFM)(OI_OPP_HANDLE objHandle,
+                                     const OI_OBEX_UNICODE *name,
+                                     const OI_CHAR *type,
+                                     OI_UINT32 size,
+                                     OI_BYTE *data,
+                                     OI_UINT32 len,
+                                     OI_STATUS status,
+                                     OI_OPP_CONNECTION oppConnection);
+
+/**
+ * This function and corresponding callback is needed by an OPP client and server.
+ *
+ * @param name           a null-terminated unicode string name of the object to
+ *                       be opened. A NULL name means open the default object.
+ *                       The default object is the owner's business card.
+ *
+ * @param type           a null-terminated ascii string for the object type.
+ *
+ * @param maxRead        the maximum number of bytes to read from the object on this
+ *                       call.
+ *
+ * @param openCfm        the function that will be called when the open completes.
+ *
+ * @param oppConnection  identifies the OPP client or server connection that is
+ *                       performing this operation.
+ */
+typedef OI_STATUS (*OI_OPP_OPEN_READ)(const OI_OBEX_UNICODE *name,
+                                      const OI_CHAR *type,
+                                      OI_UINT32 maxRead,
+                                      OI_OPP_OPEN_READ_CFM openCfm,
+                                      OI_OPP_CONNECTION oppConnection);
+
+
+/**
+ * A function of this type is called to confirm the success or failure opening
+ * an object for writing.
+ *
+ * @param objHandle      A handle that can be used to write the object contents.
+ *
+ * @param status         OI_OK if the object could be opened to write or
+ *                       an error if the object could not be opened.
+ *
+ * @param oppConnection  identifies the OPP client or server connection that is
+ *                       performing this operation.
+ */
+typedef void (*OI_OPP_OPEN_WRITE_CFM)(OI_OPP_HANDLE objHandle,
+                                      OI_STATUS status,
+                                      OI_OPP_CONNECTION oppConnection);
+
+/**
+ * This function and corresponding callback is needed by an OPP client and server.
+ *
+ * @param name           a NULL terminated unicode string name of the object to
+ *                       be opened. A NULL name means that the remote OPP device
+ *                       did not provide a file name for the object.  (This can
+ *                       happen when pulling a default object from a device that
+ *                       follows the IrDA OBEX spec over the Bluetooth OPP spec.)
+ *
+ * @param type           a NULL terminated ascii string for the object type.
+ *
+ * @param objSize        a hint about the size of the object.
+ *
+ * @param openCfm        the function to be called when the open completes.
+ *
+ * @param oppConnection  identifies the OPP client or server connection that is
+ *                       performing this operation.
+ */
+typedef OI_STATUS (*OI_OPP_OPEN_WRITE)(const OI_OBEX_UNICODE *name,
+                                       const OI_CHAR *type,
+                                       OI_UINT32 objSize,
+                                       OI_OPP_OPEN_WRITE_CFM openCfm,
+                                       OI_OPP_CONNECTION oppConnection);
+
+/**
+ * This function does not use a callback function. It is assumed that object
+ * close will complete asynchronously or in the case of a failure will report or
+ * log an error with the application.
+ *
+ * @param handle         A handle for an open object.
+ *
+ * @param status         OI_OK or an error status if the object is being closed
+ *                       because of an error. In this case if the object was
+ *                       being written the state of the object is unknown and
+ *                       the application may choose to delete the object.
+ *
+ * @param oppConnection  identifies the OPP client or server connection that is
+ *                       performing this operation.
+ */
+typedef void (*OI_OPP_CLOSE)(OI_OPP_HANDLE objHandle,
+                             OI_STATUS status,
+                             OI_OPP_CONNECTION oppConnection);
+
+/**
+ * A function of this type is called to confirm the success or failure of a
+ * object read.
+ *
+ * @param objHandle      handle passed to the read call.
+ *
+ * @param data           A pointer to a buffer containing the data read.
+ *
+ * @param len            The number of bytes read.
+ *
+ * @param status         a status code indicating if the read was succesful:
+ *                       - OI_OK if the read completed
+ *                       - OI_STATUS_END_OF_FILE if the read was successful and
+ *                         the end of object has been reached.
+ *                       - An error status indicating that the read failed.
+ *
+ * @param oppConnection  identifies the OPP client or server connection that is
+ *                       performing this operation.
+ *
+ */
+typedef void (*OI_OPP_READ_CFM)(OI_OPP_HANDLE objHandle,
+                                OI_BYTE *data,
+                                OI_UINT32 len,
+                                OI_STATUS status,
+                                OI_OPP_CONNECTION oppConnection);
+
+/**
+ * This function and corresponding callback is needed by an OPP client that
+ * supports object push and and opp server that supports object pull.
+ *
+ * @param objHandle   a handle previously returned by an OI_OPP_OPEN_CFM function
+ *
+ * @param maxRead     the maximum number of bytes to read from the object on this
+ *                    call.
+ *
+ * @param readCfm     the function that will be called when the read completes.
+ *
+ * @param oppConnection  identifies the OPP client or server connection that is
+ *                       performing this operation.
+ */
+typedef OI_STATUS (*OI_OPP_READ)(OI_OPP_HANDLE objHandle,
+                                 OI_UINT32 maxRead,
+                                 OI_OPP_READ_CFM readCfm,
+                                 OI_OPP_CONNECTION oppConnection);
+
+
+/**
+ * A function of this type is called to confirm the success or failure of a object
+ * read multiple.
+ *
+ * @param numBuffers     The number of reads buffers returned by this call
+ *
+ * @param data           An array of buffers containing the data read.
+ *
+ * @param len            An array of lengths for the number of bytes in each buffer
+ *
+  * @param status         a status code indicating if the read was succesful:
+ *                       - OI_OK if the read completed
+ *                       - OI_STATUS_END_OF_FILE if the read was successful and
+ *                         the end of object has been reached.
+ *                       - An error status indicating that the read failed.
+ *
+ * @param oppConnection  Identifies which OPP client or server connection is
+ *                       performing this operation.
+ *
+ */
+
+typedef void (*OI_OPP_READ_MULTIPLE_CFM)(OI_OPP_HANDLE handle,
+                                         OI_UINT8 numBuffers,
+                                         OI_BYTE *data[],
+                                         OI_UINT32 len[],
+                                         OI_STATUS status,
+                                         OI_OPP_CONNECTION oppConnection);
+
+
+/**
+ * This function and corresponding callback is optional for an OPP client or server.
+ *
+ * @param handle          A handle previously returned by an OI_OPP_OPEN_CFM function
+ *
+ * @param numReads        The maximum number of mutiple reads that can be made on this call. May be
+ *                        zero in which case the readMultipleCfm callback will not be called.
+ *
+ * @param releaseBuf      Buffer previously passed in readMultipleCfm that can now be released. Will
+ *                        be NULL on the first ReadMultiple call.
+ *
+ * @param releaseBufLen   Length of the buffer that is being released.
+ *
+ * @param readMultipleCfm The function that will be called as each read completes. This parameter
+ *                        will be NULL if OPP is simply releasing buffers and does not require to be
+ *                        called back.
+ *
+ * @param oppConnection   Identifies which OPP client or server connection is performing this
+ *                        operation.
+ */
+typedef OI_STATUS (*OI_OPP_READ_MULTIPLE)(OI_OPP_HANDLE handle,
+                                          OI_UINT8 numReads,
+                                          OI_BYTE *releaseBuf,
+                                          OI_UINT32 releaseBufLen,
+                                          OI_OPP_READ_MULTIPLE_CFM readMultipleCfm,
+                                          OI_OPP_CONNECTION oppConnection);
+
+/**
+ * A function of this type is called to confirm the success or failure of a
+ * object write operation.
+ *
+ * @param objHandle      handle passed to the write call.
+ *
+ * @param status         Indicates the success or failure of the write operation.
+ *
+ * @param oppConnection  identifies which OPP client or server connection is
+ *                       performing this operation.
+ */
+typedef void (*OI_OPP_WRITE_CFM)(OI_OPP_HANDLE objHandle,
+                                 OI_STATUS status,
+                                 OI_OPP_CONNECTION oppConnection);
+
+
+/**
+ * This function and corresponding callback is only required by servers that
+ * support object push and clients that support object pull.
+ *
+ * @param objHandle      a handle previously returned by an OI_OPP_OPEN_CFM function
+ *
+ * @param buffer         a pointer to a buffer containing the data to be written to
+ *                       the object
+ *
+ * @param bufLen         the number of bytes to write to the object on this call.
+ *
+ * @param writeCfm       function that will be called when the read completes.
+ *
+ * @param oppConnection  identifies which OPP client or server connection is
+ *                       performing this operation.
+ */
+typedef OI_STATUS (*OI_OPP_WRITE)(OI_OPP_HANDLE objHandle,
+                                  const OI_BYTE *buffer,
+                                  OI_UINT32 bufLen,
+                                  OI_OPP_WRITE_CFM writeCfm,
+                                  OI_OPP_CONNECTION oppConnection);
+
+
+/* ********************************************************************************
+ *
+ *               Object operations
+ *
+ * ********************************************************************************/
+
+typedef struct {
+
+    OI_OPP_OPEN_READ       OpenRead;
+    OI_OPP_OPEN_WRITE      OpenWrite;
+    OI_OPP_CLOSE           Close;
+    OI_OPP_READ            Read;
+    OI_OPP_WRITE           Write;
+    OI_OPP_READ_MULTIPLE   ReadMultiple;
+
+} OI_OPP_OBJSYS_FUNCTIONS;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_OPP_SYS_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_pbap_client.h b/obex_profiles/sdk/include/profiles/oi_pbap_client.h
new file mode 100644
index 0000000..0f6d85a
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_pbap_client.h
@@ -0,0 +1,407 @@
+#ifndef _OI_PBAP_CLIENT_H
+#define _OI_PBAP_CLIENT_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * Phonebook Access Profile client API
+ *
+ * The Phonebook Access Profile provides functions for establishing a
+ * connection to a remote device that supports the Phonebook Access Profile
+ * over RFCOMM and functions for pulling vCards. This implementation currently
+ * only allows one connection at a time. A Bluetooth device address and an
+ * RFCOMM channel number are required for setting up the connection. Unless
+ * the application already knows the RFCOMM channel number, the application
+ * will need to perform service discovery to obtain the channel number.
+ *
+ * All phonebook data (vCards and vCard listings) go through the callbacks
+ * defined in oi_pbap_sys.h.  That is, when there is vCard data from the
+ * server, the open callback will be called to establish reference handle
+ * between the application and the PBAP client API.  The PBAP client API will
+ * then use the write callback to send the actual vCard data to the
+ * application.  The close callback lets the application know that get data
+ * operation is now complete.
+ */
+
+#include "oi_obexspec.h"
+#include "oi_obexcli.h"
+#include "oi_sdp.h"
+#include "oi_pbap_consts.h"
+#include "oi_pbap_sys.h"
+
+/** \addtogroup PBAP PBAP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * This function indicates the result of a connection attempt to a PBAP
+ * server.
+ *
+ * @param connectionId Handle representing the connection to the PBAP server.
+ *
+ * @param status       OI_OK if the connection succeeded, or an error code if
+ *                     the operation failed
+ */
+typedef void (*OI_PBAP_CONNECTION_CFM)(OI_PBAP_CONNECTION connectionId,
+                                       OI_STATUS status);
+
+/**
+ * A callback function of this type is made to the application to request a password and
+ * optional user id to authenticate connection. The client must provide this callback function
+ * to OI_PBAPClient_ConnectAuthenticate() if the client supports OBEX authentication.
+ * The implementation of this callback function must call OI_PBAPClient_AuthenticationRsp() before
+ * return.
+ *
+ * @param connectionId     a unique ID that represents the in-progress connection to PBAP server.
+ *
+ * @param userIdRequired   depending on the calling context indicates either:
+ *                          - that the server requested a user id as well
+ *                            as a password. The client can provide a user id even
+ *                            if the server does not require one. Whether the server
+ *                            actually makes use of the user id in this case
+ *                            depends entirely on the server implementation.
+ *                          or
+ *                          - that the client requires a user id to authorize the server
+ *                            in client-initiated authentication scenario.
+ */
+typedef void (*OI_PBAP_CLIENT_AUTHENTICATION_CB)(OI_PBAP_CONNECTION connectionId,
+                                                 OI_BOOL userIdRequired);
+
+
+/**
+ * This function establishes an authorized OBEX connection over RFCOMM to a
+ * remote PBAP server.  The client must provide a callback function of
+ * type OI_PBAP_CLIENT_AUTHENTICATION_CB to this function if the client
+ * supports OBEX authentication.
+ *
+ * @param addr              the address of a remote Bluetooth device that supports PBAP
+ *
+ * @param lowerProtocol     This identifies the RFCOMM channel number or the L2CAP PSM for the
+ *                          PBAP server running on the remote device.  the remote device. The caller
+ *                          will normally perform service discovery on the remote device to obtain
+ *                          the required channel number or PSM.
+ *
+ * @param authentication    specifies whether authentication is required when
+ *                          connecting to a server
+ *
+ * @param connectionId      [OUT] returns a handle representing the connection to the PBAP server
+ *
+ * @param supportedFeatures     specified supported features for PBAP Client.
+ *
+ * @param connectionCfm     callback function for indicating the connection result status.
+ *
+ * @param disconnectInd     callback function to indicate a disconnection.
+ *
+ * @param authenticationCB  authentication callback function
+ *
+ * @return                  OI_OK if the connection request can be issued
+ */
+OI_STATUS OI_PBAPClient_Connect(OI_BD_ADDR *addr,
+                                OI_OBEX_LOWER_PROTOCOL *lowerProtocol,
+                                OI_OBEXCLI_AUTHENTICATION authentication,
+                                OI_PBAP_CONNECTION *connectionId,
+                                OI_UINT32 supportedFeatures,
+                                OI_PBAP_CONNECTION_CFM connectionCfm,
+                                OI_PBAP_DISCONNECTION_IND disconnectInd,
+                                OI_PBAP_CLIENT_AUTHENTICATION_CB authenticationCB,
+                                const OI_PBAP_CLIENT_FILESYS_FUNCTIONS *fops);
+
+
+/**
+ * This function is called by the application in response to an authentication
+ * request to provide a password and optional user id for OBEX authentication.
+ *
+ * @param connectionId handle representing the connection to the PBAP server.
+ *
+ * @param userId       the user id for the connecting client. This parameter is
+ *                     required if the server indicated that user id is
+ *                     required. Otherwise is can be NULL. The client can
+ *                     provide a user id even if the server does not require
+ *                     one.
+ *
+ * @param userIdLen    Length of the userId.
+ *
+ * @param password     is a NULL terminated client's password.
+ */
+OI_STATUS OI_PBAPClient_AuthenticationRsp(OI_PBAP_CONNECTION connectionId,
+                                          const OI_BYTE *userId,
+                                          OI_UINT8 userIdLen,
+                                          const OI_CHAR *password);
+
+
+
+
+/**
+ * This function terminates the current OBEX connection to a remote PBAP server.
+ *
+ * @param connectionId handle representing the connection to the PBAP server.
+ *
+ */
+OI_STATUS OI_PBAPClient_Disconnect(OI_PBAP_CONNECTION connectionId);
+
+/**
+ * This callback informs the application that the aborting of the current
+ * operation has comleted.
+ *
+ * @param connectionId  handle representing the connection to the PBAP server.
+ */
+typedef void (*OI_PBAP_ABORT_CFM)(OI_PBAP_CONNECTION connectionId);
+
+/**
+ * This function terminates the current operation.
+ *
+ * @param connectionId  handle representing the connection to the PBAP server.
+ *
+ * @return an error status if there is no operation to abort.
+ */
+OI_STATUS OI_PBAPClient_Abort(OI_PBAP_CONNECTION connectionId, OI_PBAP_ABORT_CFM abortCfm);
+
+
+/**
+ * This callback function reports the number of phonebook entries for the
+ * currently selected phonebook to the application.
+ *
+ * @param connectionId   Handle representing the connection to the PBAP server.
+ *
+ * @param phonebooksize  Total number of entries in the phonebook.
+ *
+ * @param status         OI_OK if the operation succeeded, or an error code if
+ *                       the operation failed.
+ */
+typedef void (*OI_PBAP_CLIENT_GET_PHONEBOOK_SIZE_CB)(OI_PBAP_CONNECTION connectionId,
+                                                     OI_UINT16 phonebookSize,
+                                                     OI_STATUS status);
+
+
+
+/**
+ * This function gets the number of phonebook entries in the currently
+ * selected phonebook.
+ *
+ * @param connectionId        Handle representing the connection to the PBAP server.
+ *
+ * @param repository          Phonebook repository to access
+ *
+ * @param phonebook           Phonebook to access
+ *
+ * @param getPhonebookSizeCb  Callback function to call with the size information.
+ *
+ * @return OI_OK if request for setting the phonebook was successfully sent.
+ */
+OI_STATUS OI_PBAPClient_GetPhonebookSize(OI_PBAP_CONNECTION connectionId,
+                                         OI_PBAP_REPOSITORY repository,
+                                         OI_PBAP_PHONEBOOK phonebook,
+                                         OI_PBAP_CLIENT_GET_PHONEBOOK_SIZE_CB getPhonebookSizeCB);
+
+
+/**
+ * This callback function informs the application of the completion status of the
+ * pull phonebook operation and the number of newly missed calls if the
+ * current phonebook is the missed calls phonebook.
+ *
+ * @param connectionId    Handle representing the connection to the PBAP server.
+ *
+ * @param newMissedCalls  Number of missed calls not checked by the user (when in
+ *                        the missed calls phonebook).
+ *
+ * @param status          OI_OK if the operation succeeded, or an error code if
+ *                        the operation failed.
+ */
+typedef void (*OI_PBAP_CLIENT_PULL_PHONEBOOK_CB)(OI_PBAP_CONNECTION connectionId,
+                                                 OI_UINT8 newMissedCalls,
+                                                 OI_STATUS status);
+
+/**
+ * This function pulls the contents of the current phonebook.
+ *
+ * @param connectionId    Handle representing the connection to the PBAP server.
+ *
+ * @param repository      Phonebook repository to access
+ *
+ * @param phonebook       Phonebook to access
+ *
+ * @param filter          An OR'd list of all vCard attributes to include (0 retrieves
+ *                        all avaliable attributes).
+ *
+ * @param format          Select vCard 2.1 or 3.0 format.
+ *
+ * @param maxListCount    Maximum number of phonebook entries to include.
+ *
+ * @param listStartOffset Starting position in list of phone book entries to retrieve.
+ *
+ * @param pullPhonebookCB Callback function to call when phonebook data is received.
+ *
+ * @return OI_OK if request for phonebook was successfully sent.
+ */
+OI_STATUS OI_PBAPClient_PullPhonebook(OI_PBAP_CONNECTION connectionId,
+                                      OI_PBAP_REPOSITORY repository,
+                                      OI_PBAP_PHONEBOOK phonebook,
+                                      const OI_UINT64 *filter,
+                                      OI_PBAP_FORMAT_TAG_VALUES format,
+                                      OI_UINT16 maxListcount,
+                                      OI_UINT16 listStartOffset,
+                                      OI_PBAP_CLIENT_PULL_PHONEBOOK_CB pullPhonebookCB);
+
+
+
+/**
+ * This callback function provides the list of vCard entries that match the
+ * requested criteria.
+ *
+ * @param connectionId   Handle representing the connection to the PBAP server.
+ *
+ * @param newMissedCalls Number of missed calls not checked by the user.
+ *
+ * @param status         OI_OK if the operation succeeded, or an error code if
+ *                       the operation failed.
+ */
+typedef void (*OI_PBAP_CLIENT_PULL_VCARD_LISTING_CB)(OI_PBAP_CONNECTION connectionId,
+                                                     OI_UINT8 newMissedCalls,
+                                                     OI_STATUS status);
+
+/**
+ * This function pulls a list of vCards from the current phonebook.
+ *
+ * @param connectionId       Handle representing the connection to the PBAP server.
+ *
+ * @param repository         Phonebook repository to access
+ *
+ * @param phonebook          Phonebook to access
+ *
+ * @param order              The sorting order of the vCards.
+ *
+ * @param searchAttribute    Search criteria type.
+ *
+ * @param searchValue        String that specifies what to search for (NULL to match all vCards).
+ *
+ * @param searchValueLen     Number of bytes in the searchValue (0 to match all vCards).
+ *
+ * @param maxListCount       Maximum number of phonebook entries to include.
+ *
+ * @param listStartOffset    Starting position in list of phone book entries to retrieve.
+ *
+ * @param pullvCardListingCB Callback function to call when the vCard listing is received.
+ *
+ * @return OI_OK if request for the vCard listing was successfully sent.
+ */
+OI_STATUS OI_PBAPClient_PullvCardListing(OI_PBAP_CONNECTION connectionId,
+                                         OI_PBAP_REPOSITORY repository,
+                                         OI_PBAP_PHONEBOOK phonebook,
+                                         OI_PBAP_ORDER_TAG_VALUES order,
+                                         OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES searchAttribute,
+                                         OI_BYTE *searchValue,
+                                         OI_UINT8 searchValueLen,
+                                         OI_UINT16 maxListCount,
+                                         OI_UINT16 listStartOffset,
+                                         OI_PBAP_CLIENT_PULL_VCARD_LISTING_CB pullvCardListingCB);
+
+
+/**
+ * This callback function provides the requested vCard entry.
+ *
+ * @param connectionId Handle representing the connection to the PBAP server.
+ *
+ * @param status       OI_OK if the operation succeeded, or an error code if
+ *                     the operation failed.
+ */
+typedef void (*OI_PBAP_CLIENT_PULL_VCARD_ENTRY_CB)(OI_PBAP_CONNECTION connectionId,
+                                                   OI_STATUS status);
+
+/**
+ * This function pulls a specific vCard from the current phonebook.
+ *
+ * @param connectionId Handle representing the connection to the PBAP server.
+ *
+ * @param repository   Phonebook repository to access
+ *
+ * @param phonebook    Phonebook to access
+ *
+ * @param entry        The vCard entry to retrieve.
+ *
+ * @param filter       An OR'd list of all vCard attributes to include (0 retrieves
+ *                     all avaliable attributes).
+ *
+ * @param format       Select vCard 2.1 or 3.0 format.
+ *
+ * @param pullvCardCB  Callback function to call when the vCard listing is received.
+ *
+ * @return OI_OK if request for the vCard entry was successfully sent.
+ */
+OI_STATUS OI_PBAPClient_PullvCardEntry(OI_PBAP_CONNECTION connectionId,
+                                       OI_PBAP_REPOSITORY repository,
+                                       OI_PBAP_PHONEBOOK phonebook,
+                                       OI_UINT32 entry,
+                                       const OI_UINT64 *filter,
+                                       OI_PBAP_FORMAT_TAG_VALUES format,
+                                       OI_PBAP_CLIENT_PULL_VCARD_ENTRY_CB pullvCardCB);
+
+/**
+ * This callback function provides the requested setpath.
+ *
+ * @param connectionId Handle representing the connection to the PBAP server.
+ *
+ * @param status       OI_OK if the operation succeeded, or an error code if
+ *                     the operation failed.
+ */
+typedef void (*OI_PBAP_CLIENT_SETPATH_CB)(OI_PBAP_CONNECTION connectionId,
+                                                   OI_STATUS status);
+
+/**
+ * This function set path to specified repository.
+ *
+ * @param connectionId Handle representing the connection to the PBAP server.
+ *
+ * @param repository   Phonebook repository to access
+ *
+ * @param phonebook    Phonebook to access
+ *
+ * @param setPathCB  Callback function to call when the set path is completed.
+ *
+ * @return OI_OK if set path is done successfully.
+ */
+OI_STATUS OI_PBAPClient_SetPath(OI_PBAP_CONNECTION connectionId,
+                                       OI_PBAP_REPOSITORY repository,
+                                       OI_PBAP_PHONEBOOK phonebook,
+                                       OI_PBAP_CLIENT_SETPATH_CB setPathCB);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_PBAP_CLIENT_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_pbap_consts.h b/obex_profiles/sdk/include/profiles/oi_pbap_consts.h
new file mode 100644
index 0000000..3c41d71
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_pbap_consts.h
@@ -0,0 +1,166 @@
+#ifndef _OI_PBAP_CONSTS_H
+#define _OI_PBAP_CONSTS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ * This file contains definitions for values specified in the PBAP (Phonebook Access) Profile.
+ */
+
+#include "oi_stddefs.h"
+
+/** \addtogroup PBAP PBAP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define OI_PBAP_PHONEBOOK_TYPE      "x-bt/phonebook"
+#define OI_PBAP_VCARD_LISTING_TYPE  "x-bt/vcard-listing"
+#define OI_PBAP_VCARD_TYPE          "x-bt/vcard"
+
+#define OI_PBAP_OBEX_TARGET_UUID   { 0x79,0x61,0x35,0xf0,0xf0,0xc5,0x11,0xd8,0x09,0x66,0x08,0x00,0x20,0x0c,0x9a,0x66 }
+
+
+typedef enum {
+    OI_PBAP_TAG_ID_ORDER             = 0x01,
+    OI_PBAP_TAG_ID_SEARCH_VALUE      = 0x02,
+    OI_PBAP_TAG_ID_SEARCH_ATTRIBUTE  = 0x03,
+    OI_PBAP_TAG_ID_MAX_LIST_COUNT    = 0x04,
+    OI_PBAP_TAG_ID_LIST_START_OFFSET = 0x05,
+    OI_PBAP_TAG_ID_FILTER            = 0x06,
+    OI_PBAP_TAG_ID_FORMAT            = 0x07,
+    OI_PBAP_TAG_ID_PHONEBOOK_SIZE    = 0x08,
+    OI_PBAP_TAG_ID_NEW_MISSED_CALLS  = 0x09,
+    OI_PBAP_TAG_ID_SUPP_FEATURES     = 0x10
+} OI_PBAP_APPLICATION_PARAM_TAG_IDS;
+
+typedef enum {
+    OI_PBAP_ORDER_INDEXED      = 0x00,
+    OI_PBAP_ORDER_ALPHANUMERIC = 0x01,
+    OI_PBAP_ORDER_PHONETIC     = 0x02
+} OI_PBAP_ORDER_TAG_VALUES;
+
+typedef enum {
+    OI_PBAP_SEARCH_ATTRIBUTE_NAME   = 0x00,
+    OI_PBAP_SEARCH_ATTRIBUTE_NUMBER = 0x01,
+    OI_PBAP_SEARCH_ATTRIBUTE_SOUND  = 0x02
+} OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES;
+
+
+/** PBAP filter mask values */
+/* Lower 32 bits of PBAP Filter mask values */
+#define OI_PBAP_VCARD_ATTRIBUTE_VERSION       OI_BIT0   /**<  VERSION vCard Version */
+#define OI_PBAP_VCARD_ATTRIBUTE_FN            OI_BIT1   /**<  FN Formatted Name */
+#define OI_PBAP_VCARD_ATTRIBUTE_N             OI_BIT2   /**<  N Structured Presentation of Name */
+#define OI_PBAP_VCARD_ATTRIBUTE_PHOTO         OI_BIT3   /**<  PHOTO Associated Image or Photo */
+#define OI_PBAP_VCARD_ATTRIBUTE_BDAY          OI_BIT4   /**<  BDAY Birthday */
+#define OI_PBAP_VCARD_ATTRIBUTE_ADR           OI_BIT5   /**<  ADR Delivery Address */
+#define OI_PBAP_VCARD_ATTRIBUTE_LABEL         OI_BIT6   /**<  LABEL Delivery */
+#define OI_PBAP_VCARD_ATTRIBUTE_TEL           OI_BIT7   /**<  TEL Telephone Number */
+#define OI_PBAP_VCARD_ATTRIBUTE_EMAIL         OI_BIT8   /**<  EMAIL Electronic Mail Address */
+#define OI_PBAP_VCARD_ATTRIBUTE_MAILER        OI_BIT9   /**<  MAILER Electronic Mail */
+#define OI_PBAP_VCARD_ATTRIBUTE_TX            OI_BIT10  /**<  TZ Time Zone */
+#define OI_PBAP_VCARD_ATTRIBUTE_GEO           OI_BIT11  /**<  GEO Geographic Position */
+#define OI_PBAP_VCARD_ATTRIBUTE_TITLE         OI_BIT12  /**<  TITLE Job */
+#define OI_PBAP_VCARD_ATTRIBUTE_ROLE          OI_BIT13  /**<  ROLE Role within the Organization */
+#define OI_PBAP_VCARD_ATTRIBUTE_LOGO          OI_BIT14  /**<  LOGO Organization Logo */
+#define OI_PBAP_VCARD_ATTRIBUTE_AGENT         OI_BIT15  /**<  AGENT vCard of Person Representing */
+#define OI_PBAP_VCARD_ATTRIBUTE_ORG           OI_BIT16  /**<  ORG Name of Organization */
+#define OI_PBAP_VCARD_ATTRIBUTE_NOTE          OI_BIT17  /**<  NOTE Comments */
+#define OI_PBAP_VCARD_ATTRIBUTE_REV           OI_BIT18  /**<  REV Revision */
+#define OI_PBAP_VCARD_ATTRIBUTE_SOUND         OI_BIT19  /**<  SOUND Pronunciation of Name */
+#define OI_PBAP_VCARD_ATTRIBUTE_URL           OI_BIT20  /**<  URL Uniform Resource Locator */
+#define OI_PBAP_VCARD_ATTRIBUTE_UID           OI_BIT21  /**<  UID Unique ID */
+#define OI_PBAP_VCARD_ATTRIBUTE_KEY           OI_BIT22  /**<  KEY Public Encryption Key */
+#define OI_PBAP_VCARD_ATTRIBUTE_NICKNAME      OI_BIT23  /**<  NICKNAME Nickname */
+#define OI_PBAP_VCARD_ATTRIBUTE_CATEGORIES    OI_BIT24  /**<  CATEGORIES Categories */
+#define OI_PBAP_VCARD_ATTRIBUTE_PROID         OI_BIT25  /**<  PROID Product ID */
+#define OI_PBAP_VCARD_ATTRIBUTE_CLASS         OI_BIT26  /**<  CLASS Class Information */
+#define OI_PBAP_VCARD_ATTRIBUTE_SORT_STRING   OI_BIT27  /**<  SORT_STRING String Used for Sorting Operation */
+#define OI_PBAP_VCARD_ATTRIBUTE_CALL_DATETIME OI_BIT28  /**<  X-IRMC-CALL-DATETIME Time Stamp */
+
+#define OI_PBAP_VCARD_ATTRIBUTE_RSVD0         OI_BIT29  /**<  Reserved for future use */
+#define OI_PBAP_VCARD_ATTRIBUTE_RSVD1         OI_BIT30  /**<  Reserved for future use */
+#define OI_PBAP_VCARD_ATTRIBUTE_RSVD2         OI_BIT31  /**<  Reserved for future use */
+
+/* Upper 32 bits of PBAP Filter mask values */
+#define OI_PBAP_VCARD_ATTRIBUTE_PROPRIETARY OI_BIT7  /**< PROPRIETARY Flag indicating bits 40-63 contain proprietary fields */
+
+#define OI_PBAP_VCARD_ATTRIBUTE_ALL { 0, 0 }
+#define OI_PBAP_VCARD_ATTRIBUTE_CHECK_ALL(_filter) (((_filter)->I1 == 0) && ((_filter)->I2 == 0))
+
+typedef enum {
+    OI_PBAP_FORMAT_VCARD_2_1  = 0x00,
+    OI_PBAP_FORMAT_VCARD_3_0  = 0x01
+} OI_PBAP_FORMAT_TAG_VALUES;
+
+
+/** PBAP Supported Features */
+#define OI_PBAP_SUPPORTED_FEATURE_PHONEBOOK_DOWNLOAD OI_BIT0
+#define OI_PBAP_SUPPORTED_FEATURE_PHONEBOOK_BROWSE   OI_BIT1
+
+/** PBAP Suported Repositories */
+#define OI_PBAP_SUPPORTED_REPOSITORIES_LOCAL OI_BIT0
+#define OI_PBAP_SUPPORTED_REPOSITORIES_SIM   OI_BIT1
+
+/**
+ * The list of repositories defined by the PBAP specification.
+ */
+typedef enum {
+    OI_PBAP_LOCAL_REPOSITORY,   /**< Collection of phonebooks stored on the phone. */
+    OI_PBAP_SIM1_REPOSITORY,    /**< Collection of phonebooks stored on the SIM card. */
+    OI_PBAP_INVALID_REPOSITORY  /**< Invalid repository. */
+} OI_PBAP_REPOSITORY;
+
+
+/**
+ * List of phonebooks defined by the PBAP specification.
+ */
+typedef enum {
+    OI_PBAP_MAIN_PHONEBOOK,           /**< The main phonebook. */
+    OI_PBAP_INCOMING_CALLS_HISTORY,   /**< List of recent incomming calls. */
+    OI_PBAP_OUTGOING_CALLS_HISTORY,   /**< List of recent outgoing calls. */
+    OI_PBAP_MISSED_CALLS_HISTORY,     /**< List of recently missed incomming calls. */
+    OI_PBAP_COMBINED_CALLS_HISTORY,   /**< All recent incomming, outgoing, and missed calls. */
+    OI_PBAP_INVALID_PHONEBOOK         /**< Invalid phonebook. */
+} OI_PBAP_PHONEBOOK;
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_PBAP_CONSTS_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_pbap_server.h b/obex_profiles/sdk/include/profiles/oi_pbap_server.h
new file mode 100644
index 0000000..ecda523
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_pbap_server.h
@@ -0,0 +1,262 @@
+#ifndef _OI_PBAP_SERVER_H
+#define _OI_PBAP_SERVER_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ *  @file
+ *
+ *  This file provides the API for the server side of the Phonebook Access
+ *  Profile.
+ *
+ *  The Phonebook Access Profile provides functions for establishing a
+ *  connection to a remote device that supports the Phonebook Access Profile
+ *  over RFCOMM and functions for putting and getting files. This
+ *  implementation currently only allows one client connection at a time.
+ */
+
+#include "oi_obexsrv.h"
+#include "oi_status.h"
+#include "oi_sdp.h"
+#include "oi_pbap_sys.h"
+
+/** \addtogroup PBAP PBAP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * Type of a registered PBAP server instance.
+ */
+typedef OI_OBEX_SERVER_HANDLE OI_PBAP_SERVER_HANDLE;
+
+
+/**
+ * A callback function of this type is called to indicate a connection request.
+ * The server application provides a function with this profile to
+ * OI_PBAPServer_Register().
+ *
+ * @param clientAddr     The Bluetooth device address of the client requesting
+ *                       the connection.
+ *
+ * @param unauthorized   Indicates if the connection requires authentication. If
+ *                       this parameter is TRUE the server application must call
+ *                       OI_PBAPServer_AuthenticationResponse() to provide a password
+ *                       to PBAP server.
+ *                       After succesful authentication this function will be
+ *                       called again wuth unauthorized == FALSE indicating that
+ *                       the connection has been established and the server application
+ *                       must call OI_PBAPServer_AcceptConnection(). If authentication
+ *                       was attempted but failed this parameter will still be TRUE.
+ *
+ * @param userId         The user id  of the client requesting the connection.
+ *                       If this parameter is NULL and unauthorized is TRUE this
+ *                       means either that the server received authentication
+ *                       challenge from the connecting client or, in case of handling
+ *                       authentication response, client's user id was not required.
+ *                       If userId is nonzero and the user id match is found, the server
+ *                       application must call OI_PBAPServer_AuthenticationResponse()
+ *                       to provide a password to PBAP server. The application server
+ *                       may use this value to choose a root directory or select
+ *                       a previously stored password.
+ *                       If the user id match is not found, the server application must call
+ *                       OI_PBAPServer_AcceptConnection() to either disconnect or
+ *                       request another authentication attempt from the client.
+ *
+ * @param userIdLen      Length of the user id.
+ *
+ * @param connectionId   handle representing the connection to an PBAP client.
+ */
+typedef void (*OI_PBAP_CONNECTION_IND)(OI_BD_ADDR *clientAddr,
+                                       OI_BOOL unauthorized,
+                                       OI_BYTE *userId,
+                                       OI_UINT8 userIdLen,
+                                       OI_PBAP_CONNECTION connectionId);
+
+/**
+ * This function is called by the application in response to a connnection
+ * indication that requires authentication.
+ *
+ * @param connectionId handle representing the connection to an PBAP client.
+ *
+ * @param userId       the user id for the connecting user. If the routine is called in response
+ *                     to a authentication challenge from a client, this parameter should be set
+ *                     to a User Id provided by the server.
+ *                     If the routine is called to handle authentication response from a client,
+ *                     this parapemter would hold a User Id provided by the client.
+ *
+ * @param userIdLen    Length of the userId.
+ *
+ * @param password     NULL-teminated password
+ */
+OI_STATUS OI_PBAPServer_AuthenticationResponse(OI_PBAP_CONNECTION connectionId,
+                                               const OI_BYTE *userId,
+                                               OI_UINT8 userIdLen,
+                                               const OI_CHAR *password);
+/**
+ * An application calls this function to accept or reject an indicated
+ * connection.
+ *
+ * @param connectionId   handle representing the connection to an PBAP client.
+ *
+ * @param newMissedCalls  Number of missed calls not yet checked by the user.
+ *
+ * @param accept         TRUE if the connection is being accepted, FALSE
+ *                       otherwise. If FALSE the values of the remaining
+ *                       parameters is ignored.
+ *
+ */
+OI_STATUS OI_PBAPServer_AcceptConnection(OI_PBAP_CONNECTION connectionId,
+                                         OI_UINT8 newMissedCalls,
+                                         OI_BOOL accept);
+
+
+/**
+ * Forcibly severs the connection from a PBAP client to the PBAP server. This
+ * function should be called for all active connections before terminating the
+ * PBAP server.
+ *
+ * @param connectionId  handle representing the connection between a remote
+ *                      client and the local PBAP server.
+ *
+ * @return              OI_OK if the connection will be terminated.
+ */
+OI_STATUS OI_PBAPServer_ForceDisconnect(OI_PBAP_CONNECTION connectionId);
+
+
+
+
+/**
+ * This function updates the number newly missed calls when for when the
+ * client makes a request of the missed call history phonebook.
+ *
+ * @param newMissedCalls    Number of newly missed calls in the missed call
+ *                          history.
+ */
+void OI_PBAPServer_SetNewMissedCalls(OI_UINT8 newMissedCalls);
+
+
+/**
+ * The function gets called when the client needs to know the number of
+ * entries in a phonebook.
+ *
+ * @param connectionId  handle representing the connection between a remote
+ *                      client and the local PBAP server.
+ *
+ * @param repository    The local or SIM1 repository to get the phonebook size from.
+ *
+ * @param phonebook     The phonebook in the repository to get the size of.
+ *
+ */
+typedef void (*OI_PBAP_SERVER_GET_PHONEBOOK_SIZE_IND)(OI_PBAP_CONNECTION connectionId,
+                                                      OI_PBAP_REPOSITORY repository,
+                                                      OI_PBAP_PHONEBOOK phonebook);
+
+
+/**
+ * This function is for the reponse to the get phonebook size request.
+ *
+ * @param connectionId  handle representing the connection between a remote
+ *                      client and the local PBAP server.
+ *
+ * @param size          Total number of entries in the phonebook.
+ *
+ * @param status        OI_OK if the determination of size was successful.
+ *
+ * @return              OI_OK if sending response to client succeeded.
+ */
+OI_STATUS OI_PBAPServer_GetPhonebookSizeRsp(OI_PBAP_CONNECTION connectionId,
+                                            OI_UINT16 size,
+                                            OI_STATUS status);
+
+
+
+/**
+ * This function initialzes the PBAP server to accept connections and registers
+ * it with the SDP database so that the service becomes discoverable.
+ *
+ * @param authentication This parameter indicates whether connections to this
+ *                       server must be authenticated using OBEX authentication.
+ *                       If this parameter is FALSE, clients connecting to the
+ *                       server may demand authentication.
+ *
+ * @param connectInd     a callback function for indicating an incoming client
+ *                       connection to the server application.
+ * @param disconnectInd  a callback function for indicating a disconnection
+ *
+ * @param fileOperations interface to file system operations.
+ *
+ * @param strings        strings to register in service record
+ *
+ * @param srecHandle     [OUT] returns the handle to the SDP record
+ *
+ * @param serverHandle   [OUT] returns the server handle for
+ *                       the server. The server handle is required for
+ *                       OI_PBAPServer_Deregister().
+ *
+ * @param suppRepositories  Bit mask describing the repositories supported by the
+ *                          server.
+ *
+ * @return               OI_OK if the service was successfully registered.
+ */
+
+OI_STATUS OI_PBAPServer_Register(OI_OBEXSRV_AUTHENTICATION authentication,
+                                 OI_PBAP_CONNECTION_IND connectInd,
+                                 OI_PBAP_DISCONNECTION_IND disconnectInd,
+                                 OI_PBAP_SERVER_GET_PHONEBOOK_SIZE_IND getPhonebookSize,
+                                 const OI_PBAP_SERVER_FILESYS_FUNCTIONS *fileOperations,
+                                 const OI_SDP_STRINGS *strings,
+                                 OI_UINT32 *srecHandle,
+                                 OI_UINT8 suppRepositories,
+                                 OI_PBAP_SERVER_HANDLE *serverHandle);
+
+
+/**
+ * Deregisters a PBAP server.
+ *
+ * @param serverHandle    The server handle returned when the server was registered.
+ *
+ * @return                OI_OK if the service was successfully deregistered.
+ *
+ */
+OI_STATUS OI_PBAPServer_Deregister(OI_PBAP_SERVER_HANDLE serverHandle);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_PBAP_SERVER_H */
diff --git a/obex_profiles/sdk/include/profiles/oi_pbap_sys.h b/obex_profiles/sdk/include/profiles/oi_pbap_sys.h
new file mode 100644
index 0000000..a9e867b
--- /dev/null
+++ b/obex_profiles/sdk/include/profiles/oi_pbap_sys.h
@@ -0,0 +1,360 @@
+#ifndef _OI_PBAP_SYS_H
+#define _OI_PBAP_SYS_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides the file system abstraction layer used by
+ * the Phonebook Access Profile client and server.
+ *
+ * This interface is described entirely as callback functions. The application
+ * must provide the appropriate sets of functions to the PBAP client and PBAP
+ * server when initializing these two services. A Bluetooth compliant
+ * implementation of a PBAP server must return certain specific error codes
+ * to report various operation failure modes.
+ *
+ * Callbacks and errors are mutually exclusive.  If you invoke a callback from
+ * one of the functions below, that function must return OI_OK.  If you do not
+ * invoke a callback, the function must return an error message.  Note that if
+ * you wish your application to be BQB-compliant, you should generate error
+ * codes consistent with BLUEmagic 3.0 best practices; see the sample code for
+ * examples.
+ */
+
+#include "oi_status.h"
+#include "oi_stddefs.h"
+#include "oi_obex.h"
+#include "oi_obexspec.h"
+#include "oi_pbap_consts.h"
+
+/** \addtogroup PBAP PBAP APIs */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef OI_OBEX_CONNECTION_HANDLE OI_PBAP_CONNECTION;
+
+typedef void* OI_PBAP_HANDLE;
+
+
+/*********************************************************************************
+ * The file and folder functions are all asynchronous. However implementations
+ * are permitted to call the callback function from within the function if the
+ * file operation can be completed quickly. This will be the case for many
+ * implementations.
+ *********************************************************************************/
+
+
+
+
+/**
+ * A function of this type is called to confirm the success or failure of a file
+ * open.
+ *
+ * @param handle          A handle that can be used to read the file contents.
+ *                        The handle must not be NULL.
+ *
+ * @param status          OI_OK if the folder could be opened with the required
+ *                        mode or an error if the file could not be opened.
+ *
+ * @param pbapConnection  identifies which PBAP client or server connection is
+ *                        performing this operation.
+ */
+typedef void (*OI_PBAP_OPEN_CFM)(OI_PBAP_HANDLE handle,
+                                 OI_STATUS status,
+                                 OI_PBAP_CONNECTION pbapConnection);
+
+/**
+ * This function and corresponding callback is needed by a PBAP client and
+ * server.  Whether the file is opened for read access or write access is
+ * determined by if it is called from server code or client code.
+ *
+ * @param name            a unicode string name of the file to be opened.
+ *
+ * @param openCfm         the function that will be called when the open
+ *                        completes.
+ *
+ * @param pbapConnection  identifies which PBAP client or server connection is
+ *                        performing this operation.
+ */
+typedef OI_STATUS (*OI_PBAP_OPEN)(const OI_OBEX_UNICODE *name,
+                                  OI_PBAP_OPEN_CFM openCfm,
+                                  OI_PBAP_CONNECTION pbapConnection);
+
+/**
+ * A callback function of this type is called to indicate a server has
+ * disconnected from the PBAP client. The client application provides a function
+ * with this profile to OI_PBAPClient_Register()
+ *
+ * @param connectionId   handle representing the connection to an PBAP client.
+ */
+typedef void (*OI_PBAP_DISCONNECTION_IND)(OI_PBAP_CONNECTION connectionId);
+
+
+/**
+ * This function does not use a callback function. It is assumed that file
+ * close will complete asynchronously or in the case of a failure will report
+ * or log an error with the application.
+ *
+ * @param handle          a handle for an open file.
+ *
+ * @param pbapConnection  identifies which PBAP client or server connection is
+ *                        performing this operation.
+ *
+ * @param status          OI_OK if the file operation completed succesfully. An
+ *                        error status if the file operation terminated before it
+ *                        was complete.
+ */
+typedef void (*OI_PBAP_CLOSE)(OI_PBAP_HANDLE handle,
+                              OI_PBAP_CONNECTION pbapConnection,
+                              OI_STATUS status);
+
+/**
+ * A function of this type is called to confirm the success or failure of a file
+ * read.
+ *
+ * @param data            a pointer to a buffer containing the data read.
+ *
+ * @param len             the number of bytes read.
+ *
+ * @param status          a status code indicating if the read was succesful:
+ *                        - OI_OK if the read completed
+ *                        - OI_STATUS_END_OF_FILE if the read was successful and the
+ *                          end of file has been reached.
+ *                        - An error status indicating that the read failed.
+ *
+ * @param pbapConnection  identifies which PBAP client or server connection is
+ *                        performing this operation.
+ *
+ */
+typedef void (*OI_PBAP_READ_CFM)(OI_PBAP_HANDLE handle,
+                                 OI_BYTE *data,
+                                 OI_UINT16 len,
+                                 OI_STATUS status,
+                                 OI_PBAP_CONNECTION pbapConnection);
+
+/**
+ * This function and corresponding callback is needed by a PBAP server only.
+ *
+ * @param handle          a handle previously returned by an OI_PBAP_OPEN_CFM
+ *                        function
+ *
+ * @param maxRead         the maximum number of bytes to read from the file on
+ *                        this call.
+ *
+ * @param readCfm         the function that will be called when the read
+ *                        completes.
+ *
+ * @param pbapConnection  identifies which PBAP client or server connection is
+ *                        performing this operation.
+ */
+typedef OI_STATUS (*OI_PBAP_READ)(OI_PBAP_HANDLE handle,
+                                  OI_UINT16 maxRead,
+                                  OI_PBAP_READ_CFM readCfm,
+                                  OI_PBAP_CONNECTION pbapConnection);
+
+/**
+ * A function of this type is called to confirm the success or failure of a
+ * file write operation.
+ *
+ * @param handle          a handle previously returned by an OI_PBAP_OPEN_CFM
+ *                        function
+ *
+ * @param status          indicates the success or failure of the write
+ *                        operation.
+ *
+ * @param pbapConnection  identifies which PBAP client or server connection is
+ *                        performing this operation.
+ */
+typedef void (*OI_PBAP_WRITE_CFM)(OI_PBAP_HANDLE handle,
+                                  OI_STATUS status,
+                                  OI_PBAP_CONNECTION pbapConnection);
+
+/**
+ * This function and corresponding callback is needed by a PBAP client.
+ *
+ * @param handle          a handle previously returned by an OI_PBAP_OPEN_CFM
+ *                        function
+ *
+ * @param buffer          a pointer to a buffer containing the data to be written
+ *                        to the file
+ *
+ * @param bufLen          the number of bytes to write to the file on this call.
+ *
+ * @param writeCfm        the function that will be called when the read
+ *                        completes.
+ *
+ * @param pbapConnection  identifies which PBAP client or server connection is
+ *                        performing this operation.
+ */
+typedef OI_STATUS (*OI_PBAP_WRITE)(OI_PBAP_HANDLE handle,
+                                   const OI_BYTE *buffer,
+                                   OI_UINT16 bufLen,
+                                   OI_PBAP_WRITE_CFM writeCfm,
+                                   OI_PBAP_CONNECTION pbapConnection);
+
+/**
+ * This function opens a handle for the PBAP server code to read the listing
+ * of a phonebook.
+ *
+ * @param repository       The local or SIM1 repository to get the listing from.
+ *
+ * @param phonebook        The phonebook in the repository to get the listing from.
+ *
+ * @param order            The sorting order of the phonebook entries.
+ *
+ * @param searchAttribute  The type of criteria for finding specific phonebook entries.
+ *
+ * @param searchValue      Criteria for find specific entries (NULL for all entries).
+ *
+ * @param searchValueLen   Number of bytes in the search value.
+ *
+ * @param maxListCount     Maximum number of entries to return.
+ *
+ * @param listStartOffset  Index of first entry to include in listing.
+ *
+ * @param browsePbCfm      Callback indicating success or failure of this request.
+ *
+ * @param pbapConnection   Identifies which PBAP client or server connection is
+ *                         performing this operation.
+ */
+typedef OI_STATUS (*OI_PBAP_BROWSE_PB)(OI_PBAP_REPOSITORY repository,
+                                       OI_PBAP_PHONEBOOK phonebook,
+                                       OI_PBAP_ORDER_TAG_VALUES order,
+                                       OI_PBAP_SEARCH_ATTRIBUTE_TAG_VALUES searchAttribute,
+                                       OI_BYTE *searchValue,
+                                       OI_UINT8 searchValueLen,
+                                       OI_UINT16 maxListCount,
+                                       OI_UINT16 listStartOffset,
+                                       OI_PBAP_OPEN_CFM browsePbCfm,
+                                       OI_PBAP_CONNECTION pbapConnection);
+
+
+/**
+ * This function opens a handle for reading an entire phonebook.
+ *
+ * @param repository       The local or SIM1 repository to get the phonebook
+ *                         contents from.
+ *
+ * @param phonebook        The phonebook in the repository to get the contents of.
+ *
+ * @param filter           A bit mask indicating the data fields to include in the
+ *                         vCard data.
+ *
+ * @param format           The format of the vCard data: v2.1 or v3.0.  The server
+ *                         must support both.
+ *
+ * @param maxListCount     Maximum number of entries to return.
+ *
+ * @param listStartOffset  Index of first entry to include in listing.
+ *
+ * @param openPbCfm        Callback indicating success or failure of this request.
+ *
+ * @param pbapConnection   Identifies which PBAP client or server connection is
+ *                         performing this operation.
+ */
+typedef OI_STATUS (*OI_PBAP_OPEN_PB)(OI_PBAP_REPOSITORY repository,
+                                     OI_PBAP_PHONEBOOK phonebook,
+                                     const OI_UINT64 *filter,
+                                     OI_PBAP_FORMAT_TAG_VALUES format,
+                                     OI_UINT16 maxListCount,
+                                     OI_UINT16 listStartOffset,
+                                     OI_PBAP_OPEN_CFM openPbCfm,
+                                     OI_PBAP_CONNECTION pbapConnection);
+
+/**
+ * This function opens a handle for reading an entire phonebook.
+ *
+ * @param repository       The local or SIM1 repository to get the vCard from.
+ *
+ * @param phonebook        The phonebook in the repository to get the vCard from.
+ *
+ * @param entry            Index of the desired entry in the phonebook.
+ *
+ * @param filter           A bit mask indicating the data fields to include in the
+ *                         vCard data.
+ *
+ * @param format           The format of the vCard data: v2.1 or v3.0.  The server
+ *                         must support both.
+ *
+ * @param openvCardCfm     Callback indicating success or failure of this request.
+ *
+ * @param pbapConnection   Identifies which PBAP client or server connection is
+ *                         performing this operation.
+ */
+typedef OI_STATUS (*OI_PBAP_OPEN_VCARD)(OI_PBAP_REPOSITORY repository,
+                                        OI_PBAP_PHONEBOOK phonebook,
+                                        OI_UINT32 entry,
+                                        const OI_UINT64 *filter,
+                                        OI_PBAP_FORMAT_TAG_VALUES format,
+                                        OI_PBAP_OPEN_CFM openvCardCfm,
+                                        OI_PBAP_CONNECTION pbapConnection);
+
+
+/*********************************************************************************
+ *
+ *                             File operations
+ *
+ *********************************************************************************/
+
+/**
+   This structure defines client filesystem functions.
+ */
+typedef struct {
+    OI_PBAP_OPEN            open;
+    OI_PBAP_CLOSE           close;
+    OI_PBAP_WRITE           write;
+} OI_PBAP_CLIENT_FILESYS_FUNCTIONS;
+
+/**
+   This structure defines server filesystem functions.
+ */
+typedef struct {
+    OI_PBAP_BROWSE_PB       listPB;
+    OI_PBAP_OPEN_PB         openPB;
+    OI_PBAP_OPEN_VCARD      openvCard;
+    OI_PBAP_CLOSE           close;
+    OI_PBAP_READ            read;
+} OI_PBAP_SERVER_FILESYS_FUNCTIONS;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* _OI_PBAP_SYS_H */
diff --git a/obex_profiles/sdk/oem/oi_bt_profile_config_default.c b/obex_profiles/sdk/oem/oi_bt_profile_config_default.c
new file mode 100644
index 0000000..8bb269f
--- /dev/null
+++ b/obex_profiles/sdk/oem/oi_bt_profile_config_default.c
@@ -0,0 +1,158 @@
+#ifndef _OI_BT_PROFILE_CONFIG_C
+#define _OI_BT_PROFILE_CONFIG_C
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ *  @file
+ *  This file defines configuration parameters for various profiles and protocols.
+ *
+ *  Values in this file may be changed; these values will be used to populate instances
+ *  of the data structures defined in oi_bt_profile_config.h that will be used during
+ *  profile initialization and configuration functions.
+ *
+ *  Do not change the file oi_bt_profile_config.h.
+ *
+ */
+
+#include "oi_stddefs.h"
+#include "oi_rfcomm_prefs.h"
+#include "oi_l2cap_prefs.h"
+#include "oi_l2cap.h"
+#include "oi_bt_profile_config.h"
+
+
+/* Basic Imaging Profile */
+
+const OI_CONFIG_BIP_SRV oi_default_config_BIP_SRV =
+{
+    3     // OI_UINT     maxServers - numer of servers that can be registered simaltaneously
+};
+
+/****************************************************/
+
+/* File Transfer Profile */
+
+const OI_CONFIG_FTP_SRV oi_default_config_FTP_SRV = {
+    RFCOMM_PREF_FTP_SRV    // OI_UINT8    rfcomm_channel_pref - preferred rfcomm channel id (from oi_rfcomm_prefs.h)
+};
+
+const OI_CONFIG_FTP_CLI oi_default_config_FTP_CLI = {
+    5        // OI_UINT8 max_folder_tree_depth - maximum folder recursion for folder put/get */
+};
+
+/****************************************************/
+
+/* OBEX protocol, Generic Object Exchange Profile */
+
+const OI_CONFIG_OBEX_CLI oi_default_config_OBEX_CLI = {
+    OI_SECONDS(25),  /*
+                      * OI_INTERVAL responseTimeout; This timeout should be a fairly large value. It
+                      * is intended to detect the case where the Bluetooth link is still up but the
+                      * OBEX server has gone unresponsive, probably because it has crashed.
+                      */
+
+      0,             /* Unused */
+
+    #ifdef  SMALL_RAM_MEMORY
+        400,    /* OI_UINT16 maxPktLen; Maximum size of the OBEX packet */
+    #else
+        65500,  /* OI_UINT16 maxPktLen; Maximum size of the OBEX packet */
+    #endif
+    "YYYY BLUEmagic 3.0 YYYY"    // OI_CHAR *privateKey;
+};
+
+
+const OI_CONFIG_OBEX_SRV oi_default_config_OBEX_SRV = {
+
+    OI_SECONDS(30),  /*
+                      * OI_INTERVAL connectTimeout; Timeout waiting for a respsonse to an OBEX
+                      * connection request.
+                      */
+
+    OI_SECONDS(120), /*
+                      * OI_INTERVAL authTimeout; Timeout waiting for a response to an OBEX
+                      * authentication request. Ths timeout must be long enough to allow the user to
+                      * enter a PIN code.
+                      */
+
+    0,               /* Unused */
+
+    #ifdef  SMALL_RAM_MEMORY
+        400,    /* OI_UINT16 maxPktLen; Maximum size of the OBEX packet */
+    #else
+        65500,  /* OI_UINT16 maxPktLen; Maximum size of the OBEX packet */
+    #endif
+    "XXXX BLUEmagic 3.0 XXXX",   // OI_CHAR     *privateKey;
+};
+
+
+/****************************************************/
+
+/* Object Push Profile */
+
+const OI_CONFIG_OPP_SRV oi_default_config_OPP_SRV = {
+    RFCOMM_PREF_OPP_SRV,    // OI_UINT8    rfcomm_channel_pref - preferred rfcomm channel id (from oi_rfcomm_prefs.h)
+    L2CAP_PREF_OPP_SRV      // OI_UINT16    l2cap_channel_pref - preferred rfcomm channel id (from oi_l2cap_prefs.h)
+};
+
+/****************************************************/
+
+/* Phonebook Access Profile */
+
+const OI_CONFIG_PBAP_SRV oi_default_config_PBAP_SRV = {
+    RFCOMM_PREF_PBAP_SRV,    // OI_UINT8    rfcomm_channel_pref - preferred rfcomm channel id (from oi_rfcomm_prefs.h)
+    L2CAP_PREF_PBAP_SRV      // OI_UINT16    l2cap_prefs - preferred rfcomm channel id (from oi_l2cap_prefs.h)
+};
+
+/* const OI_CONFIG_PBAP_CLI oi_default_config_PBAP_CLI = { }; */
+
+/****************************************************/
+
+/* MAP  server */
+
+const OI_CONFIG_MAP_SRV oi_default_config_MAP_SRV =  {
+    RFCOMM_PREF_MAP_SRV,        // OI_UINT8    rfcomm_channel_pref
+    9,                        // Max. MAS connections to the server
+	3                         // Max. no. of MCEs that can be connected to the server
+};
+
+/****************************************************/
+
+/* MNS  server */
+
+const OI_CONFIG_MAP_CLI oi_default_config_MAP_CLI =  {
+    RFCOMM_PREF_MNS_SRV        // OI_UINT8    rfcomm_channel_pref
+};
+
+/****************************************************/
+
+#endif  // _OI_BT_PROFILE_CONFIG_C
diff --git a/obex_profiles/sdk/oem/oi_bt_stack_config_default.c b/obex_profiles/sdk/oem/oi_bt_stack_config_default.c
new file mode 100644
index 0000000..98eec40
--- /dev/null
+++ b/obex_profiles/sdk/oem/oi_bt_stack_config_default.c
@@ -0,0 +1,112 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ *  @file
+ *  This file defines configuration parameters for various modules, including the CThru Dispatcher,
+ *  Security Manager, security database, Device Manager, Policy Manager, and core protocol
+ *  stack modules.
+ *
+ *  Values in this file may be changed; these values will be used to populate instances of the data structures
+ *  defined in oi_bt_stack_config.h that will be sent as arguments to initialization and configuration functions.
+ *  See the the @ref init_docpage section for details of recommended and required usage of these values.
+ *  Do not change the file oi_bt_stack_config.h.
+ *
+ *  Many of the parameters in this file affect the amount of RAM memory that the stack requires.
+ *  To accomodate embedded platforms where RAM may be limited, some configurations in this file
+ *  will depend on whether SMALL_RAM_MEMORY is defined or not. If SMALL_RAM_MEMORY is defined,
+ *  configuration will be defined for less memory usage.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_time.h"
+#include "oi_bt_stack_config.h"
+#include "oi_bt_assigned_nos.h"
+#include "oi_dataelem.h"
+#include "oi_l2cap.h"
+
+/**************************************************
+  common configuration
+ **************************************************/
+
+/*  This constant structure configures parameters used by several modules of the
+    BLUEmagic 3.0 Bluetooth protocol stack and supporting layers. */
+const OI_CONFIG_COMMON_CONFIG oi_default_config_COMMON_CONFIG =  {
+#ifdef SMALL_RAM_MEMORY
+    1,                    /* OI_UINT8    maxAclConnections */
+
+    1,                    /* OI_UINT8    maxLogicalConnections */
+
+    1,                    /* OI_UINT8    maxScoConnections */
+
+    26,                   /* OI_UINT8    deviceNameMaxLen (includes NUL terminator) */
+
+    672,                  /* OI_UINT16   maxMTU */
+
+    672,                  /* OI_UINT16   maxMPS */
+#else
+    7,                    /* OI_UINT8    maxAclConnections */
+
+    14,                   /* OI_UINT8    maxLogicalConnections */
+
+    7,                    /* OI_UINT8    maxScoConnections */
+
+    61,                   /* OI_UINT8    deviceNameMaxLen (includes NUL terminator) */
+
+    OI_L2CAP_SDU_SAFE_MAX,/* OI_UINT16   maxMTU */
+
+    8158,                 /* OI_UINT16   maxMPS */
+#endif
+
+    1,                    /* OI_UINT8    automaticUnPark */
+
+    0                     /* OI_UINT8    automaticUnSniff */
+};
+
+/**************************************************
+  Dispatcher configuration
+ **************************************************/
+
+/*  This constant structure configures the size of the table used by the CThru Dispatcher
+ *  to store callback function registration entries. The parameter indicates the size of
+ *  the table in 16-bit units, not number of entries. An entry consumes between 20 and 24 bytes.
+ *  A reasonable parameter setting for many applications would be 64. A feasible minimum might
+ *  be between 16 and 32.
+ */
+const OI_CONFIG_DISPATCH oi_default_config_DISPATCH = {
+#ifdef SMALL_RAM_MEMORY
+    16                   /* OI_UINT16 DispatchTableSize */
+#else
+    64                   /* OI_UINT16 DispatchTableSize */
+#endif
+};
+
+
+/*****************************************************************************/
diff --git a/obex_profiles/sdk/oem/oi_bt_stack_init_default.c b/obex_profiles/sdk/oem/oi_bt_stack_init_default.c
new file mode 100644
index 0000000..0ee3fbb
--- /dev/null
+++ b/obex_profiles/sdk/oem/oi_bt_stack_init_default.c
@@ -0,0 +1,144 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ * @file
+ *
+ * This file provides default routines for the initialization and termination of the
+ * BLUEmagic 3.0 protocol stack
+ *
+ *
+ *  This default initialization a method for vendor-specific initialization.
+ *      Define the token USE_DEFAULT_VENDOR_INIT (any value)
+ *      his will cause the external function OI_DefaultVendorInit() to be called.
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_OEM
+
+#include "oi_common.h"
+#include "oi_osinterface.h"
+#include "oi_argcheck.h"
+#include "oi_utils.h"
+#include "oi_bt_stack_init.h"
+#include "oi_bt_module_init.h"
+#include "oi_support_init.h"
+#include "oi_wrapper.h"
+#include "oi_bt_stack_config.h"
+#include "oi_config_table.h"
+#include "oi_debug.h"
+
+/*
+ * Initialization completion callback
+ */
+static OI_INIT_COMPLETE_CB stackInitCb;
+
+/*
+ * Initializer functions which bring up all required portions of BM3
+ */
+OI_STATUS OI_BT_StackInit(OI_INIT_COMPLETE_CB                 initComplete,
+                          OI_DISPATCH_SERVICE_REQUEST_HANDLER handler)
+{
+    return(OI_BT_StackInit_Custom(initComplete, handler, NULL));
+}
+
+OI_STATUS OI_BT_StackInit_Custom(OI_INIT_COMPLETE_CB                 initComplete,
+                                 OI_DISPATCH_SERVICE_REQUEST_HANDLER handler,
+                                 void (*customCB)(void))
+{
+    OI_STATUS status;
+
+    OI_ARGCHECK(NULL != initComplete);
+    OI_ARGCHECK(NULL != handler);
+
+    stackInitCb = initComplete;
+
+    /*
+     * Initialize infrastructure needed by all modules
+     */
+    OI_InitFlags_ResetAllFlags();
+    OI_ConfigTable_Init();
+    /*
+     * Give application's a chance to override default configurations (if desired)
+     */
+    if (NULL != customCB)  {
+        OI_Print("Invoking customization callback\n");
+        customCB();
+    }
+
+    status = OI_Support_Init();
+    if (!OI_SUCCESS(status)) {
+        OI_Printf("Support code initialization failed\n");
+        return status;
+    }
+
+    /*
+     * Memory Manager
+     */
+    status = OI_MEMMGR_Init(OI_CONFIG_TABLE_GET(MEMMGR));
+    if (!OI_SUCCESS(status)) {
+        OI_Printf("Memory Manager initialization failed\n");
+        return status;
+    }
+
+    /*
+     * Dispatcher
+     */
+    status = OI_Dispatch_Init(handler);
+    if (!OI_SUCCESS(status)) {
+        OI_Printf("OI_Dispatch_Init failed\n");
+        return status;
+    }
+
+    /*
+     * EventLoop
+     */
+    status = OI_EVENTLOOP_Init();
+    if (!OI_SUCCESS(status)) {
+        OI_Printf("OI_EVENTLOOP_Init failed\n");
+        return status;
+    }
+
+    /* initialization has begun, callback will be called when init has completed */
+    return OI_OK;
+}
+
+OI_STATUS OI_BT_Stack_Terminate(void)
+{
+    OI_EVENTLOOP_Shutdown();
+
+    OI_Dispatch_Terminate();
+
+    OI_InitFlags_ResetAllFlags();
+
+    return OI_OK;
+
+}
+
diff --git a/obex_profiles/sdk/oem/oi_wrapper.h b/obex_profiles/sdk/oem/oi_wrapper.h
new file mode 100644
index 0000000..a8c5c55
--- /dev/null
+++ b/obex_profiles/sdk/oem/oi_wrapper.h
@@ -0,0 +1,183 @@
+#ifndef _OI_WRAPPER_H
+#define _OI_WRAPPER_H
+
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ *
+ * This file provides the interface to the sample protocol stack
+ * wrapper.
+ *
+ * For each platform, an example protocol stack wrapper is provided to demonstrate
+ * application-level management of the BLUEmagic 3.0 protocol stack and support modules.
+ * The stack wrapper initializes the protocol stack and support modules and provides
+ * a stack access token (usually a mutex, but perhaps some other mechanism, depending
+ * on the specific operating system in use) to enforce exclusive access to the protocol
+ * stack.
+ */
+
+#include "oi_stddefs.h"
+#include "oi_status.h"
+#include "oi_bt_stack_init.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * This function performs initialization of the stack wrapper module,
+ * including initializing the stack synchronization scheme.
+ * This function allocates the stack access token and initializes the lower and upper
+ * layer protocol stack. The stack access token does not exist until this function
+ * returns, so no calls that obtain or release the token should be called prior to
+ * this function.
+ *
+ *  - OI_OBEX_Init &mdash; Legacy Synchronously Only
+ *    form.
+ *
+ *
+ * @param initComplete         Function to call upon completion of stack
+ *                             initialization. If NULL is
+ *                             passed, then the call is
+ *                             completed synchronously.
+ *
+ * @param idleSleepMsecs       Amount of time to allocate to the
+ *                             Dispatcher during calls to
+ *                             OI_StackConsole_GetInput() and
+ *                             OI_Wrapper_WaitForEvent().
+ */
+OI_STATUS OI_OBEX_Init(OI_UINT32           idleSleepMsecs);
+
+/**
+ * This function is an alternative to OI_Wrapper_Init() which provides the same functionality.
+ * This function allows the application to customize the core
+ * stack and profile configurations by providing a customization
+ * callback. The customization callback will be invoked during
+ * the initialization process before the core stack components
+ * are initialized. The customization callback then has the
+ * opportunity to specify the module configuration using
+ * OI_CONFIG_TABLE_PUT(). Refer to file oi_config_table.h for
+ * API descriptions.
+ *
+ *  - OI_Wrapper_Init_Custom $mdash; Legacy Synchronously
+ *   Only form.
+ *
+ * @param initComplete         Function to call upon completion of stack
+ *                             initialization. If NULL is
+ *                             passed, then the call is
+ *                             completed synchronously.
+ *
+ * @param idleSleepMsecs       Amount of time to allocate to the
+ *                             Dispatcher during calls to
+ *                             OI_StackConsole_GetInput() and
+ *                             OI_Wrapper_WaitForEvent()
+ *
+ * @param customCB  Callback to be invoked at the appropriate
+ *                  point during initialization.
+ *
+ */
+OI_STATUS OI_Wrapper_Init_Custom(OI_UINT32 idleSleepMsecs,
+                                     void (*customCB)(void));
+
+/**
+ * This function enters device-under-test mode when called, and is an alternative to both
+ * OI_Wrapper_Init() and OI_Wrapper_Init_Custom().
+ * This function does not have a return value.
+ */
+void OI_Wrapper_Init_DUT(void);
+
+/**
+ * A thread attempts to get the stack access token by calling this function.
+ * This function must be called before calling into the protocol
+ * stack. This function may be blocked if the token is not
+ * available. When this function returns, the caller owns the
+ * stack token and may call into the stack. It is incumbent on
+ * the caller to release the stack token when it is no longer
+ * needed.
+ */
+void    OI_Wrapper_GetToken(void);
+
+/**
+ * A thread releases the stack access token by calling this function.
+ * This function returns the stack token. When this function returns to the caller,
+ * the caller no longer owns the token and the caller may not call into the stack
+ * without re-acquiring the token.
+ */
+void    OI_Wrapper_ReleaseToken(void);
+
+/**
+ * Wait for event.
+ *   This function blocks until the indicated event is signaled or until the timeout
+ *   (if any) occurs. This function must be called without the stack access token.
+ *   Because this is a blocking call, it must not be called from within a BLUEmagic
+ *   callback routine.
+ *
+ *   @param pEventFlag       Pointer to a Boolean value to which
+ *                           OI_Wrapper_SignalEvent() also
+ *                           has a pointer, allowing the wait
+ *                           function to test whether the event
+ *                           has occurred
+ *   @param timeoutSeconds   Maximum time to wait on the event
+ *                           (Zero indicates no timeout.)
+ *   @return                 OI_OK if event occured; OI_TIMEOUT if timed out
+ */
+OI_STATUS OI_Wrapper_WaitForEvent(OI_BOOL *pEventFlag, OI_UINT timeoutSeconds) ;
+
+
+/**
+ * Signal event.
+ *   This function signals that the event for which OI_Wrapper_WaitForEvent() is waiting
+ *   has occurred. This function may be called at any time, from any context.
+ *
+ *   @param pEventFlag    Pointer to a Boolean value to which
+ *                        OI_Wrapper_WaitForEvent() also
+ *                        has a pointer, allowing the signal
+ *                        function to signal whether the event
+ *                        has occurred
+ *   @return              OI_OK always
+ */
+OI_STATUS OI_Wrapper_SignalEvent (OI_BOOL *pEventFlag) ;
+
+
+/**
+ * Deinitializes the stack wrapper and cleans up all resources.
+ * Because this function is intended to allow BLUEmagic 3.0
+ * software to clean up after itself, this function must be
+ * called without the stack access token.
+ */
+void OI_OBEX_Deinit(void) ;
+
+#ifdef __cplusplus
+}
+#endif
+
+/*****************************************************************************/
+#endif /* _OI_WRAPPER_H */
diff --git a/obex_profiles/stack/dataelem/dataelem.c b/obex_profiles/stack/dataelem/dataelem.c
new file mode 100644
index 0000000..8f2a463
--- /dev/null
+++ b/obex_profiles/stack/dataelem/dataelem.c
@@ -0,0 +1,143 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+@file
+@internal
+This file provides helper functions for the managing of data elements.
+*/
+
+#define __OI_MODULE__ OI_MODULE_DATAELEM
+
+#include "oi_debug.h"
+#include "oi_bt_assigned_nos.h"
+#include "oi_memmgr.h"
+#include "oi_assert.h"
+#include "oi_dataelem.h"
+
+/*****************************************************************************
+  comparison functions and macros for different size UUIDs
+ ******************************************************************************/
+
+/** macro for comparing two 128-bit UUIDs */
+#define LongUUID_eq_LongUUID(uA, uB)   (OI_MemCmp((uA), (uB), sizeof(OI_UUID128)) == 0)
+
+/** function for comparing a 32-bit UUID to a 128-bit UUID */
+OI_BOOL OI_ShortUUID_eq_LongUUID(OI_UUID32 shortUUID,
+                                 const OI_UUID128 *longUUID)
+{
+    OI_UUID128 TestUUID = OI_UUID_BASE_UUID128;
+
+    OI_ASSERT(longUUID != NULL);
+
+    /*
+     * TestUUID was initialized to the constant 128-bit base UUID, so all that is needed is to set
+     * the 32-bit variable component and compare the resultant 128-bit UUID.
+     */
+    TestUUID.ms32bits = shortUUID;
+    return LongUUID_eq_LongUUID(longUUID, &TestUUID);
+}
+
+/** function for comparing two UUIDs */
+OI_BOOL OI_DATAELEM_SameUUID(const OI_DATAELEM *A,
+                             const OI_DATAELEM *B)
+{
+    if ((A->ElemType != OI_DATAELEM_UUID) || (B->ElemType != OI_DATAELEM_UUID)) {
+        return FALSE;
+    }
+
+    switch (A->Size) {
+        case sizeof(OI_UUID16):
+        case sizeof(OI_UUID32):
+            if (B->Size == sizeof(OI_UUID128)) {
+                return OI_ShortUUID_eq_LongUUID(A->Value.ShortUUID, B->Value.LongUUID);
+            } else {
+                return A->Value.ShortUUID == B->Value.ShortUUID;
+            }
+        case sizeof(OI_UUID128):
+            if (B->Size == sizeof(OI_UUID128)) {
+                return LongUUID_eq_LongUUID(A->Value.LongUUID, B->Value.LongUUID);
+            } else {
+                return OI_ShortUUID_eq_LongUUID(B->Value.ShortUUID, A->Value.LongUUID);
+            }
+    }
+    return FALSE;
+}
+
+
+OI_STATUS OI_DATAELEM_ConvertToUUID128(OI_UUID128 *uuid128, const OI_DATAELEM *U)
+{
+
+    if (U->ElemType != OI_DATAELEM_UUID) {
+        return OI_FAIL;
+    }
+    if (U->Size == sizeof(OI_UUID128)) {
+        *uuid128 = *U->Value.LongUUID;
+    } else {
+        OI_UUID128 baseUUID = OI_UUID_BASE_UUID128;
+        baseUUID.ms32bits = U->Value.ShortUUID;
+        *uuid128 = baseUUID;
+    }
+    return OI_OK;
+}
+
+
+OI_UUID32 OI_DATAELEM_ConvertToUUID32(const OI_DATAELEM *U)
+{
+    OI_UUID128 TestUUID = OI_UUID_BASE_UUID128;
+
+    if (U->ElemType == OI_DATAELEM_UUID) {
+        switch (U->Size) {
+            case sizeof(OI_UUID16):
+            case sizeof(OI_UUID32):
+                return U->Value.ShortUUID;
+            case sizeof(OI_UUID128):
+                TestUUID.ms32bits = U->Value.LongUUID->ms32bits;
+                if (LongUUID_eq_LongUUID(U->Value.LongUUID, &TestUUID)) {
+                    return (OI_UUID32) U->Value.LongUUID->ms32bits;
+                }
+        }
+    }
+    /*
+     * no 32-bit representation of this UUID
+     */
+    return 0;
+}
+
+OI_CHAR* OI_UUIDDataelemText(const OI_DATAELEM *pElem)
+{
+    OI_ASSERT(OI_DATAELEM_UUID == pElem->ElemType);
+
+    if (sizeof(OI_UUID128) == pElem->Size) {
+        return OI_UUID128Text(pElem->Value.LongUUID);
+    } else {
+        return OI_UUIDText(pElem->Value.ShortUUID);
+    }
+}
+
diff --git a/obex_profiles/stack/dataelem/dataelem_text.c b/obex_profiles/stack/dataelem/dataelem_text.c
new file mode 100644
index 0000000..203e758
--- /dev/null
+++ b/obex_profiles/stack/dataelem/dataelem_text.c
@@ -0,0 +1,232 @@
+/**
+* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*/
+
+#define __OI_MODULE__ OI_MODULE_DATAELEM
+
+#include "oi_status.h"
+#include "oi_dataelem.h"
+#include "oi_debug.h"
+#include "oi_assert.h"
+#include "oi_varstring.h"
+#include "oi_bt_assigned_nos.h"
+
+
+
+#define STR_0x            "0x"
+#define STR_LT            "<"
+#define STR_LT_SLASH      "</"
+#define STR_GT            ">"
+#define STR_SLASH_GT_NL   "/>\n"
+
+
+#define STR_NEWLINE       "\n"
+
+
+#define INDENT_INCREMENT 4
+#define MAX_BYTES_ON_LINE 32
+
+
+#define NewlineCat(t)    OI_VStrCat((t), STR_NEWLINE)
+
+
+#ifdef OI_DEBUG
+
+/**
+ * This function puts a symbolic name as an attribute in the tag for element values that map
+ * to symbolic names.
+ */
+static void ShowName(OI_VARSTRING *VStr,
+                     OI_DATAELEM const *Element)
+{
+    OI_CHAR *name = NULL;
+
+    switch (Element->ElemType) {
+        case OI_DATAELEM_UUID:
+            if (Element->Size <= sizeof(OI_UUID32)) {
+                name = OI_UUIDText(Element->Value.ShortUUID);
+            }
+            break;
+        default:
+            return;
+    }
+
+    if (name != NULL) {
+        OI_VStrCat(VStr, " id=\"");
+        OI_VStrCat(VStr, name);
+        OI_VStrCat(VStr, "\"");
+    }
+}
+
+void OI_DataElement_XML(OI_VARSTRING *VStr,
+                        OI_DATAELEM const *Element,
+                        OI_UINT8 Indent)
+{
+    OI_UINT8 i;
+    OI_UINT16 tagStart;
+    OI_UINT16 tagEnd;
+
+    if (Element->ElemType == OI_DATAELEM_REF) {
+        Element = Element->Value.ElemRef;
+    }
+
+    OI_VSpaceCat(VStr, Indent);
+    OI_VStrCat(VStr, STR_LT);
+    tagStart = VStr->Len;
+
+    switch (Element->ElemType) {
+        case OI_DATAELEM_BOOL:
+            OI_VStrCat(VStr, (Element->Value.Boolean) ? "true" : "false");
+            OI_VStrCat(VStr, STR_SLASH_GT_NL);
+            return;
+        case OI_DATAELEM_NULL:
+            OI_VStrCat(VStr, "null");
+            OI_VStrCat(VStr, STR_SLASH_GT_NL);
+            return;
+        case OI_DATAELEM_UINT:
+            OI_VStrCat(VStr, "uint");
+            OI_VDecCat(VStr, Element->Size * 8);
+            break;
+        case OI_DATAELEM_SINT:
+            OI_VStrCat(VStr, "sint");
+            OI_VDecCat(VStr, Element->Size * 8);
+            break;
+        case OI_DATAELEM_UUID:
+            OI_VStrCat(VStr, "uuid");
+            OI_VDecCat(VStr, Element->Size * 8);
+            break;
+        case OI_DATAELEM_TEXT:
+            OI_VStrCat(VStr, "text");
+            break;
+        case OI_DATAELEM_URL:
+            OI_VStrCat(VStr, "url");
+            break;
+        case OI_DATAELEM_SEQ:
+            OI_VStrCat(VStr, "seq");
+            break;
+        case OI_DATAELEM_ALT:
+            OI_VStrCat(VStr, "alt");
+            break;
+    }
+
+    tagEnd = VStr->Len;
+    ShowName(VStr, Element);
+    OI_VStrCat(VStr, STR_GT);
+
+    switch (Element->ElemType) {
+        case OI_DATAELEM_UINT:
+        case OI_DATAELEM_SINT:
+            if (Element->Size > sizeof(OI_UINT32)) {
+                OI_VStrCat(VStr, STR_0x);
+                if (Element->Size == sizeof(OI_UINT64)) {
+                    OI_VHexCat(VStr, Element->Value.UInt64->I1, 2 * sizeof(OI_UINT32));
+                    OI_VHexCat(VStr, Element->Value.UInt64->I2, 2 * sizeof(OI_UINT32));
+                } else {
+                    OI_VHexCat(VStr, Element->Value.UInt128->I1, 2 * sizeof(OI_UINT32));
+                    OI_VHexCat(VStr, Element->Value.UInt128->I2, 2 * sizeof(OI_UINT32));
+                    OI_VHexCat(VStr, Element->Value.UInt128->I3, 2 * sizeof(OI_UINT32));
+                    OI_VHexCat(VStr, Element->Value.UInt128->I4, 2 * sizeof(OI_UINT32));
+                }
+            } else {
+                if (Element->ElemType == OI_DATAELEM_UINT) {
+                    OI_VStrCat(VStr, STR_0x);
+                    OI_VHexCat(VStr, Element->Value.UInt, 2 * Element->Size);
+                } else {
+                    OI_VDecCat(VStr, Element->Value.SInt);
+                }
+            }
+            break;
+        case OI_DATAELEM_UUID:
+            OI_VStrCat(VStr, STR_0x);
+            if (Element->Size <= sizeof(OI_UUID32)) {
+                OI_VHexCat(VStr, Element->Value.ShortUUID, 2 * Element->Size);
+            } else {
+                OI_VHexCat(VStr, Element->Value.LongUUID->ms32bits, 2 * sizeof(OI_UINT32));
+                OI_VStrCat(VStr, ",");
+                for (i = 0; i < sizeof(Element->Value.LongUUID->base); ++i) {
+                    OI_VHexCat(VStr, Element->Value.LongUUID->base[i], 2 * sizeof(OI_UINT8));
+                    if ((i == 1) || (i == 3) || (i == 5)) {
+                        OI_VStrCat(VStr, ",");
+                    }
+                }
+            }
+            break;
+        case OI_DATAELEM_SEQ:
+        case OI_DATAELEM_ALT:
+            NewlineCat(VStr);
+            Indent += INDENT_INCREMENT;
+            for (i = 0; i < Element->Size; ++i) {
+                OI_DataElement_XML(VStr, &Element->Value.ElemSeq[i], Indent);
+            }
+            Indent -= INDENT_INCREMENT;
+            OI_VSpaceCat(VStr, Indent);
+            break;
+        case OI_DATAELEM_URL:
+        case OI_DATAELEM_TEXT:
+            OI_VStrnCat(VStr, Element->Value.Text, Element->Size);
+            break;
+        default:
+            OI_VStrCat(VStr, "!!!Corrupt Data Element!!!");
+    }
+
+    OI_VStrCat(VStr, STR_LT_SLASH);
+    OI_VStrnCat(VStr, &VStr->Buffer[tagStart], (OI_UINT16) (tagEnd - tagStart));
+    OI_VStrCat(VStr, STR_GT);
+    NewlineCat(VStr);
+}
+
+
+void OI_DataElement_Print(OI_DATAELEM *Element)
+{
+    OI_VARSTRING vStr;
+    OI_CHAR      *str;
+
+    OI_VStrAlloc(&vStr, 100);
+    OI_DataElement_XML(&vStr, Element, 0);
+    str = OI_VStrGetString(&vStr);
+    if (str) {
+        OI_DBGPRINTSTR((str));
+    }
+    OI_VStrFree(&vStr);
+}
+
+#else /* OI_DEBUG */
+
+void OI_DataElement_Print(OI_DATAELEM *Element)
+{
+}
+
+void OI_DataElement_XML(OI_VARSTRING *VStr,
+                        OI_DATAELEM const *Element,
+                        OI_UINT8 Indent)
+{
+    OI_VStrCat(VStr, "<data element/>");
+}
+
+#endif /* OI_DEBUG */
diff --git a/obex_profiles/stack/support/bt_assigned_nos.c b/obex_profiles/stack/support/bt_assigned_nos.c
new file mode 100644
index 0000000..56697fc
--- /dev/null
+++ b/obex_profiles/stack/support/bt_assigned_nos.c
@@ -0,0 +1,294 @@
+/**
+* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*/
+
+/**
+@file
+@internal
+This file provides assigned number text display routines.
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_bt_assigned_nos.h"
+#include "oi_memmgr.h"
+
+static const OI_CHAR digits[] = "0123456789ABCDEF";
+static OI_CHAR buffer[7];
+
+
+#define ATTRID_CASE(x) case OI_ATTRID_##x : return #x
+
+OI_CHAR* OI_AttrIdText(OI_UINT16 AttrId)
+{
+#ifdef OI_DEBUG
+    switch (AttrId) {
+        ATTRID_CASE(ServiceRecordHandle);
+        ATTRID_CASE(ServiceClassIDList);
+        ATTRID_CASE(ServiceRecordState);
+        ATTRID_CASE(ServiceID);
+        ATTRID_CASE(ProtocolDescriptorList);
+        ATTRID_CASE(BrowseGroupList);
+        ATTRID_CASE(LanguageBaseAttributeIDList);
+        ATTRID_CASE(ServiceInfoTimeToLive);
+        ATTRID_CASE(ServiceAvailability);
+        ATTRID_CASE(BluetoothProfileDescriptorList);
+        ATTRID_CASE(DocumentationURL);
+        ATTRID_CASE(ClientExecutableURL);
+        ATTRID_CASE(IconURL);
+        ATTRID_CASE(AdditionalProtocolDescriptorLists);
+        case OI_ATTRID_GroupID:
+            /* DUPLICATE ASSIGNED #
+            ATTRID_CASE(GroupID);
+            ATTRID_CASE(IpSubnet);
+            ATTRID_CASE(VersionNumberList);
+               */
+            return "GroupID or IpSubnet or VersionNumberList";
+        ATTRID_CASE(ServiceDatabaseState);
+        ATTRID_CASE(Service_Version);
+        case OI_ATTRID_External_Network:
+            /* DUPLICATE ASSIGNED #
+            ATTRID_CASE(External_Network);
+            ATTRID_CASE(Network);
+            ATTRID_CASE(Supported_Data_Stores_List);
+               */
+            return "External_Network or Network or Supported_Data_Stores_List";
+        case OI_ATTRID_RemoteAudioVolumeControl:
+            /* DUPLICATE ASSIGNED #
+            ATTRID_CASE(RemoteAudioVolumeControl);
+            ATTRID_CASE(FaxClass1Support);
+               */
+            return "FaxClass1Support or RemoteAudioVolumeControl";
+        case OI_ATTRID_FaxClass20Support:
+            /* DUPLICATE ASSIGNED #
+            ATTRID_CASE(FaxClass20Support);
+            ATTRID_CASE(SupportedFormatsList);
+               */
+            return "FaxClass20Support or SupportedFormatsList";
+        ATTRID_CASE(FaxClass2Support);
+        ATTRID_CASE(Audio_Feedback_Support);
+        ATTRID_CASE(NetworkAddress);
+        ATTRID_CASE(WAPGateWay);
+        ATTRID_CASE(HomePageURL);
+        ATTRID_CASE(WAPStackType);
+        ATTRID_CASE(SecurityDescription);
+        ATTRID_CASE(NetAccessType);
+        ATTRID_CASE(MaxNetAccessRate);
+        ATTRID_CASE(SupportedCapabilities);
+        ATTRID_CASE(SupportedFeatures);
+        ATTRID_CASE(SupportedFunctions);
+        ATTRID_CASE(TotalImagingDataCapacity);
+
+        ATTRID_CASE(BPP_DocumentFormats);
+        ATTRID_CASE(BPP_CharacterRepertoires);
+        ATTRID_CASE(BPP_XHTMLPrintImageFormats);
+        ATTRID_CASE(BPP_Color);
+        ATTRID_CASE(BPP_1284ID);
+        ATTRID_CASE(BPP_PrinterName);
+        ATTRID_CASE(BPP_PrinterLocation);
+        ATTRID_CASE(BPP_Duplex);
+        ATTRID_CASE(BPP_MediaTypes);
+        ATTRID_CASE(BPP_MaxMediaWidth);
+        ATTRID_CASE(BPP_MaxMediaLength);
+        ATTRID_CASE(BPP_EnhancedLayout);
+        ATTRID_CASE(BPP_RUIFormats);
+        ATTRID_CASE(BPP_ReferencePrintingRUI);
+        ATTRID_CASE(BPP_DirectPrintingRUI);
+        ATTRID_CASE(BPP_ReferencePrintingTopURL);
+        ATTRID_CASE(BPP_DirectPrintingTopURL);
+
+        case OI_ATTRID_DEFAULT_LanguageBaseOffset + OI_ATTRID_ServiceName        : return "ServiceName";
+        case OI_ATTRID_DEFAULT_LanguageBaseOffset + OI_ATTRID_ServiceDescription : return "ServiceDescription";
+        case OI_ATTRID_DEFAULT_LanguageBaseOffset + OI_ATTRID_ProviderName       : return "ProviderName";
+
+    }
+#endif /* OI_DEBUG */
+    buffer[0] = '0';
+    buffer[1] = 'x';
+    buffer[2] = digits[(AttrId >> 12) & 0xF];
+    buffer[3] = digits[(AttrId >> 8) & 0xF];
+    buffer[4] = digits[(AttrId >> 4) & 0xF];
+    buffer[5] = digits[(AttrId >> 0) & 0xF];
+    buffer[6] = 0;
+    return buffer;
+}
+
+
+OI_CHAR* OI_UUID128Text(OI_UUID128 *UUID)
+{
+
+    OI_UUID128 TestUUID = OI_UUID_BASE_UUID128;
+
+    if (!UUID) {
+        return "invalid";
+    }
+    /* other 128-bit UUID's are known only if they are Bluetooth UUID's */
+    if (OI_MemCmp(UUID->base, TestUUID.base, sizeof(TestUUID.base)) != 0) {
+        return "unknown";
+    } else {
+        return OI_UUIDText(UUID->ms32bits);
+    }
+}
+
+
+OI_CHAR* OI_UUIDText(OI_UUID32 UUID)
+{
+#ifdef OI_DEBUG
+    switch (UUID) {
+        /*
+         * Protocol UUIDs
+         */
+        case OI_UUID_NULL                                 : return "NULL";
+        case OI_UUID_SDP                                  : return "SDP";
+        case OI_UUID_UDP                                  : return "UDP";
+        case OI_UUID_RFCOMM                               : return "RFCOMM";
+        case OI_UUID_TCP                                  : return "TCP";
+        case OI_UUID_TCS_BIN                              : return "TCS_BIN";
+        case OI_UUID_TCS_AT                               : return "TCS_AT";
+        case OI_UUID_OBEX                                 : return "OBEX";
+        case OI_UUID_IP                                   : return "IP";
+        case OI_UUID_FTP                                  : return "FTP";
+        case OI_UUID_HTTP                                 : return "HTTP";
+        case OI_UUID_WSP                                  : return "WSP";
+        case OI_UUID_BNEP                                 : return "BNEP";
+        case OI_UUID_UPNP                                 : return "UPNP";
+        case OI_UUID_HIDP                                 : return "HIDP";
+        case OI_UUID_HardcopyControlChannel               : return "HardcopyControlChannel";
+        case OI_UUID_HardcopyDataChannel                  : return "HardcopyDataChannel";
+        case OI_UUID_HardcopyNotification                 : return "HardcopyNotification";
+        case OI_UUID_AVCTP                                : return "AVCTP";
+        case OI_UUID_AVDTP                                : return "AVDTP";
+        case OI_UUID_L2CAP                                : return "L2CAP";
+        /*
+         * Service UUIDs
+         */
+        case OI_UUID_ServiceDiscoveryServerServiceClassID  : return "ServiceDiscoveryServerServiceClassID";
+        case OI_UUID_BrowseGroupDescriptorServiceClassID   : return "BrowseGroupDescriptorServiceClassID";
+        case OI_UUID_PublicBrowseGroup                     : return "PublicBrowseGroup";
+        case OI_UUID_SerialPort                            : return "SerialPort";
+        case OI_UUID_LANAccessUsingPPP                     : return "LANAccessUsingPPP";
+        case OI_UUID_DialupNetworking                      : return "DialupNetworking";
+        case OI_UUID_IrMCSync                              : return "IrMCSync";
+        case OI_UUID_OBEXObjectPush                        : return "OBEXObjectPush";
+        case OI_UUID_OBEXFileTransfer                      : return "OBEXFileTransfer";
+        case OI_UUID_IrMCSyncCommand                       : return "IrMCSyncCommand";
+        case OI_UUID_Headset                               : return "Headset";
+        case OI_UUID_CordlessTelephony                     : return "CordlessTelephony";
+        case OI_UUID_AudioSource                           : return "AudioSource";
+        case OI_UUID_AudioSink                             : return "AudioSink";
+        case OI_UUID_AV_RemoteControlTarget                : return "AV_RemoteControlTarget";
+        case OI_UUID_AdvancedAudioDistribution             : return "AdvancedAudioDistribution";
+        case OI_UUID_AV_RemoteControl                      : return "AV_RemoteControl";
+        case OI_UUID_VideoConferencing                     : return "VideoConferencing";
+        case OI_UUID_Intercom                              : return "Intercom";
+        case OI_UUID_Fax                                   : return "Fax";
+        case OI_UUID_HeadsetAudioGateway                   : return "HeadsetAudioGateway";
+        case OI_UUID_WAP                                   : return "WAP";
+        case OI_UUID_WAP_CLIENT                            : return "WAP_CLIENT";
+        case OI_UUID_PANU                                  : return "PANU";
+        case OI_UUID_NAP                                   : return "NAP";
+        case OI_UUID_GN                                    : return "GN";
+        case OI_UUID_DirectPrinting                        : return "DirectPrinting";
+        case OI_UUID_ReferencePrinting                     : return "ReferencePrinting";
+        case OI_UUID_Imaging                               : return "Imaging";
+        case OI_UUID_ImagingResponder                      : return "ImagingResponder";
+        case OI_UUID_ImagingAutomaticArchive               : return "ImagingAutomaticArchive";
+        case OI_UUID_ImagingReferencedObjects              : return "ImagingReferencedObjects";
+        case OI_UUID_Handsfree                             : return "Handsfree";
+        case OI_UUID_HandsfreeAudioGateway                 : return "HandsfreeAudioGateway";
+        case OI_UUID_DirectPrintingReferenceObjectsService : return "DirectPrintingReferenceObjectsService";
+        case OI_UUID_ReflectedUI                           : return "ReflectedUI";
+        case OI_UUID_BasicPrinting                         : return "BasicPrinting";
+        case OI_UUID_PrintingStatus                        : return "PrintingStatus";
+        case OI_UUID_HumanInterfaceDeviceService           : return "HumanInterfaceDeviceService";
+        case OI_UUID_HardcopyCableReplacement              : return "HardcopyCableReplacement";
+        case OI_UUID_HCR_Print                             : return "HCR_Print";
+        case OI_UUID_HCR_Scan                              : return "HCR_Scan";
+        case OI_UUID_Common_ISDN_Access                    : return "Common_ISDN_Access";
+        case OI_UUID_VideoConferencingGW                   : return "VideoConferencingGW";
+        case OI_UUID_UID_MT                                : return "UID_MT";
+        case OI_UUID_UID_TA                                : return "UID_TA";
+        case OI_UUID_Audio_Video                           : return "Audio_Video";
+        case OI_UUID_SIM_Access                            : return "SIM_Access";
+        case OI_UUID_PhonebookAccessClient                 : return "PhonebookAccessClient";
+        case OI_UUID_PhonebookAccessServer                 : return "PhonebookAccessServer";
+        case OI_UUID_PhonebookAccess                       : return "PhonebookAccess";
+        case OI_UUID_Headset_HS                            : return "Headset_HS";
+        case OI_UUID_MessageAccessServer                   : return "MessageAccessServer";
+        case OI_UUID_MessageNotificationServer             : return "MessageNotificationServer";
+        case OI_UUID_MessageAccessProfile                  : return "MessageAccessProfile";
+        case OI_UUID_PnPInformation                        : return "PnPInformation";
+        case OI_UUID_GenericNetworking                     : return "GenericNetworking";
+        case OI_UUID_GenericFileTransfer                   : return "GenericFileTransfer";
+        case OI_UUID_GenericAudio                          : return "GenericAudio";
+        case OI_UUID_GenericTelephony                      : return "GenericTelephony";
+        case OI_UUID_UPNP_Service                          : return "UPNP_Service";
+        case OI_UUID_UPNP_IP_Service                       : return "UPNP_IP_Service";
+        case OI_UUID_ESDP_UPNP_IP_PAN                      : return "ESDP_UPNP_IP_PAN";
+        case OI_UUID_ESDP_UPNP_IP_LAP                      : return "ESDP_UPNP_IP_LAP";
+        case OI_UUID_ESDP_UPNP_IP_L2CAP                    : return "ESDP_UPNP_IP_L2CAP";
+        case OI_UUID_VideoSource                           : return "VideoSource";
+        case OI_UUID_VideoSink                             : return "VideoSink";
+        case OI_UUID_VideoDistribution                     : return "VideoDistribution";
+    }
+#endif /* OI_DEBUG */
+    buffer[0] = '0';
+    buffer[1] = 'x';
+    buffer[2] = digits[(UUID >> 12) & 0xF];
+    buffer[3] = digits[(UUID >> 8) & 0xF];
+    buffer[4] = digits[(UUID >> 4) & 0xF];
+    buffer[5] = digits[(UUID >> 0) & 0xF];
+    buffer[6] = 0;
+    return buffer;
+}
+
+OI_CHAR* OI_PSMText(OI_UINT16 psm)
+{
+#ifdef OI_DEBUG
+    switch (psm) {
+        case OI_PSM_SDP:            return "OI_PSM_SDP";
+        case OI_PSM_RFCOMM:         return "OI_PSM_RFCOMM";
+        case OI_PSM_TCS:            return "OI_PSM_TCS";
+        case OI_PSM_TCS_CORDLESS:   return "OI_PSM_TCS_CORDLESS";
+        case OI_PSM_BNEP:           return "OI_PSM_BNEP";
+        case OI_PSM_HID_CONTROL:    return "OI_PSM_HID_CONTROL";
+        case OI_PSM_HID_INTERRUPT:  return "OI_PSM_HID_INTERRUPT";
+        case OI_PSM_AVCTP:          return "OI_PSM_AVCTP";
+        case OI_PSM_AVDTP:          return "OI_PSM_AVDTP";
+        case OI_PSM_AVCTP_BROWSING: return "OI_PSM_AVCTP_BROWSING";
+        case OI_PSM_UDI_C_PLANE:    return "OI_PSM_UDI_C_PLANE";
+    }
+    return "";
+#else
+    return "";
+#endif
+}
+
+/*****************************************************************************/
+
diff --git a/obex_profiles/stack/support/md5_hash.c b/obex_profiles/stack/support/md5_hash.c
new file mode 100644
index 0000000..d9f3cad
--- /dev/null
+++ b/obex_profiles/stack/support/md5_hash.c
@@ -0,0 +1,240 @@
+/** @file
+ * @internal
+ * This code implements the MD5 message-digest algorithm. The algorithm is due
+ * to Ron Rivest and is described in RFC 1321.
+ *
+ * This code was written by Colin Plumb in 1993; no copyright is claimed.
+ *
+ * To compute the message digest of a chunk of bytes, declare an MD5_Context
+ * structure, pass it to OI_MD5_Init, call OI_MD5_Update as needed on buffers full of
+ * bytes, and then call OI_MD5_Final, which will fill a supplied 16-byte array with
+ * the digest.
+ */
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "md5_hash.h"
+#include "oi_memmgr.h"
+
+
+static void Transform(OI_UINT32 *buf,
+                      OI_UINT32 *in);
+
+
+/*
+ * Shuffle the bytes into little-endian order within 32 bit unsigned integers
+ * as per the MD5 spec. Note: this code works regardless of the CPU byte order.
+ */
+
+static void ByteSwap(OI_UINT32 *buf,
+                     OI_UINT count)
+{
+    OI_BYTE *p = (OI_BYTE*) buf;
+
+    do {
+        *buf++ = (OI_UINT32) ((OI_UINT) p[3] << 8 | p[2]) << 16 | ((OI_UINT) p[1] << 8 | p[0]);
+        p += sizeof(OI_UINT32);
+    } while (--count);
+}
+
+
+/*
+ * Start MD5 accumulation. Set bit count to 0 and buffer to mysterious
+ * initialization constants.
+ */
+
+void OI_MD5_Init(MD5_CONTEXT *ctx)
+{
+    ctx->buf[0] = 0x67452301;
+    ctx->buf[1] = 0xefcdab89;
+    ctx->buf[2] = 0x98badcfe;
+    ctx->buf[3] = 0x10325476;
+
+    ctx->bytes[0] = 0;
+    ctx->bytes[1] = 0;
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+void OI_MD5_Update(MD5_CONTEXT *ctx,
+                OI_BYTE *buf,
+                OI_UINT16 len)
+{
+    OI_UINT t;
+
+    /* Update byte count */
+    t = ctx->bytes[0];
+    if ((ctx->bytes[0] = t + len) < t) {
+        ctx->bytes[1]++; /* Carry from low to high */
+    }
+    t = 64 - (t & 0x3f); /* Space avail in ctx->in (at least 1) */
+    if ((OI_UINT)t > len) {
+        OI_MemCopy((OI_BYTE*)ctx->in + 64 - (OI_UINT)t, buf,  len);
+        return;
+    }
+    /* First chunk is an odd size */
+    OI_MemCopy((OI_BYTE*)ctx->in + 64 - (OI_UINT)t, buf, (OI_UINT)t);
+    ByteSwap(ctx->in, 16);
+    Transform(ctx->buf, ctx->in);
+    buf += (OI_UINT)t;
+    len -= (OI_UINT)t;
+    /* Process data in 64-byte chunks */
+    while (len >= 64) {
+        OI_MemCopy(ctx->in, buf, 64);
+        ByteSwap(ctx->in, 16);
+        Transform(ctx->buf, ctx->in);
+        buf += 64;
+        len -= 64;
+    }
+    /* Handle any remaining bytes of data. */
+    OI_MemCopy(ctx->in, buf, len);
+}
+
+
+/*
+ * Final wrapup - pad to 64-byte boundary with the bit pattern 1 0* (64-bit
+ * count of bits processed, MSB-first)
+ */
+
+void OI_MD5_Final(OI_BYTE *digest,
+               MD5_CONTEXT *ctx)
+{
+    OI_INT count;
+    OI_BYTE *p;
+
+    /* Bytes in ctx->in */
+    count = (OI_INT)(ctx->bytes[0] & 0x3f);
+    /* First unused byte */
+    p = (OI_BYTE*)ctx->in + count;
+
+    /* Set the first char of padding to 0x80. There is always room.*/
+    *p++ = 0x80;
+
+    /* Bytes of padding needed to make 56 bytes (-8..55) */
+    count = 56 - 1 - count;
+    if (count < 0) { /* Padding forces an extra block */
+        OI_MemZero(p, count+8);
+        ByteSwap(ctx->in, 16);
+        Transform(ctx->buf, ctx->in);
+        p = (OI_BYTE*)ctx->in;
+        count = 56;
+    }
+    OI_MemZero(p, count+8);
+    ByteSwap(ctx->in, 14);
+    /* Append length in bits and transform */
+    ctx->in[14] = ctx->bytes[0] << 3;
+    ctx->in[15] = ctx->bytes[1] << 3 | ctx->bytes[0] >> 29;
+    Transform(ctx->buf, ctx->in);
+    ByteSwap(ctx->buf, 4);
+    OI_MemCopy(digest, ctx->buf, 16);
+    OI_MemZero(ctx, sizeof(ctx));
+}
+
+
+/*
+ * The four core functions - F1 is optimized somewhat
+ */
+
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+#define F2(x, y, z) F1(z, x, y)
+#define F3(x, y, z) (x ^ y ^ z)
+#define F4(x, y, z) (y ^ (x | ~z))
+
+
+/*
+ * This is the central step in the MD5 algorithm.
+ */
+
+#define MD5STEP_F1(w,x,y,z,in,s) (w += F1(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)
+#define MD5STEP_F2(w,x,y,z,in,s) (w += F2(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)
+#define MD5STEP_F3(w,x,y,z,in,s) (w += F3(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)
+#define MD5STEP_F4(w,x,y,z,in,s) (w += F4(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)
+
+
+/*
+ * The core of the MD5 algorithm, this alters an existing MD5 hash to
+ * reflect the addition of 16 longwords of new data. MD5Update blocks
+ * the data and converts bytes into longwords for this routine.
+ */
+
+static void Transform(OI_UINT32 *buf,
+                      OI_UINT32 *in)
+{
+    OI_UINT32 a, b, c, d;
+
+    a = buf[0];
+    b = buf[1];
+    c = buf[2];
+    d = buf[3];
+    MD5STEP_F1(a, b, c, d, (in[0] + 0xd76aa478), 7);
+    MD5STEP_F1(d, a, b, c, (in[1] + 0xe8c7b756), 12);
+    MD5STEP_F1(c, d, a, b, (in[2] + 0x242070db), 17);
+    MD5STEP_F1(b, c, d, a, (in[3] + 0xc1bdceee), 22);
+    MD5STEP_F1(a, b, c, d, (in[4] + 0xf57c0faf), 7);
+    MD5STEP_F1(d, a, b, c, (in[5] + 0x4787c62a), 12);
+    MD5STEP_F1(c, d, a, b, (in[6] + 0xa8304613), 17);
+    MD5STEP_F1(b, c, d, a, (in[7] + 0xfd469501), 22);
+    MD5STEP_F1(a, b, c, d, (in[8] + 0x698098d8), 7);
+    MD5STEP_F1(d, a, b, c, (in[9] + 0x8b44f7af), 12);
+    MD5STEP_F1(c, d, a, b, (in[10] + 0xffff5bb1), 17);
+    MD5STEP_F1(b, c, d, a, (in[11] + 0x895cd7be), 22);
+    MD5STEP_F1(a, b, c, d, (in[12] + 0x6b901122), 7);
+    MD5STEP_F1(d, a, b, c, (in[13] + 0xfd987193), 12);
+    MD5STEP_F1(c, d, a, b, (in[14] + 0xa679438e), 17);
+    MD5STEP_F1(b, c, d, a, (in[15] + 0x49b40821), 22);
+    MD5STEP_F2(a, b, c, d, (in[1] + 0xf61e2562), 5);
+    MD5STEP_F2(d, a, b, c, (in[6] + 0xc040b340), 9);
+    MD5STEP_F2(c, d, a, b, (in[11] + 0x265e5a51), 14);
+    MD5STEP_F2(b, c, d, a, (in[0] + 0xe9b6c7aa), 20);
+    MD5STEP_F2(a, b, c, d, (in[5] + 0xd62f105d), 5);
+    MD5STEP_F2(d, a, b, c, (in[10] + 0x02441453), 9);
+    MD5STEP_F2(c, d, a, b, (in[15] + 0xd8a1e681), 14);
+    MD5STEP_F2(b, c, d, a, (in[4] + 0xe7d3fbc8), 20);
+    MD5STEP_F2(a, b, c, d, (in[9] + 0x21e1cde6), 5);
+    MD5STEP_F2(d, a, b, c, (in[14] + 0xc33707d6), 9);
+    MD5STEP_F2(c, d, a, b, (in[3] + 0xf4d50d87), 14);
+    MD5STEP_F2(b, c, d, a, (in[8] + 0x455a14ed), 20);
+    MD5STEP_F2(a, b, c, d, (in[13] + 0xa9e3e905), 5);
+    MD5STEP_F2(d, a, b, c, (in[2] + 0xfcefa3f8), 9);
+    MD5STEP_F2(c, d, a, b, (in[7] + 0x676f02d9), 14);
+    MD5STEP_F2(b, c, d, a, (in[12] + 0x8d2a4c8a), 20);
+    MD5STEP_F3(a, b, c, d, (in[5] + 0xfffa3942), 4);
+    MD5STEP_F3(d, a, b, c, (in[8] + 0x8771f681), 11);
+    MD5STEP_F3(c, d, a, b, (in[11] + 0x6d9d6122), 16);
+    MD5STEP_F3(b, c, d, a, (in[14] + 0xfde5380c), 23);
+    MD5STEP_F3(a, b, c, d, (in[1] + 0xa4beea44), 4);
+    MD5STEP_F3(d, a, b, c, (in[4] + 0x4bdecfa9), 11);
+    MD5STEP_F3(c, d, a, b, (in[7] + 0xf6bb4b60), 16);
+    MD5STEP_F3(b, c, d, a, (in[10] + 0xbebfbc70), 23);
+    MD5STEP_F3(a, b, c, d, (in[13] + 0x289b7ec6), 4);
+    MD5STEP_F3(d, a, b, c, (in[0] + 0xeaa127fa), 11);
+    MD5STEP_F3(c, d, a, b, (in[3] + 0xd4ef3085), 16);
+    MD5STEP_F3(b, c, d, a, (in[6] + 0x04881d05), 23);
+    MD5STEP_F3(a, b, c, d, (in[9] + 0xd9d4d039), 4);
+    MD5STEP_F3(d, a, b, c, (in[12] + 0xe6db99e5), 11);
+    MD5STEP_F3(c, d, a, b, (in[15] + 0x1fa27cf8), 16);
+    MD5STEP_F3(b, c, d, a, (in[2] + 0xc4ac5665), 23);
+    MD5STEP_F4(a, b, c, d, (in[0] + 0xf4292244), 6);
+    MD5STEP_F4(d, a, b, c, (in[7] + 0x432aff97), 10);
+    MD5STEP_F4(c, d, a, b, (in[14] + 0xab9423a7), 15);
+    MD5STEP_F4(b, c, d, a, (in[5] + 0xfc93a039), 21);
+    MD5STEP_F4(a, b, c, d, (in[12] + 0x655b59c3), 6);
+    MD5STEP_F4(d, a, b, c, (in[3] + 0x8f0ccc92), 10);
+    MD5STEP_F4(c, d, a, b, (in[10] + 0xffeff47d), 15);
+    MD5STEP_F4(b, c, d, a, (in[1] + 0x85845dd1), 21);
+    MD5STEP_F4(a, b, c, d, (in[8] + 0x6fa87e4f), 6);
+    MD5STEP_F4(d, a, b, c, (in[15] + 0xfe2ce6e0), 10);
+    MD5STEP_F4(c, d, a, b, (in[6] + 0xa3014314), 15);
+    MD5STEP_F4(b, c, d, a, (in[13] + 0x4e0811a1), 21);
+    MD5STEP_F4(a, b, c, d, (in[4] + 0xf7537e82), 6);
+    MD5STEP_F4(d, a, b, c, (in[11] + 0xbd3af235), 10);
+    MD5STEP_F4(c, d, a, b, (in[2] + 0x2ad7d2bb), 15);
+    MD5STEP_F4(b, c, d, a, (in[9] + 0xeb86d391), 21);
+    buf[0] += a;
+    buf[1] += b;
+    buf[2] += c;
+    buf[3] += d;
+}
+
diff --git a/obex_profiles/stack/support/memprof.c b/obex_profiles/stack/support/memprof.c
new file mode 100644
index 0000000..b90d4d8
--- /dev/null
+++ b/obex_profiles/stack/support/memprof.c
@@ -0,0 +1,516 @@
+/**
+* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*/
+
+/**
+ * @file
+ * @internal
+ *
+ * functions to record the use of memory by the Memory Manager
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_MEMMGR
+
+#include "oi_core_common.h"
+#include "oi_osinterface.h"
+#include "oi_memmgr.h"
+#include "oi_memprof.h"
+#include "oi_utils.h"
+
+
+/**
+ * variables for use by the memmgr profiler
+ */
+
+typedef struct {
+    OI_UINT dynamicSize;
+    OI_UINT staticSize;
+    OI_UINT dynamicSizeMax;
+} MODULE_MEMORY;
+
+
+/*
+ * Entire file is ifdef'd out if we are not doing memory profiling.
+ */
+#ifdef MEMMGR_PROFILE
+
+
+static MODULE_MEMORY moduleMemUsage[OI_MODULE_UNKNOWN + 1];
+
+
+/*
+ * The currentUses total requested size for dynamic memory.
+ */
+
+static OI_UINT32 dynamicRequestSize;
+static OI_UINT32 dynamicRequestCount;
+
+/*
+ * The largest total of requested memory.
+ */
+
+static OI_UINT32 dynamicHighWaterMark;
+static OI_UINT32 dynamicHighCount;
+
+/**
+ * The total size of the memory allocated by OI_StaticMalloc.
+ */
+
+static OI_UINT32 staticMemSize;
+
+
+/**
+ * Tracks actual allocations to provide a workable pool configuration.
+ */
+typedef struct {
+    OI_UINT16 sizeL;      /* lower bound of pool size */
+    OI_UINT16 sizeH;      /* upper bound of pool size */
+    OI_UINT8 currentUses; /* current allocation count */
+    OI_UINT8 maxUses;     /* high-water mark of allocations of this size */
+} ALLOC_TRACKER;
+
+
+#ifdef  SMALL_RAM_MEMORY
+#define MAX_POOLS      32
+#else
+#define MAX_POOLS      1024
+#endif
+
+static ALLOC_TRACKER pools[MAX_POOLS];
+
+static OI_UINT8 MasterPool[MAX_POOLS];
+static OI_UINT8 PromotePool[MAX_POOLS];
+
+/* Round size up to nearest 4 byte boundary */
+/* Minimum size is 4 bytes, as implemented by oi_memmgr.c */
+#define ROUND_SIZE(s)  ( (s) ? ((OI_UINT16) (((s) + 3) & ~(0x3))) : 4)
+
+
+#define NEAR(x, y) \
+    (((x) >= (y)) ? (((x) - (y)) <= ((y) >> 1)) : (((y) - (x)) <= ((x) >> 1)))
+
+
+#define SIZE_IN_RANGE(sz, p)  ((((sz) >= (p).sizeL)) && (((sz) <= (p).sizeH) || NEAR((sz), (p).sizeH)))
+
+
+static OI_INT poolCount;
+
+#ifdef MEMMGR_DEBUG
+static OI_INT debug_overhead;
+#endif
+
+
+
+
+OI_STATUS OI_MemProf_Init(OI_INT overhead)
+{
+    OI_MemZero(MasterPool, sizeof(MasterPool));
+    OI_MemZero(PromotePool, sizeof(PromotePool));
+    OI_MemZero(moduleMemUsage, sizeof(moduleMemUsage));
+    OI_MemZero(pools, sizeof(pools));
+
+#ifdef MEMMGR_DEBUG
+    debug_overhead = overhead;
+#endif
+
+    dynamicRequestSize = 0;
+    dynamicRequestCount = 0;
+    dynamicHighWaterMark = 0;
+    dynamicHighCount = 0;
+    staticMemSize = 0;
+    poolCount = 0;
+    return OI_OK;
+}
+
+
+void OI_MemProf_StaticMalloc(OI_INT32 size,
+                             OI_UINT8 module,
+                             OI_CHAR *filename)
+{
+    moduleMemUsage[module].staticSize += ROUND_SIZE(size);
+
+    /* Total */
+    staticMemSize += ROUND_SIZE(size);
+}
+
+
+void OI_MemProf_Malloc(OI_INT32 size,
+                       void* addr,
+                       OI_UINT8 module,
+                       OI_CHAR *fileName)
+{
+    OI_UINT16 poolSize;
+    OI_INT i;
+    OI_INT j;
+    OI_INT k;
+    OI_INT borrow = 0;
+    OI_BOOL   interesting = FALSE;
+
+    if ( module == OI_MODULE_UNKNOWN ){
+        OI_DBGPRINT(("Unknown Module \"%s\" allocated %ld", fileName, size));
+    }
+
+    moduleMemUsage[module].dynamicSize += size;
+    if (moduleMemUsage[module].dynamicSize >  moduleMemUsage[module].dynamicSizeMax) {
+        moduleMemUsage[module].dynamicSizeMax = moduleMemUsage[module].dynamicSize;
+    }
+
+    /* Total Size */
+    if ((dynamicRequestSize += size) > dynamicHighWaterMark) {
+        dynamicHighWaterMark = dynamicRequestSize;
+        OI_DBGPRINT2(("Peak dynamic memory: %ld", dynamicHighWaterMark));
+        interesting = TRUE;
+    }
+
+    /* Total Count */
+    dynamicRequestCount++;
+    if (dynamicRequestCount > dynamicHighCount) {
+        dynamicHighCount = dynamicRequestCount;
+        OI_DBGPRINT2(("Peak Buffers Allocated: %ld", dynamicHighCount));
+        interesting = TRUE;
+    }
+
+    /*
+     * Round size up to nearest 8 byte boundary.
+     */
+    poolSize = ROUND_SIZE(size);
+
+    /* Per-pool count */
+    for (i = 0; i < MAX_POOLS; ++i) {
+        if (poolCount < MAX_POOLS){
+            /* Force new pool if unique */
+            if ( pools[i].sizeH == 0 ){
+                /* If larger than largest pool, create new at end */
+                pools[i].sizeL = pools[i].sizeH = poolSize;
+                pools[i].maxUses = pools[i].currentUses = 1;
+                MasterPool[i] = PromotePool[i] = 0;
+                poolCount++;
+                interesting = TRUE;
+                break;
+            }
+            else if ( poolSize > pools[i].sizeH ){
+                /* Keep Looking */
+                continue;
+            }
+            else if (poolSize < pools[i].sizeL){
+                /* Create new pool Here */
+                for (j = poolCount-1; j >= i; --j) {
+                    if (j < (MAX_POOLS - 1)) {
+                        pools[j + 1] = pools[j];
+                        MasterPool[j + 1] = MasterPool[j];
+                        PromotePool[j + 1] = PromotePool[j];
+                    }
+                }
+                pools[i].sizeL = pools[i].sizeH = poolSize;
+                pools[i].maxUses = pools[i].currentUses = 1;
+                MasterPool[i] = PromotePool[i] = 0;
+                poolCount++;
+                interesting = TRUE;
+                break;
+            }
+            /* Else, stuff into equivilent sized pool */
+        }
+        if (i < poolCount) {
+            /*
+             * If this is the pool, increment the usage count.
+             */
+            if ( (poolSize <= pools[i].sizeH) || (i == (MAX_POOLS - 1)) ) {
+                /*
+                 * Check we are not running into the next pool.
+                 */
+                if (i < (MAX_POOLS-1)) {
+                    if ((i + 1) < poolCount) {
+                        if (poolSize >= pools[i + 1].sizeL) {
+                            continue;
+                        }
+                    }
+                }
+                if ((++pools[i].currentUses) > pools[i].maxUses) {
+                    pools[i].maxUses = pools[i].currentUses;
+                    interesting = TRUE;
+                }
+                if (poolSize < pools[i].sizeL) {
+                    pools[i].sizeL = poolSize;
+                }
+                if (poolSize > pools[i].sizeH) {
+                    pools[i].sizeH = poolSize;
+                }
+                break;
+            }
+            /*
+             * Pools are sorted in order of increasing size.
+             */
+            if (poolSize > pools[i].sizeH) {
+                continue;
+            }
+            /*
+             * Move existing pools to make room.
+             */
+            for (j = poolCount-1; j >= i; --j) {
+                pools[j + 1] = pools[j];
+                MasterPool[j + 1] = MasterPool[j];
+                PromotePool[j + 1] = PromotePool[j];
+            }
+        }
+        MasterPool[i] = PromotePool[i] = 0;
+        pools[i].sizeL = pools[i].sizeH = poolSize;
+        pools[i].currentUses = pools[i].maxUses = 1;
+        interesting = TRUE;
+        ++poolCount;
+        break;
+    }
+
+    interesting = TRUE;
+    if ( interesting ){
+        j = 0;
+        k = 0;
+        for (i=(poolCount-1); i >= 0; i--){
+
+            /* See if we have under-run on buffers */
+            j += MasterPool[i];
+            j -=  pools[i].currentUses;
+            if ( j < 0 ){
+                MasterPool[i]++;
+                j++;
+            }
+
+            /* See if any Promotions can be made if pool count increases */
+            k += PromotePool[i];
+            k -=  pools[i].currentUses;
+            if ( k < 0 ){
+                OI_DBGPRINT2(("Borrow For: %d", pools[i].sizeH));
+                PromotePool[i]++;
+                k++;
+                borrow++;
+            }
+            else if ( (k > 0) && borrow && PromotePool[i] ){
+                OI_DBGPRINT2(("Borrow From: %d", pools[i].sizeH));
+                PromotePool[i]--;
+                borrow--;
+                k--;
+            }
+        }
+    }
+
+    if (i == MAX_POOLS) {
+        OI_DBGPRINT(("Pool usage could not be recorded for size = %d\n", poolSize));
+    }
+
+}
+
+
+void OI_MemProf_Free(OI_INT32 size,
+                     void* free,
+                     OI_UINT8 module,
+                     OI_CHAR *filename)
+{
+    OI_INT i;
+    OI_UINT16 poolSize;
+
+    /* Module count */
+    OI_ASSERT( (OI_INT)moduleMemUsage[module].dynamicSize >= size);
+    moduleMemUsage[module].dynamicSize -= size;
+
+    /* Total count */
+    if ((OI_INT)dynamicRequestSize < size) {
+        OI_LOG_ERROR(("dynamicRequestSize <= size (%d < %d)", (OI_INT)dynamicRequestSize, size));
+    }
+    dynamicRequestSize -= size;
+    dynamicRequestCount--;
+
+    poolSize = ROUND_SIZE(size);
+
+    /* Per-pool count */
+    for (i = 0; i < poolCount; ++i) {
+        if ((poolSize >= pools[i].sizeL) && (poolSize <= pools[i].sizeH)) {
+            if (pools[i].currentUses == 0) {
+                OI_DBGPRINT(("Underflow in pool %d", size));
+                continue;
+            }
+            --pools[i].currentUses;
+            break;
+        }
+    }
+}
+
+
+#ifdef MEMMGR_DEBUG
+
+
+void OI_MEMMGR_Dump(void)
+{
+    static const OI_CHAR *spaces = "                ";
+    OI_UINT16 i,j;
+    OI_UINT totalPoolUse = 0;
+    OI_UINT Overhead = 0;
+    OI_UINT DebugOverhead;
+    OI_UINT coalesce;
+
+    OI_Printf(("**********************************************\n"));
+    OI_Printf(("Maximum Dynamic memory pools used\n"));
+    for (i = 0, j = 0; i < poolCount; ++i) {
+        OI_Printf("{ %4d, %4d},\n", pools[i].maxUses,pools[i].sizeH);
+        totalPoolUse +=  pools[i].maxUses * pools[i].sizeH;
+        j += pools[i].maxUses;
+    }
+    Overhead = 12 * poolCount;
+    OI_Printf("\nTotal pool usage = %d + %d = %d versus optimal = %ld\n", totalPoolUse, Overhead, (Overhead+totalPoolUse), dynamicHighWaterMark);
+    OI_Printf("\nTotal pool Buffers = %d versus Max allocations = %ld\n", j, dynamicHighCount);
+    OI_Printf("**********************************************\n");
+
+    if (OI_CheckDebugControl(OI_MODULE_MEMMGR, 0, OI_DBG_MSG_PRINT_ENABLE)) {
+        OI_Printf("Dynamic Pool Recommendation #1 - Promotion Allowed\n");
+        totalPoolUse = 0;
+        Overhead = 0;
+        for (i = 0, j = 0; i < poolCount; ++i) {
+            if ( MasterPool[i] ){
+                OI_Printf("{ %4d, %4d},\n", MasterPool[i],pools[i].sizeH);
+                totalPoolUse +=  MasterPool[i] * pools[i].sizeH;
+                j += MasterPool[i];
+                Overhead++;
+            }
+        }
+
+        Overhead *= 12;
+        OI_Printf("\nTotal pool usage = %d + %d = %d versus optimal = %ld\n", totalPoolUse, Overhead, (Overhead+totalPoolUse), dynamicHighWaterMark);
+        OI_Printf("\nTotal pool Buffers = %d versus Max allocations = %ld\n", j, dynamicHighCount);
+        OI_Printf("**********************************************\n");
+        OI_Printf("Dynamic Pool Recommendation #2 - Promotion Required\n");
+        totalPoolUse = 0;
+        Overhead = 0;
+        for (i = 0, j = 0; i < poolCount; ++i) {
+            if ( PromotePool[i] ){
+                OI_Printf("{ %4d, %4d},\n", PromotePool[i],pools[i].sizeH);
+                totalPoolUse +=  PromotePool[i] * pools[i].sizeH;
+                j += PromotePool[i];
+                Overhead++;
+            }
+        }
+
+        Overhead *= 12;
+        OI_Printf("\nTotal pool usage = %d + %d = %d versus optimal = %ld\n", totalPoolUse, Overhead, (Overhead+totalPoolUse), dynamicHighWaterMark);
+        OI_Printf("\nTotal pool Buffers = %d versus Max allocations = %ld\n", j, dynamicHighCount);
+        OI_Printf("**********************************************\n");
+    }
+
+    OI_Printf("Highly Optimized Dynamic Pool Recommendation (Minimums)\n");
+    totalPoolUse = 0;
+    Overhead = 0;
+    coalesce = 0;
+    for (i = 0, j = 0; i < poolCount; ++i) {
+        coalesce += PromotePool[i];
+        if ( coalesce ){
+            if ((i < (MAX_POOLS-1)) && (12 >= (coalesce * (pools[i+1].sizeH - pools[i].sizeH))) && PromotePool[i+1]){
+                /* coalesce */
+            }
+            else if ((i < (MAX_POOLS-2)) && (12 >= (coalesce * (pools[i+2].sizeH - pools[i].sizeH))) && PromotePool[i+2]){
+                /* coalesce */
+            }
+            else{
+                OI_Printf("{ %4d, %4d},\n", coalesce,pools[i].sizeH);
+                totalPoolUse +=  coalesce * pools[i].sizeH;
+                j += coalesce;
+                Overhead++;
+                coalesce = 0;
+            }
+        }
+    }
+
+    DebugOverhead = 16 * Overhead; /* Extra debug OI_UINT32 in debug pools */
+    Overhead *= 12;
+    OI_Printf("\nTotal pool usage = %d + %d = %d versus optimal = %ld\n", totalPoolUse, Overhead, (Overhead+totalPoolUse), dynamicHighWaterMark);
+    OI_Printf("\nTotal pool Buffers = %d versus Max allocations = %ld\n", j, dynamicHighCount);
+    OI_Printf("**********************************************\n");
+
+
+    OI_Printf("\nActual memory usage by module\n");
+    OI_Printf("Module          Static  Dynamic  Dyn Max  Total  Max Total\n");
+    OI_Printf("------          ------  -------  -------  -----  ---------\n");
+
+    for (i = 0; i < OI_NUM_MODULES; i++) {
+        OI_INT staticSize;
+        OI_INT dynamicSize;
+        OI_INT dynamicSizeMax;
+
+        staticSize = moduleMemUsage[i].staticSize;
+        dynamicSize = moduleMemUsage[i].dynamicSize;
+        dynamicSizeMax = moduleMemUsage[i].dynamicSizeMax;
+
+        if (!OI_CheckDebugControl((OI_MODULE)i, 0, OI_DBG_MSG_PRINT_ENABLE)) {
+            /* If debugging turned on for this module, don't supress output */
+            while (OI_Strcmp(OI_ModuleToString((OI_MODULE)i), OI_ModuleToString((OI_MODULE)(i + 1))) == 0) {
+                staticSize += moduleMemUsage[i+1].staticSize;
+                dynamicSize += moduleMemUsage[i+1].dynamicSize;
+                dynamicSizeMax += moduleMemUsage[i+1].dynamicSizeMax;
+                i++;
+            }
+        }
+
+        if ((staticSize + dynamicSizeMax) || OI_CheckDebugControl((OI_MODULE)i, 0, OI_DBG_MSG_PRINT_ENABLE)) {
+            const OI_CHAR *modStr = OI_ModuleToString((OI_MODULE)i);
+            if (modStr) {
+                OI_Printf("%s%s%5d    %5d    %5d  %5d      %5d\n",
+                          modStr,
+                          &spaces[OI_StrLen(modStr)],
+                          staticSize,
+                          dynamicSize,
+                          dynamicSizeMax,
+                          staticSize + dynamicSize,
+                          staticSize + dynamicSizeMax);
+            }
+        }
+    }
+
+    if ( moduleMemUsage[OI_MODULE_UNKNOWN].staticSize || moduleMemUsage[OI_MODULE_UNKNOWN].dynamicSizeMax  ){
+        OI_Printf("%s%s%5d    %5d    %5d  %5d      %5d\n",
+                  "UNKNOWN",
+                  &spaces[7],
+                  moduleMemUsage[OI_MODULE_UNKNOWN].staticSize,
+                  moduleMemUsage[OI_MODULE_UNKNOWN].dynamicSize,
+                  moduleMemUsage[OI_MODULE_UNKNOWN].dynamicSizeMax,
+                  moduleMemUsage[OI_MODULE_UNKNOWN].staticSize + moduleMemUsage[OI_MODULE_UNKNOWN].dynamicSize,
+                  moduleMemUsage[OI_MODULE_UNKNOWN].staticSize + moduleMemUsage[OI_MODULE_UNKNOWN].dynamicSizeMax);
+    }
+
+    OI_Printf("\nCurrent dynamic size: %6ld\n", dynamicRequestSize);
+    OI_Printf(  "Current dynamic bufs: %6ld\n", dynamicRequestCount);
+    OI_Printf(  "Max optimal dynamic:  %6ld\n", dynamicHighWaterMark);
+    OI_Printf(  "Max optimal buffers:  %6ld\n", dynamicHighCount);
+    OI_Printf(  "Total static:         %6ld\n", staticMemSize);
+    OI_Printf(  "Max total:            %6ld\n", (dynamicHighWaterMark + staticMemSize) );
+    OI_Printf(  "Min Heap (Release):   %6ld  (Minimal pools plus overhead and static)\n",
+              ( Overhead + totalPoolUse + staticMemSize) );
+    OI_Printf(  "Min Heap (Debug):     %6ld  (Minimal pools plus overhead and static)\n",
+              ( (debug_overhead * j ) + DebugOverhead + totalPoolUse + staticMemSize) );
+}
+
+#endif /* MEMMGR_DEBUG */
+
+#endif /* MEMMGR_PROFILE */
diff --git a/obex_profiles/stack/support/oi_config_table.c b/obex_profiles/stack/support/oi_config_table.c
new file mode 100644
index 0000000..d962021
--- /dev/null
+++ b/obex_profiles/stack/support/oi_config_table.c
@@ -0,0 +1,186 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file contains the configuration table and access routines.
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_core_common.h"
+#include "oi_modules.h"
+#include "oi_config_table.h"
+#include "oi_support_init.h"
+#include "oi_init_flags.h"
+#include "oi_bt_stack_config.h"
+#include "oi_bt_profile_config.h"
+#include "oi_bt_module_init.h"
+
+/* The configuration table contains pointers to configuration structures.
+    In release mode, the table is indexed directly by module id.
+    In debug mode, the table contains the module id as well as the config pointer in order to
+        verify consistency of the module id enum with the configuration table.
+*/
+
+typedef struct {
+    const void    *pConfig ;
+
+    #ifdef OI_DEBUG
+    OI_MODULE   moduleId ;
+    #endif
+
+} OI_CONFIG_TABLE_ENTRY ;
+
+#ifdef OI_DEBUG
+#define DEFAULT_CONFIG_REC(module)  { (const void*)(&oi_default_config_##module), OI_MODULE_##module }
+#define NULL_CONFIG_REC(module)     { NULL,                                OI_MODULE_##module }
+#else
+#define DEFAULT_CONFIG_REC(module)  { (const void*)(&oi_default_config_##module) }
+#define NULL_CONFIG_REC(module)     { NULL }
+#endif
+
+/* Constant table of default configurations.
+
+    The entries must be in exactly the same order as enumerated in modules.h */
+
+static const OI_CONFIG_TABLE_ENTRY defaultConfigurations[OI_NUM_STACK_MODULES] =  {
+    /* profiles and protocols */
+
+    NULL_CONFIG_REC(BIP_CLI),               /**< Basic Imaging Profile protocol client */
+    DEFAULT_CONFIG_REC(BIP_SRV),            /**< Basic Imaging Profile protocol server*/
+    NULL_CONFIG_REC(BPP_SENDER),            /**< Basic Printing Profile */
+    NULL_CONFIG_REC(BPP_PRINTER),           /**< Basic Printing Profile */
+    DEFAULT_CONFIG_REC(FTP_CLI),            /**< File Transfer Profile protocol client */
+    DEFAULT_CONFIG_REC(FTP_SRV),            /**< File Transfer Profile protocol server */
+    DEFAULT_CONFIG_REC(OBEX_CLI),           /**< OBEX protocol, Generic Object Exchange Profile */
+    DEFAULT_CONFIG_REC(OBEX_SRV),           /**< OBEX protocol, Generic Object Exchange Profile */
+    NULL_CONFIG_REC(OPP_CLI),               /**< Object Push Profile protocol client */
+    DEFAULT_CONFIG_REC(OPP_SRV),            /**< Object Push Profile protocol server */
+    NULL_CONFIG_REC(PBAP_CLI),              /**< Phonebook Access Profile protocol client */
+    DEFAULT_CONFIG_REC(PBAP_SRV),           /**< Phonebook Access Profile protocol server */
+    DEFAULT_CONFIG_REC(MAP_CLI),            /**< Message Access Profile Client */
+    DEFAULT_CONFIG_REC(MAP_SRV),            /**< Message Access Profile  Server */
+
+    /* corestack components */
+
+    DEFAULT_CONFIG_REC(COMMON_CONFIG),      /**< Config common to all modules */
+    DEFAULT_CONFIG_REC(DISPATCH),           /**< Dispatcher */
+    NULL_CONFIG_REC(DATAELEM),              /**< Data Elements, marshaller */
+#ifdef OI_USE_NATIVE_MALLOC
+    NULL_CONFIG_REC(MEMMGR),                /**< modules that do memory management */
+#else
+    DEFAULT_CONFIG_REC(MEMMGR),             /**< modules that do memory management */
+#endif
+    NULL_CONFIG_REC(SUPPORT),               /**< support functions, including CThru Dispatcher, Memory Manager, time functions, and stack initialization */
+} ;
+
+/* Ram table of current configurations */
+
+static OI_CONFIG_TABLE_ENTRY curConfig[OI_NUM_STACK_MODULES] ;
+
+/*************************************************************
+
+    Initialize the configuration table
+
+    Initialization sets the all configuration pointers to their default values.
+    This function should be called before initializing any profiles or core stack
+    components
+
+*************************************************************/
+
+void OI_ConfigTable_Init(void)
+{
+    const OI_CONFIG_TABLE_ENTRY *src ;
+    OI_CONFIG_TABLE_ENTRY       *dest ;
+    OI_UINT                      i ;
+
+    /* memmgr may not yet be initialized - cannot depend on any OI support at this time. */
+
+    src = &defaultConfigurations[0] ;
+    dest = &curConfig[0] ;
+
+    for (i = 0; i < OI_ARRAYSIZE(defaultConfigurations); ++i) {
+        #ifdef OI_DEBUG
+            OI_ASSERT(i == src->moduleId) ;
+        #endif
+
+        *dest = *src ;
+        ++src ;
+        ++dest ;
+    }
+}
+/*************************************************************
+
+    OI_ConfigTable_GetConfig (module)
+
+    Returns the current configuration pointer for the specified module
+
+*************************************************************/
+
+const void* OI_ConfigTable_GetConfig(OI_MODULE module)
+{
+    OI_ASSERT(module < OI_NUM_STACK_MODULES) ;
+    if (module >= OI_NUM_STACK_MODULES) {
+        return NULL;
+    }
+    OI_ASSERT(NULL != (curConfig[module].pConfig));
+    return(curConfig[module].pConfig) ;
+}
+
+/*************************************************************
+
+    OI_ConfigTable_SetConfig (configPtr, module)
+
+    The specified pointer becomes the current configuration pointer for the indicated module.
+
+*************************************************************/
+
+void  OI_ConfigTable_SetConfig(const void *configPtr, OI_MODULE module)
+{
+    OI_ASSERT(module < OI_NUM_STACK_MODULES);
+    OI_LOG_ERROR(("OI_ConfigTable_SetConfig fail: module %d is already initialized", module)) ;
+    // can't set config if module is already initialized
+    OI_ASSERT((OI_INIT_FLAG_UNINITIALIZED_VALUE == OI_InitFlags_GetFlag(module))) ;
+    if (OI_INIT_FLAG_UNINITIALIZED_VALUE != OI_InitFlags_GetFlag(module)) {
+        OI_LOG_ERROR(("OI_ConfigTable_SetConfig fail: module %d is already initialized", module)) ;
+        return ;
+    }
+
+    // Common configuration can be changed only if ALL modules are uninitialized
+    if ((OI_MODULE_COMMON_CONFIG == module) && !OI_InitFlags_AllUninitialized()) {
+        OI_LOG_ERROR(("OI_ConfigTable_SetConfig fail: cannot set Common Configuration")) ;
+        return ;
+    }
+
+    curConfig[module].pConfig = configPtr ;
+}
+
+/*****************************************************************************/
+
+
+
diff --git a/obex_profiles/stack/support/oi_debug.c b/obex_profiles/stack/support/oi_debug.c
new file mode 100644
index 0000000..309718e
--- /dev/null
+++ b/obex_profiles/stack/support/oi_debug.c
@@ -0,0 +1,353 @@
+/**
+* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_argcheck.h"
+#include "oi_debug.h"
+#include "oi_assert.h"
+#include "oi_osinterface.h"
+#include "oi_memmgr.h"
+#include "oi_debugcontrol.h"
+#include "oi_bt_assigned_nos.h"
+#include "oi_std_utils.h"
+#include "oi_dispatch.h"
+#include "oi_debugcontrol.h"
+#include "oi_dump.h"
+#include "oi_support_init.h"
+#include "oi_varstring.h"
+#include "oi_bt_stack_config.h"
+#include "oi_config_table.h"
+#include "oi_simplemap.h"
+
+typedef struct {
+    OI_MODULE module;
+    OI_UINT8  levelEnableFlags;
+    OI_UINT8  enableLineNum;
+    OI_UINT8  overrideAll;
+    OI_UINT8  useDefault;
+} OI_DBG_OUTPUT_CTRL;
+
+
+#if defined(OI_DEBUG) || defined(OI_DEBUG_PER_MOD)
+/** The debug info for the modules. IMPORTANT: these must be in the same order
+ *  as in the OI_MODULE definition found in sdk/include/oi_modules.h.
+ */
+static const OI_CHAR* moduleString[] = {
+    /* profiles and protocols --> updates to oi_modules.h */
+
+    "AT",           /* OI_MODULE_AT */
+    "A2DP",         /* OI_MODULE_A2DP */
+    "AVCTP",        /* OI_MODULE_AVCTP */
+    "AVDTP",        /* OI_MODULE_AVDTP */
+    "AVRCP",        /* OI_MODULE_AVRCP */
+    "BIP",          /* OI_MODULE_BIP_CLI */
+    "BIP",          /* OI_MODULE_BIP_SRV */
+    "BNEP",         /* OI_MODULE_BNEP */
+    "BPP",          /* OI_MODULE_BPP_SENDER */
+    "BPP",          /* OI_MODULE_BPP_PRINTER */
+    "CTP",          /* OI_MODULE_CTP */
+    "DUN",          /* OI_MODULE_DUN */
+    "FAX",          /* OI_MODULE_FAX */
+    "FTP",          /* OI_MODULE_FTP_CLI */
+    "FTP",          /* OI_MODULE_FTP_SRV */
+    "HANDSFREE",    /* OI_MODULE_HANDSFREE */
+    "HANDSFREE_AG", /* OI_MODULE_HANDSFREE_AG */
+    "HCRP_CLI",     /* OI_MODULE_HCRP */
+    "HCRP_SRV",     /* OI_MODULE_HCRP */
+    "HEADSET",      /* OI_MODULE_HEADSET */
+    "HEADSET_AG",   /* OI_MODULE_HEADSET_AG */
+    "HID",          /* OI_MODULE_HID */
+    "INTERCOM",     /* OI_MODULE_INTERCOM */
+    "OBEX",         /* OI_MODULE_OBEX_CLI */
+    "OBEX",         /* OI_MODULE_OBEX_SRV */
+    "OPP",          /* OI_MODULE_OPP_CLI */
+    "OPP",          /* OI_MODULE_OPP_SRV */
+    "PAN",          /* OI_MODULE_PAN */
+    "PBAP",         /* OI_MODULE_PBAP_CLI */
+    "PBAP",         /* OI_MODULE_PBAP_SRV */
+    "SAP",          /* OI_MODULE_SAP_CLI */
+    "SAP",          /* OI_MODULE_SAP_SRV */
+    "SPP",          /* OI_MODULE_SPP */
+    "SYNC",         /* OI_MODULE_SYNC_CLI */
+    "SYNC",         /* OI_MODULE_SYNC_SRV */
+    "SYNC",         /* OI_MODULE_SYNC_CMD_CLI */
+    "SYNC",         /* OI_MODULE_SYNC_CMD_SRV */
+    "SYNCML",       /* OI_MODULE_SYNCML */
+    "TCS",          /* OI_MODULE_TCS */
+    "VDP",          /* OI_MODULE_VDP */
+    "MAP",          /* OI_MODULE_MAP_CLI */
+    "MAP",          /* OI_MODULE_MAP_SRV */
+
+    /* BLUEmagic 3.0 software kernel components --> updates to oi_modules.h */
+
+    "COMMON_CONFIG",/* OI_MODULE_COMMON_CONFIG */
+    "CMDCHAIN",     /* OI_MODULE_CMDCHAIN */
+    "DISPATCH",     /* OI_MODULE_DISPATCH */
+    "DATAELEM",     /* OI_MODULE_DATAELEM */
+    "DEVMGR",       /* OI_MODULE_DEVMGR */
+    "DEVMGR",       /* OI_MODULE_DEVMGR_MODES */
+    "HCI",          /* OI_MODULE_HCI */
+    "L2CAP",        /* OI_MODULE_L2CAP */
+    "MEMMGR",       /* OI_MODULE_MEMMGR */
+    "POLICYMGR",    /* OI_MODULE_POLICYMGR */
+    "RFCOMM",       /* OI_MODULE_RFCOMM */
+    "RFCOMM_SD",    /* OI_MODULE_RFCOMM_SD */
+    "SDP",          /* OI_MODULE_SDP_CLI */
+    "SDP",          /* OI_MODULE_SDP_SRV */
+    "SDP",          /* OI_MODULE_SDPDB */
+    "SECMGR",       /* OI_MODULE_SECMGR */
+    "SUPPORT",      /* OI_MODULE_SUPPORT */
+    "TRANSPORT",    /* OI_MODULE_TRANSPORT */
+    "TEST",         /* OI_MODULE_TEST */
+    "XML",          /* OI_MODULE_XML */
+    "DI",           /* OI_MODULE_DI */
+    "AMP",          /* OI_MODULE_AMP */
+    "OBEX_SD",      /* OI_MODULE_OBEX_SD */
+    "BTLE",         /* OI_MODULE_BTLE */
+
+    /* OEM files --> Updates to oi_modules.h */
+    "OEM",          /* OI_MODULE_OEM */
+
+    /* Application glue --> updates to oi_modules.h */
+    "APP",          /* OI_MODULE_APP */
+
+    /* Platform modules -> updates to oi_modules.h */
+    "DBUS",            /* OI_MODULE_DBUS */
+    "SOCKETS",         /* OI_MODULE_SOCKETS */
+    "PAL",             /* OI_MODULE_PAL */
+
+    /* Various pieces of code depend on these last 2 elements occuring in a specific order:
+       OI_MODULE_ALL must be the 2nd-to-last element
+       OI_MODULE_UNKNOWN must be the last element
+       */
+
+    "ALL",          /* OI_MODULE_ALL */
+    "UNKNOWN"       /* OI_MODULE_UNKNOWN */
+};
+
+/* Global debug table. Must have the same number of entries as moduleString.
+ * The table is designed to allow easier debugging with JTAG: the layout is
+ * 8 bytes, where the first four byte represent the module ID
+ * (can be looked up in oi_module.h) and the following settings represent
+ * debug options. The most common setting to enable out put of debug info
+ * for a certain module would be to set "levelEnableFlags" to 0x3e and
+ *  "enableLineNum" to 1.
+  */
+OI_DBG_OUTPUT_CTRL OI_ModuleDbgControl[OI_NUM_MODULES + 2];
+
+#endif
+
+
+/**
+ * If OI_TEST_HARNESS is not defined we use smaller debug print buffers. This means that debug
+ * messages may be truncated.
+ */
+
+#ifdef OI_TEST_HARNESS
+#define MAX_HEX_TEXT_LEN   2048  /* Must be at least 18 bytes for BD Addr */
+#define MAX_DBG_MSG_LEN    4096
+#else
+#define MAX_HEX_TEXT_LEN   128  /* Must be at least 18 bytes for BD Addr */
+#define MAX_DBG_MSG_LEN    256
+#endif
+
+#define MAX_DBG_HDR_LEN     64
+
+
+/*
+ * This global variable allows any BM3 function to verify that the
+ * current process does in fact own the stack token.
+ *
+ * Initialize to TRUE for those platforms which do not choose to
+ * manipulate this variable from within stackwrapper token handling.
+ */
+
+OI_BOOL OI_StackTokenHeld = TRUE;
+
+/**
+ * Formatting buffer (possibly large) shared by OI_DbgPrint and OI_Printf
+ */
+static OI_CHAR msgBuf[MAX_DBG_MSG_LEN];
+
+/**
+ * Smaller scratch buffer
+ */
+static OI_CHAR smallFmtBuf[MAX_HEX_TEXT_LEN];
+
+#if defined(OI_DEBUG) || defined(OI_DEBUG_PER_MOD)
+/**
+ * Header buffer only used by DbgPrint
+ */
+static OI_CHAR hdrBuf[MAX_DBG_HDR_LEN];
+
+typedef struct {
+    OI_BOOL checked;         /* make sure _OI_Dbg_Check() is called before _OI_DbgPrint() */
+    OI_UINT8 debugLevel;     /* requested debug level */
+    OI_UINT8 module;         /* current module */
+    OI_UINT8 hdrIndent;      /* number of characters in the debug header */
+    OI_CHAR *hdr;            /* debug header string */
+    OI_BOOL linePrinted;     /* TRUE if the line was printed. */
+} DBG_INFO;
+
+static DBG_INFO dbgInfo;
+int default_log_level;
+
+
+static OI_DBG_OUTPUT_CTRL defaultDbgControl = {
+    OI_MODULE_UNKNOWN,
+    OI_DBG_MSG_ALL_ENABLE,
+    TRUE,
+    FALSE,
+    FALSE
+};
+
+#endif
+
+/**
+ * Sets the logging level
+ *
+ * @param level    The level for which logs would be printed
+ */
+void OI_SetLogLevel(OI_UINT16 level)
+{
+    default_log_level = level;
+}
+OI_STATUS OI_Support_Init(void)
+{
+#if defined(OI_DEBUG) || defined(OI_DEBUG_PER_MOD)
+
+    OI_UINT i;
+
+    for (i = 0; i< OI_ARRAYSIZE(OI_ModuleDbgControl); i++) {
+        OI_ModuleDbgControl[i].module = (OI_MODULE) i;
+    }
+
+    /* All modules show errors and warnings by default. */
+    if (OI_ModuleDbgControl[OI_MODULE_ALL].levelEnableFlags == 0) {
+        OI_ModuleDbgControl[OI_MODULE_ALL].levelEnableFlags = OI_DBG_MSG_ERROR_ENABLE;
+    }
+
+    OI_ModuleDbgControl[OI_MODULE_UNKNOWN] = defaultDbgControl;
+    OI_ModuleDbgControl[OI_MODULE_UNKNOWN].overrideAll = TRUE;
+
+    dbgInfo.checked = FALSE;
+#endif
+
+    OI_SimpleMap_Init();
+    default_log_level = OI_MSG_CODE_TRACE;
+
+    return OI_OK;
+}
+
+
+OI_CHAR* OI_BDAddrText(const OI_BD_ADDR *Addr)
+{
+    OI_VARSTRING BDAddrVStr = {FALSE, OI_ARRAYSIZE(smallFmtBuf), 0, smallFmtBuf, FALSE};
+
+    OI_FormatStr(&BDAddrVStr, "%:", Addr);
+    return OI_VStrGetString(&BDAddrVStr);
+}
+
+
+OI_CHAR* OI_HexText(const OI_BYTE* Bytes, OI_UINT16 Len)
+{
+    OI_VARSTRING hexVStr = {FALSE, OI_ARRAYSIZE(smallFmtBuf), 0, smallFmtBuf, FALSE};
+
+    OI_FormatStr(&hexVStr, "%@", Bytes, Len);
+    return OI_VStrGetString(&hexVStr);
+}
+
+
+void OI_VPrintf(const OI_CHAR *format, va_list argp)
+{
+    OI_VARSTRING dbgVStr = {FALSE, OI_ARRAYSIZE(msgBuf), 0, msgBuf, FALSE};
+    OI_STATUS status;
+
+    status = OI_VFormatStr(&dbgVStr, format, argp);
+    if (!OI_SUCCESS(status)) {
+        dbgVStr.Len = 0;
+        OI_FormatStr(&dbgVStr, "Invalid parameter in debug output %! \"%s\"", status, format);
+    }
+    OI_Print(OI_VStrGetString(&dbgVStr));
+}
+
+
+OI_INT32 OI_VSNPrintf(OI_CHAR *buffer,
+                      OI_UINT16 bufLen,
+                      const OI_CHAR* format,
+                      va_list argp)
+{
+    OI_STATUS status;
+    OI_VARSTRING bufVStr;
+
+    if (!buffer || !bufLen) {
+        return -1;
+    }
+
+    bufVStr.Managed = FALSE;
+    bufVStr.MaxLen = bufLen - 1;
+    bufVStr.Len = 0;
+    bufVStr.Buffer= buffer;
+
+    status = OI_VFormatStr(&bufVStr, format, argp);
+    if (OI_SUCCESS(status)) {
+        buffer[bufVStr.Len] = 0;
+        return bufVStr.Len;
+    } else {
+        return -1;
+    }
+}
+
+
+OI_INT32 OI_SNPrintf(OI_CHAR *buffer,
+                     OI_UINT16 bufLen,
+                     const OI_CHAR* format, ...)
+{
+    OI_INT32 len;
+    va_list argp;
+
+    va_start(argp, format);
+    len = OI_VSNPrintf(buffer, bufLen, format, argp);
+    va_end(argp);
+    return len;
+}
+
+
+void OI_Printf(const OI_CHAR* format, ...)
+{
+    va_list argp;
+
+    va_start(argp, format);
+    OI_VPrintf(format, argp);
+    va_end(argp);
+}
+
+
diff --git a/obex_profiles/stack/support/oi_dispatch.c b/obex_profiles/stack/support/oi_dispatch.c
new file mode 100644
index 0000000..d9d7a23
--- /dev/null
+++ b/obex_profiles/stack/support/oi_dispatch.c
@@ -0,0 +1,936 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+@file
+@internal
+This file handles deferred callbacks.
+*/
+
+#define __OI_MODULE__ OI_MODULE_DISPATCH
+
+#include "oi_assert.h"
+#include "oi_argcheck.h"
+#include "oi_dispatch.h"
+#include "oi_memmgr.h"
+#include "oi_time.h"
+#include "oi_osinterface.h"
+#include "oi_debug.h"
+#include "oi_init_flags.h"
+#include "oi_config_table.h"
+#include "oi_bt_stack_init.h"
+#include "oi_utils.h"
+#include "oi_bt_module_init.h"
+#include "oi_dump.h"
+
+
+
+/**
+ * Space allocated directly in the dispatch table for storing copies of
+ * arguments to be passed to the callback functions.
+ * mallocArg memory is allocated to store arguments larger the this size.
+ */
+
+#define MAX_INLINE_ARG_SIZE   8
+
+typedef enum {
+    FREE_SLOT = 0,
+    FUNC_RUNNING,    /** Function is running and the handle is no longer valid */
+    FUNC_ACTIVE,     /** Function is registered and active */
+    FUNC_RUNNABLE,   /** Function is read to run and will be running soon */
+    FUNC_SUSPENDED   /** Function is registered and suspended */
+} _ENTRY_STATE;
+
+#ifdef OI_DEBUG
+typedef _ENTRY_STATE ENTRY_STATE;
+#else
+typedef OI_UINT8 ENTRY_STATE;
+#endif
+
+/**
+ * Type definition for entries in the dispatch table
+ *
+ * A dispatch table entry holds a pointer to a callback function, and arg struct
+ * to pass to the callback function and if this is a timed callback, a timeout
+ * interval.
+ *
+ * The dispatcher always makes a copy of the argument data. The copy is stored
+ * inlineArg in the dispatch table if there is room, otherwise into dynamically
+ * allocated memory.
+ */
+
+typedef struct {
+    ENTRY_STATE      state;
+    OI_INTERVAL      timeout;
+
+    /*
+     * Used to generate unique callback handles.
+     */
+    OI_UINT16        salt;
+    OI_UINT16        argSize;
+    DISPATCH_CB_FUNC CBFunc;
+    union {
+        OI_BYTE      *mallocArg;
+        OI_BYTE      inlineArg[MAX_INLINE_ARG_SIZE];
+    } arg;
+} DISPATCH_ENTRY;
+
+
+typedef struct {
+    /*
+     * DispatchRun must not be called recursively.
+     */
+    OI_UINT8 Running;
+
+    /*
+     * Flag Dispatches registered with a Zero Time-out as high priority, which
+     * will be handled prior to any new incoming BT traffic.
+     */
+    OI_UINT8 ImmediateDispatch;
+
+    /*
+     * MaxUsedEntry is the high water mark for the dispatch table.
+     */
+    OI_INT16 MaxUsedEntry;
+
+    /*
+     * The number of entries that are active (i.e. not suspended)
+     */
+    OI_INT16 numActiveEntries;
+
+    /*
+     * The dispatch table is a statically sized array of dispatch entries
+     */
+    OI_UINT16 TableSize;
+
+    /*
+     * The last requested service timeout. (Timestamp of next-to-fire timer)
+     */
+    OI_INTERVAL nextTimeout;
+
+    /*
+     * The table of registered dispatch entries.
+     */
+    DISPATCH_ENTRY *Table;
+
+    /*
+     * The callback for service notifications.
+     */
+    OI_DISPATCH_SERVICE_REQUEST_HANDLER serviceCallback;
+
+} DISPATCH_STATE;
+
+
+/*
+ * A callback handle is a 32 bit value that encodes the callback entry index
+ * along with a unique salt.
+ */
+#define CB_INDEX(h)  ((OI_UINT16) ((h) >> 16))                   // Top 16 bits are the entry index
+#define CB_SALT(h)   ((OI_UINT32) (((OI_UINT32) (h)) & 0xFFFF))  // Bottom 16 bits are the salt
+
+/*
+ * Generate a callback handle from an entry index.
+ */
+#define CB_HANDLE(i, s) ((DISPATCH_CB_HANDLE) ((((OI_UINT32) (i)) << 16) | CB_SALT(s)))
+
+
+#define ENTRY_IN_USE(e)  ((e)->CBFunc != NULL)
+
+
+/*
+ * For debugging/calibration purposes, track high water mark
+ */
+#ifdef OI_DEBUG
+    static OI_INT max_used_count;
+#endif
+
+/*
+ * Pointer to the statically allocated dispatch state information
+ */
+static DISPATCH_STATE Dispatcher;
+
+#ifdef EVAL
+
+#define TIMEBOMB_DURATION OI_MINUTES(5)
+
+/**
+ * The handler for the timebomb timeout.  Print out an error message and generate a FatalError.
+ * This code is only defined when EVAL is defined.
+ */
+static void TimebombHandler(DISPATCH_ARG *arg)
+{
+    OI_Print("****************************************************************************\n");
+    OI_Print("* Thank you for using this evaluation version of the BLUEmagic 3.0 Bluetooth\n");
+    OI_Print("*\n");
+    OI_Print("****************************************************************************\n");
+    OI_FatalError(OI_TIMEOUT);
+}
+#endif
+
+
+/*
+ * OI_Dispatch_Init
+ *
+ * Clears the dispatch table
+ */
+OI_STATUS OI_Dispatch_Init(OI_DISPATCH_SERVICE_REQUEST_HANDLER handler)
+{
+    if (OI_INIT_FLAG_VALUE(DISPATCH)) {
+        OI_SLOG_ERROR(OI_STATUS_ALREADY_INITIALIZED, ("OI_Dispatch_Init"));
+        return OI_STATUS_ALREADY_INITIALIZED;
+    }
+
+    // we require real configuration
+    OI_ASSERT(NULL != OI_CONFIG_TABLE_GET(DISPATCH));
+
+    OI_MemZero(&Dispatcher, sizeof(Dispatcher));
+
+    Dispatcher.TableSize = OI_CONFIG_TABLE_GET(DISPATCH)->DispatchTableSize;
+    Dispatcher.Table = (DISPATCH_ENTRY*) OI_StaticMalloc(sizeof(DISPATCH_ENTRY) * Dispatcher.TableSize);
+    Dispatcher.MaxUsedEntry = -1;
+    Dispatcher.serviceCallback = handler;
+#ifdef OI_DEBUG
+    max_used_count = -1;
+#endif
+
+    OI_INIT_FLAG_PUT_FLAG(TRUE, DISPATCH);
+
+#ifdef EVAL
+    /*
+     * In the EVAL version print out an initial announcement.
+     */
+    OI_Print("\n");
+    OI_Print("*******************************************************************\n");
+    OI_Print("This version of BLUEmagic 3.0 is time limited, for evaluation only.\n");
+    OI_Print(OI_Copyright());
+    OI_Print("\n");
+    OI_Print("*******************************************************************\n");
+    OI_Print("\n");
+
+    /*
+     * In the EVAL version, register a timebomb.
+     */
+    OI_Dispatch_RegisterTimedFunc(TimebombHandler, NULL, TIMEBOMB_DURATION, NULL);
+#endif
+
+    return OI_OK;
+}
+
+
+/*
+ * FreeCBEntry
+ *
+ * Frees any dynamically allocated memory associated with the callback entry and
+ * marks the entry as unused.
+ */
+
+static void FreeCBEntry(OI_INT16 entryIndex)
+{
+    DISPATCH_ENTRY *entry = &(Dispatcher.Table[entryIndex]);
+
+    OI_DBGPRINT2(("FreeCBEntry(%d)  handle: %x  TO: %d\n",
+                  entryIndex, CB_HANDLE(entryIndex, entry->salt), entry->timeout));
+
+    /*
+     * Free any dynamically allocated memory
+     */
+    if (ENTRY_IN_USE(entry) && (entry->argSize > MAX_INLINE_ARG_SIZE)) {
+        if (entry->arg.mallocArg != NULL) {
+            OI_Free(entry->arg.mallocArg);
+        }
+    }
+    OI_ASSERT(Dispatcher.numActiveEntries >= 0);
+    /*
+     * Adjust the active entries count
+     */
+    if (entry->state == FUNC_ACTIVE) {
+        --Dispatcher.numActiveEntries;
+    }
+    /*
+     * Flag that the entry is no longer in use
+     */
+    entry->CBFunc = NULL;
+    entry->state = FREE_SLOT;
+
+    /*
+     * Adjust dispatcher high-water mark
+     */
+    if (entryIndex == Dispatcher.MaxUsedEntry) {
+        while ((Dispatcher.MaxUsedEntry >= 0) && !ENTRY_IN_USE(&(Dispatcher.Table[Dispatcher.MaxUsedEntry]))) {
+            --Dispatcher.MaxUsedEntry;
+        }
+    }
+}
+
+
+/*
+ * OI_Dispatch_Terminate
+ *
+ * Clears any dynamically allocated callback argument data and clears
+ * the dispatch table
+ */
+
+void OI_Dispatch_Terminate(void)
+{
+    OI_INT16 i;
+
+    if (Dispatcher.Table != NULL) {
+        /*
+         * Frees up any registered callbacks
+         */
+        for (i = 0; i < Dispatcher.MaxUsedEntry; ++i) {
+            FreeCBEntry(i);
+        }
+        Dispatcher.Table = NULL;
+    }
+}
+
+
+/**
+ * Request service, if required.
+ */
+static void Dispatch_RequestService(OI_INTERVAL timeout)
+{
+    if (NULL != Dispatcher.serviceCallback) {
+        /*
+         * convert OI_INTERVAL to milliseconds
+         */
+        Dispatcher.serviceCallback(OI_INTERVAL_TO_MILLISECONDS(timeout));
+    }
+}
+
+/**
+ * Free running interval timer based on OI_Time_Now
+ */
+static OI_INTERVAL Dispatch_timeNowInterval(void)
+{
+    OI_TIME     now;
+    OI_INTERVAL ret_val;
+
+    OI_Time_Now(&now);
+    ret_val = OI_SECONDS(now.seconds);
+    ret_val += OI_MSECONDS(now.mseconds);
+    //OI_DBGPRINT2(("Dispatch_timeNowInterval: %d.%03d ==> %d\n", now.seconds, now.mseconds, ret_val));
+
+    return ret_val;
+}
+
+
+/*
+ * OI_Dispatch_RegisterFunc
+ *
+ * Registers a callback function in the dispatch table.
+ */
+
+OI_STATUS OI_Dispatch_RegisterFunc(DISPATCH_CB_FUNC CBFunction,
+                                   DISPATCH_ARG *args,
+                                   DISPATCH_CB_HANDLE *CBHandle)
+{
+    return OI_Dispatch_RegisterTimedFunc(CBFunction, args, 0, CBHandle);
+}
+
+
+/**
+ * Helper routinte shared by internal and external functions to set the timeout
+ * for a dispatcher entry.
+ */
+static void InternalSetTimeout(DISPATCH_ENTRY *entry,
+                               OI_INTERVAL timeout)
+{
+    OI_INTERVAL intervalNow = Dispatch_timeNowInterval();
+    OI_INT16 deltaTime = (OI_INT16)(Dispatcher.nextTimeout - intervalNow);
+
+    OI_ASSERT(entry);
+
+    entry->timeout = intervalNow + timeout;
+    OI_DBGPRINT2(("InternalSetTimeout(%d), this TO: %d, old TO: %d, Cur time: %d\n",
+                  timeout, entry->timeout, Dispatcher.nextTimeout, intervalNow));
+
+    /*
+     * Service request bookkeeping if this is the only or next entry needing dispatch.
+     */
+    if ((Dispatcher.numActiveEntries == 0) || (deltaTime >= timeout)) {
+        Dispatcher.nextTimeout = entry->timeout;
+        //OI_DBGPRINT(("Dispatch_RequestService (%d)\n", timeout));
+        Dispatch_RequestService(timeout);
+    }
+    /*
+     * If entry was suspended it is now active
+     */
+    if (entry->state == FUNC_SUSPENDED) {
+        OI_DBGPRINT2(("Activating suspended entry %x numActiveEntries=%d", entry, Dispatcher.numActiveEntries));
+        entry->state = FUNC_ACTIVE;
+        ++Dispatcher.numActiveEntries;
+    };
+
+}
+
+
+/*
+ * OI_Dispatch_SetFuncTimeout
+ *
+ * Checks that the callback handle is valid, and if so updates the timeout value
+ * on the callback function.
+ */
+
+OI_STATUS OI_Dispatch_SetFuncTimeout(DISPATCH_CB_HANDLE CBHandle,
+                                     OI_INTERVAL        timeout)
+{
+    if (!OI_Dispatch_IsValidHandle(CBHandle)) {
+        OI_DBGPRINT(("OI_Dispatch_SetFuncTimeout %!", OI_DISPATCH_INVALID_CB_HANDLE));
+        return OI_DISPATCH_INVALID_CB_HANDLE;
+    }
+
+    OI_DBGPRINT(("OI_Dispatch_SetFuncTimeout(%d)  entry: %d  handle: %x  old TO: %d\n",
+                 timeout, CB_INDEX(CBHandle), CBHandle, Dispatcher.Table[CB_INDEX(CBHandle)].timeout));
+
+
+    OI_ASSERT(timeout <= OI_MAX_INTERVAL);
+
+    if (timeout <= OI_MAX_INTERVAL) {
+        InternalSetTimeout(&Dispatcher.Table[CB_INDEX(CBHandle)], timeout);
+        return OI_STATUS_SUCCESS;
+    } else {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS, ("timeout > OI_MAX_INTERVAL"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+}
+
+
+/*
+ * OI_Dispatch_SuspendFunc
+ *
+ * Checks that the callback handle is valid, and if so updates the timeout value
+ * on the callback function.
+ */
+
+OI_STATUS OI_Dispatch_SuspendFunc(DISPATCH_CB_HANDLE CBHandle)
+{
+    DISPATCH_ENTRY *entry;
+
+    if (!OI_Dispatch_IsValidHandle(CBHandle)) {
+        OI_DBGPRINT(("OI_Dispatch_SuspendFunc %!", OI_DISPATCH_INVALID_CB_HANDLE));
+        return OI_DISPATCH_INVALID_CB_HANDLE;
+    }
+
+    OI_DBGPRINT(("OI_Dispatch_SuspendFunc entry: %d  handle: %x", CB_INDEX(CBHandle), CBHandle));
+
+    entry = &Dispatcher.Table[CB_INDEX(CBHandle)];
+    if (entry->state == FUNC_ACTIVE) {
+        entry->state = FUNC_SUSPENDED;
+        OI_ASSERT(Dispatcher.numActiveEntries > 0);
+        OI_DBGPRINT2(("Suspending entry %x numActiveEntries=%d", entry, Dispatcher.numActiveEntries));
+        --Dispatcher.numActiveEntries;
+    }
+    return OI_OK;
+}
+
+
+/*
+ * For storing information for an application callback registered by the public API OI_ScheduleCallbackFunction().
+ */
+typedef struct {
+    void *arg;
+    OI_SCHEDULED_CALLBACK cb;
+} APPLICATION_CB;
+
+
+static void AppCallback(DISPATCH_ARG *arg)
+{
+    APPLICATION_CB appCb = Dispatch_GetArg(arg, APPLICATION_CB);
+
+    appCb.cb(appCb.arg);
+}
+
+
+/*
+ * Public (SDK) interface for registering a timeout callback.
+ */
+OI_STATUS OI_ScheduleCallbackFunction(OI_SCHEDULED_CALLBACK callbackFunction,
+                                      void                 *arg,
+                                      OI_INTERVAL           timeout,
+                                      OI_CALLBACK_HANDLE   *handle)
+{
+    APPLICATION_CB appCb;
+    DISPATCH_ARG darg;
+
+    OI_ARGCHECK(NULL != callbackFunction);
+
+    appCb.arg = arg;
+    appCb.cb = callbackFunction;
+
+    Dispatch_SetArg(darg, appCb);
+    return OI_Dispatch_RegisterTimedFunc(AppCallback, &darg, timeout, handle);
+}
+
+OI_STATUS OI_CancelCallbackFunction(OI_CALLBACK_HANDLE handle)
+{
+    return OI_Dispatch_CancelFunc(handle);
+}
+
+
+/*
+ * OI_Dispatch_RegisterTimedFunc
+ *
+ * Calls OI_Dispatch_RegisterFunc to create the callback entry and then initializes
+ * the callback timer
+ */
+
+OI_STATUS OI_Dispatch_RegisterTimedFunc(DISPATCH_CB_FUNC   CBFunction,
+                                        DISPATCH_ARG       *args,
+                                        OI_INTERVAL        timeout,
+                                        DISPATCH_CB_HANDLE *CBHandle)
+{
+    OI_INT16 i;
+    DISPATCH_ENTRY *entry = NULL;
+    DISPATCH_CB_HANDLE handle = 0;
+
+    OI_ASSERT(Dispatcher.Table != NULL);
+    OI_ASSERT(CBFunction != NULL);
+    OI_ASSERT(timeout <= OI_MAX_INTERVAL);
+
+    OI_DBGPRINT(("OI_Dispatch_RegisterTimedFunc(%d)\n", timeout));
+
+
+    /*
+     * Dispatcher now has a public interface, so enable validity checks in
+     * release mode.
+     */
+    if ((timeout > OI_MAX_INTERVAL) ||
+        (CBFunction == NULL) ||
+        (Dispatcher.Table == NULL)) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS, ("OI_Dispatch_RegisterTimedFunc"));
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+
+    /*
+     * Zero time-out registered functions are "High Priority" and must be run
+     * prior to the handling of any new incoming BT traffic. Note that this
+     * treatment is explicitly *not* extended to functions with > Zero timeouts
+     * that subsequently reach Zero.
+     */
+    if (timeout == 0) {
+        Dispatcher.ImmediateDispatch = TRUE;
+    }
+
+    /*
+     * Find the first free entry in the dispatch table.
+     */
+    for (i = 0; i < Dispatcher.TableSize; ++i) {
+        entry = &Dispatcher.Table[i];
+        if (!ENTRY_IN_USE(entry)) {
+
+            /*
+             * We avoid checking the entire dispatch table for callbacks if we
+             * know where the last entry is.
+             */
+            if (i > Dispatcher.MaxUsedEntry) {
+                Dispatcher.MaxUsedEntry = i;
+#ifdef OI_DEBUG
+                if (i > max_used_count){
+                    OI_DBGPRINT(("Dispatcher high water: %d\n", i + 1));
+                    max_used_count = i;
+                }
+#endif
+            }
+
+            InternalSetTimeout(entry, timeout);
+            entry->state = FUNC_ACTIVE;
+            ++Dispatcher.numActiveEntries;
+
+            /*
+             * Set the callback function, this also flags the entry as used
+             */
+            entry->CBFunc = CBFunction;
+
+            /*
+             * Create a unique callback handle from the index and a salt.  The
+             * index can be recovered using the CB_INDEX macro. Salt should
+             * never be Zero, or a DISPATCH_CB_HANDLE of Zero is possible,
+             * making handle intitializatons to Zero untenable.
+             */
+            if ((++entry->salt) == 0){
+                OI_DBGPRINT(("Salt of Zero reached - index: %d\n", i));
+                ++entry->salt;
+            }
+
+            handle = CB_HANDLE(i, entry->salt);
+
+            OI_DBGPRINT2(("Function added to dispatcher - entry: %d  handle: %x  TO: %d\n",
+                          i, handle, entry->timeout));
+
+            break;
+        }
+    }
+
+    OI_ASSERT(i < Dispatcher.TableSize);
+    if (i == Dispatcher.TableSize) {
+        OI_SLOG_ERROR(OI_DISPATCH_TABLE_OVERFLOW, ("OI_Dispatch_RegisterTimedFunc"));
+        return OI_DISPATCH_TABLE_OVERFLOW;
+    }
+
+    if (args == NULL) {
+        entry->argSize = 0;
+    } else {
+        /*
+         * The dispatcher makes a copy of the callback arguments.
+         */
+        if (args->size <= MAX_INLINE_ARG_SIZE) {
+            /*
+             * Copy the callback arguments directly into the callback entry.
+             */
+            for (i = 0; i < args->size; ++i) {
+                entry->arg.inlineArg[i] = ((OI_BYTE*) args->data)[i];
+            }
+        } else {
+            /*
+             * Malloc memory for the callback arguments.
+             */
+            if ((entry->arg.mallocArg = OI_Malloc(args->size)) == NULL) {
+                FreeCBEntry(i);
+                OI_SLOG_ERROR(OI_STATUS_OUT_OF_MEMORY, ("OI_Malloc %d", args->size));
+                return OI_STATUS_OUT_OF_MEMORY;
+            }
+            OI_MemCopy(entry->arg.mallocArg, args->data, args->size);
+        }
+        entry->argSize = args->size;
+    }
+
+    if (CBHandle != NULL) {
+        *CBHandle = handle;
+    }
+
+    return OI_STATUS_SUCCESS;
+}
+
+
+
+
+/*
+ * DispatchCancelFunc
+ *
+ * Checks that the callback handle is valid and if so, deletes the associated
+ * callback function from the dispatch table.
+ */
+
+OI_STATUS OI_Dispatch_CancelFunc(DISPATCH_CB_HANDLE CBHandle)
+{
+    if (!OI_Dispatch_IsValidHandle(CBHandle)) {
+        OI_DBGPRINT(("OI_Dispatch_CancelFunc %!", OI_DISPATCH_INVALID_CB_HANDLE));
+        return OI_DISPATCH_INVALID_CB_HANDLE;
+    } else {
+        OI_DBGPRINT2(("Cancelling dispatcher function (entry %d  handle: %x  TO: %d)\n",
+                      CB_INDEX(CBHandle), CBHandle, Dispatcher.Table[CB_INDEX(CBHandle)].timeout));
+        FreeCBEntry(CB_INDEX(CBHandle));
+        return OI_STATUS_SUCCESS;
+    }
+}
+
+/*
+ * Remove this function from the dispatch queue and call it immediately.
+ */
+OI_STATUS OI_Dispatch_CallFunc(DISPATCH_CB_HANDLE CBHandle)
+{
+    DISPATCH_ARG arg;
+    DISPATCH_ENTRY *entry;
+
+    if (!OI_Dispatch_IsValidHandle(CBHandle)) {
+        OI_SLOG_ERROR(OI_DISPATCH_INVALID_CB_HANDLE, ("OI_Dispatch_CallFunc"));
+        return OI_DISPATCH_INVALID_CB_HANDLE;
+    }
+    entry = &(Dispatcher.Table[CB_INDEX(CBHandle)]);
+    if (entry->state == FUNC_ACTIVE) {
+        /*
+         * This entry is no longer active
+         */
+        --Dispatcher.numActiveEntries;
+    }
+    /*
+     * Mark that the function is now running so that the handle is no longer valid.
+     */
+    entry->state = FUNC_RUNNING;
+    OI_DBGPRINT2(("Force call dispatcher function (entry: %d  handle: %x  TO: %d  current time: %d)\n",
+                  CB_INDEX(CBHandle), CBHandle, entry->timeout, Dispatch_timeNowInterval()));
+    if (entry->argSize == 0) {
+        entry->CBFunc(NULL);
+    } else {
+        arg.size = entry->argSize;
+        if (arg.size <= MAX_INLINE_ARG_SIZE) {
+            arg.data = entry->arg.inlineArg;
+        } else {
+            arg.data = entry->arg.mallocArg;
+        }
+        entry->CBFunc(&arg);
+    }
+    FreeCBEntry(CB_INDEX(CBHandle));
+    return OI_STATUS_SUCCESS;
+}
+
+/*
+ * DispatchIsValidHandle
+ *
+ * Checks if this is a valid dispatch function handle.
+ */
+
+OI_BOOL OI_Dispatch_IsValidHandle(DISPATCH_CB_HANDLE CBHandle)
+{
+    OI_UINT16 index = CB_INDEX(CBHandle);
+
+    OI_ASSERT(Dispatcher.Table != NULL);
+
+    /*
+     * Check index is in range
+     */
+    if (index >= Dispatcher.TableSize) {
+        return FALSE;
+    }
+    /*
+     * Check that there is a function registered in this table entry and the
+     * function is not already running.
+     */
+    if ((Dispatcher.Table[index].state == FREE_SLOT) || (Dispatcher.Table[index].state == FUNC_RUNNING)) {
+        return FALSE;
+    }
+    /*
+     * Check the salt in the CBHandle is what we expect
+     */
+    return CB_SALT(Dispatcher.Table[index].salt) == CB_SALT(CBHandle);
+}
+
+
+/*
+ * OI_Dispatch_Run
+ *
+ * Invokes currently registered callbacks that are runnable now.
+ *
+ * Callbacks that are registered or become runnable while OI_Dispatch_Run is
+ * executing do not get called until next time.
+ */
+
+OI_INT16 OI_Dispatch_Run()
+{
+    OI_INT16 i;
+    OI_INT16 calls = 0;
+    DISPATCH_ARG arg;
+    DISPATCH_ENTRY *entry;
+    OI_INTERVAL smallestTimeout;
+    OI_INTERVAL intervalNow;
+
+    //OI_DBGPRINT2(("OI_Dispatch_Run"));
+
+    /*
+     * Silently ignore Run requests if the dispatcher has not been initialized or has been
+     * terminated.
+     */
+    if (Dispatcher.Table == NULL) {
+        return 0;
+    }
+
+    OI_ASSERT(!Dispatcher.Running);
+
+    Dispatcher.Running = TRUE;
+
+
+    /*
+     * Request free-running interval time to test against registered timers.
+     */
+    intervalNow = Dispatch_timeNowInterval();
+
+    /*
+     * First pass over the list decrements the timeouts to figure out which
+     * callbacks are runnable
+     */
+    for (i = 0; i <= Dispatcher.MaxUsedEntry; ++i) {
+        entry = &Dispatcher.Table[i];
+        if (ENTRY_IN_USE(entry) && (entry->state != FUNC_SUSPENDED)) {
+            if (((OI_INT16)(entry->timeout - intervalNow)) <= 0) {
+#ifdef OI_DEBUG
+                if (((OI_INT16)(entry->timeout - intervalNow)) < -1) {
+                    OI_SLOG_ERROR(OI_STATUS_NONE, ("Dispatcher function called late (entry: %d  handle %x  TO: %d  currTime: %d)\n",
+                                                   i, CB_HANDLE(i, entry->salt), entry->timeout, intervalNow));
+                }
+#endif
+                if (entry->state == FUNC_ACTIVE) {
+                    /*
+                     * This entry is no longer active
+                     */
+                    --Dispatcher.numActiveEntries;
+                }
+                entry->state = FUNC_RUNNABLE;
+                calls++;
+            }
+        }
+    }
+
+    /*
+     * Second passed over the list invokes callbacks that are runnable
+     */
+    if (calls) {
+        OI_DBGPRINT2(("Dispatcher Running at %d\n", intervalNow));
+        for (i = 0; i <= Dispatcher.MaxUsedEntry; ++i) {
+            entry = &Dispatcher.Table[i];
+            if (entry->state == FUNC_RUNNABLE) {
+                /*
+                 * Mark that the function is now running so that the handle is no longer valid.
+                 */
+                entry->state = FUNC_RUNNING;
+                /*
+                 * Call the callback function then free the entry
+                 */
+                OI_DBGPRINT2(("Calling dispatcher function (entry: %d  handle: %x  TO: %d\n",
+                              i, CB_HANDLE(i, entry->salt), entry->timeout));
+                if (entry->argSize == 0) {
+                    entry->CBFunc(NULL);
+                } else {
+                    arg.size = entry->argSize;
+                    if (arg.size <= MAX_INLINE_ARG_SIZE) {
+                        arg.data = entry->arg.inlineArg;
+                    } else {
+                        arg.data = entry->arg.mallocArg;
+                    }
+                    entry->CBFunc(&arg);
+                }
+                FreeCBEntry(i);
+            }
+        }
+    }
+
+    /*
+     * Find the pending task with the smallest timeout so know when
+     * next to request service. We have to do this check after all current
+     * tasks have completed.
+     */
+    smallestTimeout = (OI_INTERVAL)-1;
+    for (i = 0; i <= Dispatcher.MaxUsedEntry; ++i) {
+        entry = &Dispatcher.Table[i];
+        if (ENTRY_IN_USE(entry) && (entry->state != FUNC_SUSPENDED)) {
+            OI_INTERVAL timeout = entry->timeout - intervalNow;
+            if (timeout < smallestTimeout) {
+                smallestTimeout = timeout;
+                Dispatcher.nextTimeout = entry->timeout;
+            }
+        }
+    }
+
+    /*
+     * If there are no tasks that will become runnable in the near future there
+     * is no need to callback to request service. Setting a timer to
+     * OI_MAX_INTERVAL effectively puts the task in statis.
+     */
+    if (smallestTimeout < (OI_INTERVAL)-1) {
+        //OI_DBGPRINT2(("Dispatch_RequestService (%d)\n", smallestTimeout));
+        Dispatch_RequestService(smallestTimeout);
+    }
+    else {
+        //OI_DBGPRINT2(("No service request: %d %d %d\n", smallestTimeout, OI_MAX_INTERVAL, Dispatcher.MaxUsedEntry));
+    }
+    Dispatcher.Running = FALSE;
+
+    /*
+     * If dispatch table has no ready to run callbacks, then by inference there
+     * are no ImmediateDispatch functions.
+     */
+    if (calls == 0) {
+        Dispatcher.ImmediateDispatch = FALSE;
+    }
+
+    return calls;
+}
+
+/*
+ * OI_Dispatch_Immediate_Run
+ *
+ * Invokes OI_Dispatch_Run if Immediate callbacks have
+ * been registered since the previous run.
+ *
+ */
+
+void OI_Dispatch_Immediate_Run()
+{
+    /*
+     * It is possible that Dispatched functions may themselves request an
+     * immediate dispatch, so the flag must be repeatedly cleared and re-checked
+     * to ensure that all immediate callbacks have been handled.
+     */
+    if (!Dispatcher.Running) {
+        while (Dispatcher.ImmediateDispatch) {
+            Dispatcher.ImmediateDispatch = FALSE;
+            OI_DBGPRINT2(("OI_Dispatch_Immediate_Run"));
+            OI_Dispatch_Run();
+        }
+    }
+}
+
+/*
+ * OI_DISPATCH_Dump
+ *
+ * Dump dispatcher internal state
+ *
+ */
+
+#ifdef OI_DEBUG
+
+static OI_CHAR* stateToText(ENTRY_STATE state)
+{
+    switch (state) {
+        case FREE_SLOT:         return "FREE_SLOT";
+        case FUNC_RUNNING:      return "FUNC_RUNNING";
+        case FUNC_ACTIVE:       return "FUNC_ACTIVE";
+        case FUNC_RUNNABLE:     return "FUNC_RUNNABLE";
+        case FUNC_SUSPENDED:    return "FUNC_SUSPENDED";
+    }
+    return "unknown state";
+}
+
+
+void OI_DISPATCH_Dump(void)
+{
+    DISPATCH_ENTRY  *entry;
+    OI_INT           i;
+    OI_INTERVAL      intervalNow = Dispatch_timeNowInterval();
+
+    OI_Printf("Dispatcher dump:\n");
+    OI_Printf("   Running          %d\n",  Dispatcher.Running);
+    OI_Printf("   TableSize        %d\n",  Dispatcher.TableSize);
+    OI_Printf("   numActiveEntries %d\n",  Dispatcher.numActiveEntries);
+    OI_Printf("   MaxUsedEntry     %d\n",  Dispatcher.MaxUsedEntry);
+    OI_Printf("   nextTimeout      %d\n",  Dispatcher.nextTimeout);
+    OI_Printf("   max_used_count   %d\n",  max_used_count);
+    for (i = 0; i < Dispatcher.TableSize; ++i) {
+        entry = &Dispatcher.Table[i];
+        if (ENTRY_IN_USE(entry)) {
+            OI_Printf("entry %2d: %18s timeout %d\n",
+                      i, stateToText(entry->state), (entry->state == FUNC_SUSPENDED) ? 0 : entry->timeout - intervalNow);
+        }
+    }
+}
+#endif
+
+/*****************************************************************************/
+
diff --git a/obex_profiles/stack/support/oi_fcs.c b/obex_profiles/stack/support/oi_fcs.c
new file mode 100644
index 0000000..842aad6
--- /dev/null
+++ b/obex_profiles/stack/support/oi_fcs.c
@@ -0,0 +1,81 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "oi_common.h"
+#include "oi_fcs.h"
+
+
+static const OI_UINT16 crcTable[256] =
+{
+    0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
+    0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
+    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
+    0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
+    0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
+    0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
+    0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
+    0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
+    0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
+    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
+    0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
+    0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
+    0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
+    0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
+    0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
+    0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
+    0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
+    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
+    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
+    0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
+    0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
+    0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
+    0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
+    0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
+    0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
+    0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
+    0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
+    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
+    0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
+    0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
+    0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
+    0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
+};
+
+
+void OI_FCS_Compute(const OI_BYTE *buffer,
+                    OI_UINT16 bufLen,
+                    OI_UINT16 *runningCrc)
+{
+    OI_UINT16 crc = *runningCrc;
+
+    while (bufLen--) {
+        crc = crcTable[(crc ^ *buffer++) & 0xFF] ^ (crc >> 8);
+    }
+    *runningCrc = crc;
+}
diff --git a/obex_profiles/stack/support/oi_handle.c b/obex_profiles/stack/support/oi_handle.c
new file mode 100644
index 0000000..78284ae
--- /dev/null
+++ b/obex_profiles/stack/support/oi_handle.c
@@ -0,0 +1,150 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_stddefs.h"
+#include "oi_handle.h"
+#include "oi_debug.h"
+#include "oi_dump.h"
+#include "oi_utils.h"
+
+
+typedef struct {
+    void *refData;
+    const OI_CHAR *handleType;
+    OI_UINT32 salt;
+} HANDLE_INTERNAL;
+
+static HANDLE_INTERNAL handles[OI_MAX_HANDLES];
+
+/*
+ * Initialize salt to some arbitrary value.
+ */
+static OI_UINT32 salt = 0x4E61436C; /* "NaCl" */
+
+#define INDEX_BITS 9
+#define SALT_BITS  (32 - INDEX_BITS)
+#define SALT_MASK  ((1 << SALT_BITS) - 1)
+
+
+/*
+ * Handles don't get allocated that often so we can simply search for a free entry.
+ */
+OI_HANDLE OI_HANDLE_Alloc(const OI_CHAR *handleType,
+                          void *refData)
+{
+    OI_UINT i;
+    OI_HANDLE handle;
+
+    if (refData == NULL) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS, ("OI_HANDLE_Alloc: data cannot be NULL"));
+        return NULL;
+    }
+    for (i = 0; i < OI_ARRAYSIZE(handles); ++i) {
+        if (handles[i].salt == 0) {
+            handles[i].refData = refData;
+            handles[i].handleType = handleType;
+            if (++salt == 0) {
+                salt = 1;
+            }
+            handles[i].salt = salt;
+            handle = (OI_HANDLE)((i << SALT_BITS) | (salt & SALT_MASK));
+            OI_DBGPRINT(("OI_HANDLE_Alloc index:%d salt:%08x handle:%08x", i, salt, handle));
+            return handle;
+        }
+    }
+    return NULL;
+}
+
+
+OI_BOOL OI_HANDLE_IsValid(OI_HANDLE handle,
+                          const OI_CHAR *handleType)
+{
+    OI_UINT32 index = (OI_UINT32)(handle) >> SALT_BITS;
+    OI_UINT32 salt = (OI_UINT32)(handle) & SALT_MASK;
+
+    if (index < OI_ARRAYSIZE(handles) && ((handles[index].salt & SALT_MASK) == salt)) {
+        return handles[index].handleType == handleType;
+    } else {
+        return FALSE;
+    }
+}
+
+
+/**
+ * Returns the value referenced by a handle
+ */
+void* OI_HANDLE_Deref(OI_HANDLE handle)
+{
+    OI_UINT32 index = (OI_UINT32)(handle) >> SALT_BITS;
+    OI_UINT32 salt = (OI_UINT32)(handle) & SALT_MASK;
+
+    OI_DBGPRINT(("OI_HANDLE_Deref index:%d salt:%08x handle:%08x", index, salt, handle));
+    if ((index < OI_ARRAYSIZE(handles)) && ((handles[index].salt & SALT_MASK) == salt)) {
+        return handles[index].refData;
+    } else {
+        return NULL;
+    }
+}
+
+
+/**
+ * Frees a handle
+ */
+OI_STATUS OI_HANDLE_Free(OI_HANDLE handle)
+{
+    OI_UINT32 index = (OI_UINT32)(handle) >> SALT_BITS;
+    OI_UINT32 salt = (OI_UINT32)(handle) & SALT_MASK;
+
+    OI_DBGPRINT(("OI_HANDLE_Free index:%d salt:%08x handle:%08x", index, salt, handle));
+    if ((index < OI_ARRAYSIZE(handles)) && ((handles[index].salt & SALT_MASK) == salt)) {
+        handles[index].salt = 0;
+        return OI_OK;
+    } else {
+        return OI_STATUS_INVALID_HANDLE;
+    }
+}
+
+
+
+#ifdef OI_DEBUG
+void OI_HANDLE_Dump(void)
+{
+    OI_UINT i;
+
+    OI_Printf("Handles\n");
+    for (i = 0; i < OI_ARRAYSIZE(handles); ++i) {
+        if (handles[i].salt) {
+            OI_HANDLE h = (OI_HANDLE)((i << SALT_BITS) | (handles[i].salt & SALT_MASK));
+            OI_Printf("[%d] type:%s handle:%#x refData:%#x\n", i, handles[i].handleType, h, handles[i].refData);
+        }
+    }
+}
+#endif
diff --git a/obex_profiles/stack/support/oi_init_flags.c b/obex_profiles/stack/support/oi_init_flags.c
new file mode 100644
index 0000000..a5c8604
--- /dev/null
+++ b/obex_profiles/stack/support/oi_init_flags.c
@@ -0,0 +1,146 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+@internal
+    This file contains the global initialization table and access routines.
+
+ */
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_core_common.h"
+#include "oi_modules.h"
+#include "oi_init_flags.h"
+#include "oi_bt_module_init.h"
+
+/* The initialization table is an array of initialization flags.  It is global in
+    release mode, so that applications can efficiently access the flags (via macros). */
+
+#ifdef OI_DEBUG
+
+static OI_INIT_FLAG OI_GV_InitializationFlags[OI_NUM_STACK_MODULES] ;
+
+#else
+
+OI_INIT_FLAG OI_GV_InitializationFlags[OI_NUM_STACK_MODULES] ;
+
+#endif
+
+/*************************************************************
+
+    Reset all initialization flags
+
+    Know what you're doing if you call this function.
+
+    It should only be called as part of a global, reset/restart process.
+
+*************************************************************/
+
+
+void OI_InitFlags_ResetAllFlags(void)
+{
+    //OI_DBGPRINT(("OI_InitFlags_ResetAllFlags - resetting all initialization flags")) ;
+    OI_MemSet(OI_GV_InitializationFlags, 0, sizeof(OI_GV_InitializationFlags)) ;
+}
+/*************************************************************
+
+    Initialization flag access
+
+*************************************************************/
+
+OI_INIT_FLAG OI_InitFlags_GetFlag(OI_MODULE module)
+{
+    OI_ASSERT(module < OI_ARRAYSIZE(OI_GV_InitializationFlags)) ;
+    if (!(module < OI_ARRAYSIZE(OI_GV_InitializationFlags))) {
+        return 0;
+    }
+    return (OI_GV_InitializationFlags[module]) ;
+}
+
+void OI_InitFlags_PutFlag(OI_INIT_FLAG flagValue, OI_MODULE module, OI_MODULE callingModule)
+{
+    OI_ASSERT(module == callingModule);
+    OI_ASSERT(module < OI_ARRAYSIZE(OI_GV_InitializationFlags)) ;
+    if (!(module < OI_ARRAYSIZE(OI_GV_InitializationFlags))) {
+        return;
+    }
+    if (OI_GV_InitializationFlags[module] == OI_INIT_FLAG_UNINITIALIZED_VALUE) {
+        if (flagValue != OI_INIT_FLAG_UNINITIALIZED_VALUE) {
+            // was uninitialized, changing to initialized
+            if (module != OI_MODULE_SUPPORT) { /* avoid an infinite recursion when initializing the debugprint code */
+                /* OI_DBGPRINT(("%s init flag changed from uninitialized to %d\n", ModuleToString(module), flagValue)) ; */
+            }
+        }
+    }
+    else if (flagValue == OI_INIT_FLAG_UNINITIALIZED_VALUE) {
+        // was initialized, changing to uninitialized
+        if (module != OI_MODULE_SUPPORT) { /* avoid an infinite recursion when initializing the debugprint code */
+            /* OI_DBGPRINT(("%s init flag changed from %d to uninitialized\n",_ModuleToString(module), OI_GV_InitializationFlags[module])) ; */
+        }
+    }
+    OI_GV_InitializationFlags[module] = flagValue ;
+}
+
+void OI_InitFlags_Increment(OI_MODULE module)
+{
+    OI_ASSERT(module < OI_ARRAYSIZE(OI_GV_InitializationFlags)) ;
+    if (!(module < OI_ARRAYSIZE(OI_GV_InitializationFlags))) {
+        return;
+    }
+    ++OI_GV_InitializationFlags[module];
+}
+
+void OI_InitFlags_Decrement(OI_MODULE module)
+{
+    OI_ASSERT(module < OI_ARRAYSIZE(OI_GV_InitializationFlags)) ;
+    if (!(module < OI_ARRAYSIZE(OI_GV_InitializationFlags))) {
+        return;
+    }
+    OI_ASSERT(OI_GV_InitializationFlags[module]);
+    --OI_GV_InitializationFlags[module];
+}
+
+OI_BOOL OI_InitFlags_AllUninitialized(void)
+{
+    OI_UINT  i ;
+
+    for (i = 0; i < OI_ARRAYSIZE(OI_GV_InitializationFlags); ++i) {
+        if (OI_INIT_FLAG_UNINITIALIZED_VALUE != OI_GV_InitializationFlags[i]) {
+            return(FALSE) ;
+        }
+    }
+    return(TRUE) ;
+}
+/*****************************************************************************/
+
+
+
+
diff --git a/obex_profiles/stack/support/oi_list.c b/obex_profiles/stack/support/oi_list.c
new file mode 100644
index 0000000..c352799
--- /dev/null
+++ b/obex_profiles/stack/support/oi_list.c
@@ -0,0 +1,134 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+ @file
+@internal
+
+ linked list functions
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_core_common.h"
+#include "oi_list.h"
+
+/** Internal function for adding to a list between two elements. */
+static void Add(OI_LIST_ELEM *newElem, OI_LIST_ELEM *prev, OI_LIST_ELEM *next)
+{
+    if (newElem == NULL || prev == NULL || next == NULL)
+        return;
+
+    prev->next = newElem;
+    newElem->next = next;
+    newElem->prev = prev;
+    next->prev = newElem;
+}
+
+void OI_List_DynamicInit(OI_LIST_ELEM *elem)
+{
+    if (elem == NULL)
+        return;
+
+    elem->prev = elem;
+    elem->next = elem;
+}
+
+
+void OI_List_Add(OI_LIST_ELEM *newElem, OI_LIST_ELEM *list)
+{
+    if (list == NULL)
+        return;
+
+    Add(newElem, list, list->next);
+}
+
+
+void OI_List_AddTail(OI_LIST_ELEM *newElem, OI_LIST_ELEM *list)
+{
+    if (list == NULL)
+        return;
+
+    Add(newElem, list->prev, list);
+}
+
+
+OI_LIST_ELEM* OI_List_Del(OI_LIST_ELEM *elem)
+{
+    if (elem == NULL)
+        return NULL;
+
+    OI_LIST_ELEM *prev = elem->prev;
+    OI_LIST_ELEM *next = elem->next;
+
+    /*
+     * Ensure that element to be deleted is in list.
+     */
+    if ((prev->next != elem) || (next->prev != elem)) {
+        OI_LOG_ERROR(("Attempt to delete element not in list"));
+        return elem;
+    }
+    prev->next = next;
+    next->prev = prev;
+#ifdef OI_DEBUG
+    elem->next = NULL;
+    elem->prev = NULL;
+#endif
+    return prev;
+}
+
+
+OI_LIST_ELEM *OI_List_RemoveHead(OI_LIST_ELEM *list)
+{
+    OI_LIST_ELEM *elem;
+
+    if (list == NULL)
+        return NULL;
+
+    if (OI_List_IsEmpty(list)) {
+        return NULL;
+    }
+
+    elem = list->next;
+    OI_List_Del(elem);
+    return elem;
+}
+
+
+OI_UINT OI_List_CountElements(OI_LIST_ELEM *list)
+{
+    OI_UINT count = 0;
+    OI_LIST_ELEM *pos;
+
+    OI_LIST_FOREACH(pos, list) {
+        ++count;
+    }
+    return count;
+}
diff --git a/obex_profiles/stack/support/oi_mbuf.c b/obex_profiles/stack/support/oi_mbuf.c
new file mode 100644
index 0000000..a9d2dcb
--- /dev/null
+++ b/obex_profiles/stack/support/oi_mbuf.c
@@ -0,0 +1,812 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+@file
+@internal
+
+ This module implements a non-linear buffering scheme called "mbufs" that allows
+ data to be passed down the stack layers without requiring data copying at each
+ layer. The simple concept is that with an mbuf, a data packet is stored in
+ multiple buffers rather than in a single contiguous data buffer. As each stack
+ layer proceses data from the higher layers, data can be segmented and
+ packetized without the need to actually copy any of the data. This improves
+ performance by eliminating memory-to-memory copying and reduces total memory
+ usage by elminating the need for each stack layer to allocate buffers to
+ accomodate payloads passed in from the upper layers.
+*/
+
+#define __OI_MODULE__ OI_MODULE_MEMMGR
+
+#include "oi_debug.h"
+#include "oi_assert.h"
+#include "oi_memmgr.h"
+#include "oi_status.h"
+#include "oi_std_utils.h"
+#include "oi_mbuf.h"
+#include "oi_fcs.h"
+
+
+
+/*
+ * An mbuf is considered to be windowed if there is a non-zero window size set or if it has a
+ * non-zero window start position.
+ */
+#define MBUF_IS_WINDOWED(m) ((m)->winSize || (m)->winStart)
+
+
+/*
+ * Allocate and initialize an mbuf sized to accomodate the requested number of cells.
+ */
+
+OI_MBUF* OI_MBUF_Alloc(OI_UINT8 numCells)
+{
+    OI_UINT size = sizeof(OI_MBUF) + sizeof(OI_MBUF_CELL) * (numCells - DEFAULT_MBUF_CELLS);
+    OI_MBUF *mbuf;
+
+    mbuf = OI_Calloc(size);
+    if (mbuf) {
+        mbuf->allocCells = numCells;
+    }
+    return mbuf;
+}
+
+
+OI_STATUS OI_MBUF_Init(OI_MBUF *mbuf,
+                       OI_UINT8 numCells)
+{
+    OI_UINT size = sizeof(OI_MBUF) + sizeof(OI_MBUF_CELL) * (numCells - DEFAULT_MBUF_CELLS);
+    OI_ASSERT(mbuf != NULL);
+    OI_ASSERT(numCells > 0);
+
+    if (numCells > DEFAULT_MBUF_CELLS) {
+        OI_SLOG_ERROR(OI_STATUS_MBUF_OVERFLOW, ("OI_MBUF_Init %d", OI_STATUS_MBUF_OVERFLOW)) ;
+        return OI_STATUS_MBUF_OVERFLOW;
+    }
+    OI_MemZero(mbuf, size);
+    mbuf->allocCells = numCells;
+    return OI_OK;
+}
+
+
+/*
+ * Recursively cleans an MBUF by clearing the currPos and currCell values and resetting numBytes.
+ * All information related to windowing is preserved.
+ */
+static OI_UINT16 Clean(OI_MBUF *mbuf)
+{
+    OI_DBGPRINT2(("MBUF clean %lx", mbuf));
+
+    if (OI_MBUF_IS_DIRTY(mbuf)) {
+        OI_UINT i;
+        OI_UINT16 len = 0;
+        /*
+         * Note that the windowing information is preserved
+         */
+        mbuf->currPos = 0;
+        mbuf->currCell = 0;
+
+        for (i = 0; i < mbuf->usedCells; ++i) {
+            OI_MBUF_CELL *cell = &mbuf->cells[i];
+            if (MBUF_NESTED == cell->disposition) {
+                Clean(cell->buf.mcell.mbuf);
+            }
+            len += cell->len;
+        }
+        /*
+         * If the mbuf is windowed numBytes is the window size, otherwise it is the un-windowed size
+         */
+        if (MBUF_IS_WINDOWED(mbuf)) {
+            OI_ASSERT(mbuf->winSize <= len);
+            mbuf->numBytes = mbuf->winSize;
+        } else {
+            mbuf->numBytes = len;
+        }
+    }
+    return mbuf->numBytes;
+}
+
+
+/*
+ * Not currently a public API but this function is used for testing.
+ */
+void OI_MBUF_Reset(OI_MBUF *mbuf)
+{
+    Clean(mbuf);
+}
+
+
+OI_UINT16 OI_MBUF_Clear(OI_MBUF *mbuf)
+{
+    OI_UINT i;
+    OI_UINT16 len = 0;
+
+#ifdef OI_DEBUG
+    OI_UINT allocCells = mbuf->allocCells;
+    OI_UINT size = sizeof(OI_MBUF) + sizeof(OI_MBUF_CELL) * (allocCells - DEFAULT_MBUF_CELLS);
+#endif
+
+    OI_DBGPRINT2(("MBUF Clear %lx", mbuf));
+
+    for (i = 0; i < mbuf->usedCells; ++i) {
+        OI_MBUF_CELL *cell = &mbuf->cells[i];
+        switch (cell->disposition) {
+            case MBUF_KEEP:
+            case MBUF_INLINE:
+                len += cell->len;
+                break;
+            case MBUF_COPY:
+            case MBUF_FREE:
+                OI_Free((void *)cell->buf.ptr);
+                len += cell->len;
+                break;
+            case MBUF_NESTED:
+                len += Clean(cell->buf.mcell.mbuf);
+                break;
+        }
+    }
+#ifdef OI_DEBUG
+    OI_MemZero(mbuf, size);
+    mbuf->allocCells = allocCells;
+#else
+    mbuf->usedCells = 0;
+    mbuf->currPos = 0;
+    mbuf->currCell = 0;
+    mbuf->numBytes = 0;
+    mbuf->winSize = 0;
+    mbuf->winStart = 0;
+#endif
+    return len;
+}
+
+
+/**
+ * Free an mbuf previously allocated by OI_MBUF_Alloc.
+ */
+
+OI_UINT16 OI_MBUF_Free(OI_MBUF *mbuf)
+{
+    OI_UINT16 len;
+
+    OI_DBGPRINT2(("MBUF Free %lx", mbuf));
+    len = OI_MBUF_Clear(mbuf);
+    OI_Free(mbuf);
+    return len;
+}
+
+
+static OI_STATUS InitCell(OI_MBUF_CELL *currCell,
+                          const OI_BYTE* buf,
+                          OI_UINT16 len,
+                          OI_MBUF_DISPOSITION disposition)
+{
+    OI_INT i;
+    OI_BYTE *ptr;
+
+    /*
+     * Verify data being added to this MBUF is valid (see Bug2627)
+     */
+    OI_ASSERT(OI_MEMMGR_CheckSize(buf, len));
+
+    if (disposition == MBUF_COPY) {
+        /*
+         * Avoid malloc and free for small fragments by copying data directly into mbuf
+         */
+        if (len <= MBUF_INLINE_BUF_SIZE) {
+            for (i = 0; i < len; ++i) {
+                currCell->buf.data[i] = buf[i];
+            }
+            disposition = MBUF_INLINE;
+        } else {
+            /*
+             * Malloc memory for the mbuf data.
+             */
+            if ((ptr = OI_Malloc(len)) == NULL) {
+                /*
+                 * Clear the cell to keep the enclosing mbuf consistent.
+                 */
+                currCell->buf.ptr = NULL;
+                currCell->len = 0;
+                currCell->disposition = MBUF_KEEP;
+                return OI_STATUS_OUT_OF_MEMORY;
+            }
+            OI_MemCopy(ptr, buf, len);
+            currCell->buf.ptr = ptr;
+        }
+    } else {
+        currCell->buf.ptr = buf;
+    }
+    currCell->disposition = disposition;
+    currCell->len = len;
+    return OI_OK;
+}
+
+
+
+void OI_MBUF_Unwrap(OI_MBUF *mbuf,
+                    OI_BYTE **data,
+                    OI_UINT16 *len)
+{
+    OI_ASSERT(mbuf && data && len);
+    OI_ASSERT(mbuf->allocCells <= 1);
+    OI_ASSERT(mbuf->usedCells == mbuf->allocCells);
+
+    if (mbuf->allocCells == 1) {
+        OI_ASSERT(mbuf->cells[0].disposition == MBUF_KEEP);
+        *data = (OI_BYTE*)mbuf->cells[0].buf.ptr;
+        *len = mbuf->cells[0].len;
+    } else {
+        OI_ASSERT(mbuf->allocCells == 0);
+        *data = NULL;
+        *len = 0;
+    }
+    OI_Free(mbuf);
+}
+
+
+OI_MBUF* OI_MBUF_Wrap(const OI_BYTE *data,
+                      OI_UINT16 len,
+                      OI_MBUF_DISPOSITION disposition)
+{
+    OI_MBUF *mbuf;
+    OI_STATUS result;
+
+    if ((data == NULL) || (len == 0)) {
+        mbuf = OI_MBUF_Alloc(0);
+    } else {
+        mbuf = OI_MBUF_Alloc(1);
+        if (mbuf != NULL) {
+            mbuf->usedCells = 1;
+            mbuf->numBytes = len;
+            result = InitCell(mbuf->cells, data, len, disposition);
+            if (!OI_SUCCESS(result)) {
+                OI_SLOG_ERROR(result, ("OI_MBUF_Wrap - InitCell failed %d", result));
+                OI_MBUF_Free(mbuf);
+                mbuf = NULL;
+            }
+        }
+    }
+    OI_DBGPRINT2(("OI_MBUF_Wrap %lx", mbuf));
+    return mbuf;
+}
+
+
+/**
+ * Add a new cell to the front of an mbuf. This function will typically be used to add a packet
+ * header to a payload passed from a higher layer.
+ */
+
+OI_STATUS OI_MBUF_Prepend(OI_MBUF* mbuf,
+                          const OI_BYTE* buf,
+                          OI_UINT16 len,
+                          OI_MBUF_DISPOSITION disposition)
+{
+    OI_UINT i;
+    OI_STATUS status;
+
+    OI_ASSERT(mbuf);
+    OI_ASSERT(buf);
+    OI_ASSERT(!OI_MBUF_IS_DIRTY(mbuf));
+    /*
+     * Cannot prepend to an mbuf that is windowed
+     */
+    OI_ASSERT(!MBUF_IS_WINDOWED(mbuf));
+
+    if (disposition > MBUF_KEEP) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    if (len == 0) {
+        return OI_OK;
+    }
+    if (mbuf->usedCells >= mbuf->allocCells) {
+        OI_SLOG_ERROR(OI_STATUS_MBUF_OVERFLOW, ("MBUF Prepend overflow: alloc %d", mbuf->allocCells));
+        OI_MBUF_Dump(mbuf, "overflow in prepend");
+        return OI_STATUS_MBUF_OVERFLOW;
+    }
+    /*
+     * Make room for the new cell
+     */
+    for (i = mbuf->usedCells; i > 0; --i) {
+        mbuf->cells[i] = mbuf->cells[i - 1];
+    }
+    /*
+     * Increment used cells first to avoid potential memory leak if InitCell fails
+     */
+    mbuf->usedCells++;
+    status = InitCell(&mbuf->cells[0], buf, len, disposition);
+    if (OI_SUCCESS(status)) {
+        mbuf->numBytes += len;
+    }
+
+    return status;
+}
+
+
+/**
+ * Add a cell to the end of an mbuf. This function will typically be used to add
+ * a packet trailer to a payload passed from a higher layer.
+ */
+
+OI_STATUS OI_MBUF_Append(OI_MBUF* mbuf,
+                         const OI_BYTE* buf,
+                         OI_UINT16 len,
+                         OI_MBUF_DISPOSITION disposition)
+{
+    OI_STATUS status;
+
+    OI_ASSERT(mbuf);
+    OI_ASSERT(!OI_MBUF_IS_DIRTY(mbuf));
+
+    /*
+     * Cannot append to an mbuf that is windowed
+     */
+    OI_ASSERT(!MBUF_IS_WINDOWED(mbuf));
+
+    if (disposition > MBUF_KEEP) {
+        return OI_STATUS_INVALID_PARAMETERS;
+    }
+    if (len == 0) {
+        return OI_OK;
+    }
+    if (mbuf->usedCells >= mbuf->allocCells) {
+        OI_SLOG_ERROR(OI_STATUS_MBUF_OVERFLOW, ("MBUF Append overflow: alloc %d", mbuf->allocCells));
+        OI_MBUF_Dump(mbuf, "overflow in append");
+        return OI_STATUS_MBUF_OVERFLOW;
+    }
+    status = InitCell(&mbuf->cells[mbuf->usedCells], buf, len, disposition);
+    if (OI_SUCCESS(status)) {
+        mbuf->usedCells++;
+        mbuf->numBytes += len;
+    }
+    return status;
+}
+
+
+OI_MBUF* OI_MBUF_GetNestedMbuf(OI_MBUF *mbuf,
+                               OI_UINT8 index)
+{
+    OI_MBUF_CELL *cell;
+
+    if (index >= mbuf->usedCells) {
+        return NULL;
+    }
+    cell = &mbuf->cells[index];
+    if (cell->disposition != MBUF_NESTED) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_STATE, ("Cell does not hold a nested MBUF"));
+        return NULL;
+    }
+    return cell->buf.mcell.mbuf;
+}
+
+
+OI_STATUS OI_MBUF_AppendMbuf(OI_MBUF *mbuf,
+                             OI_MBUF *added)
+{
+    OI_MBUF_CELL *cell;
+
+    OI_ASSERT(!OI_MBUF_IS_DIRTY(mbuf));
+    OI_ASSERT(!OI_MBUF_IS_DIRTY(added));
+
+    OI_DBGPRINT(("Append MBUF %lx to %lx", added, mbuf));
+
+    if (mbuf->usedCells >= mbuf->allocCells) {
+        OI_SLOG_ERROR(OI_STATUS_MBUF_OVERFLOW, ("MBUF Append Mbuf overflow: alloc %d", mbuf->allocCells));
+        OI_MBUF_Dump(mbuf, "overflow in append mbuf");
+        return OI_STATUS_MBUF_OVERFLOW;
+    }
+    cell = &mbuf->cells[mbuf->usedCells];
+
+    mbuf->usedCells++;
+    mbuf->numBytes += added->numBytes;
+    cell->disposition = MBUF_NESTED;
+    cell->buf.mcell.mbuf = added;
+    /*
+     * Save the windowing information from the inner MBUF
+     */
+    cell->buf.mcell.winStart = added->winStart;
+    cell->len = added->numBytes;
+
+    return OI_OK;
+}
+
+
+static OI_UINT16 PullBytes(OI_BYTE *dest,
+                           OI_MBUF *src,
+                           OI_UINT16 numBytes,
+                           OI_UINT16 winPos)
+{
+    OI_BYTE *destStart = dest;
+    OI_UINT8 currCell = src->currCell;
+    OI_UINT16 currPos = src->currPos;
+
+    /*
+     * Immediately following a reset the mbuf tree is clean and data before the start of the window is
+     * skipped. After the initial bytes have been pulled the currCell and currPos will be positioned
+     * beyond the start of the window so winPos no longer applies.
+     */
+    if (OI_MBUF_IS_DIRTY(src)) {
+        winPos = 0;
+    }
+
+    while (currCell < src->usedCells) {
+        OI_MBUF_CELL *cell = &src->cells[currCell];
+        OI_UINT16 len = cell->len;
+        /*
+         * If the current cell is completely outside the window skip it
+         */
+        if (len < winPos) {
+            OI_ASSERT(currPos == 0);
+            winPos -= len;
+        } else {
+            /*
+             * Skip bytes that are outside the window
+             */
+            currPos += winPos;
+            winPos = 0;
+            /*
+             * Cannot pull more bytes from the cell than available
+             */
+            OI_ASSERT(len >= currPos);
+            len = OI_MIN(numBytes, len - currPos);
+
+            if (cell->disposition == MBUF_NESTED) {
+                /*
+                 * Use the window position that size in effect when the mbuf was nested
+                 */
+                len = PullBytes(dest, cell->buf.mcell.mbuf, len, cell->buf.mcell.winStart + currPos);
+            } else {
+                const OI_BYTE *data = (cell->disposition == MBUF_INLINE) ? cell->buf.data : cell->buf.ptr;
+                OI_MemCopy(dest, data + currPos, len);
+            }
+            currPos += len;
+            dest += len;
+            OI_ASSERT(numBytes >= len);
+            numBytes -= len;
+            /*
+             * If there are no more bytes to pull we are done
+             */
+            if (numBytes == 0) {
+                break;
+            }
+        }
+        currPos = 0;
+        ++currCell;
+    }
+
+    src->currCell = currCell;
+    src->currPos = currPos;
+
+    return (OI_UINT16)(dest - destStart);
+}
+
+
+
+/**
+ * Moves bytes from an mbuf into a contiguous buffer.
+ */
+
+OI_UINT16 OI_MBUF_PullBytes(OI_BYTE *dest,
+                            OI_MBUF *src,
+                            OI_UINT16 numBytes)
+{
+    OI_UINT16 pulled = 0;
+
+    OI_ASSERT(dest);
+    OI_ASSERT(src);
+
+    if (numBytes > 0) {
+        pulled = PullBytes(dest, src, OI_MIN(src->numBytes, numBytes), src->winStart);
+        OI_ASSERT(src->numBytes >= pulled);
+        src->numBytes -= pulled;
+    }
+    return pulled;
+}
+
+
+static OI_UINT16 ComputeFCS(const OI_MBUF *mbuf,
+                            OI_UINT16 numBytes,
+                            OI_UINT16 winPos,
+                            OI_UINT16 *runningFCS)
+{
+    OI_UINT16 checkedLen = 0;
+    OI_UINT8 currCell;
+
+    OI_ASSERT(!OI_MBUF_IS_DIRTY(mbuf));
+
+    for (currCell = 0; currCell < mbuf->usedCells; ++currCell) {
+        const OI_MBUF_CELL *cell = &mbuf->cells[currCell];
+        OI_UINT16 len = cell->len;
+        /*
+         * If the current cell is outside the window skip it
+         */
+        if (len < winPos) {
+            winPos -= len;
+        } else {
+            len = OI_MIN(numBytes, len - winPos);
+            if (cell->disposition == MBUF_NESTED) {
+                len = ComputeFCS(cell->buf.mcell.mbuf, len, winPos + cell->buf.mcell.winStart, runningFCS);
+            } else {
+                const OI_BYTE *data = (cell->disposition == MBUF_INLINE) ? cell->buf.data : cell->buf.ptr;
+                OI_FCS_Compute(data + winPos, len, runningFCS);
+            }
+            checkedLen += len;
+            numBytes -= len;
+            if (numBytes == 0) {
+                break;
+            }
+            winPos = 0;
+        }
+    }
+    return checkedLen;
+}
+
+
+OI_UINT16 OI_MBUF_ComputeFCS(const OI_MBUF *mbuf,
+                             OI_UINT16 numBytes,
+                             OI_UINT16 *runningFCS)
+{
+    OI_ASSERT(mbuf);
+    return ComputeFCS(mbuf, OI_MIN(numBytes, mbuf->numBytes), mbuf->winStart, runningFCS);
+}
+
+
+OI_UINT16 OI_MBUF_SetWindowAt(OI_MBUF *mbuf,
+                              OI_UINT16 winStart,
+                              OI_UINT16 winSize)
+{
+    OI_UINT16 i;
+    OI_UINT16 len = 0;
+
+    OI_ASSERT(mbuf);
+    OI_ASSERT(!OI_MBUF_IS_DIRTY(mbuf));
+
+    OI_DBGPRINT(("SetWindowAt %lx (current pos %d) at %d size %d", mbuf, mbuf->winStart, winStart, winSize));
+
+    /*
+     * Recalculate the total number of bytes in the mbuf
+     */
+    for (i = 0; i < mbuf->usedCells; ++i) {
+        len += mbuf->cells[i].len;
+    }
+    /*
+     * Apply the windowing
+     */
+    mbuf->winStart = OI_MIN(len, winStart);
+    mbuf->winSize = OI_MIN(len - mbuf->winStart, winSize);
+    mbuf->numBytes = mbuf->winSize;
+
+    return mbuf->winSize;
+}
+
+
+OI_UINT16 OI_MBUF_SetWindow(OI_MBUF *mbuf,
+                            OI_UINT16 winSize)
+{
+    return OI_MBUF_SetWindowAt(mbuf, 0, winSize);
+}
+
+
+OI_UINT16 OI_MBUF_AdvanceWindow(OI_MBUF *mbuf,
+                                OI_UINT16 winSize)
+{
+    OI_ASSERT(mbuf);
+    return OI_MBUF_SetWindowAt(mbuf, mbuf->winStart + mbuf->winSize, winSize);
+}
+
+
+const OI_BYTE * OI_MBUF_PeekBytes(OI_MBUF *mbuf,
+                                  OI_UINT16 offset,
+                                  OI_UINT16 *contigLen)
+{
+    const OI_BYTE *ret = NULL;
+    OI_INT i;
+
+    /* Make offset relative to any defined window */
+    offset += mbuf->winStart;
+
+    for (i = 0; i < mbuf->usedCells; ++i) {
+        OI_MBUF_CELL *cell = &mbuf->cells[i];
+        if (offset >= cell->len) {
+            offset -= cell->len;
+        }
+        else {
+            if (MBUF_INLINE == cell->disposition) {
+                *contigLen = cell->len - offset;
+                ret = &cell->buf.data[0] + offset;
+            }
+            else if (MBUF_NESTED == cell->disposition) {
+                ret = OI_MBUF_PeekBytes(cell->buf.mcell.mbuf, offset, contigLen);
+            }
+            else {
+                *contigLen = cell->len - offset;
+                ret = cell->buf.ptr + offset;
+            }
+            break;
+        }
+    }
+    return ret;
+}
+
+#ifdef OI_DEBUG
+OI_UINT16 OI_MBUF_NumBytes(OI_MBUF *mb)
+{
+    OI_ASSERT(mb);
+
+    return (mb ? mb->numBytes : 0);
+}
+#endif
+
+
+#ifdef OI_DEBUG
+
+/**
+ * Print out contents of an mbuf.
+ */
+
+static OI_UINT16 MBUF_Print(OI_UINT indent,
+                     OI_MBUF *mbuf,
+                     OI_UINT16 numBytes,
+                     OI_UINT16 winPos)
+{
+    OI_UINT i;
+    OI_UINT16 currPos = mbuf->currPos;
+    OI_UINT8 currCell = mbuf->currCell;
+    OI_UINT16 totalLen = 0;
+    OI_CHAR inTxt[33];
+
+    OI_ASSERT(indent < OI_ARRAYSIZE(inTxt));
+
+    for (i = 0; i < indent; ++i) {
+        inTxt[i] = ' ';
+    }
+    inTxt[indent] = 0;
+
+    if (MBUF_IS_WINDOWED(mbuf)) {
+        OI_Printf("MBUF window @%d len:%d ", winPos, mbuf->winSize);
+    } else {
+        OI_Printf("MBUF ");
+    }
+    if (OI_MBUF_IS_DIRTY(mbuf)) {
+        winPos = 0;
+        OI_Printf("(dirty) ");
+    }
+    if (numBytes == 0) {
+        OI_Printf("empty\n");
+    } else {
+        OI_Printf("\n");
+        while (currCell < mbuf->usedCells) {
+            OI_MBUF_CELL *cell = &mbuf->cells[currCell];
+            OI_UINT16 len = cell->len;
+            /*
+             * If the current cell is outside the window skip it
+             */
+            if (len < winPos) {
+                OI_ASSERT(currPos == 0);
+                winPos -= len;
+            } else {
+                /*
+                 * Skip bytes that are outside the window
+                 */
+                currPos += winPos;
+                winPos = 0;
+                OI_ASSERT(len >= currPos);
+                len = OI_MIN(numBytes, len - currPos);
+
+                if (cell->disposition == MBUF_NESTED) {
+                    OI_Printf("%s[%d] ", inTxt, currCell);
+                    /*
+                     * Use the window position and size in effect when the mbuf was nested
+                     */
+                    len = MBUF_Print(indent + 4, cell->buf.mcell.mbuf, len, cell->buf.mcell.winStart + currPos);
+                } else {
+                    const OI_BYTE *data = (cell->disposition == MBUF_INLINE) ? cell->buf.data : cell->buf.ptr;
+                    /*
+                     * Skip bytes that are outside the window
+                     */
+                    OI_Printf("%s[%d] %@", inTxt, currCell, data + currPos, len);
+                    currPos += len;
+                }
+                currPos += len;
+                totalLen += len;
+                numBytes -= len;
+                if (numBytes == 0) {
+                    break;
+                }
+            }
+            currPos = 0;
+            ++currCell;
+        }
+    }
+    return totalLen;
+}
+
+
+void OI_MBUF_Print(OI_MBUF *mbuf)
+{
+    MBUF_Print(0, mbuf, mbuf->numBytes, mbuf->winStart);
+}
+
+/**
+ * Print out structure of an mbuf.
+ */
+
+static void MBUF_Dump(OI_UINT indent,
+                      OI_MBUF *mbuf,
+                      OI_CHAR *tag)
+{
+    OI_UINT i;
+    OI_CHAR inTxt[33];
+
+    OI_ASSERT(indent < OI_ARRAYSIZE(inTxt));
+
+    for (i = 0; i < indent; ++i) {
+        inTxt[i] = ' ';
+    }
+    inTxt[indent] = 0;
+
+    OI_Printf("%sMBUF%s %lx %s:\n", inTxt, OI_MBUF_IS_DIRTY(mbuf) ? " (dirty)" : "", mbuf, tag);
+    if (MBUF_IS_WINDOWED(mbuf)) {
+        OI_Printf("%sis windowed winStart=%d winSize=%d\n", inTxt, mbuf->winStart, mbuf->winSize);
+    }
+    OI_Printf("%salloc=%d used=%d\n", inTxt, mbuf->allocCells, mbuf->usedCells);
+    OI_Printf("%snumBytes=%d\n", inTxt, mbuf->numBytes);
+    OI_Printf("%scurrCell=%d currPos=%d\n", inTxt, mbuf->currCell, mbuf->currPos);
+
+    for (i = 0; i < mbuf->usedCells; ++i) {
+        OI_MBUF_CELL *cell = &mbuf->cells[i];
+        const OI_BYTE *p;
+        if (cell->disposition == MBUF_NESTED) {
+            OI_Printf("%scell[%d] NESTED len=%d winStart=%d\n", inTxt, i, cell->len, cell->buf.mcell.winStart);
+            MBUF_Dump(indent + 4, cell->buf.mcell.mbuf, "");
+            continue;
+        }
+        if (cell->disposition == MBUF_INLINE) {
+            p = cell->buf.data;
+        } else {
+            p = cell->buf.ptr;
+        }
+        if (cell->len) {
+            OI_UINT16 max = OI_MIN(cell->len, 8);
+            OI_Printf("%scell[%d] len=%d data=%@", inTxt, i, cell->len, p, max);
+        } else {
+            OI_Printf("%scell[%d] EMPTY\n", inTxt, i);
+        }
+    }
+}
+
+
+void OI_MBUF_Dump(OI_MBUF *mbuf,
+                  OI_CHAR *tag)
+{
+    MBUF_Dump(0, mbuf, tag);
+}
+
+#endif /* OI_DEBUG */
+
+
diff --git a/obex_profiles/stack/support/oi_memmgr.c b/obex_profiles/stack/support/oi_memmgr.c
new file mode 100644
index 0000000..b18d645
--- /dev/null
+++ b/obex_profiles/stack/support/oi_memmgr.c
@@ -0,0 +1,1318 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+@file
+@internal
+
+This file implements memory management functions.
+*/
+
+#define __OI_MODULE__ OI_MODULE_MEMMGR
+
+#include "oi_common.h"
+#include "oi_debug.h"
+#include "oi_std_utils.h"
+#include "oi_memmgr.h"
+#include "oi_time.h"
+#include "oi_memprof.h"
+#include "oi_debugcontrol.h"
+#include "oi_support_init.h"
+#include "oi_debug.h"
+#include "oi_dump.h"
+
+#include "oi_init_flags.h"
+
+/*
+ * Use OI_Printf instead of OI_DBGPRINT if we are not compiled for debugging.
+ */
+#ifndef OI_DEBUG
+#undef OI_DBGPRINT
+#undef OI_DBGPRINT2
+#define OI_DBGPRINT(s)    OI_Printf s
+#define OI_DBGPRINT2(s)   OI_Printf s
+#endif
+
+
+/*
+ * Comment out the whole file if we are using the native malloc
+ */
+#ifndef OI_USE_NATIVE_MALLOC
+
+/************************************************************************************
+
+  Memory Heap
+
+ ************************************************************************************/
+/*
+ *  All memory is managed by the memory manager resides in a heap which is
+ *  passed to the mm in the initialization call.  Memory is staticMalloc'd from
+ *  the heap and never returned.  Dynamic memory allocation is also from the
+ *  heap, but via the pool mechanism.
+ *
+ *  The heap is managed with a 'current' and 'end' pointers.  The current
+ *  pointer points at the next available memory location in the heap.  The end
+ *  pointer points at the first memory location past the end of the heap.
+ */
+
+static OI_BYTE *heapCurrentPtr;
+static OI_BYTE *heapEndPtr;
+
+/************************************************************************************
+
+  Memory Pools
+
+ ************************************************************************************/
+
+/*
+ * A sanity check - no sane person would ever allocate 100 different size pools.
+ */
+
+#define MEMMGR_MAX_POOL_COUNT 100
+
+
+/*
+ * Forward declaration of ALLOC_BLOCK
+ */
+
+typedef struct _ALLOC_BLOCK ALLOC_BLOCK;
+
+#ifdef MEMMGR_DEBUG
+
+/*
+ * The guard string helps to detect certain classes of memory bounds overrun
+ * errors. It also helps to identify the start of memory blocks when debugging
+ * raw memory.  The guard string length must be a multiple of 4 bytes to
+ * maintain proper memory alignment of the ALLOC_BLOCK structure.
+ */
+static const OI_BYTE GUARD_STRING[] = "!QTI!!";
+
+static OI_BOOL CheckGuardString(ALLOC_BLOCK const *blockPtr);
+
+void *last_alloc;   /* the last block allocated */
+
+void *last_free;    /* the last block freed */
+
+/*
+ * Add extra to end of each block to test for overshoot
+ */
+#define DEBUG_EXTRA 4
+
+/*
+ * Verify that allocated memory extends at least size bytes beyond addr.
+ */
+#define CHECK_EXTENT(addr, size)  OI_ASSERT(OI_MEMMGR_CheckSize(addr, size))
+
+#else
+
+#define CHECK_EXTENT(addr, size)
+static OI_BYTE debug_out = 0;
+
+/*
+ * No Overshoot detection in Release Builds
+ */
+#define DEBUG_EXTRA 0
+
+#endif /* MEMMGR_DEBUG */
+
+
+/*
+ * Type ALLOCBLOCK
+ *
+ * Raw memory blocks are cast to this type when linking and unlinking from the
+ * free list. If MEMMGR_DEBUG is TRUE additional fields are allocated for
+ * profiling and error checking.
+ *
+ * The actual allocated size is used for error checking when clearing or copying
+ * memory and is also used to tune memory allocation for embedded applications.
+ *
+ * The Guard field is used to detect memory corruption errors due to bounds
+ * errors. A fairly large guard field is more reliable at catching such errors
+ * and use of an identifiable string makes it easier to debug other memory
+ * allocation errors.
+ */
+
+
+struct _ALLOC_BLOCK {
+#ifdef MEMMGR_DEBUG
+    struct {
+        OI_BYTE   guard[sizeof(GUARD_STRING)]; /* Detects memory corruption */
+        OI_UINT32 allocSize;                   /* Actual allocation size */
+        OI_TIME   allocTime;                   /* Timestamp for the time the block was allocated */
+        OI_CHAR  *fname;                       /* File name of allocator */
+        OI_CHAR  *freeFile;                    /* File name of last freer */
+        OI_UINT16 lineNum;                     /* File line number of allocator */
+        OI_UINT16 freeLine;                    /* File line number of last freer */
+        OI_BYTE   free;                        /* Has the block been freed? */
+        OI_UINT8  module;                      /* Module that last Malloc'd block */
+        OI_UINT8  alignment[2];                /* (Unused) Force 32 bit alignment on 16 bit platforms */
+        ALLOC_BLOCK *priorPool;                /* Prior Pool location for Guard String coruption */
+    } MemDebug;
+#endif
+    ALLOC_BLOCK *next;     /* Link to next block in free list */
+};
+
+
+/*
+ * The size of a block header (with debugging off this should be zero)
+ */
+
+#define BLOCK_HEADER_SIZE  (sizeof(ALLOC_BLOCK) - sizeof(ALLOC_BLOCK*))
+
+
+/*
+ * Macro to get the start of an alloc block
+ */
+
+#define GET_ALLOC_BLOCK(b) ((ALLOC_BLOCK*) ((OI_BYTE *) (b) - BLOCK_HEADER_SIZE))
+
+
+
+/*
+ * Type MEMPOOL
+ *
+ * A memory pool is a linked list of memory blocks of the same size. The
+ * FreeList pointer is a pointer to a linked list of unallocated ALLOCBLOCKS.
+ *
+ * In production use OI_Malloc will always allocate the first block in the free
+ * list, and OI_Free will always add a freed block to the head of the list. For
+ * debugging we mix things up to help flush out memory allocation bugs.
+ */
+
+typedef struct {
+    OI_BYTE     *LAddr;    /* Lowest memory address allocated to this pool */
+    OI_BYTE     *HAddr;    /* Highest memory address allocated to this pool */
+    ALLOC_BLOCK *freeList; /* Pointer to first free memory allocation block */
+#ifdef MEMMGR_DEBUG
+    OI_UINT32   poolSize;  /* Allocated size for every block in this pool */
+#endif /* MEMMGR_DEBUG */
+} MEM_POOL;
+
+
+/*
+ * The pool table is array of memory pools of various sizes as specified in the
+ * pool configuration array. In a production system MEMMGR_MAX_POOL_COUNT should
+ * be equal the exact number of bytes specified in the pool configuration table
+ */
+
+static MEM_POOL *PoolTable;
+
+
+/*
+ * The heap is a statically allocated contiguous block of memory. All memory
+ * blocks are allocated from the heap. Same size blocks in memory pools are
+ * allocated contiguously. This means that we can tell which pool a memory block
+ * is allocated from by comparing the memory block address to the low and high
+ * bounds of entries in the Pool_Table.
+ */
+
+static OI_BYTE *PoolHeap;
+
+#ifdef MEMMGR_DEBUG
+
+static OI_BYTE *PoolHeapEnd;
+
+/*
+ * Test if an address references data allocated from the pool heap
+ */
+#define IS_DYNAMIC_ALLOC(a)   ((((const OI_BYTE*)(a)) >= PoolHeap) && (((const OI_BYTE*)(a)) < PoolHeapEnd ))
+
+static OI_UINT32 MEMMGR_ValidateAllocBlock(void const *block);
+static OI_UINT32 MEMMGR_ValidateFreeBlock(ALLOC_BLOCK *blockPtr, OI_UINT32 poolsize);
+#endif
+
+
+/*
+ * Test if an address references data allocated from a specific pool
+ */
+
+#define IS_FROM_POOL(a, p) ((((const OI_BYTE*)(a) >= PoolTable[p].LAddr)) && ((const OI_BYTE*)(a) < PoolTable[p].HAddr))
+
+
+/*
+ * Number of pools is established by pool configuragion parameter passed to OI_Memory_Manager_Init
+ */
+
+static OI_UINT16 PoolCount;
+
+
+/*
+ * The pool configuration for the pool heap as passed in to OI_MEMMGR_Init
+ */
+
+static const OI_MEMMGR_POOL_CONFIG *PoolConfiguration;
+
+
+/*
+ * OI_MEMMGR_Init
+ *
+ * Allocates blocks for each of the memory pools as specified in the pool
+ * configuration parameter. The pool configuration is an array of tuples that
+ * specify the block size for memory blocks in a pool and the number of blocks
+ * in the pool. All blocks for all pools are allocated from a statically
+ * allocated pool heap.
+ */
+
+OI_STATUS OI_MEMMGR_Init(const OI_CONFIG_MEMMGR *config)
+{
+    OI_INT16 numBlocks;
+    OI_INT32 blockSize;
+    OI_INT32 poolSize;
+    OI_INT16 pool;
+    OI_INT32 poolHeapSize = 0;
+    OI_BYTE *poolHeapPtr;
+#ifdef MEMMGR_DEBUG
+    OI_INT32 prevBlockSize = 0;    /* to verify pool table ordering  */
+    ALLOC_BLOCK *priorPool = NULL;
+
+    /*
+     * We want to ensure that the memory allocator always returns a pointer that
+     * is aligned on a 32-bit boundary.  OI_Static_Malloc always returns a
+     * 4-byte aligned block, so all we need to do is ensure that all block sizes
+     * are a multiple of 4 and that the sizeof debug structure (if any) is a
+     * multiple of 4.
+     */
+
+    OI_ASSERT(0 == (BLOCK_HEADER_SIZE & (3)));
+#endif /* MEMMGR_DEBUG */
+
+    OI_ASSERT(!OI_INIT_FLAG_VALUE(MEMMGR));
+    if ( OI_INIT_FLAG_VALUE(MEMMGR) ){
+        return OI_STATUS_ALREADY_INITIALIZED;
+    }
+
+    /*
+     * Initialize the overall heap - it will be needed for subsequent allocation
+     * of pool heaps.
+     */
+
+    OI_ASSERT(NULL != config->heapConfig);
+    OI_ASSERT(NULL != config->heapConfig->heap);
+    OI_ASSERT(0 != config->heapConfig->heapSize);
+
+    heapCurrentPtr = (OI_BYTE*)config->heapConfig->heap;
+    heapEndPtr = heapCurrentPtr + config->heapConfig->heapSize;
+
+    /*
+     * Establish the pool configuration that will be used
+     */
+    PoolConfiguration = config->poolConfig;
+
+    /*
+     * Count the pools and calculate the size of the pool heap
+     */
+    for (pool = 0; pool < MEMMGR_MAX_POOL_COUNT; ++pool) {
+
+        numBlocks = PoolConfiguration[pool].numBlocks;
+        blockSize = PoolConfiguration[pool].blockSize;
+
+        /*
+         * End of the config table is marked by a pair of zeroes.
+         */
+        if ((blockSize == 0) && (numBlocks == 0)) {
+            PoolCount = pool;
+            break;
+        }
+
+        OI_ASSERT( 0 == (blockSize & (3)));   /* must be a multiple of 4 */
+        OI_ASSERT((blockSize > 0) && (numBlocks > 0));
+
+#ifdef MEMMGR_DEBUG
+        OI_ASSERT(blockSize > prevBlockSize); /* verify increasing block size order */
+        prevBlockSize = blockSize;
+#endif /* MEMMGR_DEBUG */
+
+        /*
+         * The pool heap space needed for a block is the block size defined for
+         * this pool plus the block header (zero when debugging is off).
+         */
+        poolSize = blockSize + BLOCK_HEADER_SIZE + DEBUG_EXTRA;
+        poolHeapSize += poolSize * numBlocks;
+    }
+
+    /*
+     * Check Dynamic memory size
+     */
+    poolSize = poolHeapSize + (sizeof(MEM_POOL) * PoolCount);
+    OI_ASSERT( poolSize <= ((OI_INT32) (config->heapConfig->heapSize)) );
+
+    /*
+     * Zero memory pool space
+     */
+    OI_MemZero( heapCurrentPtr, poolSize );
+
+    /*
+     * Reserve the memory allocator pool table
+     */
+    PoolTable = (void *) heapCurrentPtr;
+    heapCurrentPtr += (sizeof(MEM_POOL) * PoolCount);
+    heapCurrentPtr = (OI_BYTE*)((OI_UINT32)(heapCurrentPtr + 3) & (~3));
+
+
+    /*
+     * Reserve the memory for the pool heap
+     */
+    PoolHeap = (void *) heapCurrentPtr;
+    heapCurrentPtr += poolHeapSize;
+    heapCurrentPtr = (OI_BYTE*)((OI_UINT32)(heapCurrentPtr + 3) & (~3));
+
+
+#ifdef MEMMGR_DEBUG
+    PoolHeapEnd = PoolHeap + poolHeapSize;
+#endif /* MEMMGR_DEBUG */
+
+    /*
+     * Initialize the pool tables
+     */
+    poolHeapPtr = PoolHeap;
+    for (pool = 0; pool < PoolCount; ++pool) {
+        OI_INT16 blockNum;
+        ALLOC_BLOCK *freeList = NULL;
+
+        numBlocks = PoolConfiguration[pool].numBlocks;
+        blockSize = PoolConfiguration[pool].blockSize;
+
+        poolSize = blockSize + BLOCK_HEADER_SIZE + DEBUG_EXTRA;
+
+        /*
+         * Set low and high addresses for blocks in this pool.
+         */
+        PoolTable[pool].LAddr = poolHeapPtr;
+        PoolTable[pool].HAddr = poolHeapPtr + (numBlocks * poolSize);
+
+#ifdef MEMMGR_DEBUG
+        PoolTable[pool].poolSize = poolSize;
+#endif /* MEMMGR_DEBUG */
+
+        /*
+         * Allocate space for each of the blocks in the pool and link them into
+         * the free list for the pool
+         */
+        for (blockNum = 0; blockNum < numBlocks; ++ blockNum) {
+
+            ALLOC_BLOCK *blockPtr = (ALLOC_BLOCK*) poolHeapPtr;
+
+            /* Link this block into the pool's free list */
+            blockPtr->next = freeList;
+            freeList = blockPtr;
+
+            poolHeapPtr += poolSize;
+
+#ifdef MEMMGR_DEBUG
+            {
+                OI_UINT32  i;
+                OI_UINT8  *fill;
+
+                /* Initialize the guard string */
+                for (i = 0; i < sizeof(GUARD_STRING); ++i) {
+                    blockPtr->MemDebug.guard[i] = GUARD_STRING[i];
+                }
+                blockPtr->MemDebug.priorPool = priorPool;
+                priorPool = blockPtr;
+                blockPtr->MemDebug.free = TRUE;
+                blockPtr->MemDebug.allocSize = 0;
+                /*
+                 * Fill block with odd value pattern to trap usage of freed blocks.
+                 */
+                fill = ((OI_UINT8 *)(void*) &(blockPtr->next)) + sizeof(blockPtr->next);
+                for (; fill < poolHeapPtr; fill++) {
+                    *fill = 0x55;
+                }
+
+            }
+#endif /* MEMMGR_DEBUG */
+
+        }
+
+        OI_ASSERT(PoolTable[pool].HAddr == poolHeapPtr);
+
+        /*
+         * Initialize free list with the last allocated block
+         */
+        PoolTable[pool].freeList = freeList;
+
+    }
+
+    /* Mark MEMMGR as initialized */
+    OI_INIT_FLAG_PUT_FLAG(TRUE, MEMMGR);
+
+
+    MEMPROF_INIT( BLOCK_HEADER_SIZE ); /*Initialize after the pools are allocated */
+
+    /*
+     * NOTE: Using printf because we always want this information to be be displayed.
+     */
+    OI_Printf("MemMgr initialized: Dynamic pool heap size: %ld\n", (OI_UINT32)(heapCurrentPtr) - (OI_UINT32)config->heapConfig->heap);
+    OI_Printf("MemMgr initialized: StaticMalloc heap available: %ld\n", (OI_UINT32)heapEndPtr - (OI_UINT32)heapCurrentPtr);
+
+    return OI_STATUS_SUCCESS;
+}
+
+void OI_MEMMGR_DebugEnable(OI_BOOL enable)
+{
+#ifndef MEMMGR_DEBUG
+    debug_out = enable ? TRUE : FALSE;
+#endif
+}
+
+
+/*
+ * Check if a call to OI_Malloc would fail
+ */
+OI_BOOL OI_MallocWillFail(OI_INT32 size)
+{
+    OI_UINT16 pool;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    for (pool = 0; pool < PoolCount; ++pool) {
+        if (PoolTable[pool].freeList != NULL) {
+            if (PoolConfiguration[pool].blockSize >= (OI_UINT32)size) {
+                return FALSE;
+            }
+        }
+    }
+    return TRUE;
+}
+
+/*
+ * OI_Malloc
+ *
+ * Searches through the pool list to find a pool with block size >= the
+ * requested size. If the best fit pool is empty, goes to the next pool. Assumes
+ * that pools in the pool table are sorted by size.
+ *
+ * If a suitable pool is found, the block at the head of the free list is
+ * removed from the free list and returned.
+ */
+
+#ifndef MEMMGR_DEBUG
+/* Non-Debug version */
+
+void* _OI_Malloc(OI_INT32 size)
+{
+    OI_INT16 pool;
+    ALLOC_BLOCK *blockPtr;
+    OI_UINT32 usize = size;
+    void *retval;
+    OI_UINT32 largest_available = 0;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    for (pool = 0; pool < PoolCount; ++pool) {
+        if (usize <= PoolConfiguration[pool].blockSize) {
+            blockPtr = PoolTable[pool].freeList;
+            if (blockPtr != NULL) {
+                PoolTable[pool].freeList = blockPtr->next;
+                /*
+                 * Allocated memory starts where the next pointer used to be
+                 */
+                retval = (void*) &(blockPtr->next);
+                /* Poor mans memprof --> print out details of memory allocation */
+                if (debug_out) OI_Printf("\r+%d %x\n", usize, retval);
+                return retval;
+            }
+        } else {
+            /* Poor mans memprof --> remember largest available block size */
+            if (PoolTable[pool].freeList) {
+                largest_available = PoolConfiguration[pool].blockSize;
+            }
+        }
+    }
+
+    OI_DBGPRINT(("Dyn Req: %ld\nAvail: %ld\nStatic: %ld\n", usize, largest_available, (OI_UINT32)(heapEndPtr - heapCurrentPtr)));
+    OI_LOG_ERROR(("OI_Malloc(%d) failed", usize));
+
+    /* Poor mans memprof --> print out details of memory failure */
+    if (debug_out){
+        OI_Printf("\r+%d 88888888\n", usize);
+        OI_FatalError(OI_STATUS_OUT_OF_MEMORY);
+    }
+
+    return 0;
+}
+
+
+void* _OI_Calloc(OI_INT32 size)
+{
+    void* block;
+    OI_INT32 i;
+
+    block = _OI_Malloc(size);
+    if (block != NULL) {
+        for (i = 0; i < size; ++i) {
+            ((OI_BYTE*) block)[i] = 0;
+        }
+    }
+    return block;
+
+}
+
+#else /* MEMMGR_DEBUG */
+
+/* Debug version */
+
+void* _OI_Malloc_Dbg(OI_INT32  size,
+                     OI_UINT8 module,
+                     OI_CHAR *fname,
+                     OI_UINT16 lineNum)
+{
+    OI_INT16 pool;
+    ALLOC_BLOCK *blockPtr;
+    OI_UINT32 usize = size;
+    void *retval;
+
+    OI_DBGPRINT2(("%s@%d - malloc(%ld)", fname, lineNum, size));
+    OI_ASSERT(OI_StackTokenHeld);
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+
+    for (pool = 0; pool < PoolCount; ++pool) {
+        if (usize <= PoolConfiguration[pool].blockSize) {
+            blockPtr = PoolTable[pool].freeList;
+            if (blockPtr != NULL) {
+                PoolTable[pool].freeList = blockPtr->next;
+                if( MEMMGR_ValidateFreeBlock(blockPtr, PoolConfiguration[pool].blockSize) != 0 ){
+                    /* Additional dump of data if we are about to ASSERT */
+                    OI_LOG_ERROR(("ERROR! - Block used after it was freed:\n"));
+                    OI_LOG_ERROR(("Corruption at byte: %ld\n", MEMMGR_ValidateFreeBlock(blockPtr, PoolConfiguration[pool].blockSize)));
+                    OI_LOG_ERROR(("Prior Alloc: %/@%d OI_Malloc(%ld)\n",blockPtr->MemDebug.fname,blockPtr->MemDebug.lineNum,blockPtr->MemDebug.allocSize));
+                    OI_LOG_ERROR(("Prior Free: %/@%d OI_Free(%lx)\n",blockPtr->MemDebug.freeFile,blockPtr->MemDebug.freeLine,(OI_UINT32)&(blockPtr->next)));
+                    OI_LOG_ERROR(("Cur Data: %@", &(blockPtr->next), 16));
+                    OI_LOG_ERROR(("New Alloc: %/@%d OI_Malloc(%ld)\n",fname,lineNum,size));
+                    OI_ASSERT_FAIL("OI_Malloc: block validation failed");
+                }
+
+                blockPtr->MemDebug.allocSize = size;  /* Record actual allocation size */
+                blockPtr->MemDebug.free = FALSE;      /* This block is no longer free */
+                blockPtr->MemDebug.fname = fname;     /* allocator's filename */
+                blockPtr->MemDebug.lineNum = lineNum; /* allocator's line number */
+                blockPtr->MemDebug.module = module;
+                OI_Time_Now(&blockPtr->MemDebug.allocTime);
+                MEMPROF_MALLOC(size, (void*) &(blockPtr->next), module, fname);
+
+                if ( !IS_DYNAMIC_ALLOC((void*) &(blockPtr->next))){
+                    OI_LOG_ERROR(("Alloc Error\n%/@%d OI_Malloc(%ld)\n",fname,lineNum,size));
+                }
+                last_alloc = ((void*) &(blockPtr->next));
+
+                /*
+                 * Allocated memory starts where the next pointer used to be
+                 */
+                retval = (void*) &(blockPtr->next);
+                {
+                    /*
+                     * Write the entire block (not just the allocated size).
+                     * Note that OI_Memset cannot do this because it checks the
+                     * allocated size of the block.
+                     */
+                    OI_UINT32 *p = (OI_UINT32 *)((OI_UINT8 *) retval + PoolConfiguration[pool].blockSize + DEBUG_EXTRA);
+                    while (p != (OI_UINT32 *)retval) {
+                        *(--p) = 0x77777777;
+                    }
+                }
+                return retval;
+            }
+        }
+    }
+
+    OI_MEMMGR_DumpUsedBlocks();
+    OI_MEMMGR_Dump();
+    OI_LOG_ERROR(("OI_Malloc(%ld) failed for %/@%d", size, fname, lineNum));
+    return 0;
+}
+
+
+void* _OI_Calloc_Dbg(OI_INT32 size,
+                     OI_UINT8 module,
+                     OI_CHAR  *fname,
+                     OI_UINT16 lineNum)
+{
+    void* block;
+    OI_INT32 i;
+
+    block = _OI_Malloc_Dbg(size, module, fname, lineNum);
+    if (block != NULL) {
+        for (i = 0; i < size; ++i) {
+            ((OI_BYTE*) block)[i] = 0;
+        }
+    }
+    return block;
+
+}
+
+#endif /* MEMMGR_DEBUG */
+
+
+static void Free(void *block)
+{
+    ALLOC_BLOCK *blockPtr;
+    OI_INT16 pool;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    OI_ASSERT(block != NULL);
+
+#ifdef MEMMGR_DEBUG
+    OI_ASSERT(IS_DYNAMIC_ALLOC(block));
+#endif /* MEMMGR_DEBUG */
+
+
+    blockPtr = GET_ALLOC_BLOCK(block);
+
+    if (block != &(blockPtr->next)) {
+        OI_ASSERT_FAIL("OI_Free: pointer was not returned by OI_Malloc");
+    }
+
+    for (pool = 0; pool < PoolCount; ++pool) {
+        if (IS_FROM_POOL(block, pool)) {
+            blockPtr->next = PoolTable[pool].freeList;
+            PoolTable[pool].freeList = blockPtr;
+            return;
+        }
+    }
+    OI_ASSERT_FAIL("OI_Free: memory not allocated by OI_Malloc");
+}
+
+
+/*
+ * OI_Free
+ *
+ * Returns a memory block to the pool heap. First determines which pool the block
+ * belongs by comparing the address of the block to be freed against the address
+ * ranges for the pools. The block is then linked into the free list for the
+ * block and becoming the first free block in the list.
+ */
+
+#ifndef MEMMGR_DEBUG
+
+void _OI_Free(void *block)
+{
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    if (debug_out) OI_Printf("\r-%x\n", block);
+    Free(block);
+}
+
+#else /* MEMMGR_DEBUG */
+
+void _OI_Free_Dbg(void *block,
+                  OI_UINT8 module,
+                  OI_CHAR *fname,
+                  OI_UINT16 lineNum)
+{
+    OI_UINT32 position; /* test for writing past end of block */
+
+    OI_DBGPRINT2(("%s@%d - free(%lx)", fname, lineNum, block));
+    OI_ASSERT(OI_StackTokenHeld);
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    last_free = block;
+    if (!IS_DYNAMIC_ALLOC(block)) {
+        OI_LOG_ERROR(("Block Not Dynamic\n%/@%d OI_Free(%lx)\n", fname, lineNum, (OI_UINT32)block));
+        OI_ASSERT(block != NULL);
+    }
+    position = MEMMGR_ValidateAllocBlock(block);
+    Free(block);
+    {
+        ALLOC_BLOCK *blockPtr = GET_ALLOC_BLOCK(block);
+        OI_UINT8 alloc_by = blockPtr->MemDebug.module;
+        OI_UINT8 freed_by = module;
+        OI_UINT32 blockSize = 0;
+        OI_UINT8 *start = ((OI_UINT8 *)(void*)&blockPtr->next) + sizeof(blockPtr->next); /* skip past next since it was already set by Free() */
+        OI_UINT8 *end;
+
+        /* Check for prior freeing before checking overshoot, because data changes */
+        if ( blockPtr->MemDebug.free ){
+            OI_LOG_ERROR(("ERROR! - Block Freed Twice\n%/@%d OI_Free(%lx)\n",fname, lineNum, (OI_UINT32)block));
+            OI_LOG_ERROR(("Prior Free: %/@%d \n",blockPtr->MemDebug.freeFile,blockPtr->MemDebug.freeLine));
+            OI_LOG_ERROR(("Prior Alloc: %/@%d OI_Malloc(%ld)\n",blockPtr->MemDebug.fname,blockPtr->MemDebug.lineNum,blockPtr->MemDebug.allocSize));
+            OI_ASSERT(!blockPtr->MemDebug.free);
+        }
+
+        /* overshooting must be checked prior to actual freeing and memory fill with 55 */
+        if ( position ){
+            OI_LOG_ERROR(("ERROR! - Block overshot prior to being freed at byte %ld\n", position));
+            OI_LOG_ERROR(("This Free: %/@%d OI_Free(%lx)\n",fname, lineNum, (OI_UINT32)block));
+            OI_LOG_ERROR(("Prior Alloc: %/@%d OI_Malloc(%ld)\n",blockPtr->MemDebug.fname,blockPtr->MemDebug.lineNum,blockPtr->MemDebug.allocSize));
+            OI_LOG_ERROR(("Prior Free: %/@%d \n",blockPtr->MemDebug.freeFile,blockPtr->MemDebug.freeLine));
+            OI_ASSERT(!position);
+        }
+
+        /*
+         * Fill freed block with odd value pattern to trap usage of freed
+         * blocks. Since block sizes must be 4-byte multiples, use UINT32 pointer arithmetic.
+         */
+        for (position = 0; position < PoolCount; ++position) {
+            if (IS_FROM_POOL(block, position)) {
+                blockSize = PoolConfiguration[position].blockSize;
+                break;
+            }
+        }
+
+        end = start + blockSize + DEBUG_EXTRA - sizeof (blockPtr->next); /* block size includes next */
+        while (start < end) {
+            *start++ = 0x55;
+        }
+
+        OI_ASSERT(CheckGuardString(blockPtr));
+
+        blockPtr->MemDebug.freeFile = fname;
+        blockPtr->MemDebug.freeLine = lineNum;
+        blockPtr->MemDebug.free = TRUE;
+
+        /* Always use the alloc_by module so we don't get out of sync. */
+        MEMPROF_FREE(blockPtr->MemDebug.allocSize, block, blockPtr->MemDebug.module, blockPtr->MemDebug.fname);
+
+        if ((alloc_by != OI_MODULE_MEMMGR) && (freed_by != OI_MODULE_MEMMGR)) {
+            if (alloc_by != freed_by) {
+                /*
+                 * The following is DBGPRINT rather than LOG_ERROR because
+                 * mismatch of allocating module and freeing module is at times
+                 * a normal occurrence
+                 */
+                OI_DBGPRINT(("Memory allocated by %/ (line %d) was freed by %/ (line %d)\n", blockPtr->MemDebug.fname, blockPtr->MemDebug.lineNum, fname, lineNum));
+            }
+        }
+    }
+}
+
+#endif /* MEMMGR_DEBUG */
+
+
+/*
+ * OI_FreeIf
+ *
+ * Calls free if the block is not null
+ */
+
+#ifndef MEMMGR_DEBUG
+void _OI_FreeIf(const void *block)
+{
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+
+    if (block != NULL) {
+        OI_Free((void *)block);
+    }
+}
+#else /* MEMMGR_DEBUG */
+void _OI_FreeIf_Dbg(const void *block,
+                    OI_UINT8 module,
+                    OI_CHAR *fname,
+                    OI_UINT16 lineNum)
+{
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+
+    if (block != NULL) {
+        _OI_Free_Dbg((void *)block, module, fname, lineNum);
+    }
+}
+#endif /* MEMMGR_DEBUG */
+
+
+/*
+ * OI_StaticMalloc
+ *
+ * Allocates memory from the static allocation pool. This is data that is
+ * required for the stack to function and will never explicitly freed.
+ */
+
+void* _OI_StaticMalloc(OI_INT32 size)
+{
+    OI_BYTE *pMalloc;
+    OI_BYTE *pNewCur;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    /*
+     * Malloc'd space is current heap pointer aligned on 32-bit boundary
+     */
+    pMalloc = (OI_BYTE*)((OI_UINT32)(heapCurrentPtr + 3) & (~3));
+    /*
+     * Calculate new value for current heap pointer
+     */
+    pNewCur = pMalloc + size;
+
+#ifndef MEMMGR_DEBUG
+    /* Poor Mans memory profiler */
+    if (debug_out) OI_Printf("\r=%d %x\n", size, pMalloc);
+#endif
+
+    /*
+     * if the new value is past the end pointer, we don't have enough memory for
+     * the current request (watch for possible memory wrap). This is a fatal
+     * error because OI_StaticMalloc must always succeed.
+     */
+    if ((pNewCur > heapEndPtr) || (pNewCur < pMalloc)) {
+        OI_DBGPRINT(("Static Req: %ld, Overflow: %ld\n", size, (OI_UINT32)(pNewCur - heapEndPtr)));
+        OI_FatalError(OI_STATUS_OUT_OF_MEMORY);
+    }
+    heapCurrentPtr = pNewCur;
+    /*
+     * Zero the memory as required by api
+     */
+    OI_MemZero(pMalloc, size);
+    return pMalloc;
+}
+#ifdef MEMMGR_DEBUG
+void* _OI_StaticMalloc_Dbg(OI_INT32 size,
+                           OI_UINT8 module,
+                           OI_CHAR *fname,
+                           OI_UINT16 lineNum)
+{
+    void *retVal;
+
+    OI_ASSERT(OI_StackTokenHeld);
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+
+    MEMPROF_STATIC_MALLOC(size, module, fname);
+    retVal = _OI_StaticMalloc(size);
+
+    OI_DBGPRINT(("%/@%d StaticMalloc(%ld)  - remaining: %ld", fname, lineNum, size, (OI_UINT32)(heapEndPtr - heapCurrentPtr)));
+
+    return retVal;
+}
+#endif /* MEMMGR_DEBUG */
+
+
+#ifndef OI_USE_NATIVE_MEMCPY
+
+/*
+ * OI_MemCopy
+ */
+
+void OI_MemCopy(void *To, void const *From, OI_UINT32 Size)
+{
+    /*
+     * Do not OI_ASSERT(initialized) this function can be called before the
+     * memory manager is initialized.
+     */
+    OI_ASSERT((To != NULL) || (Size == 0));
+    OI_ASSERT((From != NULL) || (Size == 0));
+
+    CHECK_EXTENT(To, Size);
+    CHECK_EXTENT(From, Size);
+
+    if (From < To) {
+        /* copy starting at tail */
+        while (Size > 0) {
+            --Size;
+            ((OI_BYTE*) To)[Size] = ((const OI_BYTE*) From)[Size];
+        };
+    } else {
+        OI_UINT32 i;
+        /* From > To ... copy starting at head */
+        for (i = 0; i < Size; ++i) {
+            ((OI_BYTE*) To)[i] = ((const OI_BYTE*) From)[i];
+        }
+    }
+}
+
+
+/*
+ * OI_MemSet
+ */
+
+void OI_MemSet(void *Block, OI_UINT8 Val, OI_UINT32 Size)
+{
+    OI_UINT32 i;
+
+    /*
+     * Do not OI_ASSERT(initialized) this function can be called before the
+     * memory manager is initialized.
+     */
+    OI_ASSERT((Block != NULL) || (Size == 0));
+    CHECK_EXTENT(Block, Size);
+
+    for (i = 0; i < Size; ++i) {
+        ((OI_BYTE*) Block)[i] = Val;
+    }
+}
+
+
+/*
+ * OI_MemZero
+ */
+
+void OI_MemZero(void *Block, OI_UINT32 Size)
+{
+    OI_UINT32 i;
+
+    /*
+     * Do not OI_ASSERT(initialized) this function can be called before the
+     * memory manager is initialized.
+     */
+    OI_ASSERT((Block != NULL) || (Size == 0));
+    CHECK_EXTENT(Block, Size);
+
+    for (i = 0; i < Size; ++i) {
+        ((OI_BYTE*) Block)[i] = 0;
+    }
+}
+
+
+/*
+ * OI_MemCmp
+ */
+
+OI_INT OI_MemCmp(void const *s1, void const *s2, OI_UINT32 n) {
+
+    OI_UINT32 i;
+
+    /*
+     * Do not OI_ASSERT(initialized) this function can be called before the
+     * memory manager is initialized.
+     */
+    OI_ASSERT((s1 != NULL) && (s2 != NULL));
+    CHECK_EXTENT(s1, n);
+    CHECK_EXTENT(s2, n);
+
+    for (i = 0; i < n; i++) {
+        if ( ((const OI_BYTE *)s1)[i] < ((const OI_BYTE *)s2)[i]) return -1;
+        if ( ((const OI_BYTE *)s1)[i] > ((const OI_BYTE *)s2)[i]) return 1;
+    }
+
+    return 0;
+}
+
+#endif /* OI_USE_NATIVE_MEMCPY */
+
+
+
+/* **************************************************************************
+ *
+ * Debug and checking functions that are only used if MEMMGR_DEBUG is defined
+ *
+ * **************************************************************************/
+#ifdef MEMMGR_DEBUG
+
+/*
+ * OI_MaxAllocBlock
+ *
+ * Searches through the pool list to find the smallest available block of
+ * memory. First checks that a pool's free list is not empty then checks the
+ * size of the blocks in that pool.
+ */
+
+OI_UINT32 OI_MaxAllocBlock(void)
+{
+    OI_UINT16 pool;
+    OI_UINT32 maxSize = 0;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    for (pool = 0; pool < PoolCount; ++pool) {
+        if (PoolTable[pool].freeList != NULL) {
+            if (PoolConfiguration[pool].blockSize > maxSize) {
+                maxSize = PoolConfiguration[pool].blockSize;
+            }
+        }
+    }
+
+    return maxSize;
+}
+
+
+/*
+ * OI_MinAllocBlock
+ *
+ * Searches through the pool list to find the smallest available block of memory.
+ * First checks that a pool's free list is not empty then checks the size of the
+ * blocks in that pool.
+ */
+
+OI_UINT32 OI_MinAllocBlock(void)
+{
+    OI_UINT16 pool;
+    OI_UINT32 minSize = OI_INT32_MAX;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    for (pool = 0; pool < PoolCount; ++pool) {
+        if (PoolTable[pool].freeList != NULL) {
+            if (PoolConfiguration[pool].blockSize < minSize) {
+                minSize = PoolConfiguration[pool].blockSize;
+            }
+        }
+    }
+    return minSize;
+}
+
+
+static OI_BOOL CheckGuardString(ALLOC_BLOCK const *blockPtr)
+{
+    OI_UINT32 i;
+
+    for (i = 0; i < sizeof(GUARD_STRING); ++i) {
+        if (GUARD_STRING[i] != blockPtr->MemDebug.guard[i]) {
+            OI_LOG_ERROR(("CheckGuardString failed"));
+            if (blockPtr->MemDebug.priorPool) {
+                blockPtr = blockPtr->MemDebug.priorPool;
+                OI_LOG_ERROR(("Prior Block now free: %d\n",blockPtr->MemDebug.free));
+                OI_LOG_ERROR(("Prior Last Alloc: %/@%d OI_Malloc(%ld)\n",blockPtr->MemDebug.fname,blockPtr->MemDebug.lineNum,blockPtr->MemDebug.allocSize));
+                OI_LOG_ERROR(("Prior Last Free: %/@%d OI_Free(%lx)\n",blockPtr->MemDebug.freeFile,blockPtr->MemDebug.freeLine,(OI_UINT32)&(blockPtr->next)));
+            }
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+/*
+ * OI_MEMMGR_Check
+ *
+ * Checks that if the block was dynamically allocated that the guard string is
+ * intact. Always returns TRUE for statically allocated memory.
+ */
+
+OI_BOOL OI_MEMMGR_Check(void const *Block)
+{
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    if (IS_DYNAMIC_ALLOC(Block)) {
+        return CheckGuardString(GET_ALLOC_BLOCK(Block));
+    }
+    return TRUE; /* not dynamically allocated memory */
+}
+
+
+/* Validate this alloc'd block hasn't overshot its valid range */
+static OI_UINT32 MEMMGR_ValidateAllocBlock(void const *block)
+{
+    OI_UINT8 const *check;
+    OI_UINT32 index;
+    OI_UINT32 blockSize = 0;
+    ALLOC_BLOCK *blockPtr = GET_ALLOC_BLOCK(block);
+
+    for (index = 0; index < PoolCount; ++index) {
+        if (IS_FROM_POOL(block, index)) {
+            blockSize = PoolConfiguration[index].blockSize;
+            break;
+        }
+    }
+
+    check = block;
+    for( index = blockPtr->MemDebug.allocSize; index < (blockSize + DEBUG_EXTRA); index++ ){
+        if ( check[index] != 0x77 ){
+            return index;
+        }
+    }
+
+    /* Looks good */
+    return 0;
+}
+
+/* Validate that this free block hasn't been written to */
+static OI_UINT32 MEMMGR_ValidateFreeBlock(ALLOC_BLOCK *blockPtr, OI_UINT32 poolsize)
+{
+    OI_UINT8 *check;
+    OI_UINT32 invalid;
+
+    if( !blockPtr->MemDebug.free ||                                         /* block must be marked free */
+        (!IS_DYNAMIC_ALLOC(blockPtr->next) && (blockPtr->next != NULL))){   /* next block must be dynamic */
+        return 1;
+    }
+
+    /* Verify next block is properly alligned */
+    if( ((OI_UINT32)(blockPtr->next)) & 0x03 ){
+        return 3;
+    }
+
+    /* Verify that all bytes in block still have Free pattern */
+    check = (OI_UINT8 *) &blockPtr[1];
+    for (invalid = 0; invalid < (poolsize + DEBUG_EXTRA - sizeof(blockPtr->next)); invalid++){
+        if ( check[invalid] != 0x55 ){
+            return invalid + sizeof(blockPtr->next);
+        }
+    }
+
+    /* Looks good */
+    return 0;
+}
+
+/*
+ * OI_MEMMGR_CheckSize
+ *
+ * For dynamically allocated memory, checks that there are at least "Size" bytes
+ * between addr and the end of the appropriate allocation block.
+ *
+ * Always returns TRUE for statically allocated or stack memory.
+ */
+
+OI_BOOL OI_MEMMGR_CheckSize(void const *addr,
+                            OI_UINT32 Size)
+{
+    ALLOC_BLOCK *blockPtr = NULL;
+    OI_UINT32 poolSize;
+    OI_UINT32 poolNum;
+    OI_UINT16 pool;
+
+    /*
+     * There are a couple of situations during stack initialization that this
+     * function is called before the memory manager has been initializted.
+     */
+    if (!OI_INIT_FLAG_VALUE(MEMMGR)) {
+        return TRUE;
+    }
+
+    if (!IS_DYNAMIC_ALLOC(addr)) {
+        return TRUE;
+    }
+    /*
+     * Figure out which block this address is in
+     */
+    for (pool = 0; pool < PoolCount; ++pool) {
+        if (IS_FROM_POOL(addr, pool)) {
+            poolSize = PoolTable[pool].poolSize;
+            poolNum = ((OI_UINT32) addr - (OI_UINT32) PoolTable[pool].LAddr) / poolSize;
+            blockPtr = (ALLOC_BLOCK*) (PoolTable[pool].LAddr + poolSize * poolNum);
+            break;
+        }
+    }
+    OI_ASSERT(blockPtr != NULL);
+    OI_ASSERT(CheckGuardString(blockPtr));
+
+    /* Print out debugging info prior to assert fail if this block has been freed */
+    if (blockPtr->MemDebug.free){
+        OI_LOG_ERROR(("ERROR! - Block Checked after it was freed:\n"));
+        OI_LOG_ERROR(("Prior Alloc: %/@%d OI_Malloc(%ld)\n",blockPtr->MemDebug.fname,blockPtr->MemDebug.lineNum,blockPtr->MemDebug.allocSize));
+        OI_LOG_ERROR(("Prior Free: %/@%d OI_Free(%lx)\n",blockPtr->MemDebug.freeFile,blockPtr->MemDebug.freeLine,(OI_UINT32)&(blockPtr->next)));
+        OI_ASSERT_FAIL("OI_MEMMGR_CheckSize: block free");
+    }
+
+    /*
+     * Reduce available space by the offset of addr relative to blockPtr
+     */
+    if (Size <= (blockPtr->MemDebug.allocSize - ((const OI_BYTE*) addr - (const OI_BYTE*) &(blockPtr->next)))) {
+        return TRUE;
+    }
+    OI_DBGPRINT(("CheckSize failed - requested size %ld, actual size %ld, file %s line %d\n",
+                 Size, blockPtr->MemDebug.allocSize, blockPtr->MemDebug.fname, blockPtr->MemDebug.lineNum));
+    return FALSE;
+}
+
+
+/*
+ * OI_MEMMGR_DumpPools
+ *
+ * Prints out the current pool allocation for the pool heap
+ */
+void OI_MEMMGR_DumpPools(void)
+{
+    OI_INT16 pool;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    OI_DBGPRINT(("Heap pool dump"));
+
+    for (pool = 0; pool < PoolCount; ++pool) {
+        ALLOC_BLOCK *blockPtr = PoolTable[pool].freeList;
+        OI_INT16 count = 0;
+        OI_UINT32 maxSize = 0;
+        while (blockPtr != NULL) {
+            ++count;
+            if (blockPtr->MemDebug.allocSize > maxSize) {
+                maxSize = blockPtr->MemDebug.allocSize;
+            }
+            blockPtr = blockPtr->next;
+        }
+        OI_DBGPRINT(("  [%lx .. %lx] alloc size %ld, max size %ld, free %d\n",
+                     (OI_UINT32) PoolTable[pool].LAddr,
+                     (OI_UINT32) PoolTable[pool].HAddr,
+                     PoolConfiguration[pool].blockSize, maxSize, count));
+
+    }
+}
+
+/*
+ * OI_MEMMGR_DumpUsedBlocks
+ *
+ * Prints out all blocks that are currently in use
+ */
+
+void OI_MEMMGR_DumpUsedBlocks(void)
+{
+    OI_INT16 poolNum;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    OI_Printf("MemHeap dump of all used blocks\n");
+    OI_Printf("-----------------------------------------------\n");
+
+    /*
+     * for each pool, examine each block in the pool. If it is not free, print
+     * out all the information about the block.
+     */
+    for (poolNum = 0; poolNum < PoolCount; ++poolNum) {
+        MEM_POOL        *pPool = &PoolTable[poolNum];  /* ptr to pool */
+        ALLOC_BLOCK     *pBlock;                       /* ptr to block */
+        OI_UINT16       freeCount = 0;
+        OI_UINT16       usedCount = 0;
+
+        pBlock = (ALLOC_BLOCK*)(pPool->LAddr);         /* point at first block in this pool */
+        while (pBlock < (ALLOC_BLOCK*)pPool->HAddr) {  /* while still within this pool */
+            if (pBlock->MemDebug.free) {
+                ++freeCount;
+            } else {
+                ++usedCount;
+                OI_Printf("   Malloc(%d) at %T from %s@%d\n",
+                          pBlock->MemDebug.allocSize,
+                          &pBlock->MemDebug.allocTime,
+                          pBlock->MemDebug.fname,
+                          pBlock->MemDebug.lineNum);
+            }
+            pBlock = (ALLOC_BLOCK*)(((OI_UINT32)pBlock) + pPool->poolSize);
+        }
+        OI_Printf("[pool %4ld]  used:%4d free:%4d\n",
+                   PoolConfiguration[poolNum].blockSize, usedCount, freeCount);
+        OI_Printf("-----------------------------------------------\n");
+    }
+}
+
+
+OI_UINT32 OI_MEMMGR_CurrentDynamicAllocation(void)
+{
+    OI_INT16    curPool;
+    OI_UINT32   freeBlocksThisPool;
+    OI_UINT32   allocThisPool;
+    ALLOC_BLOCK *pFree;
+    OI_UINT32   totalAlloc = 0;
+
+    OI_ASSERT(OI_INIT_FLAG_VALUE(MEMMGR));
+    for (curPool = 0; curPool < PoolCount; ++curPool) {
+        // count number of blocks in the free list
+        freeBlocksThisPool = 0;
+        pFree = PoolTable[curPool].freeList;
+        while (NULL != pFree) {
+            ++freeBlocksThisPool;
+            pFree = pFree->next;
+        }
+        // allocated memory from this pool = (total_blocks - free_blocks) * blocksize
+        allocThisPool = (PoolConfiguration[curPool].numBlocks - freeBlocksThisPool) * PoolConfiguration[curPool].blockSize;
+        totalAlloc += allocThisPool;
+    }
+    return(totalAlloc);
+}
+
+#endif /* MEMMGR_DEBUG */
+
+
+
+
+#endif /* OI_USE_NATIVE_MALLOC */
+
+/*****************************************************************************/
diff --git a/obex_profiles/stack/support/oi_memprof.h b/obex_profiles/stack/support/oi_memprof.h
new file mode 100644
index 0000000..2f07e84
--- /dev/null
+++ b/obex_profiles/stack/support/oi_memprof.h
@@ -0,0 +1,92 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * @internal
+ *
+ * functions to record the use of memory by the Memory Manager
+ *
+ */
+
+#ifndef _MEMPROF_H
+#define _MEMPROF_H
+
+#include "oi_stddefs.h"
+
+/** \addtogroup MemMgr_Internal */
+/**@{*/
+
+/*
+ * Cannot do memory profiling if using native malloc.
+ */
+#ifdef OI_USE_NATIVE_MALLOC
+#undef MEMMGR_PROFILE
+#endif
+
+
+#ifdef MEMMGR_PROFILE
+
+#define MEMPROF_INIT(x)                 OI_MemProf_Init(x)
+#define MEMPROF_STATIC_MALLOC(s, m, f)  OI_MemProf_StaticMalloc(s, m, f)
+#define MEMPROF_MALLOC(s, a, m, f)      OI_MemProf_Malloc(s, a, m, f)
+#define MEMPROF_FREE(s, a, m, f)        OI_MemProf_Free(s, a, m, f)
+
+OI_STATUS OI_MemProf_Init(OI_INT debug_overhead);
+
+
+void OI_MemProf_StaticMalloc(OI_INT32 size,
+                             OI_UINT8 module,
+                             OI_CHAR *fileName);
+
+
+void OI_MemProf_Malloc(OI_INT32 size,
+                       void* addr,
+                       OI_UINT8 module,
+                       OI_CHAR *fileName);
+
+
+void OI_MemProf_Free(OI_INT32 size,
+                     void* addr,
+                     OI_UINT8 module,
+                     OI_CHAR *filename);
+
+#else
+
+#define MEMPROF_INIT(x)
+#define MEMPROF_STATIC_MALLOC(s, m, f)
+#define MEMPROF_MALLOC(s, a, m, f)
+#define MEMPROF_FREE(s, a, m, f)
+
+#endif /* MEMMG_PROFILE */
+
+
+#endif /* _MEMPROF_H */
+
+/**@}*/
diff --git a/obex_profiles/stack/support/oi_obextext.c b/obex_profiles/stack/support/oi_obextext.c
new file mode 100644
index 0000000..2ed199d
--- /dev/null
+++ b/obex_profiles/stack/support/oi_obextext.c
@@ -0,0 +1,241 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+@file
+@internal
+
+functions for converting OBEX headers to text
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_stddefs.h"
+#include "oi_obextext.h"
+#include "oi_obexspec.h"
+#include "oi_status.h"
+#include "oi_assert.h"
+#include "oi_varstring.h"
+
+
+const OI_CHAR* OI_OBEX_PktText(OI_UINT8 code)
+{
+
+    switch (OI_OBEX_FINAL(code)) {
+        case OI_OBEX_FINAL(OI_OBEX_CMD_CONNECT):                       return "CONNECT";
+        case OI_OBEX_FINAL(OI_OBEX_CMD_DISCONNECT):                    return "DISCONNECT";
+        case OI_OBEX_FINAL(OI_OBEX_CMD_PUT):                           return "PUT";
+        case OI_OBEX_FINAL(OI_OBEX_CMD_GET):                           return "GET";
+        case OI_OBEX_FINAL(OI_OBEX_CMD_SET_PATH):                      return "SET_PATH";
+        case OI_OBEX_FINAL(OI_OBEX_CMD_ACTION):                        return "ACTION";
+        case OI_OBEX_FINAL(OI_OBEX_CMD_SESSION):                       return "SESSION";
+        case OI_OBEX_FINAL(OI_OBEX_CMD_ABORT):                         return "ABORT";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_CONTINUE):                      return "CONTINUE";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_OK):                            return "OK";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_CREATED):                       return "CREATED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_ACCEPTED):                      return "ACCEPTED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NON_AUTHORITATIVE_INFORMATION): return "NON_AUTHORITATIVE_INFORMATION";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NO_CONTENT):                    return "NO_CONTENT";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_RESET_CONTENT):                 return "RESET_CONTENT";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_PARTIAL_CONTENT):               return "PARTIAL_CONTENT";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_MULTIPLE_CHOICES):              return "MULTIPLE_CHOICES";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_MOVED_PERMANENTLY):             return "MOVED_PERMANENTLY";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_MOVED_TEMPORARILY):             return "MOVED_TEMPORARILY";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_SEE_OTHER):                     return "SEE_OTHER";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NOT_MODIFIED):                  return "NOT_MODIFIED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_USE_PROXY):                     return "USE_PROXY";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_BAD_REQUEST):                   return "BAD_REQUEST";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_UNAUTHORIZED):                  return "UNAUTHORIZED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_PAYMENT_REQUIRED):              return "PAYMENT_REQUIRED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_FORBIDDEN):                     return "FORBIDDEN";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NOT_FOUND):                     return "NOT_FOUND";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_METHOD_NOT_ALLOWED):            return "METHOD_NOT_ALLOWED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NOT_ACCEPTABLE):                return "NOT_ACCEPTABLE";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_PROXY_AUTHENTICATION_REQUIRED): return "PROXY_AUTHENTICATION_REQUIRED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_REQUEST_TIME_OUT):              return "REQUEST_TIME_OUT";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_CONFLICT):                      return "CONFLICT";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_GONE):                          return "GONE";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_LENGTH_REQUIRED):               return "LENGTH_REQUIRED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_PRECONDITION_FAILED):           return "PRECONDITION_FAILED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_REQUESTED_ENTITY_TOO_LARGE):    return "REQUESTED_ENTITY_TOO_LARGE";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_REQUEST_URL_TOO_LARGE):         return "REQUEST_URL_TOO_LARGE";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_UNSUPPORTED_MEDIA_TYPE):        return "UNSUPPORTED_MEDIA_TYPE";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_INTERNAL_SERVER_ERROR):         return "INTERNAL_SERVER_ERROR";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_NOT_IMPLEMENTED):               return "NOT_IMPLEMENTED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_BAD_GATEWAY):                   return "BAD_GATEWAY";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_SERVICE_UNAVAILABLE):           return "SERVICE_UNAVAILABLE";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_GATEWAY_TIMEOUT):               return "GATEWAY_TIMEOUT";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_HTTP_VERSION_NOT_SUPPORTED):    return "HTTP_VERSION_NOT_SUPPORTED";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_DATABASE_FULL):                 return "DATABASE_FULL";
+        case OI_OBEX_FINAL(OI_OBEX_RSP_DATABASE_LOCKED):               return "DATABASE_LOCKED";
+        default:                                            return "**** bad packet ****";
+    }
+
+}
+
+
+static const OI_CHAR* HdrId(OI_UINT8 code)
+{
+    switch (code) {
+       case OI_OBEX_HDR_COUNT:                      return "COUNT";
+        case OI_OBEX_HDR_NAME:                       return "NAME";
+        case OI_OBEX_HDR_TYPE:                       return "TYPE";
+        case OI_OBEX_HDR_LENGTH:                     return "LENGTH";
+        case OI_OBEX_HDR_TIME:                       return "TIME";
+        case OI_OBEX_HDR_DESCRIPTION:                return "DESCRIPTION";
+        case OI_OBEX_HDR_TARGET:                     return "TARGET";
+        case OI_OBEX_HDR_HTTP:                       return "HTTP";
+        case OI_OBEX_HDR_BODY:                       return "BODY";
+        case OI_OBEX_HDR_END_OF_BODY:                return "END_OF_BODY";
+        case OI_OBEX_HDR_WHO:                        return "WHO";
+        case OI_OBEX_HDR_CONNECTION_ID:              return "CONNECTION_ID";
+        case OI_OBEX_HDR_APPLICATION_PARAMS:         return "APPLICATION_PARAMS";
+        case OI_OBEX_HDR_AUTHENTICATION_CHALLENGE:   return "AUTHENTICATION_CHALLENGE";
+        case OI_OBEX_HDR_AUTHENTICATION_RESPONSE:    return "AUTHENTICATION_RESPONSE";
+        case OI_OBEX_HDR_OBJECT_CLASS:               return "OBJECT_CLASS";
+        case OI_OBEX_HDR_SESSION_PARAMS:             return "SESSION_PARAMS";
+        case OI_OBEX_HDR_ACTION_ID:                  return "ACTION_ID";
+        case OI_OBEX_HDR_DEST_NAME:                  return "DEST_NAME";
+        case OI_OBEX_HDR_SINGLE_RESPONSE_MODE:       return "SINGLE_RESPONSE_MODE";
+        case OI_OBEX_HDR_SINGLE_RESPONSE_PARAMETERS: return "SINGLE_RESPONSE_MODE_PARAMETERS";
+        case OI_OBEX_HDR_PERMISSIONS:                return "PERMISSIONS";
+        default:                                     return "**** unknown header ****";
+
+    }
+}
+
+
+static void FormatSessionParams(OI_VARSTRING *VStr,
+                                OI_UINT8 *data,
+                                OI_UINT16 datalen)
+{
+    while (datalen >= 2) {
+        OI_UINT8 tag = data[0];
+        OI_UINT8 len = data[1];
+
+        datalen -= 2;
+        if (datalen < len) {
+            break;
+        }
+        data += 2;
+        switch (tag) {
+            case OI_OBEX_SESSION_PARAM_OPCODE:
+                OI_FormatStr(VStr, "OPCODE %d ", data[0]);
+                break;
+            case OI_OBEX_SESSION_PARAM_DEVICE_ADDR:
+                OI_FormatStr(VStr, "DEVICE ADDR %@ ", data, len);
+                break;
+            case OI_OBEX_SESSION_PARAM_NONCE:
+                OI_FormatStr(VStr, "NONCE %@ ", data, len);
+                break;
+            case OI_OBEX_SESSION_PARAM_ID:
+                OI_FormatStr(VStr, "ID %@ ", data, len);
+                break;
+            case OI_OBEX_SESSION_PARAM_NEXT_SEQ_NUM:
+                OI_FormatStr(VStr, "NEXT SEQ NUM %d ", data[0]);
+                break;
+            case OI_OBEX_SESSION_PARAM_TIMEOUT:
+                OI_FormatStr(VStr, "TIMEOUT %u", data[0] | (data[1] << 8) | (data[2] << 16) || (data[3] << 24));
+                break;
+            default:
+                break;
+        }
+        datalen -= len;
+        data += len;
+    }
+}
+
+static void FormatApplicationParams(OI_VARSTRING *VStr,
+                                OI_UINT8 *data,
+                                OI_UINT16 datalen)
+{
+    while (datalen >= 2) {
+        OI_UINT8    tag     = data[0];
+        OI_UINT8    tagLen  = data[1];
+
+        data += 2;
+        datalen -= 2;
+        if (datalen < tagLen) {
+            break;
+        }
+
+        OI_FormatStr(VStr, " tag %d, len %d;", tag, tagLen);
+        data += tagLen;
+        datalen -= tagLen;
+    }
+}
+
+void OI_OBEX_HeaderTxt(OI_VARSTRING *VStr,
+                       OI_OBEX_HEADER *hdr)
+{
+    const OI_CHAR *id = HdrId(hdr->id);
+
+    switch (OI_OBEX_HDR_KIND(hdr->id)) {
+        case OI_OBEX_HDR_ID_UNICODE:
+            if (hdr->val.unicode.len == 0) {
+                OI_FormatStr(VStr, "%s=<empty>", id);
+            } else {
+                OI_FormatStr(VStr, "%s=\"%S\"", id, hdr->val.unicode.str);
+            }
+            break;
+        case OI_OBEX_HDR_ID_BYTESEQ:
+            switch (hdr->id) {
+                case OI_OBEX_HDR_TYPE:
+                    OI_FormatStr(VStr, "%s=%?s", id, hdr->val.byteseq.data, hdr->val.byteseq.len);
+                    break;
+                case OI_OBEX_HDR_TARGET:
+                    OI_FormatStr(VStr, "%s %@", id, hdr->val.byteseq.data, hdr->val.byteseq.len);
+                    break;
+                case OI_OBEX_HDR_SESSION_PARAMS:
+                    OI_FormatStr(VStr, "%s ", id);
+                    FormatSessionParams(VStr, hdr->val.byteseq.data, hdr->val.byteseq.len);
+                    break;
+                case OI_OBEX_HDR_APPLICATION_PARAMS:
+                    OI_FormatStr(VStr, "%s  size=%d;", id, hdr->val.byteseq.len);
+                    FormatApplicationParams(VStr, hdr->val.byteseq.data, hdr->val.byteseq.len);
+                    break;
+                default:
+                    OI_FormatStr(VStr, "%s size=%d", id, hdr->val.byteseq.len);
+                    break;
+            }
+            break;
+        case OI_OBEX_HDR_ID_UINT8:
+            OI_FormatStr(VStr, "%s=%d", id, hdr->val.uInt8);
+            break;
+        case OI_OBEX_HDR_ID_UINT32:
+            if (hdr->id == OI_OBEX_HDR_PERMISSIONS) {
+                OI_FormatStr(VStr, "%s=%8x (%32b)", id, hdr->val.uInt32, hdr->val.uInt32);
+            } else {
+                OI_FormatStr(VStr, "%s=%ld", id, hdr->val.uInt32);
+            }
+            break;
+        default:
+            OI_FormatStr(VStr, "BAD HEADER!");
+    }
+}
diff --git a/obex_profiles/stack/support/oi_simplemap.c b/obex_profiles/stack/support/oi_simplemap.c
new file mode 100644
index 0000000..38b07f2
--- /dev/null
+++ b/obex_profiles/stack/support/oi_simplemap.c
@@ -0,0 +1,146 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *  Generic utility for mapping from an arbitrary key to a value.
+ */
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_stddefs.h"
+#include "oi_memmgr.h"
+#include "oi_simplemap.h"
+
+
+typedef struct _Entry {
+    const void *key;
+    const OI_CHAR *keyNamespace;
+    void *value;
+    struct _Entry *next;
+} Entry;
+
+
+static Entry *map;
+
+
+void OI_SimpleMap_Init(void)
+{
+    map = NULL;
+}
+
+
+static Entry* Get(const void *key, const OI_CHAR *keyNamespace)
+{
+    Entry *e = map;
+    while (e) {
+        if ((e->key == key) && (e->keyNamespace == keyNamespace)) {
+            return e;
+        }
+        e = e->next;
+    }
+    return NULL;
+}
+
+
+void OI_SimpleMap_Add(const void *key, const OI_CHAR *keyNamespace, void *value)
+{
+    Entry *e = Get(key, keyNamespace);
+    if (!e) {
+        e = OI_Malloc(sizeof(Entry));
+        if (!e) {
+            return;
+        }
+        e->key = key;
+        e->keyNamespace = keyNamespace;
+        e->next = map;
+        map = e;
+    }
+    e->value = value;
+}
+
+
+void* OI_SimpleMap_Remove(const void *key, const OI_CHAR *keyNamespace)
+{
+    void *value;
+    Entry *prev = NULL;
+    Entry *e = map;
+    while (e) {
+        if ((e->key == key) && (e->keyNamespace == keyNamespace)) {
+            if (prev) {
+                prev->next = e->next;
+            } else {
+                map = e->next;
+            }
+            value = e->value;
+            OI_Free(e);
+            return value;
+        }
+        prev = e;
+        e = e->next;
+    }
+    return NULL;
+}
+
+
+void* OI_SimpleMap_Get(const void *key, const OI_CHAR *keyNamespace)
+{
+    Entry *e = Get(key, keyNamespace);
+    return e ? e->value : NULL;
+}
+
+
+const void* OI_SimpleMap_Enum(void **iter, const OI_CHAR *keyNamespace)
+{
+    Entry *e;
+    if (!iter) {
+        return NULL;
+    }
+    if (*iter == iter) {
+        *iter = NULL;
+        return NULL;
+    }
+    /* Check for restart */
+    if (*iter == NULL) {
+        *iter = map;
+    }
+    e = (Entry*)(*iter);
+    while (e) {
+        if (e->keyNamespace == keyNamespace) {
+            if (e->next) {
+                *iter = e->next;
+            } else {
+                /* End marker */
+                *iter = iter;
+            }
+            return e->key;
+        }
+        e = e->next;
+    }
+    *iter = NULL;
+    return NULL;
+}
diff --git a/obex_profiles/stack/support/oi_statustext.c b/obex_profiles/stack/support/oi_statustext.c
new file mode 100644
index 0000000..7c73b79
--- /dev/null
+++ b/obex_profiles/stack/support/oi_statustext.c
@@ -0,0 +1,652 @@
+/**
+* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+This file provide text strings for OI_STATUS values.
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_debug.h"
+#include "oi_status.h"
+#include "oi_statustext.h"
+
+
+/*
+ * define a macro to help us turn OI_STATUS values into text
+ */
+
+#define    OI_CASE(a) case a: return(#a) ;
+
+/*
+ * Compose a string for status
+ */
+
+static OI_CHAR fmtBuf[22];  /* must be big enough for 10 digits + text */
+static OI_CHAR* OI_StatusNum(OI_STATUS value)
+{
+    static const OI_CHAR dig[] = "0123456789";
+    OI_CHAR* c = fmtBuf + OI_ARRAYSIZE(fmtBuf);
+    OI_UINT32 uval = (OI_UINT32) value;
+
+    if (value == OI_OK) {
+        return "OI_OK";
+    } else if (value == OI_STATUS_NONE) {
+        return "OI_STATUS_NONE";
+    }
+
+    *(--c) = 0;
+    while (uval != 0) {
+        OI_UINT v = uval / 10;
+        OI_UINT r = uval%10;
+        *(--c) = dig[r];
+        uval = v;
+    }
+    /* Prefix " STATUS " */
+    *(--c) = ' ';
+    *(--c) = 'S';
+    *(--c) = 'U';
+    *(--c) = 'T';
+    *(--c) = 'A';
+    *(--c) = 'T';
+    *(--c) = 'S';
+    *(--c) = ' ';
+    if (value <= OI_MAX_BM3_STATUS_VAL) {
+        /* Prefix "BM3" */
+        *(--c) = '3';
+        *(--c) = 'M';
+        *(--c) = 'B';
+    } else if (value >= OI_STATUS_RESERVED_FOR_APPS) {
+            /* Prefix "APP" */
+            *(--c) = 'P';
+            *(--c) = 'P';
+            *(--c) = 'A';
+    } else {
+        /* Prefix nothing.  We could test for each of the internal product
+            status codes (soundabout, etc), but want to avoid code bloat */
+    }
+    return c;
+}
+
+/*
+ * text strings only provided for debug build
+ */
+
+#if !(defined(OI_DEBUG) || defined(OI_ENABLE_SLOG_ERROR) || defined(OI_ENABLE_SLOG_WARNING))
+
+OI_CHAR* OI_StatusText(OI_STATUS value)
+{
+    return OI_StatusNum(value);
+}
+
+#else
+
+static OI_CHAR* OI_BM3StatusText(OI_STATUS value)
+{
+    switch (value) {
+
+        OI_CASE(OI_OK);
+
+        OI_CASE(OI_STATUS_INVALID_PARAMETERS);
+        OI_CASE(OI_STATUS_NOT_IMPLEMENTED);
+        OI_CASE(OI_STATUS_NOT_INITIALIZED);
+        OI_CASE(OI_STATUS_NO_RESOURCES);
+        OI_CASE(OI_STATUS_INTERNAL_ERROR);
+        OI_CASE(OI_STATUS_OUT_OF_MEMORY);
+        OI_CASE(OI_ILLEGAL_REENTRANT_CALL);
+        OI_CASE(OI_STATUS_INITIALIZATION_FAILED);
+        OI_CASE(OI_STATUS_INITIALIZATION_PENDING);
+        OI_CASE(OI_STATUS_NO_SCO_SUPPORT);
+        OI_CASE(OI_STATUS_OUT_OF_STATIC_MEMORY);
+        OI_CASE(OI_TIMEOUT);
+        OI_CASE(OI_OS_ERROR);
+        OI_CASE(OI_FAIL);
+        OI_CASE(OI_STRING_FORMAT_ERROR);
+        OI_CASE(OI_STATUS_PENDING);
+        OI_CASE(OI_STATUS_INVALID_COMMAND);
+        OI_CASE(OI_BUSY_FAIL);
+        OI_CASE(OI_STATUS_ALREADY_REGISTERED);
+        OI_CASE(OI_STATUS_NOT_FOUND);
+        OI_CASE(OI_STATUS_NOT_REGISTERED);
+        OI_CASE(OI_STATUS_NOT_CONNECTED);
+        OI_CASE(OI_CALLBACK_FUNCTION_REQUIRED);
+        OI_CASE(OI_STATUS_MBUF_OVERFLOW);
+        OI_CASE(OI_STATUS_MBUF_UNDERFLOW);
+        OI_CASE(OI_STATUS_CONNECTION_EXISTS);
+        OI_CASE(OI_STATUS_NOT_CONFIGURED);
+        OI_CASE(OI_LOWER_STACK_ERROR);
+        OI_CASE(OI_STATUS_RESET_IN_PROGRESS);
+        OI_CASE(OI_STATUS_ACCESS_DENIED);
+        OI_CASE(OI_STATUS_DATA_ERROR);
+        OI_CASE(OI_STATUS_INVALID_ROLE);
+        OI_CASE(OI_STATUS_ALREADY_CONNECTED);
+        OI_CASE(OI_STATUS_PARSE_ERROR);
+        OI_CASE(OI_STATUS_END_OF_FILE);
+        OI_CASE(OI_STATUS_READ_ERROR);
+        OI_CASE(OI_STATUS_WRITE_ERROR);
+        OI_CASE(OI_STATUS_NEGOTIATION_FAILURE);
+        OI_CASE(OI_STATUS_READ_IN_PROGRESS);
+        OI_CASE(OI_STATUS_ALREADY_INITIALIZED);
+        OI_CASE(OI_STATUS_STILL_CONNECTED);
+        OI_CASE(OI_STATUS_MTU_EXCEEDED);
+        OI_CASE(OI_STATUS_LINK_TERMINATED);
+        OI_CASE(OI_STATUS_PIN_CODE_TOO_LONG);
+        OI_CASE(OI_STATUS_STILL_REGISTERED);
+        OI_CASE(OI_STATUS_SPEC_VIOLATION);
+
+        OI_CASE(OI_STATUS_PSM_ALREADY_REGISTERED);
+        OI_CASE(OI_STATUS_INVALID_CID);
+        OI_CASE(OI_STATUS_CID_NOT_FOUND);
+        OI_CASE(OI_STATUS_CHANNEL_NOT_FOUND);
+        OI_CASE(OI_STATUS_PSM_NOT_FOUND);
+        OI_CASE(OI_STATUS_INVALID_STATE);
+        OI_CASE(OI_STATUS_WRITE_IN_PROGRESS);
+        OI_CASE(OI_STATUS_INVALID_PACKET);
+        OI_CASE(OI_STATUS_SEND_COMPLETE);
+        OI_CASE(OI_STATUS_INVALID_HANDLE);
+        OI_CASE(OI_STATUS_GROUP_FULL);
+        OI_CASE(OI_STATUS_DEVICE_ALREADY_IN_GROUP);
+        OI_CASE(OI_STATUS_DUPLICATE_GROUP);
+        OI_CASE(OI_STATUS_EMPTY_GROUP);
+        OI_CASE(OI_STATUS_PACKET_NOT_FOUND);
+        OI_CASE(OI_STATUS_BUFFER_TOO_SMALL);
+        OI_CASE(OI_STATUS_IDENTIFIER_NOT_FOUND);
+
+        OI_CASE(OI_L2CAP_DISCONNECT_LOWER_LAYER);
+        OI_CASE(OI_L2CAP_DISCONNECT_REMOTE_REQUEST);
+        OI_CASE(OI_L2CAP_GROUP_ADD_CONNECT_FAIL);
+        OI_CASE(OI_L2CAP_GROUP_REMOVE_FAILURE);
+        OI_CASE(OI_L2CAP_DATA_WRITE_ERROR_LINK_TERM);
+        OI_CASE(OI_L2CAP_DISCONNECT_LOCAL_REQUEST);
+        /* Timeouts */
+        OI_CASE(OI_L2CAP_CONNECT_TIMEOUT);
+        OI_CASE(OI_L2CAP_DISCONNECT_TIMEOUT);
+        OI_CASE(OI_L2CAP_PING_TIMEOUT);
+        OI_CASE(OI_L2CAP_GET_INFO_TIMEOUT);
+        OI_CASE(OI_L2CAP_INVALID_ADDRESS);
+        OI_CASE(OI_L2CAP_CMD_REJECT_RCVD);
+        /* Spec Connect errors */
+        OI_CASE(OI_L2CAP_CONNECT_BASE);
+        OI_CASE(OI_L2CAP_CONNECT_PENDING);
+        OI_CASE(OI_L2CAP_CONNECT_REFUSED_INVALID_PSM);
+        OI_CASE(OI_L2CAP_CONNECT_REFUSED_SECURITY);
+        OI_CASE(OI_L2CAP_CONNECT_REFUSED_NO_RESOURCES);
+        /* Spec Config errors */
+        OI_CASE(OI_L2CAP_CONFIG_BASE);
+        OI_CASE(OI_L2CAP_CONFIG_FAIL_UNKNOWN_OPTIONS);
+        /* Spec GetInfo errors */
+        OI_CASE(OI_L2CAP_GET_INFO_BASE);
+        OI_CASE(OI_L2CAP_GET_INFO_NOT_SUPPORTED);
+        OI_CASE(OI_L2CAP_MTU_EXCEEDED);
+        OI_CASE(OI_L2CAP_INVALID_PSM);
+        OI_CASE(OI_L2CAP_INVALID_MTU);
+        OI_CASE(OI_L2CAP_INVALID_FLUSHTO);
+
+        /* HCI internal errors and warnings */
+        OI_CASE(OI_HCI_NO_SUCH_CONNECTION);
+        OI_CASE(OI_HCI_CB_LIST_FULL);
+        OI_CASE(OI_HCI_EVENT_UNDERRUN);
+        OI_CASE(OI_HCI_UNKNOWN_EVENT_CODE);
+        OI_CASE(OI_HCI_BAD_EVENT_PARM_LEN);
+        OI_CASE(OI_HCI_CMD_QUEUE_FULL);
+        OI_CASE(OI_HCI_SHORT_EVENT);
+        OI_CASE(OI_HCI_TRANSMIT_NOT_READY);
+        OI_CASE(OI_HCI_ORPHAN_SENT_EVENT);
+        OI_CASE(OI_HCI_CMD_TABLE_ERROR);
+        OI_CASE(OI_HCI_UNKNOWN_CMD_ID);
+        OI_CASE(OI_HCI_UNEXPECTED_EVENT);
+        OI_CASE(OI_HCI_EVENT_TABLE_ERROR);
+        OI_CASE(OI_HCI_EXPECTED_EVENT_TIMOUT);
+        OI_CASE(OI_HCI_NO_CMD_DESC_FOR_OPCODE);
+        OI_CASE(OI_HCI_INVALID_OPCODE_ERROR);
+        OI_CASE(OI_HCI_FLOW_CONTROL_DISABLED);
+        OI_CASE(OI_HCI_TX_COMPLETE);
+        OI_CASE(OI_HCI_TX_ERROR);
+        OI_CASE(OI_HCI_DEVICE_NOT_INITIALIZED);
+        OI_CASE(OI_HCI_UNSUPPORTED_COMMAND);
+        OI_CASE(OI_HCI_PASSTHROUGH_ERROR);
+        OI_CASE(OI_HCI_PASSTHROUGH_ALREADY_SET);
+        OI_CASE(OI_HCI_RESET_FAILURE);
+        OI_CASE(OI_HCI_TRANSPORT_RESET);
+        /* HCI command and event errors */
+        OI_CASE(OI_HCIERR_UNKNOWN_HCI_COMMAND);
+        OI_CASE(OI_HCIERR_NO_CONNECTION);
+        OI_CASE(OI_HCIERR_HARDWARE_FAILURE);
+        OI_CASE(OI_HCIERR_PAGE_TIMEOUT);
+        OI_CASE(OI_HCIERR_AUTHENTICATION_FAILURE);
+        OI_CASE(OI_HCIERR_KEY_MISSING);
+        OI_CASE(OI_HCIERR_MEMORY_FULL);
+        OI_CASE(OI_HCIERR_CONNECTION_TIMEOUT);
+        OI_CASE(OI_HCIERR_MAX_NUM_OF_CONNECTIONS);
+        OI_CASE(OI_HCIERR_MAX_NUM_OF_SCO_CONNECTIONS);
+        OI_CASE(OI_HCIERR_ACL_CONNECTION_ALREADY_EXISTS);
+        OI_CASE(OI_HCIERR_COMMAND_DISALLOWED);
+        OI_CASE(OI_HCIERR_HOST_REJECTED_RESOURCES);
+        OI_CASE(OI_HCIERR_HOST_REJECTED_SECURITY);
+        OI_CASE(OI_HCIERR_HOST_REJECTED_PERSONAL_DEVICE);
+        OI_CASE(OI_HCIERR_HOST_TIMEOUT);
+        OI_CASE(OI_HCIERR_UNSUPPORTED);
+        OI_CASE(OI_HCIERR_INVALID_PARAMETERS);
+        OI_CASE(OI_HCIERR_OTHER_END_USER_DISCONNECT);
+        OI_CASE(OI_HCIERR_OTHER_END_LOW_RESOURCES);
+        OI_CASE(OI_HCIERR_OTHER_END_POWERING_OFF);
+        OI_CASE(OI_HCIERR_CONNECTION_TERMINATED_LOCALLY);
+        OI_CASE(OI_HCIERR_REPEATED_ATTEMPTS);
+        OI_CASE(OI_HCIERR_PAIRING_NOT_ALLOWED);
+        OI_CASE(OI_HCIERR_UNKNOWN_LMP_PDU);
+        OI_CASE(OI_HCIERR_UNSUPPORTED_REMOTE_FEATURE);
+        OI_CASE(OI_HCIERR_SCO_OFFSET_REJECTED);
+        OI_CASE(OI_HCIERR_SCO_INTERVAL_REJECTED);
+        OI_CASE(OI_HCIERR_SCO_AIR_MODE_REJECTED);
+        OI_CASE(OI_HCIERR_INVALID_LMP_PARMS);
+        OI_CASE(OI_HCIERR_UNSPECIFIED_ERROR);
+        OI_CASE(OI_HCIERR_UNSUPPORTED_LMP_PARAMETERS);
+        OI_CASE(OI_HCIERR_ROLE_CHANGE_NOT_ALLOWED);
+        OI_CASE(OI_HCIERR_LMP_RESPONSE_TIMEOUT);
+        OI_CASE(OI_HCIERR_LMP_ERROR_TRANS_COLLISION);
+        OI_CASE(OI_HCIERR_LMP_PDU_NOT_ALLOWED);
+        OI_CASE(OI_HCIERR_ENCRYPTION_MODE_NOT_ACCEPTABLE);
+        OI_CASE(OI_HCIERR_UNIT_KEY_USED);
+        OI_CASE(OI_HCIERR_QOS_NOT_SUPPORTED);
+        OI_CASE(OI_HCIERR_INSTANT_PASSED);
+        OI_CASE(OI_HCIERR_UNIT_KEY_PAIRING_UNSUPPORTED);
+        OI_CASE(OI_HCIERR_DIFFERENT_TRANS_COLLISION);
+        OI_CASE(OI_HCIERR_RESERVED_2B);
+        OI_CASE(OI_HCIERR_QOS_UNACCEPTABLE_PARAMETER);
+        OI_CASE(OI_HCIERR_QOS_REJECTED);
+        OI_CASE(OI_HCIERR_CHANNEL_CLASSIFICATION_NS);
+        OI_CASE(OI_HCIERR_INSUFFICIENT_SECURITY);
+        OI_CASE(OI_HCIERR_PARM_OUT_OF_MANDATORY_RANGE);
+        OI_CASE(OI_HCIERR_RESERVED_31);
+        OI_CASE(OI_HCIERR_ROLE_SWITCH_PENDING);
+        OI_CASE(OI_HCIERR_RESERVED_33);
+        OI_CASE(OI_HCIERR_RESERVED_SLOT_VIOLATION);
+        OI_CASE(OI_HCIERR_ROLE_SWITCH_FAILED);
+        OI_CASE(OI_HCIERR_EIR_TOO_LARGE);
+        OI_CASE(OI_HCIERR_SSP_NOT_SUPPORTED_BY_HOST);
+        OI_CASE(OI_HCIERR_HOST_BUSY_PAIRING);
+        OI_CASE(OI_HCIERR_UNKNOWN_ERROR);
+
+        OI_CASE(OI_SDP_SPEC_ERROR);
+        OI_CASE(OI_SDP_INVALID_SERVICE_RECORD_HANDLE);
+        OI_CASE(OI_SDP_INVALID_REQUEST_SYNTAX);
+        OI_CASE(OI_SDP_INVALID_PDU_SIZE);
+        OI_CASE(OI_SDP_INVALID_CONTINUATION_STATE);
+        OI_CASE(OI_SDP_INSUFFICIENT_RESOURCES);
+        OI_CASE(OI_SDP_ERROR);
+        OI_CASE(OI_SDP_CORRUPT_DATA_ELEMENT);
+        OI_CASE(OI_SDP_SERVER_NOT_CONNECTED);
+        OI_CASE(OI_SDP_ACCESS_DENIED);
+        OI_CASE(OI_SDP_ATTRIBUTES_OUT_OF_ORDER);
+        OI_CASE(OI_SDP_DEVICE_DOES_NOT_SUPPORT_SDP);
+        OI_CASE(OI_SDP_NO_MORE_DATA);
+        OI_CASE(OI_SDP_REQUEST_PARAMS_TOO_LONG);
+        OI_CASE(OI_SDP_REQUEST_PENDING);
+        OI_CASE(OI_SDP_SERVER_CONNECT_FAILED);
+        OI_CASE(OI_SDP_SERVER_TOO_MANY_CONNECTIONS);
+        OI_CASE(OI_SDP_NO_MATCHING_SERVICE_RECORD);
+        OI_CASE(OI_SDP_PARTIAL_RESPONSE);
+        OI_CASE(OI_SDP_ILLEGAL_ARGUMENT);
+        OI_CASE(OI_SDP_ATTRIBUTE_NOT_FOUND);
+        OI_CASE(OI_SDP_DATABASE_OUT_OF_RESOURCES);
+        OI_CASE(OI_SDP_SHORT_PDU);
+        OI_CASE(OI_SDP_TRANSACTION_ID_MISMATCH);
+        OI_CASE(OI_SDP_UNEXPECTED_RESPONSE_PDU_ID);
+        OI_CASE(OI_SDP_REQUEST_TIMEOUT);
+        OI_CASE(OI_SDP_INVALID_RESPONSE_SYNTAX);
+        OI_CASE(OI_SDP_CONNECTION_TIMEOUT);
+        OI_CASE(OI_SDP_RESPONSE_DATA_ERROR);
+        OI_CASE(OI_SDP_TOO_MANY_ATTRIBUTE_BYTES);
+        OI_CASE(OI_SDP_TOO_MANY_SERVICE_RECORDS);
+        OI_CASE(OI_SDP_INVALID_CONNECTION_ID);
+        OI_CASE(OI_SDP_CANNOT_SET_ATTRIBUTE);
+        OI_CASE(OI_SDP_BADLY_FORMED_ATTRIBUTE_VALUE);
+        OI_CASE(OI_SDP_NO_ATTRIBUTE_LIST_TO_REMOVE);
+        OI_CASE(OI_SDP_ATTRIBUTE_LIST_ALREADY_ADDED);
+        OI_CASE(OI_SDP_DATA_ELEMENT_TRUNCATED);
+
+        OI_CASE(OI_RFCOMM_WRITE_IN_PROGRESS);
+        OI_CASE(OI_RFCOMM_INVALID_BAUDRATE);
+        OI_CASE(OI_RFCOMM_INVALID_DATABIT);
+        OI_CASE(OI_RFCOMM_INVALID_STOPBIT);
+        OI_CASE(OI_RFCOMM_INVALID_PARITY);
+        OI_CASE(OI_RFCOMM_INVALID_PARITYTYPE);
+        OI_CASE(OI_RFCOMM_INVALID_FLOWCONTROL);
+        OI_CASE(OI_RFCOMM_SESSION_EXISTS);
+        OI_CASE(OI_RFCOMM_INVALID_CHANNEL);
+        OI_CASE(OI_RFCOMM_DLCI_EXISTS);
+        OI_CASE(OI_RFCOMM_LINK_NOT_FOUND);
+        OI_CASE(OI_RFCOMM_REMOTE_REJECT);
+        OI_CASE(OI_RFCOMM_TEST_IN_PROGRESS);
+        OI_CASE(OI_RFCOMM_SESSION_NOT_FOUND);
+        OI_CASE(OI_RFCOMM_INVALID_PACKET);
+        OI_CASE(OI_RFCOMM_FRAMESIZE_EXCEEDED);
+        OI_CASE(OI_RFCOMM_INVALID_DLCI);
+        OI_CASE(OI_RFCOMM_SERVER_NOT_REGISTERED);
+        OI_CASE(OI_RFCOMM_CREDIT_ERROR);
+        OI_CASE(OI_RFCOMM_NO_CHANNEL_NUMBER);
+        OI_CASE(OI_RFCOMM_QUERY_IN_PROGRESS);
+        OI_CASE(OI_RFCOMM_SESSION_SHUTDOWN);
+        OI_CASE(OI_RFCOMM_LOCAL_DEVICE_DISCONNECTED);
+        OI_CASE(OI_RFCOMM_REMOTE_DEVICE_DISCONNECTED);
+        OI_CASE(OI_RFCOMM_OUT_OF_SERVER_CHANNELS);
+
+        OI_CASE(OI_DISPATCH_INVALID_CB_HANDLE);
+        OI_CASE(OI_DISPATCH_TABLE_OVERFLOW);
+
+        OI_CASE(OI_TEST_UNKNOWN_TEST);
+        OI_CASE(OI_TEST_FAIL);
+
+        OI_CASE(OI_HCITRANS_CANNOT_CONNECT_TO_DEVICE);
+        OI_CASE(OI_HCITRANS_BUFFER_TOO_SMALL);
+        OI_CASE(OI_HCITRANS_NULL_DEVICE_HANDLE);
+        OI_CASE(OI_HCITRANS_IO_ERROR);
+        OI_CASE(OI_HCITRANS_DEVICE_NOT_READY);
+        OI_CASE(OI_HCITRANS_FUNCTION_NOT_SUPPORTED);
+        OI_CASE(OI_HCITRANS_ACCESS_DENIED);
+        OI_CASE(OI_HCITRANS_ACL_DATA_ERROR);
+        OI_CASE(OI_HCITRANS_SCO_DATA_ERROR);
+        OI_CASE(OI_HCITRANS_EVENT_DATA_ERROR);
+        OI_CASE(OI_HCITRANS_INTERNAL_ERROR);
+        OI_CASE(OI_HCITRANS_LINK_NOT_ACTIVE);
+        OI_CASE(OI_HCITRANS_INITIALIZING);
+
+        OI_CASE(OI_DEVMGR_NO_CONNECTION);
+        OI_CASE(OI_DEVMGR_HARDWARE_ERROR);
+        OI_CASE(OI_DEVMGR_PENDING_CONNECT_LIST_FULL);
+        OI_CASE(OI_DEVMGR_CONNECTION_LIST_FULL);
+        OI_CASE(OI_DEVMGR_NO_SUCH_CONNECTION);
+        OI_CASE(OI_DEVMGR_INQUIRY_IN_PROGRESS);
+        OI_CASE(OI_DEVMGR_PERIODIC_INQUIRY_ACTIVE);
+        OI_CASE(OI_DEVMGR_NO_INQUIRIES_ACTIVE);
+        OI_CASE(OI_DEVMGR_DUPLICATE_CONNECTION);
+        OI_CASE(OI_DEVMGR_DUPLICATE_EVENT_CALLBACK);
+        OI_CASE(OI_DEVMGR_EVENT_CALLBACK_LIST_FULL);
+        OI_CASE(OI_DEVMGR_EVENT_CALLBACK_NOT_FOUND);
+        OI_CASE(OI_DEVMGR_BUSY);
+        OI_CASE(OI_DEVMGR_ENUM_UNEXPECTED_INQ_COMPLETE);
+        OI_CASE(OI_DEVMGR_ENUM_UNEXPECTED_INQ_RESULT);
+        OI_CASE(OI_DEVMGR_ENUM_DATABASE_FULL);
+        OI_CASE(OI_DEVMGR_ENUM_INQUIRIES_OVERLAP);
+        OI_CASE(OI_DEVMGR_UNKNOWN_LINK_TYPE);
+        OI_CASE(OI_DEVMGR_PARAM_IO_ACTIVE);
+        OI_CASE(OI_DEVMGR_UNKNOWN_IAC_LAP);
+        OI_CASE(OI_DEVMGR_SCO_ALREADY_REGISTERED);
+        OI_CASE(OI_DEVMGR_SCO_NOT_REGISTERED);
+        OI_CASE(OI_DEVMGR_SCO_WITHOUT_ACL);
+        OI_CASE(OI_DEVMGR_NO_SUPPORT);
+        OI_CASE(OI_DEVMGR_WRITE_POLICY_FAILED);
+        OI_CASE(OI_DEVMGR_NOT_IN_MASTER_MODE);
+        OI_CASE(OI_DEVMGR_POLICY_VIOLATION);
+        OI_CASE(OI_DEVMGR_BUSY_TIMEOUT);
+        OI_CASE(OI_DEVMGR_REENCRYPT_FAILED);
+        OI_CASE(OI_DEVMGR_ROLE_POLICY_CONFLICT);
+        OI_CASE(OI_DEVMGR_BAD_INTERVAL);
+        OI_CASE(OI_DEVMGR_INVALID_SCO_HANDLE);
+        OI_CASE(OI_DEVMGR_CONNECTION_OVERLAP);
+        OI_CASE(OI_DEVMGR_ORPHAN_SUBRATE_COMPLETE);
+        OI_CASE(OI_DEVMGR_EIR_RESPONSE_2_LARGE);
+
+        OI_CASE(OI_SECMGR_NO_POLICY);
+        OI_CASE(OI_SECMGR_INTERNAL_ERROR);
+        OI_CASE(OI_SECMGR_ORPHANED_CALLBACK);
+        OI_CASE(OI_SECMGR_BUSY);
+        OI_CASE(OI_SECMGR_DEVICE_NOT_TRUSTED);
+        OI_CASE(OI_SECMGR_DEVICE_ENCRYPT_FAIL);
+        OI_CASE(OI_SECMGR_DISCONNECTED_FAIL);
+        OI_CASE(OI_SECMGR_ACCESS_PENDING);
+        OI_CASE(OI_SECMGR_PIN_CODE_TOO_SHORT);
+        OI_CASE(OI_SECMGR_UNKNOWN_ENCRYPT_VALUE);
+        OI_CASE(OI_SECMGR_INVALID_POLICY);
+        OI_CASE(OI_SECMGR_AUTHORIZATION_FAILED);
+        OI_CASE(OI_SECMGR_ENCRYPTION_FAILED);
+        OI_CASE(OI_SECMGR_UNIT_KEY_UNSUPPORTED);
+        OI_CASE(OI_SECMGR_NOT_REGISTERED);
+        OI_CASE(OI_SECMGR_ILLEGAL_WRITE_SSP_MODE);
+        OI_CASE(OI_SECMGR_INVALID_SEC_LEVEL);
+        OI_CASE(OI_SECMGR_INSUFFICIENT_LINK_KEY);
+        OI_CASE(OI_SECMGR_INVALID_KEY_TYPE);
+        OI_CASE(OI_SECMGR_SSP_NOT_ENCRYPTED);
+        OI_CASE(OI_SECMGR_ORPHAN_EVENT);
+        OI_CASE(OI_SECMGR_NOT_BONDABLE);
+
+        OI_CASE(OI_TCS_INVALID_ELEMENT_TYPE);
+        OI_CASE(OI_TCS_INVALID_PACKET);
+        OI_CASE(OI_TCS_CALL_IN_PROGRESS);
+        OI_CASE(OI_TCS_NO_CALL_IN_PROGRESS);
+
+        OI_CASE(OI_OBEX_CONTINUE);
+        OI_CASE(OI_OBEX_COMMAND_ERROR);
+        OI_CASE(OI_OBEX_CONNECTION_TIMEOUT);
+        OI_CASE(OI_OBEX_CONNECT_FAILED);
+        OI_CASE(OI_OBEX_DISCONNECT_FAILED);
+        OI_CASE(OI_OBEX_ERROR);
+        OI_CASE(OI_OBEX_INCOMPLETE_PACKET);
+        OI_CASE(OI_OBEX_LENGTH_REQUIRED);
+        OI_CASE(OI_OBEX_NOT_CONNECTED);
+        OI_CASE(OI_OBEX_NO_MORE_CONNECTIONS);
+        OI_CASE(OI_OBEX_OPERATION_IN_PROGRESS);
+        OI_CASE(OI_OBEX_PUT_RESPONSE_ERROR);
+        OI_CASE(OI_OBEX_GET_RESPONSE_ERROR);
+        OI_CASE(OI_OBEX_REQUIRED_HEADER_NOT_FOUND);
+        OI_CASE(OI_OBEX_SERVICE_UNAVAILABLE);
+        OI_CASE(OI_OBEX_TOO_MANY_HEADER_BYTES);
+        OI_CASE(OI_OBEX_UNKNOWN_COMMAND);
+        OI_CASE(OI_OBEX_UNSUPPORTED_VERSION);
+        OI_CASE(OI_OBEX_CLIENT_ABORTED_COMMAND);
+        OI_CASE(OI_OBEX_BAD_PACKET);
+        OI_CASE(OI_OBEX_BAD_REQUEST);
+        OI_CASE(OI_OBEX_OBJECT_OVERFLOW);
+        OI_CASE(OI_OBEX_NOT_FOUND);
+        OI_CASE(OI_OBEX_ACCESS_DENIED);
+        OI_CASE(OI_OBEX_VALUE_NOT_ACCEPTABLE);
+        OI_CASE(OI_OBEX_PACKET_OVERFLOW);
+        OI_CASE(OI_OBEX_NO_SUCH_FOLDER);
+        OI_CASE(OI_OBEX_NAME_REQUIRED);
+        OI_CASE(OI_OBEX_PASSWORD_TOO_LONG);
+        OI_CASE(OI_OBEX_PRECONDITION_FAILED);
+        OI_CASE(OI_OBEX_UNAUTHORIZED);
+        OI_CASE(OI_OBEX_CONFLICT);
+        OI_CASE(OI_OBEX_NOT_IMPLEMENTED);
+        OI_CASE(OI_OBEX_INVALID_AUTH_DIGEST);
+        OI_CASE(OI_OBEX_INVALID_OPERATION);
+        OI_CASE(OI_OBEX_DATABASE_FULL);
+        OI_CASE(OI_OBEX_DATABASE_LOCKED);
+        OI_CASE(OI_OBEX_INTERNAL_SERVER_ERROR);
+        OI_CASE(OI_OBEX_UNSUPPORTED_MEDIA_TYPE);
+        OI_CASE(OI_OBEX_PARTIAL_CONTENT);
+        OI_CASE(OI_OBEX_METHOD_NOT_ALLOWED);
+        OI_CASE(OI_OBEXSRV_INCOMPLETE_GET);
+        OI_CASE(OI_OBEX_FOLDER_BROWSING_NOT_ALLOWED);
+        OI_CASE(OI_OBEX_SERVER_FORCED_DISCONNECT);
+        OI_CASE(OI_OBEX_OFS_ERROR);
+        OI_CASE(OI_OBEX_FILEOP_ERROR);
+        OI_CASE(OI_OBEX_USERID_TOO_LONG);
+        OI_CASE(OI_OBEX_NOT_READY);
+        OI_CASE(OI_OBEX_NOT_MODIFIED);
+        OI_CASE(OI_OBEX_FORBIDDEN);
+        OI_CASE(OI_OBEX_CLEANUP);
+        OI_CASE(OI_OBEX_CONNECT_IN_PROGRESS);
+
+        OI_CASE(OI_HANDSFREE_EVENT_REPORTING_DISABLED);
+        OI_CASE(OI_HANDSFREE_NOT_CONNECTED);
+        OI_CASE(OI_HANDSFREE_SERVICE_NOT_STARTED);
+        OI_CASE(OI_HANDSFREE_AG_SERVICE_NOT_STARTED);
+        OI_CASE(OI_HANDSFREE_COMMAND_IN_PROGRESS);
+        OI_CASE(OI_HANDSFREE_AUDIO_ALREADY_CONNECTED);
+        OI_CASE(OI_HANDSFREE_AUDIO_NOT_CONNECTED);
+        OI_CASE(OI_HANDSFREE_FEATURE_NOT_SUPPORTED);
+
+        OI_CASE(OI_HEADSET_SERVICE_NOT_STARTED);
+        OI_CASE(OI_HEADSET_AG_SERVICE_NOT_STARTED);
+        OI_CASE(OI_HEADSET_COMMAND_IN_PROGRESS);
+
+        OI_CASE(OI_BNEP_INVALID_MTU);
+        OI_CASE(OI_BNEP_SETUP_TIMEOUT);
+        OI_CASE(OI_BNEP_SERVICE_NOT_REGISTERED);
+        OI_CASE(OI_BNEP_INVALID_HANDLE);
+        OI_CASE(OI_BNEP_RESPONSE_TIMEOUT);
+        OI_CASE(OI_BNEP_INVALID_CONNECTION);
+        OI_CASE(OI_BNEP_INVALID_FILTER);
+        OI_CASE(OI_BNEP_CONNECTION_EXISTS);
+        OI_CASE(OI_BNEP_NOT_INITIALIZED);
+        OI_CASE(OI_BNEP_CONNECT_BASE);
+        OI_CASE(OI_BNEP_CONNECT_FAILED_INVALID_DEST_UUID);
+        OI_CASE(OI_BNEP_CONNECT_FAILED_INVALID_SOURCE_UUID);
+        OI_CASE(OI_BNEP_CONNECT_FAILED_INVALID_UUID_SIZE);
+        OI_CASE(OI_BNEP_CONNECT_FAILED_NOT_ALLOWED);
+        OI_CASE(OI_BNEP_FILTER_NET_BASE);
+        OI_CASE(OI_BNEP_FILTER_NET_UNSUPPORTED_REQUEST);
+        OI_CASE(OI_BNEP_FILTER_NET_FAILED_INVALID_PROTOCOL_TYPE);
+        OI_CASE(OI_BNEP_FILTER_NET_FAILED_MAX_LIMIT_REACHED);
+        OI_CASE(OI_BNEP_FILTER_NET_FAILED_SECURITY);
+        OI_CASE(OI_BNEP_FILTER_MULTI_BASE);
+        OI_CASE(OI_BNEP_FILTER_MULTI_UNSUPPORTED_REQUEST);
+        OI_CASE(OI_BNEP_FILTER_MULTI_FAILED_INVALID_ADDRESS);
+        OI_CASE(OI_BNEP_FILTER_MULTI_FAILED_MAX_LIMIT_REACHED);
+        OI_CASE(OI_BNEP_FILTER_MULTI_FAILED_SECURITY);
+        OI_CASE(OI_BNEP_LOCAL_DEVICE_MUST_BE_MASTER);
+        OI_CASE(OI_BNEP_PACKET_FILTERED_OUT);
+
+        OI_CASE(OI_NETIFC_UP_FAILED);
+        OI_CASE(OI_NETIFC_COULD_NOT_CREATE_THREAD);
+        OI_CASE(OI_NETIFC_INITIALIZATION_FAILED);
+        OI_CASE(OI_NETIFC_INTERFACE_ALREADY_UP);
+        OI_CASE(OI_NETIFC_INTERFACE_NOT_UP);
+        OI_CASE(OI_NETIFC_PACKET_TOO_BIG);
+
+        OI_CASE(OI_PAN_ROLE_ALREADY_REGISTERED);
+        OI_CASE(OI_PAN_ROLE_NOT_ALLOWED);
+        OI_CASE(OI_PAN_INCOMPATIBLE_ROLES);
+        OI_CASE(OI_PAN_INVALID_ROLE);
+        OI_CASE(OI_PAN_CONNECTION_IN_PROGRESS);
+        OI_CASE(OI_PAN_USER_ALREADY_CONNECTED);
+        OI_CASE(OI_PAN_DEVICE_CONNECTED);
+
+        OI_CASE(OI_CODEC_SBC_NO_SYNCWORD);
+        OI_CASE(OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA);
+        OI_CASE(OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA);
+        OI_CASE(OI_CODEC_SBC_NOT_ENOUGH_AUDIO_DATA);
+        OI_CASE(OI_CODEC_SBC_CHECKSUM_MISMATCH);
+        OI_CASE(OI_CODEC_SBC_PARTIAL_DECODE);
+
+        OI_CASE(OI_FIFOQ_QUEUE_NOT_ALIGNED);
+        OI_CASE(OI_FIFOQ_INVALID_Q);
+        OI_CASE(OI_FIFOQ_BUF_TOO_LARGE);
+        OI_CASE(OI_FIFOQ_FULL);
+        OI_CASE(OI_FIFOQ_NOT_ALLOCATED);
+        OI_CASE(OI_FIFOQ_INVALID_DATA_PTR);
+
+        OI_CASE(OI_HID_HOST_SERVICE_NOT_STARTED);
+        OI_CASE(OI_HID_DEVICE_SERVICE_NOT_STARTED);
+
+        OI_CASE(OI_AT_ERROR);
+        OI_CASE(OI_AT_NO_CARRIER);
+        OI_CASE(OI_AT_BUSY);
+        OI_CASE(OI_AT_NO_ANSWER);
+        OI_CASE(OI_AT_DELAYED);
+        OI_CASE(OI_AT_BLACKLISTED);
+        OI_CASE(OI_AT_CMS_ERROR);
+        OI_CASE(OI_AT_CME_ERROR);
+
+        OI_CASE(OI_AVDTP_CONNECTION_SEQ_ERROR);
+        OI_CASE(OI_AVDTP_OUT_OF_RESOURCES);
+
+        OI_CASE(OI_PBAP_REPOSITORY_NOT_SET);
+        OI_CASE(OI_PBAP_PHONEBOOK_NOT_SET);
+
+        OI_CASE(OI_AADP_BAD_ENDPOINT);
+        OI_CASE(OI_AADP_BAD_STATE);
+
+        OI_CASE(OI_UNICODE_INVALID_SOURCE);
+        OI_CASE(OI_UNICODE_SOURCE_EXHAUSTED);
+        OI_CASE(OI_UNICODE_DESTINATION_EXHAUSTED);
+
+        OI_CASE(OI_AVRCP_TOO_MANY_CONNECTIONS);
+        OI_CASE(OI_AVRCP_NOT_IMPLEMENTED);
+        OI_CASE(OI_AVRCP_REJECTED);
+        OI_CASE(OI_AVRCP_INVALID_RESPONSE);
+        OI_CASE(OI_AVRCP_RESPONSE_PACKET_OVERFLOW);
+        OI_CASE(OI_AVRCP_RESPONSE_INVALID_PDU);
+        OI_CASE(OI_AVRCP_RESPONSE_INVALID_PARAMETER);
+        OI_CASE(OI_AVRCP_RESPONSE_PARAMETER_NOT_FOUND);
+        OI_CASE(OI_AVRCP_RESPONSE_INTERNAL_ERROR);
+
+        OI_CASE(OI_STATUS_NONE);
+
+        default:
+        return NULL;
+    }
+}
+
+/**
+ * The list of status text filters, pre-initialized with the BM3 status text
+ * filter.
+ */
+static OI_APP_STATUS_TEXT_FILTER StatusTextFilterList[OI_NUM_RESERVED_STATUS_BLOCKS + 1] = { OI_BM3StatusText };
+
+
+OI_CHAR* OI_StatusText(OI_STATUS value)
+{
+    OI_UINT i;
+    OI_CHAR *text = NULL;
+
+    for (i = 0; (text == NULL) && (i < OI_ARRAYSIZE(StatusTextFilterList)) && (StatusTextFilterList[i]) ; i++) {
+        if (StatusTextFilterList[i]) {
+            text = StatusTextFilterList[i](value);
+        }
+    }
+
+    if (text) {
+        return text;
+    } else {
+        return OI_StatusNum(value);
+    }
+}
+
+void OI_RegisterAppStatusTextFilter(OI_APP_STATUS_TEXT_FILTER filter)
+{
+    OI_UINT i;
+
+    for (i = 0; i < OI_ARRAYSIZE(StatusTextFilterList); i++) {
+        if (StatusTextFilterList[i] == filter) {
+            OI_SLOG_WARNING(OI_STATUS_ALREADY_REGISTERED, ("Filter (0x%08x) already registered",
+                                                           filter));
+            return;
+        }
+        if (StatusTextFilterList[i] == NULL) {
+            StatusTextFilterList[i] = filter;
+            return;
+        }
+    }
+
+    OI_SLOG_WARNING(OI_STATUS_NO_RESOURCES, ("Too many filters registered"));
+}
+
+#endif    /* OI_DEBUG */
+
+/*****************************************************************************/
diff --git a/obex_profiles/stack/support/oi_time.c b/obex_profiles/stack/support/oi_time.c
new file mode 100644
index 0000000..a3db575
--- /dev/null
+++ b/obex_profiles/stack/support/oi_time.c
@@ -0,0 +1,138 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+@file
+@internal
+This file implements timer functions.
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_time.h"
+#include "oi_assert.h"
+#include "oi_osinterface.h"
+#include "oi_debug.h"
+
+OI_UINT32 OI_Time_ToMS(OI_TIME *t)
+{
+    return (1000 * t->seconds + t->mseconds);
+}
+
+/*
+ * OI_Time_Compare
+ *
+ */
+
+OI_INT16 OI_Time_Compare(OI_TIME *T1,
+                         OI_TIME *T2)
+
+{
+    OI_ASSERT((T1 != NULL) & (T2 != NULL));
+
+    if (T1->seconds < T2->seconds) {
+        return -1;
+    }
+    if (T1->seconds > T2->seconds) {
+        return 1;
+    }
+    if (T1->mseconds < T2->mseconds) {
+        return -1;
+    }
+    if (T1->mseconds > T2->mseconds) {
+        return 1;
+    }
+    return 0;
+}
+
+/*
+ * OI_Time_Interval
+ *
+ */
+
+OI_INTERVAL OI_Time_Interval(OI_TIME *Sooner,
+                             OI_TIME *Later)
+{
+    OI_INT32 seconds = Later->seconds - Sooner->seconds;
+    OI_INT16 mseconds = Later->mseconds - Sooner->mseconds;
+
+    OI_ASSERT(Later->seconds >= Sooner->seconds);
+    OI_ASSERT((Later->seconds != Sooner->seconds) || (Later->mseconds >= Sooner->mseconds));
+
+    if (mseconds < 0) {
+        mseconds += 1000;
+        --seconds;
+    }
+    /*
+     * OI_INTERVALS are only accurate to within 1/10 of a second so we can avoid doing a potentially
+     * expensive divide operation by approximating a divide by 100 to a multiply by 10 and divide by
+     * 1024 which any reasonable compiler will implement as a shift.
+     */
+    return (OI_INTERVAL) (seconds * 10 + (mseconds * 10 + 512) / 1024);
+}
+
+
+
+/*
+ * OI_Time_IntervalMsecs
+ *
+ */
+
+OI_UINT32 OI_Time_IntervalMsecs(OI_TIME *Sooner,
+                                OI_TIME *Later)
+{
+    OI_INT32 seconds = Later->seconds - Sooner->seconds;
+    OI_INT16 mseconds = Later->mseconds - Sooner->mseconds;
+
+    OI_ASSERT(Later->seconds >= Sooner->seconds);
+    OI_ASSERT((Later->seconds != Sooner->seconds) || (Later->mseconds >= Sooner->mseconds));
+
+    if (mseconds < 0) {
+        mseconds += 1000;
+        --seconds;
+    }
+
+    return seconds * 1000 + mseconds;
+}
+
+
+
+/*
+ * OI_Time_NowReachedTime
+ *
+ */
+
+OI_BOOL  OI_Time_NowReachedTime(OI_TIME *pTargetTime)
+{
+    OI_TIME now;
+
+    OI_Time_Now(&now);
+    return(OI_Time_Compare(&now, pTargetTime) >= 0);
+}
+/*****************************************************************************/
diff --git a/obex_profiles/stack/support/oi_unicode.c b/obex_profiles/stack/support/oi_unicode.c
new file mode 100644
index 0000000..a111379
--- /dev/null
+++ b/obex_profiles/stack/support/oi_unicode.c
@@ -0,0 +1,484 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * @internal
+ *
+ */
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_argcheck.h"
+#include "oi_stddefs.h"
+#include "oi_utils.h"
+#include "oi_unicode.h"
+#include "oi_assert.h"
+#include "oi_unicodestream.h"
+#include "oi_std_utils.h"
+
+#include "../unicode/ConvertUTF.h"
+
+
+/* This table translates the result status from the conversion code developed
+ * by Unicode, Inc., to standard OI_STATUS codes.
+ */
+static const OI_STATUS OI_CvtUnicodeResult[] = {
+    OI_OK,
+    OI_UNICODE_SOURCE_EXHAUSTED,
+    OI_UNICODE_DESTINATION_EXHAUSTED,
+    OI_UNICODE_INVALID_SOURCE
+};
+
+OI_STATUS OI_Utf8ToUtf16(const OI_UTF8 *src, OI_INT srcLen,
+                         OI_UTF16 *dst, OI_INT dstLen)
+{
+    OI_STATUS status;
+    OI_UTF16 *dstend = dst + dstLen;
+
+    OI_DBGPRINT2(("OI_Utf8ToUtf16 (<*src = %x>, srcLen = %d, <*dst = %x>, dstLen = %d)\n",
+                  src, srcLen, dst, dstLen));
+
+    OI_ARGCHECK(src != NULL);
+    OI_ARGCHECK(srcLen > 0);
+    OI_ARGCHECK(dst != NULL);
+    OI_ARGCHECK(dstLen > 0);
+
+    OI_DBGPRINT2(("\tConverting \"%s\" from UTF8 to UTF16...\n", src, srcLen));
+
+    status = OI_CvtUnicodeResult[ConvertUTF8toUTF16(&src, src + srcLen,
+                                                    &dst, dstend,
+                                                    strictConversion)];
+    if(OI_SUCCESS(status)) {
+        if (dst < dstend) {
+            *dst = 0;  /* Ensure last character is nul terminator. */
+        } else if (dst == dstend && (dst[-1] != 0)) {
+            OI_DBGPRINT2(("Failed to add final nul terminator character.\n"));
+            status = OI_UNICODE_DESTINATION_EXHAUSTED;
+        }
+    } else {
+        OI_DBGPRINT2(("UTF conversion failed: %d\n", status));
+    }
+    return status;
+}
+
+OI_STATUS OI_Utf16ToUtf8(const OI_UTF16 *src, OI_INT srcLen,
+                         OI_UTF8 *dst, OI_INT dstLen)
+{
+    OI_STATUS status;
+    OI_UTF8 *dstend = dst + dstLen;
+
+    OI_DBGPRINT2(("OI_Utf8ToUtf16 (<*src = %x>, srcLen = %d, <*dst = %x>, dstLen = %d)\n",
+                  src, srcLen, dst, dstLen));
+
+    OI_ARGCHECK(src != NULL);
+    OI_ARGCHECK(srcLen > 0);
+    OI_ARGCHECK(dst != NULL);
+    OI_ARGCHECK(dstLen > 0);
+
+    OI_DBGPRINT2(("\tConverting \"%s\" from UTF16 to UTF8...\n", src, srcLen));
+
+    status = OI_CvtUnicodeResult[ConvertUTF16toUTF8(&src, src + srcLen,
+                                                    &dst, dstend,
+                                                    strictConversion)];
+    if(OI_SUCCESS(status)) {
+        if (dst < dstend) {
+            *dst = 0;  /* Ensure last character is nul terminator. */
+        } else  if (dst == dstend && (dst[-1] != 0)) {
+            OI_DBGPRINT2(("Failed to add final nul terminator character.\n"));
+            status = OI_UNICODE_DESTINATION_EXHAUSTED;
+        }
+    } else {
+        OI_DBGPRINT2(("UTF conversion failed: %d\n", status));
+    }
+    return status;
+}
+
+
+/**
+ * OI_StrLenUtf16()
+ *
+ * This function returns the number of 16-bit words used by the string, not
+ * the number of Unicode characters as some Unicode characters may occupy
+ * multiple 16-bit words.  In other words, it operates the same way that the
+ * standard C function strlen() would on UTF-8 strings (which also have
+ * multibyte characters).
+ */
+OI_UINT OI_StrLenUtf16(const OI_UTF16 *str)
+{
+    OI_UINT len = 0;
+
+    OI_ASSERT(str != NULL);
+
+    while (str[len] != 0) {
+        ++len;
+    }
+    return len;
+}
+
+
+/**
+ * OI_StrcmpUtf16()
+ *
+ * This function compare 2 UTF-16 strings in the same manner that the standard
+ * C function strcmp() would compare UTF-8 strings.  That is, it does an exact
+ * 16-bit word for 16-bit word compare rather than check for possible
+ * eqivalent character encodings for those characters that may have different,
+ * but equivalent encodings.
+ */
+OI_INT OI_StrcmpUtf16(const OI_UTF16 *str1,
+                      const OI_UTF16 *str2)
+{
+    OI_ASSERT(str1 != NULL);
+    OI_ASSERT(str2 != NULL);
+
+    for (;;) {
+        if (*str1 < *str2) return -1;
+        if (*str1 > *str2) return 1;
+        if (*str1 == 0) return 0;
+        str1++;
+        str2++;
+    }
+}
+
+
+OI_INT OI_StrncmpUtf16(const OI_UTF16 *str1,
+                       const OI_UTF16 *str2,
+                       OI_UINT16 len)
+{
+    OI_ASSERT(str1 != NULL);
+    OI_ASSERT(str2 != NULL);
+
+    while (len--) {
+        if (*str1 < *str2) return -1;
+        if (*str1 > *str2) return 1;
+        if (*str1 == 0) return 0;
+        str1++;
+        str2++;
+    }
+    return 0;
+}
+
+
+
+
+
+
+
+OI_INT OI_PStrcmp(const OI_PSTR *s1,
+                  OI_UNICODE_ENCODING e1,
+                  const OI_CHAR *s2)
+{
+    OI_UNICODE_STREAM bs;
+    OI_UINT32 ch = 0;
+
+    OI_ASSERT(s1 != NULL);
+    OI_ASSERT(s2 != NULL);
+
+    if (s1->sz) {
+        UnicodeStream_Init(bs, s1->p, s1->sz, e1);
+        ByteStream_Open(bs, BYTESTREAM_READ);
+        for (;;) {
+            if (!ByteStream_NumReadBytesAvail(bs)) {
+                if (*s2 == '\0') {
+                    return 0;
+                } else {
+                    return -1;
+                }
+            }
+            UnicodeStream_GetChar(bs, ch);
+            if (ch < (OI_UINT32)*s2) return -1;
+            if (ch > (OI_UINT32)*s2) return 1;
+            s2++;
+        }
+    } else {
+        if (*s2) {
+            return -1;
+        } else {
+            return 0;
+        }
+    }
+}
+
+OI_INT OI_PStrcmpInsensitive(const OI_PSTR *s1,
+                             OI_UNICODE_ENCODING e1,
+                             const OI_CHAR *s2)
+{
+    OI_UNICODE_STREAM bs;
+    OI_UINT32 ch = 0;
+    OI_UINT32 uc1;
+    OI_UINT32 uc2;
+
+    OI_ASSERT(s1 != NULL);
+    OI_ASSERT(s2 != NULL);
+
+    if (s1->sz) {
+        UnicodeStream_Init(bs, s1->p, s1->sz, e1);
+        ByteStream_Open(bs, BYTESTREAM_READ);
+        for (;;) {
+            if (!ByteStream_NumReadBytesAvail(bs)) {
+                if (*s2 == '\0') {
+                    return 0;
+                } else {
+                    return -1;
+                }
+            }
+            UnicodeStream_GetChar(bs, ch);
+            uc1 = OI_toupper(ch);
+            uc2 = OI_toupper(*s2);
+            if (uc1 < uc2) return -1;
+            if (uc1 > uc2) return 1;
+            s2++;
+        }
+    } else {
+        if (*s2) {
+            return -1;
+        } else {
+            return 0;
+        }
+    }
+}
+
+OI_INT OI_PStrncmp(const OI_PSTR *s1,
+                   OI_UNICODE_ENCODING e1,
+                   const OI_CHAR *s2,
+                   OI_UINT16 len)
+{
+    OI_UNICODE_STREAM bs;
+    OI_UINT32 ch = 0;
+
+    OI_ASSERT(s1 != NULL);
+    OI_ASSERT(s2 != NULL);
+
+    if (s1->sz) {
+        UnicodeStream_Init(bs, s1->p, s1->sz, e1);
+        ByteStream_Open(bs, BYTESTREAM_READ);
+        while (len--) {
+            if (!ByteStream_NumReadBytesAvail(bs)) {
+                if (*s2 == '\0') {
+                    return 0;
+                } else {
+                    return -1;
+                }
+            }
+            UnicodeStream_GetChar(bs, ch);
+            if (ch < (OI_UINT32)*s2) return -1;
+            if (ch > (OI_UINT32)*s2) return 1;
+            s2++;
+        }
+        return 0;
+    } else {
+        if (*s2) {
+            return -1;
+        } else {
+            return 0;
+        }
+    }
+}
+
+OI_INT OI_PStrcmp2(const OI_PSTR *s1,
+                      OI_UNICODE_ENCODING e1,
+                      const OI_PSTR *s2,
+                      OI_UNICODE_ENCODING e2)
+{
+    OI_UNICODE_STREAM bs1;
+    OI_UNICODE_STREAM bs2;
+    OI_UINT32 ch1 = 0;
+    OI_UINT32 ch2 = 0;
+    OI_INT endOfString;
+
+    OI_ASSERT(s1 != NULL);
+    OI_ASSERT(s2 != NULL);
+
+    if (s1->sz && s2->sz) {
+
+        UnicodeStream_Init(bs1, s1->p, s1->sz, e1);
+        ByteStream_Open(bs1, BYTESTREAM_READ);
+
+        UnicodeStream_Init(bs2, s2->p, s2->sz, e2);
+        ByteStream_Open(bs2, BYTESTREAM_READ);
+
+        for (;;) {
+            endOfString = ByteStream_NumReadBytesAvail(bs1) ? 0 : 1;
+            endOfString |= ByteStream_NumReadBytesAvail(bs2) ? 0 : 2;
+            switch (endOfString) {
+                case 1: return -1;
+                case 2: return 1;
+                case 3: return 0;
+            }
+            UnicodeStream_GetChar(bs1, ch1);
+            UnicodeStream_GetChar(bs2, ch2);
+            if (ch1 < ch2) return -1;
+            if (ch1 > ch2) return 1;
+        }
+    } else if (s2->sz) {
+        return -1;
+    } else if (s1->sz) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+OI_INT OI_PStrIndexOf(const OI_PSTR *s1,
+                      OI_UNICODE_ENCODING e1,
+                      const OI_CHAR *s2,
+                      OI_INT pos)
+{
+    OI_UNICODE_STREAM bs;
+    const OI_CHAR *s;
+    OI_UINT32 ch = 0;
+
+    OI_ASSERT(s1 != NULL);
+    OI_ASSERT(s2 != NULL);
+
+    if (*s2 == 0) {
+        return pos;
+    }
+
+    UnicodeStream_Init(bs, s1->p, s1->sz, e1);
+    ByteStream_Open(bs, BYTESTREAM_READ);
+    ByteStream_SetPos(bs, pos);
+    while (!ByteStream_Error(bs) && ByteStream_NumReadBytesAvail(bs)) {
+        pos = ByteStream_GetPos(bs);
+
+        for (s = s2; (*s != 0) && ByteStream_NumReadBytesAvail(bs); ++s) {
+            UnicodeStream_GetChar_Checked(bs, ch);
+            if (ch != (OI_UINT32)(*s)) {
+                break;
+            }
+        }
+        if (*s == 0) {
+            return pos;
+        }
+
+        ByteStream_SetPos(bs, pos);
+        UnicodeStream_SkipChar_Checked(bs, 1);
+    }
+    return -1;
+}
+
+OI_INT OI_PStrLastIndexOf(const OI_PSTR *s1,
+                          OI_UNICODE_ENCODING e1,
+                          const OI_CHAR *s2,
+                          OI_INT pos)
+{
+    OI_UNICODE_STREAM bs;
+    const OI_CHAR *s;
+    OI_UINT32 ch = 0;
+    OI_INT result = -1;
+
+    OI_ASSERT(s1 != NULL);
+    OI_ASSERT(s2 != NULL);
+
+    if (*s2 == 0) {
+        return 0;
+    }
+
+    UnicodeStream_Init(bs, s1->p, s1->sz, e1);
+    ByteStream_Open(bs, BYTESTREAM_READ);
+    ByteStream_SetPos(bs, pos);
+    while (!ByteStream_Error(bs) && ByteStream_NumReadBytesAvail(bs)) {
+        pos = ByteStream_GetPos(bs);
+
+        for (s = s2; (*s != 0) && ByteStream_NumReadBytesAvail(bs); ++s) {
+            UnicodeStream_GetChar_Checked(bs, ch);
+            if (ch != (OI_UINT32)(*s)) {
+                break;
+            }
+        }
+        if (*s == 0) {
+            result = pos;
+        }
+
+        ByteStream_SetPos(bs, pos);
+        UnicodeStream_SkipChar_Checked(bs, 1);
+    }
+    return result;
+}
+
+OI_INT OI_PStrLen(const OI_PSTR *s1,
+                  OI_UNICODE_ENCODING e1)
+{
+    OI_INT len = 0;
+    OI_UINT16 i;
+
+    /*
+     * Count each multi-byte sequence only once.
+     */
+    switch (e1) {
+        case OI_UNICODE_UTF8:
+            for (i = 0; i < s1->sz; ++i) {
+                if ((s1->p[i] & 0xc0) != 0x80) {
+                    ++len;
+                }
+            }
+            break;
+        case OI_UNICODE_UTF16_LE:
+            for (i = 0; i < s1->sz; i += 2) {
+                if ((s1->p[i + 1] & 0xfc) != 0xdc) {
+                    ++len;
+                }
+            }
+            break;
+        case OI_UNICODE_UTF16_BE:
+            for (i = 0; i < s1->sz; i += 2) {
+                if ((s1->p[i] & 0xfc) != 0xdc) {
+                    ++len;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    return len;
+}
+
+void OI_PStrToUStr(OI_CHAR16 *s1,
+                   const OI_PSTR *s2,
+                   OI_UNICODE_ENCODING e2)
+{
+    OI_UNICODE_STREAM bs;
+    OI_UINT32 ch = 0;
+
+    UnicodeStream_Init(bs, s2->p, s2->sz, e2);
+    ByteStream_Open(bs, BYTESTREAM_READ);
+    while (ByteStream_NumReadBytesAvail(bs)) {
+        UnicodeStream_GetChar(bs, ch);
+        if (ch > 0xffff) {
+            OI_LOG_ERROR(("Truncating extended unicode character!"));
+        }
+        *s1++ = (OI_CHAR16)ch;
+    }
+    *s1 = 0;
+}
+
+
+
+
diff --git a/obex_profiles/stack/support/oi_utils.c b/obex_profiles/stack/support/oi_utils.c
new file mode 100644
index 0000000..e51205c
--- /dev/null
+++ b/obex_profiles/stack/support/oi_utils.c
@@ -0,0 +1,544 @@
+/**
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+@file
+@internal
+This file contains utilities that are commonly found in stdlib libraries,
+including functions for manipulating and comparing strings.
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_std_utils.h"
+#include "oi_assert.h"
+#include "oi_debug.h"
+#include "oi_bt_assigned_nos.h"
+
+/** The zero address.  Used to test for an uninitialized address. */
+const OI_BD_ADDR OI_ZeroAddr = { {0,0,0,0,0,0} };
+
+/**
+ * A 128-bit UUID initialized to the base UUID.
+ */
+const OI_UUID128 OI_UUID_BaseUUID128 = OI_UUID_BASE_UUID128;
+
+#define IsDecDigit(c)    (((c) >= '0') && ((c) <= '9'))
+
+
+const OI_CHAR* OI_ScanUInt(const OI_CHAR *str,
+                           OI_UINT32 *val)
+{
+    const OI_CHAR *p = str;
+    OI_INT32 n;
+
+    if (!str || !val) {
+        return str;
+    }
+
+    while ((*p == ' ') || (*p == '\t')) {
+        ++p;
+    }
+    if (IsDecDigit(*p)) {
+        const OI_CHAR *s = OI_ScanInt(p, &n);
+        if (s != p) {
+            *val = (OI_UINT32)n;
+            return s;
+        }
+    }
+    return str;
+}
+
+
+const OI_CHAR* OI_ScanInt(const OI_CHAR *str,
+                          OI_INT32 *val)
+{
+    const OI_CHAR *p = str;
+    OI_UINT32 n = 0;
+    OI_BOOL neg;
+
+    if (!str || !val) {
+        return str;
+    }
+
+    while ((*p == ' ') || (*p == '\t')) {
+        ++p;
+    }
+    if (*p == '-') {
+        ++p;
+        neg = TRUE;
+    } else {
+        neg = FALSE;
+    }
+    if (!IsDecDigit(*p)) {
+        return str;
+    }
+    if ((p[0] == '0') && (p[1] == 'x')) {
+        p += 2;
+        while (*p) {
+            OI_CHAR d = *p;
+            if (IsDecDigit(d)) {
+                n = (n * 16) + (d - '0');
+            } else if ((d >= 'a') && (d <= 'f')) {
+                n = (n * 16) + (10 + d - 'a');
+            } else if ((d >= 'A') && (d <= 'F')) {
+                n = (n * 16) + (10 + d - 'A');
+            } else {
+                break;
+            }
+            ++p;
+        }
+    } else {
+        while (*p) {
+            const OI_CHAR d = *p;
+            if (!IsDecDigit(d)) {
+                break;
+            }
+            n = (n * 10) + (d - '0');
+            ++p;
+        }
+    }
+    if (neg) {
+        *val = -(OI_INT32)(n);
+    } else {
+        *val = (OI_INT32)n;
+    }
+    return p;
+}
+
+
+const OI_CHAR* OI_ScanStr(const OI_CHAR *str,
+                          OI_CHAR *outStr,
+                          OI_UINT16 len)
+{
+    const OI_CHAR *p = str;
+    OI_UINT16 pos = 0;
+
+    if (!str || !len) {
+        return str;
+    }
+
+    while ((*p == ' ') || (*p == '\t')) {
+        ++p;
+    }
+    while ((++pos < len) && *p) {
+        *outStr++ = *p++;
+        if ((*p == ' ') || (*p == '\t')) {
+            break;
+        }
+    }
+    *outStr = 0;
+    if (1 == pos) {
+        return str;
+    } else {
+        return p;
+    }
+}
+
+
+const OI_CHAR* OI_ScanAlt(const OI_CHAR *str,
+                          const OI_CHAR *alts,
+                          OI_INT *index)
+{
+    const OI_CHAR *p = str;
+
+    if (!str || !alts || !index) {
+        return str;
+    }
+
+    *index = 0;
+
+    while ((*p == ' ') || (*p == '\t')) {
+        ++p;
+    }
+    while (TRUE) {
+        OI_UINT len = 0;
+        while (alts[len] && (alts[len] != '|')) {
+            ++len;
+        }
+        if (OI_StrncmpInsensitive(p, alts, len) == 0) {
+            return p + len;
+        }
+        if (!alts[len]) {
+            break;
+        }
+        alts += len + 1;
+        *index += 1;
+    }
+    *index = -1;
+    return str;
+}
+
+const OI_CHAR* OI_ScanAltExact(const OI_CHAR *str,
+                               const OI_CHAR *alts,
+                               OI_INT *index)
+{
+    const OI_CHAR *p = str;
+    OI_UINT        strLen;
+
+    if (!str || !alts || !index) {
+        return str;
+    }
+
+    *index = 0;
+
+    strLen = OI_StrLen(str);
+    while ((*p == ' ') || (*p == '\t')) {
+        ++p;
+    }
+    while (TRUE) {
+        OI_UINT len = 0;
+        while (alts[len] && (alts[len] != '|')) {
+            ++len;
+        }
+        if ((strLen == len) && (OI_Strncmp(p, alts, len) == 0)) {
+            return p + len;
+        }
+        if (!alts[len]) {
+            break;
+        }
+        alts += len + 1;
+        *index += 1;
+    }
+    *index = -1;
+    return str;
+}
+
+
+
+/** Convert a string to an integer.
+ *
+ * @param str  The string to parse.
+ *
+ * @return The integer value of the string or 0 if the string could not be parsed.
+ */
+OI_INT OI_atoi(const OI_CHAR *str)
+{
+    OI_INT32 i;
+
+    if (str == OI_ScanInt(str, &i)) {
+        return 0;
+    }
+    else {
+        return (OI_INT)i;
+    }
+}
+
+
+OI_UINT OI_Strlcpy(OI_CHAR *pDest, OI_CHAR const *pStr, OI_UINT len)
+{
+    OI_CHAR *p = pDest;
+
+    if (len != 0) {
+        while (*pStr && --len) {
+            *p++ = *pStr++;
+        }
+        *p = 0;
+    }
+    while (*pStr++) {
+        ++p;
+    }
+    return (OI_UINT)(p - pDest);
+}
+
+OI_UINT OI_Strlcat(OI_CHAR *pDest, OI_CHAR const *pStr, OI_UINT len)
+{
+    OI_CHAR *p = pDest;
+
+    if (len != 0) {
+        while (*p && --len) {
+            ++p;
+        }
+        if (len != 0) {
+            while (*pStr && --len) {
+                *p++ = *pStr++;
+            }
+            *p = 0;
+        }
+    }
+    while (*pStr++) {
+        ++p;
+    }
+    return (OI_UINT)(p - pDest);
+}
+
+#ifndef OI_USE_NATIVE_MEMCPY
+
+OI_UINT OI_StrLen(OI_CHAR const *pStr)
+{
+    OI_UINT len = 0;
+
+    while (pStr[len] != 0) {
+        ++len;
+    }
+    return(len);
+}
+
+
+OI_INT OI_Strcmp(OI_CHAR const *p1,
+                 OI_CHAR const *p2)
+{
+    OI_ASSERT(p1 != NULL);
+    OI_ASSERT(p2 != NULL);
+
+    for (;;) {
+        if (*p1 < *p2) return -1;
+        if (*p1 > *p2) return 1;
+        if (*p1 == '\0') return 0;
+        p1++;
+        p2++;
+    }
+}
+
+OI_INT OI_Strncmp(OI_CHAR const *p1,
+                  OI_CHAR const *p2,
+                  OI_UINT32      len)
+{
+    OI_ASSERT(p1 != NULL);
+    OI_ASSERT(p2 != NULL);
+    while (len--) {
+        if (*p1 < *p2) return -1;
+        if (*p1 > *p2) return 1;
+        if (*p1 == '\0') return 0;
+        p1++;
+        p2++;
+    }
+    return 0;
+}
+#endif /*  ifndef OI_USE_NATIVE_MEMCPY */
+
+
+OI_INT OI_StrcmpInsensitive(OI_CHAR const *p1,
+                            OI_CHAR const *p2)
+{
+    OI_ASSERT(p1 != NULL);
+    OI_ASSERT(p2 != NULL);
+
+    for (;;) {
+        OI_CHAR uc1 = OI_toupper(*p1);
+        OI_CHAR uc2 = OI_toupper(*p2);
+        if (uc1 < uc2) return -1;
+        if (uc1 > uc2) return 1;
+        if (uc1 == '\0') return 0;
+        p1++;
+        p2++;
+    }
+}
+
+
+OI_INT OI_StrncmpInsensitive(OI_CHAR const *p1,
+                             OI_CHAR const *p2,
+                             OI_UINT        len)
+{
+    OI_ASSERT(p1 != NULL);
+    OI_ASSERT(p2 != NULL);
+
+    while (len--) {
+        OI_CHAR uc1 = OI_toupper(*p1);
+        OI_CHAR uc2 = OI_toupper(*p2);
+        if (uc1 < uc2) return -1;
+        if (uc1 > uc2) return 1;
+        if (uc1 == '\0') return 0;
+        p1++;
+        p2++;
+    }
+    return 0;
+}
+
+
+void OI_StrToUpper(OI_CHAR *str) {
+    OI_INT i;
+
+    for (i = 0; i < (OI_INT)OI_StrLen(str); i++) {
+        str[i] = OI_toupper(str[i]);
+    }
+}
+
+
+/*****************************************************************************/
+/* Parses BD_ADDR from a string of 12 hex digits, optionally separated by colons:
+   "xxxxxxxxxxxx"
+   OR
+   "xx:xx:xx:xx:xx:xx"
+   */
+
+#define OI_isdigit(c)   ( ((c) >= '0') && ((c) <= '9') ? TRUE : FALSE)
+
+
+static OI_BOOL xCharToBin(OI_BYTE  c,
+                          OI_UINT *pBin)
+{
+
+    if ((c >= '0') && (c <= '9')) {
+        *pBin = c - '0';
+        return TRUE;
+    }
+    else if ((c >= 'a') && (c <= 'f')) {
+        *pBin = c - 'a' + 10;
+        return TRUE;
+    }
+    else if ((c >= 'A') && (c <= 'F')) {
+        *pBin = c - 'A' + 10;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+
+static OI_BOOL hex2_2_bin(const OI_BYTE *hexStr,
+                          OI_UINT8 *pBin)
+{
+    OI_UINT loNibble;
+    OI_UINT hiNibble;
+
+    if (xCharToBin(hexStr[0], &hiNibble) && xCharToBin(hexStr[1], &loNibble)) {
+        *pBin = (OI_UINT8)((hiNibble << 4) + loNibble);
+        return TRUE;
+    }
+    return FALSE;
+}
+
+
+const OI_CHAR* OI_ScanBdAddr(const OI_CHAR *str,
+                             OI_BD_ADDR *addr)
+{
+    const OI_CHAR *p = str;
+    OI_INT i;
+
+    if (!addr || !str) {
+        return str;
+    }
+    /* strip leading white space */
+    while ((*p == ' ') || (*p == '\t')) {
+        ++p;
+    }
+
+    for (i = 0; i < OI_BD_ADDR_BYTE_SIZE; ++i) {
+        if (!hex2_2_bin((const OI_BYTE *)p, &addr->addr[i])) {
+            return str;
+        }
+        p += 2;
+        if (':' == *p) {
+            ++p;
+        }
+    }
+    return p;
+}
+
+
+OI_BOOL OI_ParseBdAddr(const OI_CHAR *str,
+                       OI_BD_ADDR *addr)
+
+{
+    return OI_ScanBdAddr(str, addr) != str;
+}
+
+void OI_RemoveNewlines(OI_CHAR *str)
+{
+    OI_UINT i = 0;
+
+    OI_ASSERT(str != NULL);
+    OI_ASSERT(OI_StrLen(str) >= 1);
+
+    /* Replace newline on the end with null */
+    if ( (str[OI_StrLen(str) - 1] == '\n') ||
+         (str[OI_StrLen(str) - 1] == '\r') )
+    {
+        str[OI_StrLen(str) - 1] = '\0';
+    }
+
+    /* Replace newlines in the middle with space */
+    for (i = 0; i < (OI_StrLen(str)); i++) {
+        if ( (str[i] == '\n') ||
+             (str[i] == '\r') )
+        {
+            str[i] = ' ';
+        }
+    }
+}
+
+
+/**
+ * Terminate a UTF8 string.
+ *
+ *  This function terminates or truncates a UTF8 string at a maximum length with a
+ *  null-terminator.  The function ensures termination/truncation does not occur
+ *  in the middle of a multi-byte sequence.  As such, the final length may be
+ *  shorter than than the requested maxLen.
+ *
+ *  @note - null-termination occurs 'in place', termination alters callers string.
+ *
+ * @param pStr      pointer to UTF8 string
+ *
+ * @param maxLen    requested maximum length of string after truncation
+ *
+ * @return          returns actual length of string after truncation, i.e. strlen(pStr)
+ *
+ */
+OI_UINT OI_UTF8_Terminate(OI_UTF8 *pStr, OI_UINT maxLen)
+{
+    OI_UINT curLen;
+    OI_UINT i;
+
+    if (NULL == pStr) {
+        OI_SLOG_ERROR(OI_STATUS_INVALID_PARAMETERS, ("pStr is NULL"));
+        return 0;
+    }
+    /*
+     *  First check if string is already appropriately null-terminated.  Don't use
+     *  strlen() because the string may not be null terminated.
+     */
+    curLen = 0;
+    while ((pStr[curLen] != 0) && (curLen <= maxLen)) {
+        ++curLen;
+    }
+    if (curLen <= maxLen) {
+        return curLen;
+    }
+
+    /* string is not null-terminated within maxLen */
+
+    i = maxLen;             /* index of byte we're going to stomp on */
+
+    if (pStr[i] > 0x7F) {
+        /*
+         *  Last byte is non 7bit ASCII, so it part of a multi-byte sequence.
+         *  Work backwards until we find start of sequence, indicated by byte
+         *  with the 2 high-order bits set.
+         */
+
+        while ((i > 0) && (pStr[i] < 0xC0)) {
+            i--;
+        }
+    }
+    pStr[i] = 0;
+
+    OI_ASSERT(OI_StrLen((OI_CHAR*)pStr) == (i));
+    return (i);
+}
diff --git a/obex_profiles/stack/support/oi_varstring.c b/obex_profiles/stack/support/oi_varstring.c
new file mode 100644
index 0000000..1738c4f
--- /dev/null
+++ b/obex_profiles/stack/support/oi_varstring.c
@@ -0,0 +1,1062 @@
+/**
+* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+This file implements the functionality defined in oi_varstring.h.
+*/
+
+#define __OI_MODULE__ OI_MODULE_SUPPORT
+
+#include "oi_assert.h"
+#include "oi_varstring.h"
+#include "oi_text.h"
+#include "oi_utils.h"
+#include "oi_statustext.h"
+#include "oi_dataelem_text.h"
+#include "oi_memmgr.h"
+#include "oi_xml.h"
+#include "oi_bytestream.h"
+#include "oi_unicodestream.h"
+#include "oi_unicode.h"
+#include "oi_obextext.h"
+
+#include "../unicode/ConvertUTF.h"
+
+#define VSTRING_INCREMENT_SIZE    32
+
+
+#define MAX_HEX_LEN            16*10
+
+static const OI_CHAR digits[] = "0123456789ABCDEF";
+
+static OI_STATUS UnsignedCat(OI_VARSTRING *VStr,
+                             OI_UINT32 val);
+
+
+/**
+ * Allocate an initialize an empty managed VarString
+ */
+OI_STATUS OI_VStrAlloc(OI_VARSTRING *VStr,
+                       OI_UINT       Size)
+{
+    VStr->Managed = TRUE;
+    VStr->Len = 0;
+    VStr->Buffer = OI_Malloc(Size);
+    VStr->Overflow = FALSE;
+    if (VStr->Buffer == NULL) {
+        VStr->MaxLen = 0;
+        return OI_STATUS_OUT_OF_MEMORY;
+    } else {
+        VStr->MaxLen = Size;
+        return OI_OK;
+    }
+}
+
+
+/**
+ * Free the string buffer for a managed varstring.
+ */
+void OI_VStrFree(OI_VARSTRING *VStr)
+{
+    OI_ASSERT(VStr->Managed);
+
+    OI_Free(VStr->Buffer);
+    VStr->Buffer = NULL;
+    VStr->MaxLen = 0;
+}
+
+
+static OI_BOOL StrRealloc(OI_VARSTRING *VStr)
+{
+    OI_CHAR* buffer;
+    OI_UINT16 i;
+
+    OI_ASSERT(VStr->Buffer != NULL);
+    OI_ASSERT(VStr->Managed);
+
+    buffer = OI_Malloc(VStr->MaxLen + VSTRING_INCREMENT_SIZE);
+    if (buffer == NULL) {
+        return FALSE;
+    }
+    for (i = 0; i < VStr->Len; ++i) {
+        buffer[i] = VStr->Buffer[i];
+    }
+    OI_Free(VStr->Buffer);
+    VStr->Buffer = buffer;
+    VStr->MaxLen += VSTRING_INCREMENT_SIZE;
+    return TRUE;
+}
+
+
+OI_STATUS OI_VStrnCat(OI_VARSTRING  *VStr,
+                      const OI_CHAR *Str,
+                      OI_UINT        len)
+{
+    if (Str && len) {
+        while (len-- && *Str) {
+            if (VStr->Len == (VStr->MaxLen - 1)) {
+                if (!VStr->Managed) {
+                    VStr->Overflow = TRUE;
+                    return OI_OK; /* String is truncated */
+                }
+                if (VStr->Overflow == FALSE) {
+                    if (!StrRealloc(VStr)) {
+                        VStr->Overflow = TRUE;
+                        return OI_STATUS_OUT_OF_MEMORY;
+                    }
+                }
+            }
+            VStr->Buffer[VStr->Len++] = *Str++;
+        }
+    }
+    return OI_OK;
+}
+
+
+OI_STATUS OI_VStrCat(OI_VARSTRING *VStr,
+                     const OI_CHAR *Str)
+{
+    if (Str) {
+        while (*Str ) {
+            if (VStr->Len == (VStr->MaxLen - 1)) {
+                if (!VStr->Managed) {
+                    VStr->Overflow = TRUE;
+                    return OI_OK; /* String is truncated */
+                }
+                if (VStr->Overflow == FALSE) {
+                    if (!StrRealloc(VStr)) {
+                        VStr->Overflow = TRUE;
+                        return OI_STATUS_OUT_OF_MEMORY;
+                    }
+                }
+            }
+            VStr->Buffer[VStr->Len++] = *Str++;
+        }
+    }
+    return OI_OK;
+}
+
+
+OI_STATUS OI_VStrCatAT(OI_VARSTRING *VStr,
+                       const OI_CHAR *Str)
+{
+    if (Str) {
+        while (*Str) {
+            if (VStr->Len == (VStr->MaxLen - 1)) {
+                if (!VStr->Managed) {
+                    VStr->Overflow = TRUE;
+                    return OI_OK; /* String is truncated */
+                }
+                if (VStr->Overflow == FALSE) {
+                    if (!StrRealloc(VStr)) {
+                        VStr->Overflow = TRUE;
+                        return OI_STATUS_OUT_OF_MEMORY;
+                    }
+                }
+            }
+            if (*Str == '\r') {
+                OI_VStrCat(VStr, "<cr>");
+            } else if (*Str == '\n') {
+                OI_VStrCat(VStr, "<lf>");
+            } else {
+                VStr->Buffer[VStr->Len++] = *Str;
+            }
+            ++Str;
+        }
+    }
+    return OI_OK;
+}
+
+
+OI_STATUS OI_VStrnCatAT(OI_VARSTRING  *VStr,
+                        const OI_CHAR *Str,
+                        OI_UINT        len)
+{
+    if (Str && len) {
+        while (len--) {
+            if (VStr->Len == (VStr->MaxLen - 1)) {
+                if (!VStr->Managed) {
+                    VStr->Overflow = TRUE;
+                    return OI_OK; /* String is truncated */
+                }
+                if (VStr->Overflow == FALSE) {
+                    if (!StrRealloc(VStr)) {
+                        VStr->Overflow = TRUE;
+                        return OI_STATUS_OUT_OF_MEMORY;
+                    }
+                }
+            }
+            if (*Str == '\r') {
+                OI_VStrCat(VStr, "<cr>");
+            } else if (*Str == '\n') {
+                OI_VStrCat(VStr, "<lf>");
+            } else if (*Str == '\0') {
+                OI_VStrCat(VStr, "<null>");
+			} else {
+                VStr->Buffer[VStr->Len++] = *Str;
+            }
+            ++Str;
+        }
+    }
+    return OI_OK;
+}
+
+
+OI_STATUS OI_VSpaceCat(OI_VARSTRING *VStr,
+                       OI_UINT       Count)
+{
+    while (Count--) {
+        if (VStr->Len == (VStr->MaxLen - 1)) {
+            if (!VStr->Managed) {
+                VStr->Overflow = TRUE;
+                return OI_OK; /* String is truncated */
+            }
+            if (VStr->Overflow == FALSE) {
+                if (!StrRealloc(VStr)) {
+                    VStr->Overflow = TRUE;
+                    return OI_STATUS_OUT_OF_MEMORY;
+                }
+            }
+        }
+        VStr->Buffer[VStr->Len++] = ' ';
+    }
+    return OI_OK;
+}
+
+
+/*
+ * Hex integer text
+ *
+ * Size is the number of digits - writes leading zeroes
+ */
+
+OI_STATUS OI_VHexCat(OI_VARSTRING *VStr,
+                     OI_UINT32 Val,
+                     OI_UINT Size)
+{
+    OI_CHAR hex[9];
+    OI_CHAR *t;
+
+    /*
+     * Override invalid size specification
+     */
+    if ((Size < 1) || (Size > (2 * sizeof(OI_UINT32)))) {
+        Size = 2 * sizeof(OI_UINT32);
+    }
+
+    t = &hex[sizeof(hex) - 1];
+    *t =0;
+
+    do {
+        --t;
+        *t = digits[(Val & 0xF)];
+        Val >>= 4;
+    } while (--Size);
+    return OI_VStrCat(VStr, t);
+}
+
+
+/*
+ * Decimal integer text
+ */
+
+OI_STATUS OI_VDecCat(OI_VARSTRING *VStr,
+                     OI_INT32 Val)
+{
+    OI_CHAR dec[12];
+    OI_CHAR *t;
+
+    if (Val == OI_INT32_MIN) {
+        return OI_VStrCat(VStr, "-2147483648");
+    }
+    if (Val < 0) {
+        OI_VStrCat(VStr, "-");
+        Val = -Val;
+    }
+    t = &dec[sizeof(dec) - 1];
+    *t = 0;
+
+    do {
+        OI_UINT32 div = Val / 10;
+        OI_UINT32 rem = Val - div * 10;
+        --t;
+        *t = digits[rem];
+        Val = div;
+    } while (Val != 0);
+    return OI_VStrCat(VStr, t);
+}
+
+/*
+ * Time text
+ */
+
+static OI_STATUS TimeCat(OI_VARSTRING *VStr,
+                         OI_TIME *time)
+{
+    OI_TIME now;
+    OI_CHAR *decimal;
+    OI_UINT32 secs;
+    OI_UINT32 msecs;
+
+    if (NULL == time) {
+        OI_Time_Now(&now);
+        time = &now;
+    }
+
+    secs = time->seconds & 0x1FFF;
+    msecs = time->mseconds;
+    if (msecs < 10) {
+        decimal = ".00";
+    } else if (msecs < 100) {
+        decimal = ".0";
+    } else {
+        decimal = ".";
+    }
+
+    UnsignedCat(VStr, secs);
+    OI_VStrCat(VStr, decimal);
+    return UnsignedCat(VStr, msecs);
+}
+
+/*
+ * Unsigned decimal integer text
+ */
+
+static OI_STATUS UnsignedCat(OI_VARSTRING *VStr,
+                             OI_UINT32 val)
+{
+    OI_CHAR dec[11];
+    OI_CHAR *t;
+
+    t = &dec[sizeof(dec)-1];
+    *t = 0;
+
+    do {
+        OI_UINT32 div = val / 10;
+        OI_UINT32 rem = val - div * 10;
+        --t;
+        *t = digits[rem];
+        val = div;
+    } while (val != 0);
+    return OI_VStrCat(VStr, t);
+}
+
+
+/**
+ * conversion of wide characters to ASCII
+ */
+static OI_STATUS StrnCat16(OI_VARSTRING    *VStr,
+                           const OI_CHAR16 *Str,
+                           OI_UINT          len)
+{
+    OI_UTF8 *buf;
+    OI_UTF8 *bufEnd;
+    const OI_UTF16 *srcEnd;
+    ConversionResult res = conversionOK;
+
+    if (Str) {
+        OI_UINT stringLength = OI_StrLenUtf16(Str);
+
+        srcEnd = &Str[OI_MIN(stringLength, len)];
+        do {
+            buf = (OI_UTF8*)&VStr->Buffer[VStr->Len];
+            bufEnd = (OI_UTF8*)&VStr->Buffer[VStr->MaxLen - 1];
+
+            res = ConvertUTF16toUTF8(&Str, srcEnd, &buf, bufEnd, strictConversion);
+            VStr->Len = (VStr->MaxLen - 1) - (bufEnd - buf);
+
+            if (res == targetExhausted) {
+                if (!VStr->Managed) {
+                    VStr->Overflow = TRUE;
+                    return OI_OK; /* String is truncated */
+                }
+                if (VStr->Overflow == FALSE) {
+                    if (!StrRealloc(VStr)) {
+                        VStr->Overflow = TRUE;
+                        return OI_STATUS_OUT_OF_MEMORY;
+                    }
+                }
+            }
+        } while (res == targetExhausted);
+
+        if (res != conversionOK) {
+            return OI_FAIL;
+        }
+    }
+
+    return OI_OK;
+}
+
+
+#define StrCat16(_vstr, _str) StrnCat16((_vstr), (_str), OI_UINT16_MAX)
+
+
+static OI_STATUS PStrcat(OI_VARSTRING *VStr,
+                         OI_PSTR *str,
+                         OI_UNICODE_ENCODING encoding)
+{
+    OI_UNICODE_STREAM bs;
+    OI_UINT32 ch = 0;
+    OI_STATUS result;
+
+    if (encoding > OI_UNICODE_UTF16_BE) {
+        return OI_STRING_FORMAT_ERROR;
+    }
+    if (!str->sz) {
+        return OI_OK;
+    }
+
+    UnicodeStream_Init(bs, str->p, str->sz, encoding);
+    ByteStream_Open(bs, BYTESTREAM_READ);
+    while (ByteStream_NumReadBytesAvail(bs)) {
+        UnicodeStream_GetChar(bs, ch);
+        if (ch < 0xff) {
+            if (VStr->Len == (VStr->MaxLen - 1)) {
+                if (!VStr->Managed) {
+                    VStr->Overflow = TRUE;
+                    return OI_OK; /* String is truncated */
+                }
+                if (VStr->Overflow == FALSE) {
+                    if (!StrRealloc(VStr)) {
+                        VStr->Overflow = TRUE;
+                        return OI_STATUS_OUT_OF_MEMORY;
+                    }
+                }
+            }
+            VStr->Buffer[VStr->Len++] = (OI_CHAR) (ch & 0xFF);
+        } else {
+            if (VStr->Len == (VStr->MaxLen - 7)) {
+                if (!VStr->Managed) {
+                    VStr->Overflow = TRUE;
+                    return OI_OK; /* String is truncated */
+                }
+                if (VStr->Overflow == FALSE) {
+                    if (!StrRealloc(VStr)) {
+                        VStr->Overflow = TRUE;
+                        return OI_STATUS_OUT_OF_MEMORY;
+                    }
+                }
+            }
+            VStr->Buffer[VStr->Len++] = '\\';
+            result = OI_VHexCat(VStr, ch, 6);
+            if (!OI_SUCCESS(result)) {
+                return result;
+            }
+        }
+    }
+    return OI_OK;
+}
+
+static OI_INT UnsignedChars(OI_UINT32 val)
+{
+    OI_INT digits = 0;
+
+    do {
+        val /= 10;
+        ++digits;
+    } while (val != 0);
+    return digits;
+}
+
+
+/**
+ * Defines for ANSI color strings. These are used by OI_Printf to implement the %[ format option.
+ */
+#define ANSI_COLOR_BLACK       "\033[0;30m"
+#define ANSI_COLOR_RED         "\033[0;31m"
+#define ANSI_COLOR_GREEN       "\033[0;32m"
+#define ANSI_COLOR_YELLOW      "\033[0;33m"
+#define ANSI_COLOR_BLUE        "\033[0;34m"
+#define ANSI_COLOR_MAGENTA     "\033[0;35m"
+#define ANSI_COLOR_CYAN        "\033[0;36m"
+#define ANSI_COLOR_LT_GRAY     "\033[0;37m"
+#define ANSI_COLOR_DK_GRAY     "\033[1;30m"
+#define ANSI_COLOR_BR_RED      "\033[1;31m"
+#define ANSI_COLOR_BR_GREEN    "\033[1;32m"
+#define ANSI_COLOR_BR_YELLOW   "\033[1;33m"
+#define ANSI_COLOR_BR_BLUE     "\033[1;34m"
+#define ANSI_COLOR_BR_MAGENTA  "\033[1;35m"
+#define ANSI_COLOR_BR_CYAN     "\033[1;36m"
+#define ANSI_COLOR_WHITE       "\033[1;37m"
+#define ANSI_COLOR_DEFAULT     "\033[0;39;49m"
+
+
+
+/*
+ * Full version of VFormatStr
+ */
+OI_STATUS OI_VFormatStr(OI_VARSTRING *VStr,
+                        const OI_CHAR* format,
+                        va_list argp)
+{
+    const OI_CHAR *p;
+    OI_INT16 size, precision;
+    OI_BOOL isLong;
+    OI_BOOL hasPrecision;
+    OI_BOOL moreFmt;
+    OI_BOOL hasVarLen;
+    OI_BOOL zeroPad;
+    OI_BOOL prefixSign;
+
+    for (p = format; *p != 0; p++) {
+
+        if (VStr->Len == (VStr->MaxLen - 1)) {
+            if (!VStr->Managed) {
+                VStr->Overflow = TRUE;
+                return OI_OK; /* String is truncated */
+            }
+            if (VStr->Overflow == FALSE) {
+                if (!StrRealloc(VStr)) {
+                    VStr->Overflow = TRUE;
+                    return OI_STATUS_OUT_OF_MEMORY;
+                }
+            }
+        }
+
+        if (*p != '%') {
+            VStr->Buffer[VStr->Len++] = *p;
+            continue;
+        }
+
+        moreFmt = TRUE;
+        size = 0;
+        precision = 0;
+        hasPrecision = FALSE;
+        hasVarLen = FALSE;
+        isLong = FALSE;
+        zeroPad = FALSE;
+        prefixSign = FALSE;
+
+        while (moreFmt) {
+            switch (*++p) {
+                case '+':
+                    prefixSign = TRUE;
+                    break;
+                case 'l':
+                    if ((p[1] != 'd') && (p[1] != 'x') && (p[1] != 's') && (p[1] != 'c') && (p[1] != 'u') && (p[1] != 'b')) {
+                        return OI_STRING_FORMAT_ERROR;
+                    }
+                    isLong = TRUE;
+                    break;
+                case '#':
+                    OI_VStrCat(VStr, "0x");
+                    break;
+                case '.':
+                    hasPrecision = TRUE;
+                    break;
+                case '0':
+                    if (!hasPrecision && (0 == size)) {
+                        zeroPad = TRUE;
+                    }
+                    /* fall through */
+                case '1':
+                case '2':
+                case '3':
+                case '4':
+                case '5':
+                case '6':
+                case '7':
+                case '8':
+                case '9':
+                    if (hasPrecision)
+                        precision = precision * 10 + (*p - '0');
+                    else
+                        size = size * 10 + (*p - '0');
+                    break;
+                case 'b': /* binary */
+                    {
+                        OI_UINT32 i;
+                        OI_UINT32 b = 0x80000000;
+                        if (isLong) {
+                            i  = (OI_UINT32) va_arg(argp, OI_UINT32);
+                        } else {
+                            i  = (OI_UINT32) va_arg(argp, OI_UINT);
+                        }
+                        if (hasVarLen) {
+                            hasVarLen = FALSE;
+                            size = (OI_UINT16)va_arg(argp, OI_UINT);
+                            if (size > 32) {
+                                return OI_STRING_FORMAT_ERROR;
+                            }
+                        } else if (size == 0) {
+                            size = isLong ? 8 * sizeof(OI_UINT32) : 8 * sizeof(OI_UINT);
+
+                        }
+                        if (size > 0) {
+                            b >>= 32 - size;
+                            while (b) {
+                                OI_VStrCat(VStr, (b & i) ? "1" : "0");
+                                b >>= 1;
+                            }
+                        }
+                        moreFmt = FALSE;
+                    }
+                    break;
+                case 'B': /* boolean */
+                    if (va_arg(argp, OI_UINT)) {
+                        OI_VStrCat(VStr, "TRUE");
+                    } else {
+                        OI_VStrCat(VStr, "FALSE");
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case 'c':
+                    VStr->Buffer[VStr->Len++] = (OI_CHAR) va_arg(argp, OI_UINT);
+                    moreFmt = FALSE;
+                    break;
+                case 'd':
+                    {
+                        OI_INT32 i;
+                        OI_UINT32 ui;
+                        OI_CHAR *sign = NULL;
+
+                        if (isLong) {
+                            i  = (OI_INT32) va_arg(argp, OI_INT32);
+                        } else {
+                            i  = (OI_INT32) va_arg(argp, OI_INT);
+                        }
+                        if (i < 0) {
+                            i = -i;
+                            sign = "-";
+                            --size;
+                        } else if (prefixSign) {
+                            sign = "+";
+                            --size;
+                        }
+                        ui = (OI_UINT32)i;
+                        do {
+                            ui /= 10;
+                            --size;
+                        } while ((size > 0) && (ui != 0));
+
+                        if (size > 0) {
+                            if (zeroPad) {
+                                OI_VStrCat(VStr, sign);
+                                OI_VStrnCat(VStr, "000000000000000", size);
+                            } else {
+                                OI_VSpaceCat(VStr, size);
+                                OI_VStrCat(VStr, sign);
+                            }
+                        } else {
+                            OI_VStrCat(VStr, sign);
+                        }
+                        UnsignedCat(VStr, (OI_UINT32)i);
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case 'u':
+                    {
+                        OI_UINT32 i;
+                        if (isLong) {
+                            i  = (OI_UINT32) va_arg(argp, OI_UINT32);
+                        } else {
+                            i  = (OI_UINT32) va_arg(argp, OI_UINT);
+                        }
+                        if (size > 0) {
+                            OI_INT pad = size - UnsignedChars(i);
+                            if (pad > 0) {
+                                OI_VSpaceCat(VStr, pad);
+                            }
+                        }
+                        UnsignedCat(VStr, i);
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case '?':   /* The next value will be followed by a length */
+                    hasVarLen = TRUE;
+                    break;
+                case 's':
+                    if (!isLong) {
+                        if (hasVarLen || (0 < size) || (0 < precision)) {
+                            OI_CHAR *str = va_arg(argp, OI_CHAR*);
+                            OI_UINT16 minLen, maxLen;
+                            OI_UINT16 len;
+
+                            if (hasVarLen) {
+                                minLen = 0;
+                                maxLen = (OI_UINT16)va_arg(argp, OI_UINT);
+                            }
+                            else {
+                                minLen = size;
+                                maxLen = precision;
+                            }
+
+                            OI_ASSERT((minLen <= maxLen) || (0 == maxLen));
+
+                            if (!str) {
+                                str = "(null)";
+                            }
+                            if (maxLen) {
+                                OI_VStrnCat(VStr, str, maxLen);
+                            }
+                            else if (hasVarLen) {
+                                OI_VStrCat(VStr, "(empty)");
+                            } else {
+                                OI_VStrCat(VStr, str);
+                            }
+
+                            len = OI_StrLen(str);
+                            if (len < minLen) {
+                                OI_VSpaceCat(VStr, minLen-len);
+                            }
+                        } else {
+                            OI_CHAR *str = va_arg(argp, OI_CHAR*);
+                            if (!str) {
+                                OI_VStrCat(VStr, "(null)");
+                            } else {
+                                OI_VStrCat(VStr, str);
+                            }
+                        }
+                        moreFmt = FALSE;
+                        hasVarLen = FALSE;
+                        break;
+                    }
+                    /* falling through */
+                case 'S':
+                    if (hasVarLen) {
+                        OI_CHAR16* str = va_arg(argp, OI_CHAR16*);
+                        OI_UINT16 len = (OI_UINT16)va_arg(argp, OI_UINT);
+                        if (!str) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else if (len == 0) {
+                            OI_VStrCat(VStr, "(empty)");
+                        } else {
+                            StrnCat16(VStr, str, len);
+                        }
+                    } else {
+                        OI_CHAR16* str = va_arg(argp, OI_CHAR16*);
+                        if (!str) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else {
+                            StrCat16(VStr, str);
+                        }
+                    }
+                    moreFmt = FALSE;
+                    hasVarLen = FALSE;
+                    break;
+
+                case 'T': /* Time string */ 
+                    {
+                        OI_TIME *pTime;
+
+                        pTime = (OI_TIME*) va_arg(argp, OI_TIME*);
+                        TimeCat(VStr, pTime);
+                    }                        
+                    moreFmt = FALSE;
+                    break;
+
+                case 'a': /* AT string */
+                    if (hasVarLen) {
+                        OI_CHAR *str = va_arg(argp, OI_CHAR*);
+                        OI_UINT16 len = (OI_UINT16)va_arg(argp, OI_UINT);
+                        if (!str) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else if (len == 0) {
+                            OI_VStrCat(VStr, "(empty)");
+                        } else {
+                            OI_VStrnCatAT(VStr, str, len);
+                        }
+                    } else {
+                        OI_CHAR *str = va_arg(argp, OI_CHAR*);
+                        if (!str) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else {
+                            OI_VStrCatAT(VStr, str);
+                        }
+                    }
+                    moreFmt = FALSE;
+                    hasVarLen = FALSE;
+                    break;
+                case '/': /* base file name */
+                    {
+                        OI_CHAR *s = va_arg(argp, OI_CHAR*);
+                        OI_CHAR *f = s;
+                        if (s == NULL) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else {
+                            while (*s) {
+                                if ((*s == '/') || (*s == '\\')) {
+                                    f = s + 1;
+                                }
+                                ++s;
+                            }
+                        }
+                        OI_VStrCat(VStr, f);
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case 'x':
+                    if (size == 0) {
+                        size = 8; /* default */
+                    }
+                    if (isLong) {
+                        OI_VHexCat(VStr, va_arg(argp, OI_UINT32), size);
+                    } else {
+                        OI_VHexCat(VStr, (OI_UINT32) va_arg(argp, OI_UINT), size);
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case '^':
+                    {
+                        OI_DATAELEM *elem = va_arg(argp, OI_DATAELEM *);
+                        if (!elem) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else {
+                            OI_DataElement_XML(VStr, elem, 0);
+                        }
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case '=':
+                    {
+                        OI_OBEX_HEADER *hdr = va_arg(argp, OI_OBEX_HEADER *);
+                        if (!hdr) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else {
+                            if (hasVarLen) {
+                                hasVarLen = FALSE;
+                                size = (OI_UINT16)va_arg(argp, OI_UINT);
+                                if (size == 0) {
+                                    OI_VStrCat(VStr, "(null)");
+                                }
+                            } else {
+                                size = 1;
+                            }
+                            while (size--) {
+                                OI_OBEX_HeaderTxt(VStr, hdr);
+                                if (size > 0) {
+                                    OI_VSpaceCat(VStr, 1);
+                                }
+                                ++hdr;
+                            }
+                        }
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case '%':
+                    VStr->Buffer[VStr->Len++] = '%';
+                    moreFmt = FALSE;
+                    break;
+                case '!': /* Format status */
+                    OI_VStrCat(VStr, OI_StatusText((OI_STATUS)va_arg(argp, OI_UINT)));
+                    moreFmt = FALSE;
+                    break;
+                case ':': /* Format BD_ADDR */
+                    {
+                        OI_BD_ADDR *bdAddr;
+                        OI_UINT i;
+
+                        bdAddr = va_arg(argp, OI_BD_ADDR *);
+                        if (bdAddr == NULL) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else {
+                            for (i = 0; i < OI_BD_ADDR_BYTE_SIZE; ++i) {
+                                if (i != 0) {
+                                    OI_VStrCat(VStr, ":");
+                                }
+                                OI_VHexCat(VStr, bdAddr->addr[i], 2 * sizeof(OI_UINT8));
+                            }
+                        }
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case '~': /* UTF encoded Pascal-style string */
+                    {
+                        OI_PSTR* str = va_arg(argp, OI_PSTR*);
+                        OI_UNICODE_ENCODING encoding = (OI_UNICODE_ENCODING)va_arg(argp, OI_UINT);
+                        if (!str) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else {
+                            PStrcat(VStr, str, encoding);
+                        }
+                    }
+                    moreFmt = FALSE;
+                    break;
+   
+                case '@': /* Format hex */
+                    {
+                        OI_BYTE *hex = va_arg(argp, OI_BYTE*);
+                        OI_INT len = va_arg(argp, OI_INT);
+                        OI_INT i;
+
+                        if (!hex) {
+                            OI_VStrCat(VStr, "(null)");
+                        } else {
+                            /* Sanity check */
+                            if ((len < 0) || (len > 32768)) {
+                                return OI_STATUS_INVALID_PARAMETERS;
+                            }
+                            if (size == 0) {
+                                size = 16; /* default */
+                            }
+                            for (i = 0; i < len; ++i) {
+                                if (i && (i % size) == 0) {
+                                    OI_VStrCat(VStr, "\n");
+                                }
+                                if (i == MAX_HEX_LEN) {
+                                    OI_VStrCat(VStr, " ...");
+                                    break;
+                                }
+                                OI_VHexCat(VStr, hex[i], 2 * sizeof(OI_BYTE));
+                                OI_VSpaceCat(VStr, 1);
+                            }
+                            OI_VStrCat(VStr, "\n");
+                        }
+                    }
+                    moreFmt = FALSE;
+                    break;
+                case '[': /* ANSI color codes */
+                    {
+#ifdef OI_SUPPRESS_COLOR_PRINT
+                        (void)va_arg(argp, OI_UINT);
+#else 
+                        OI_CHAR *color;
+                        switch (va_arg(argp, OI_UINT)) {
+                            case '0':
+                                color = ANSI_COLOR_BLACK;
+                                break;
+                            case 'r':
+                                color = ANSI_COLOR_RED;
+                                break;
+                            case 'g':
+                                color = ANSI_COLOR_GREEN;
+                                break;
+                            case 'b':
+                                color = ANSI_COLOR_BLUE;
+                                break;
+                            case 'c':
+                                color = ANSI_COLOR_CYAN;
+                                break;
+                            case 'y':
+                                color = ANSI_COLOR_YELLOW;
+                                break;
+                            case 'm':
+                                color = ANSI_COLOR_MAGENTA;
+                                break;
+                            case 'W':
+                                color = ANSI_COLOR_WHITE;
+                                break;
+                            case 'R':
+                                color = ANSI_COLOR_BR_RED;
+                                break;
+                            case 'G':
+                                color = ANSI_COLOR_BR_GREEN;
+                                break;
+                            case 'B':
+                                color = ANSI_COLOR_BR_BLUE;
+                                break;
+                            case 'C':
+                                color = ANSI_COLOR_BR_CYAN;
+                                break;
+                            case 'Y':
+                                color = ANSI_COLOR_BR_YELLOW;
+                                break;
+                            case 'M':
+                                color = ANSI_COLOR_BR_MAGENTA;
+                                break;
+                            case 'l':
+                            case 'L':
+                                color = ANSI_COLOR_LT_GRAY;
+                                break;
+                            case 'd':
+                            case 'D':
+                                color = ANSI_COLOR_DK_GRAY;
+                                break;
+                            default:
+                                color = ANSI_COLOR_DEFAULT;
+                                break;
+                        }
+                        OI_VStrCat(VStr, color);
+#endif
+                        moreFmt = FALSE;
+                    }
+                    break;
+                default:
+                    return OI_STRING_FORMAT_ERROR;
+            }
+            if (size > 32) {
+                return OI_STRING_FORMAT_ERROR;
+            }
+        }
+    }
+    return OI_OK;
+}
+
+
+OI_STATUS OI_FormatStr(OI_VARSTRING *VStr,
+                       const OI_CHAR *format,
+                       ...)
+{
+    OI_STATUS status;
+    va_list argp;
+
+    va_start(argp, format);
+    status = OI_VFormatStr(VStr, format, argp);
+    va_end(argp);
+
+    return status;
+}
+
+
+/*
+ * Get null terminated string from a var string
+ */
+
+OI_CHAR* OI_VStrGetString(OI_VARSTRING *VStr)
+{
+    OI_ASSERT(VStr != NULL);
+    if (VStr->Buffer == NULL) {
+        return NULL;
+    } else {
+        OI_ASSERT(VStr->Len < VStr->MaxLen);
+        VStr->Buffer[VStr->Len] = 0;
+        return VStr->Buffer;
+    }
+}
+
+/**
+ * Compare a var string to a C string
+ */
+OI_INT OI_VStrcmp(OI_VARSTRING *VStr,
+                  const OI_CHAR *cStr)
+{
+    OI_ASSERT(VStr->Len < VStr->MaxLen);
+    VStr->Buffer[VStr->Len] = 0;
+    return OI_Strcmp(VStr->Buffer, cStr);
+}
+
+/**
+ * Compare a var string to a C string
+ */
+OI_INT OI_VStrncmp(OI_VARSTRING  *VStr,
+                   const OI_CHAR *cStr,
+                   OI_UINT        len)
+{
+    OI_ASSERT(VStr->Len < VStr->MaxLen);
+    VStr->Buffer[VStr->Len] = 0;
+    return OI_Strncmp(VStr->Buffer, cStr, (OI_UINT16)len);
+}
diff --git a/obex_profiles/unicode/ConvertUTF.c b/obex_profiles/unicode/ConvertUTF.c
new file mode 100644
index 0000000..9aff2d0
--- /dev/null
+++ b/obex_profiles/unicode/ConvertUTF.c
@@ -0,0 +1,539 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ *
+ * Disclaimer
+ *
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ *
+ * Limitations on Rights to Redistribute This Code
+ *
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+    Conversions between UTF32, UTF-16, and UTF-8. Source code file.
+    Author: Mark E. Davis, 1994.
+    Rev History: Rick McGowan, fixes & updates May 2001.
+    Sept 2001: fixed const & error conditions per
+        mods suggested by S. Parent & A. Lillich.
+    June 2002: Tim Dodd added detection and handling of incomplete
+        source sequences, enhanced error detection, added casts
+        to eliminate compiler warnings.
+    July 2003: slight mods to back out aggressive FFFE detection.
+    Jan 2004: updated switches in from-UTF8 conversions.
+    Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.
+
+    See the header file "ConvertUTF.h" for complete documentation.
+
+------------------------------------------------------------------------ */
+
+
+#include "ConvertUTF.h"
+#ifdef CVTUTF_DEBUG
+#include <stdio.h>
+#endif
+
+static const int halfShift  = 10; /* used for shifting by 10 bits */
+
+static const UTF32 halfBase = 0x0010000UL;
+static const UTF32 halfMask = 0x3FFUL;
+
+#define UNI_SUR_HIGH_START  (UTF32)0xD800
+#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
+#define UNI_SUR_LOW_START   (UTF32)0xDC00
+#define UNI_SUR_LOW_END     (UTF32)0xDFFF
+#define false      0
+#define true        1
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF32toUTF16 (
+        const UTF32** sourceStart, const UTF32* sourceEnd,
+        UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF32* source = *sourceStart;
+    UTF16* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch;
+        if (target >= targetEnd) {
+            result = targetExhausted; break;
+        }
+        ch = *source++;
+        if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
+            /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
+            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+                if (flags == strictConversion) {
+                    --source; /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                } else {
+                    *target++ = UNI_REPLACEMENT_CHAR;
+                }
+            } else {
+                *target++ = (UTF16)ch; /* normal case */
+            }
+        } else if (ch > UNI_MAX_LEGAL_UTF32) {
+            if (flags == strictConversion) {
+                result = sourceIllegal;
+            } else {
+                *target++ = UNI_REPLACEMENT_CHAR;
+            }
+        } else {
+            /* target is a character in range 0xFFFF - 0x10FFFF. */
+            if (target + 1 >= targetEnd) {
+                --source; /* Back up source pointer! */
+                result = targetExhausted; break;
+            }
+            ch -= halfBase;
+            *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+            *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+        }
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF16toUTF32 (
+        const UTF16** sourceStart, const UTF16* sourceEnd,
+        UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF16* source = *sourceStart;
+    UTF32* target = *targetStart;
+    UTF32 ch, ch2;
+    while (source < sourceEnd) {
+        const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */
+        ch = *source++;
+        /* If we have a surrogate pair, convert to UTF32 first. */
+        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
+            /* If the 16 bits following the high surrogate are in the source buffer... */
+            if (source < sourceEnd) {
+                ch2 = *source;
+                /* If it's a low surrogate, convert to UTF32. */
+                if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
+                    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+                        + (ch2 - UNI_SUR_LOW_START) + halfBase;
+                    ++source;
+                } else if (flags == strictConversion) { /* it's an unpaired high surrogate */
+                    --source; /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                }
+            } else { /* We don't have the 16 bits following the high surrogate. */
+                --source; /* return to the high surrogate */
+                result = sourceExhausted;
+                break;
+            }
+        } else if (flags == strictConversion) {
+            /* UTF-16 surrogate values are illegal in UTF-32 */
+            if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+                --source; /* return to the illegal value itself */
+                result = sourceIllegal;
+                break;
+            }
+        }
+        if (target >= targetEnd) {
+            source = oldSource; /* Back up source pointer! */
+            result = targetExhausted; break;
+        }
+        *target++ = ch;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+#ifdef CVTUTF_DEBUG
+if (result == sourceIllegal) {
+    fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
+    fflush(stderr);
+}
+#endif
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Index into the table below with the first byte of a UTF-8 sequence to
+ * get the number of trailing bytes that are supposed to follow it.
+ * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
+ * left as-is for anyone who may want to do such conversion, which was
+ * allowed in earlier algorithms.
+ */
+static const char trailingBytesForUTF8[256] = {
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+/*
+ * Magic values subtracted from a buffer value during UTF8 conversion.
+ * This table contains as many values as there might be trailing bytes
+ * in a UTF-8 sequence.
+ */
+static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,
+                     0x03C82080UL, 0xFA082080UL, 0x82082080UL };
+
+/*
+ * Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
+ * into the first byte, depending on how many bytes follow.  There are
+ * as many entries in this table as there are UTF-8 sequence types.
+ * (I.e., one byte sequence, two byte... etc.). Remember that sequencs
+ * for *legal* UTF-8 will be 4 or fewer bytes total.
+ */
+static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+/* --------------------------------------------------------------------- */
+
+/* The interface converts a whole buffer to avoid function-call overhead.
+ * Constants have been gathered. Loops & conditionals have been removed as
+ * much as possible for efficiency, in favor of drop-through switches.
+ * (See "Note A" at the bottom of the file for equivalent code.)
+ * If your compiler supports it, the "isLegalUTF8" call can be turned
+ * into an inline function.
+ */
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF16toUTF8 (
+        const UTF16** sourceStart, const UTF16* sourceEnd,
+        UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF16* source = *sourceStart;
+    UTF8* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch;
+        unsigned short bytesToWrite = 0;
+        const UTF32 byteMask = 0xBF;
+        const UTF32 byteMark = 0x80;
+        const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
+        ch = *source++;
+        /* If we have a surrogate pair, convert to UTF32 first. */
+        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
+            /* If the 16 bits following the high surrogate are in the source buffer... */
+            if (source < sourceEnd) {
+                UTF32 ch2 = *source;
+                /* If it's a low surrogate, convert to UTF32. */
+                if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
+                    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+                        + (ch2 - UNI_SUR_LOW_START) + halfBase;
+                    ++source;
+                } else if (flags == strictConversion) { /* it's an unpaired high surrogate */
+                    --source; /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                }
+            } else { /* We don't have the 16 bits following the high surrogate. */
+                --source; /* return to the high surrogate */
+                result = sourceExhausted;
+                break;
+            }
+        } else if (flags == strictConversion) {
+            /* UTF-16 surrogate values are illegal in UTF-32 */
+            if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+                --source; /* return to the illegal value itself */
+                result = sourceIllegal;
+                break;
+            }
+        }
+        /* Figure out how many bytes the result will require */
+        if (ch < (UTF32)0x80) {      bytesToWrite = 1;
+        } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
+        } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
+        } else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
+        } else {                            bytesToWrite = 3;
+                                            ch = UNI_REPLACEMENT_CHAR;
+        }
+
+        target += bytesToWrite;
+        if (target > targetEnd) {
+            source = oldSource; /* Back up source pointer! */
+            target -= bytesToWrite; result = targetExhausted; break;
+        }
+        switch (bytesToWrite) { /* note: everything falls through. */
+            case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
+        }
+        target += bytesToWrite;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Utility routine to tell whether a sequence of bytes is legal UTF-8.
+ * This must be called with the length pre-determined by the first byte.
+ * If not calling this from ConvertUTF8to*, then the length can be set by:
+ *  length = trailingBytesForUTF8[*source]+1;
+ * and the sequence is illegal right away if there aren't that many bytes
+ * available.
+ * If presented with a length > 4, this returns false.  The Unicode
+ * definition of UTF-8 goes up to 4-byte sequences.
+ */
+
+static Boolean isLegalUTF8(const UTF8 *source, int length) {
+    UTF8 a;
+    const UTF8 *srcptr = source+length;
+    switch (length) {
+    default: return false;
+        /* Everything else falls through when "true"... */
+    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+    case 2: if ((a = (*--srcptr)) > 0xBF) return false;
+
+        switch (*source) {
+            /* no fall-through in this inner switch */
+            case 0xE0: if (a < 0xA0) return false; break;
+            case 0xED: if (a > 0x9F) return false; break;
+            case 0xF0: if (a < 0x90) return false; break;
+            case 0xF4: if (a > 0x8F) return false; break;
+            default:   if (a < 0x80) return false;
+        }
+
+    case 1: if (*source >= 0x80 && *source < 0xC2) return false;
+    }
+    if (*source > 0xF4) return false;
+    return true;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Exported function to return whether a UTF-8 sequence is legal or not.
+ * This is not used here; it's just exported.
+ */
+Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {
+    int length = trailingBytesForUTF8[*source]+1;
+    if (source+length > sourceEnd) {
+        return false;
+    }
+    return isLegalUTF8(source, length);
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF8toUTF16 (
+        const UTF8** sourceStart, const UTF8* sourceEnd,
+        UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF8* source = *sourceStart;
+    UTF16* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch = 0;
+        unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
+        if (source + extraBytesToRead >= sourceEnd) {
+            result = sourceExhausted; break;
+        }
+        /* Do this check whether lenient or strict */
+        if (! isLegalUTF8(source, extraBytesToRead+1)) {
+            result = sourceIllegal;
+            break;
+        }
+        /*
+         * The cases all fall through. See "Note A" below.
+         */
+        switch (extraBytesToRead) {
+            case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
+            case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
+            case 3: ch += *source++; ch <<= 6;
+            case 2: ch += *source++; ch <<= 6;
+            case 1: ch += *source++; ch <<= 6;
+            case 0: ch += *source++;
+        }
+        ch -= offsetsFromUTF8[extraBytesToRead];
+
+        if (target >= targetEnd) {
+            source -= (extraBytesToRead+1); /* Back up source pointer! */
+            result = targetExhausted; break;
+        }
+        if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
+            /* UTF-16 surrogate values are illegal in UTF-32 */
+            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+                if (flags == strictConversion) {
+                    source -= (extraBytesToRead+1); /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                } else {
+                    *target++ = UNI_REPLACEMENT_CHAR;
+                }
+            } else {
+                *target++ = (UTF16)ch; /* normal case */
+            }
+        } else if (ch > UNI_MAX_UTF16) {
+            if (flags == strictConversion) {
+                result = sourceIllegal;
+                source -= (extraBytesToRead+1); /* return to the start */
+                break; /* Bail out; shouldn't continue */
+            } else {
+                *target++ = UNI_REPLACEMENT_CHAR;
+            }
+        } else {
+            /* target is a character in range 0xFFFF - 0x10FFFF. */
+            if (target + 1 >= targetEnd) {
+                source -= (extraBytesToRead+1); /* Back up source pointer! */
+                result = targetExhausted; break;
+            }
+            ch -= halfBase;
+            *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+            *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+        }
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF32toUTF8 (
+        const UTF32** sourceStart, const UTF32* sourceEnd,
+        UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF32* source = *sourceStart;
+    UTF8* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch;
+        unsigned short bytesToWrite = 0;
+        const UTF32 byteMask = 0xBF;
+        const UTF32 byteMark = 0x80;
+        ch = *source++;
+        if (flags == strictConversion ) {
+            /* UTF-16 surrogate values are illegal in UTF-32 */
+            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+                --source; /* return to the illegal value itself */
+                result = sourceIllegal;
+                break;
+            }
+        }
+        /*
+         * Figure out how many bytes the result will require. Turn any
+         * illegally large UTF32 things (> Plane 17) into replacement chars.
+         */
+        if (ch < (UTF32)0x80) {      bytesToWrite = 1;
+        } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
+        } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
+        } else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;
+        } else {                            bytesToWrite = 3;
+                                            ch = UNI_REPLACEMENT_CHAR;
+                                            result = sourceIllegal;
+        }
+
+        target += bytesToWrite;
+        if (target > targetEnd) {
+            --source; /* Back up source pointer! */
+            target -= bytesToWrite; result = targetExhausted; break;
+        }
+        switch (bytesToWrite) { /* note: everything falls through. */
+            case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
+        }
+        target += bytesToWrite;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF8toUTF32 (
+        const UTF8** sourceStart, const UTF8* sourceEnd,
+        UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF8* source = *sourceStart;
+    UTF32* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch = 0;
+        unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
+        if (source + extraBytesToRead >= sourceEnd) {
+            result = sourceExhausted; break;
+        }
+        /* Do this check whether lenient or strict */
+        if (! isLegalUTF8(source, extraBytesToRead+1)) {
+            result = sourceIllegal;
+            break;
+        }
+        /*
+         * The cases all fall through. See "Note A" below.
+         */
+        switch (extraBytesToRead) {
+            case 5: ch += *source++; ch <<= 6;
+            case 4: ch += *source++; ch <<= 6;
+            case 3: ch += *source++; ch <<= 6;
+            case 2: ch += *source++; ch <<= 6;
+            case 1: ch += *source++; ch <<= 6;
+            case 0: ch += *source++;
+        }
+        ch -= offsetsFromUTF8[extraBytesToRead];
+
+        if (target >= targetEnd) {
+            source -= (extraBytesToRead+1); /* Back up the source pointer! */
+            result = targetExhausted; break;
+        }
+        if (ch <= UNI_MAX_LEGAL_UTF32) {
+            /*
+             * UTF-16 surrogate values are illegal in UTF-32, and anything
+             * over Plane 17 (> 0x10FFFF) is illegal.
+             */
+            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+                if (flags == strictConversion) {
+                    source -= (extraBytesToRead+1); /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                } else {
+                    *target++ = UNI_REPLACEMENT_CHAR;
+                }
+            } else {
+                *target++ = ch;
+            }
+        } else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */
+            result = sourceIllegal;
+            *target++ = UNI_REPLACEMENT_CHAR;
+        }
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* ---------------------------------------------------------------------
+
+    Note A.
+    The fall-through switches in UTF-8 reading code save a
+    temp variable, some decrements & conditionals.  The switches
+    are equivalent to the following loop:
+        {
+            int tmpBytesToRead = extraBytesToRead+1;
+            do {
+                ch += *source++;
+                --tmpBytesToRead;
+                if (tmpBytesToRead) ch <<= 6;
+            } while (tmpBytesToRead > 0);
+        }
+    In UTF-8 writing code, the switches on "bytesToWrite" are
+    similarly unrolled loops.
+
+   --------------------------------------------------------------------- */
diff --git a/obex_profiles/unicode/ConvertUTF.h b/obex_profiles/unicode/ConvertUTF.h
new file mode 100644
index 0000000..a58d2c4
--- /dev/null
+++ b/obex_profiles/unicode/ConvertUTF.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ *
+ * Disclaimer
+ *
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ *
+ * Limitations on Rights to Redistribute This Code
+ *
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+    Conversions between UTF32, UTF-16, and UTF-8.  Header file.
+
+    Several funtions are included here, forming a complete set of
+    conversions between the three formats.  UTF-7 is not included
+    here, but is handled in a separate source file.
+
+    Each of these routines takes pointers to input buffers and output
+    buffers.  The input buffers are const.
+
+    Each routine converts the text between *sourceStart and sourceEnd,
+    putting the result into the buffer between *targetStart and
+    targetEnd. Note: the end pointers are *after* the last item: e.g.
+    *(sourceEnd - 1) is the last item.
+
+    The return result indicates whether the conversion was successful,
+    and if not, whether the problem was in the source or target buffers.
+    (Only the first encountered problem is indicated.)
+
+    After the conversion, *sourceStart and *targetStart are both
+    updated to point to the end of last text successfully converted in
+    the respective buffers.
+
+    Input parameters:
+        sourceStart - pointer to a pointer to the source buffer.
+                The contents of this are modified on return so that
+                it points at the next thing to be converted.
+        targetStart - similarly, pointer to pointer to the target buffer.
+        sourceEnd, targetEnd - respectively pointers to the ends of the
+                two buffers, for overflow checking only.
+
+    These conversion functions take a ConversionFlags argument. When this
+    flag is set to strict, both irregular sequences and isolated surrogates
+    will cause an error.  When the flag is set to lenient, both irregular
+    sequences and isolated surrogates are converted.
+
+    Whether the flag is strict or lenient, all illegal sequences will cause
+    an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,
+    or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code
+    must check for illegal sequences.
+
+    When the flag is set to lenient, characters over 0x10FFFF are converted
+    to the replacement character; otherwise (when the flag is set to strict)
+    they constitute an error.
+
+    Output parameters:
+        The value "sourceIllegal" is returned from some routines if the input
+        sequence is malformed.  When "sourceIllegal" is returned, the source
+        value will point to the illegal value that caused the problem. E.g.,
+        in UTF-8 when a sequence is malformed, it points to the start of the
+        malformed sequence.
+
+    Author: Mark E. Davis, 1994.
+    Rev History: Rick McGowan, fixes & updates May 2001.
+                 Fixes & updates, Sept 2001.
+
+------------------------------------------------------------------------ */
+
+/* ---------------------------------------------------------------------
+    The following 4 definitions are compiler-specific.
+    The C standard does not guarantee that wchar_t has at least
+    16 bits, so wchar_t is no less portable than unsigned short!
+    All should be unsigned values to avoid sign extension during
+    bit mask & shift operations.
+------------------------------------------------------------------------ */
+
+#if 0
+typedef unsigned long   UTF32;  /* at least 32 bits */
+typedef unsigned short  UTF16;  /* at least 16 bits */
+typedef unsigned char   UTF8;   /* typically 8 bits */
+typedef unsigned char   Boolean; /* 0 or 1 */
+#else
+/* Map BLUEmagic types to types used by Unicode, Inc. supplied code. */
+#include "oi_stddefs.h"
+typedef OI_UTF8  UTF8;
+typedef OI_UTF16 UTF16;
+typedef OI_UTF32 UTF32;
+typedef OI_BOOL  Boolean;
+#endif
+
+
+/* Some fundamental constants */
+#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD
+#define UNI_MAX_BMP (UTF32)0x0000FFFF
+#define UNI_MAX_UTF16 (UTF32)0x0010FFFF
+#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF
+#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF
+
+typedef enum {
+        conversionOK,           /* conversion successful */
+        sourceExhausted,        /* partial character in source, but hit end */
+        targetExhausted,        /* insuff. room in target for conversion */
+        sourceIllegal           /* source sequence is illegal/malformed */
+} ConversionResult;
+
+typedef enum {
+        strictConversion = 0,
+        lenientConversion
+} ConversionFlags;
+
+/* This is for C++ and does no harm in C */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ConversionResult ConvertUTF8toUTF16 (
+                const UTF8** sourceStart, const UTF8* sourceEnd,
+                UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF16toUTF8 (
+                const UTF16** sourceStart, const UTF16* sourceEnd,
+                UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF8toUTF32 (
+                const UTF8** sourceStart, const UTF8* sourceEnd,
+                UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF32toUTF8 (
+                const UTF32** sourceStart, const UTF32* sourceEnd,
+                UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF16toUTF32 (
+                const UTF16** sourceStart, const UTF16* sourceEnd,
+                UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF32toUTF16 (
+                const UTF32** sourceStart, const UTF32* sourceEnd,
+                UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
+
+Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd);
+
+#ifdef __cplusplus
+}
+#endif
+
+/* --------------------------------------------------------------------- */
diff --git a/property-ops/Makefile.am b/property-ops/Makefile.am
index 257148c..f2d3f44 100644
--- a/property-ops/Makefile.am
+++ b/property-ops/Makefile.am
@@ -15,9 +15,15 @@ c_sources = \
     src/property_ops.c \
     src/sock_ops.c
 
+if USE_GLIB
+ btproperty_CFLAGS  = $(AM_CFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
+ btproperty_LDFLAGS = -lpthread @GLIB_LIBS@
+else
+ btproperty_CFLAGS = $(AM_CFLAGS)
+ btproperty_LDFLAGS = -lpthread
+endif
+
 library_includedir = $(pkgincludedir)
 bin_PROGRAMS = btproperty
 btproperty_CC = @CC@
-btproperty_SOURCES = $(c_sources)
-btproperty_CFLAGS = $(AM_CFLAGS)
-btproperty_LDADD = -lpthread
+btproperty_SOURCES = $(c_sources)
\ No newline at end of file
diff --git a/property-ops/configure.ac b/property-ops/configure.ac
index 1f2ba93..1ac7b84 100644
--- a/property-ops/configure.ac
+++ b/property-ops/configure.ac
@@ -37,6 +37,23 @@ if test "x$with_common_includes" != "xno"; then
    CFLAGS="${CFLAGS} -I${common_incdir}"
 fi
 
+AC_ARG_WITH([glib],
+     AC_HELP_STRING([--with-glib],
+        [enable glib, building HLOS systems which use glib]))
+
+if (test "x${with_glib}" = "xyes"); then
+       PKG_CHECK_MODULES(GTHREAD, gthread-2.0 >= 2.16, dummy=yes,
+                               AC_MSG_ERROR(GThread >= 2.16 is required))
+       PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.16, dummy=yes,
+                               AC_MSG_ERROR(GLib >= 2.16 is required))
+       GLIB_CFLAGS="$GLIB_CFLAGS $GTHREAD_CFLAGS"
+       GLIB_LIBS="$GLIB_LIBS $GTHREAD_LIBS"
+
+       AC_SUBST(GLIB_CFLAGS)
+       AC_SUBST(GLIB_LIBS)
+fi
+
+AM_CONDITIONAL(USE_GLIB, test "x${with_glib}" = "xyes")
 
 AC_SUBST([CPPFLAGS])
 AC_SUBST([CFLAGS])
diff --git a/property-ops/include/property_ops.h b/property-ops/include/property_ops.h
index 1ea2435..cafd82b 100644
--- a/property-ops/include/property_ops.h
+++ b/property-ops/include/property_ops.h
@@ -58,6 +58,12 @@ extern const char *path;
 #define ALOG(pri, tag, fmt, arg...) //syslog (LOG_WARNING, fmt, ##arg)
 #define LOG_DEBUG(fmt, arg...) ALOG(PRI_VERB, LOG_TAG, fmt, ##arg)
 
+
+#ifdef USE_GLIB
+#include <glib.h>
+#define strlcpy g_strlcpy
+#endif
+
 typedef enum {
         LOAD_FROM_PERSIST = 1,
         CHECK_IF_PROP_EXIST,
diff --git a/property-ops/src/ll.c b/property-ops/src/ll.c
index ed7a115..00ce6d5 100644
--- a/property-ops/src/ll.c
+++ b/property-ops/src/ll.c
@@ -69,8 +69,11 @@ bool __create_list_and_add( const char* search_name, const char* property_value)
     property_db *ln = (property_db*) calloc(1, sizeof(property_db)*
         sizeof(unsigned char));
 
-    strncpy(ln->unit.property_name, search_name, strlen(search_name));
-    strncpy(ln->unit.property_value, property_value, strlen(property_value));
+    if (ln == NULL )
+        return false;
+
+    strlcpy(ln->unit.property_name, search_name, (strlen(search_name) + 1));
+    strlcpy(ln->unit.property_value, property_value, (strlen(property_value) +1));
 
     ln->next = NULL;
 
@@ -87,8 +90,8 @@ bool __update_prop_value(const char* search_name, const char* property_value)
     {
         LOG_DEBUG("List Matches property Updating Value\n");
         memset(ln->unit.property_value, 0, sizeof(ln->unit.property_value));
-        strncpy(ln->unit.property_value,  property_value,
-            strlen(property_value));
+        strlcpy(ln->unit.property_value,  property_value,
+            (strlen(property_value) + 1));
         LOG_DEBUG("Value copied to the db prop name %s", search_name);
         retval =0;
     } else {
diff --git a/property-ops/src/property_config.prop b/property-ops/src/property_config.prop
index 91df9bf..389baba 100644
--- a/property-ops/src/property_config.prop
+++ b/property-ops/src/property_config.prop
@@ -4,3 +4,4 @@ wc_transport.start_hci,false,false
 bluetooth.startbtsnoop,false,false
 wc_transport.soc_initialized,false,false
 wc_transport.start_root,false,false
+bluetooth.isEnabled,false,false
diff --git a/property-ops/src/property_ops.c b/property-ops/src/property_ops.c
index f288369..ec8e1c2 100644
--- a/property-ops/src/property_ops.c
+++ b/property-ops/src/property_ops.c
@@ -181,15 +181,15 @@ property_db* __pull_one_line_data(const char* line)
             switch (iterator)
             {
                 case EXT_NAME:
-                    strncpy(extracted_val->unit.property_name,
-                            curr_line_ptr, curr_length);
+                    strlcpy(extracted_val->unit.property_name,
+                            curr_line_ptr, (curr_length + 1) );
                     LOG_DEBUG("[%s] => Extracted Name =%s\n", __func__,
                             extracted_val->unit.property_name);
                     break;
 
                 case EXT_VAL:
-                    strncpy(extracted_val->unit.property_value,
-                            curr_line_ptr, curr_length);
+                    strlcpy(extracted_val->unit.property_value,
+                            curr_line_ptr, (curr_length + 1));
                     LOG_DEBUG("[%s] => Extracted Value =%s\n", __func__
                             ,extracted_val->unit.property_value);
                     break;
diff --git a/property-ops/src/sock_ops.c b/property-ops/src/sock_ops.c
old mode 100755
new mode 100644
index 5d287b0..dfa119e
--- a/property-ops/src/sock_ops.c
+++ b/property-ops/src/sock_ops.c
@@ -48,7 +48,7 @@
 
 #include "../include/property_ops.h"
 
-#define SOCK_NAMED_ADDR  "/etc/bluetooth/btprop"
+#define SOCK_NAMED_ADDR  "/data/misc/bluetooth/btprop"
 #define TRIGGER_CONNECTION_INDEX    (1)
 #define MAX_LISTENERS               (4)
 //500ms, unless MAX_LISTENERS are connected
@@ -94,7 +94,7 @@ int init_local_socket(void)
     memset(&un_sock_name, 0, sizeof(struct sockaddr_un));
 
     un_sock_name.sun_family = AF_UNIX;
-    strncpy(un_sock_name.sun_path, SOCK_NAMED_ADDR, strlen(SOCK_NAMED_ADDR));
+    strlcpy(un_sock_name.sun_path, SOCK_NAMED_ADDR, sizeof(un_sock_name.sun_path));
     len = sizeof(un_sock_name.sun_family) + strlen(un_sock_name.sun_path);
 
     /*Bind the socket to the address.*/
@@ -225,6 +225,7 @@ int add_fd_to_set()
 bool parse_and_exec(int cmd, unsigned char* command, unsigned char* prop_val)
 {
     char delimiter[] = " ";
+    char *ptr1;
     char *token ;
     int iter = 0;
     bool result = false;
@@ -237,27 +238,43 @@ bool parse_and_exec(int cmd, unsigned char* command, unsigned char* prop_val)
     memset(prop_value, 0, sizeof(prop_value));
     memset(prop_name, 0, sizeof(prop_name));
 
-    token = strtok(command, delimiter);
+    token = strtok_r(command, delimiter, &ptr1);
     while (token) {
         LOG_DEBUG("(%s) \n", token);
-        strncpy(parsed_data[iter ++], token, strlen(token));
-        token = strtok(NULL, delimiter);
+        strlcpy(parsed_data[iter ++], token, (strlen(token) + 1));
+        token = strtok_r(NULL, delimiter, &ptr1);
     }
 
     if (cmd == GET_PROP_VALUE) {
-        strncpy(prop_name,parsed_data[1], strlen(parsed_data[1]));
+        strlcpy(prop_name,parsed_data[1], (strlen(parsed_data[1]) + 1));
         result = get_property_value_bt(prop_name, prop_val);
     } else if (cmd == SET_PROP_VALUE) {
-        strncpy(prop_name,parsed_data[1], strlen(parsed_data[1]));
-        strncpy(prop_value,parsed_data[2], strlen(parsed_data[2]));
+        strlcpy(prop_name,parsed_data[1], (strlen(parsed_data[1]) + 1));
+        strlcpy(prop_value,parsed_data[2], (strlen(parsed_data[2]) + 1));
         LOG_DEBUG("Set Prop name (%s) Prop Val (%s)\n", prop_name, prop_value);
         if (!strncmp(prop_name, "wc_transport.start_hci", strlen(prop_name))) {
             if (!strncmp(prop_value, "true", strlen(prop_value))) {
                 LOG_DEBUG("starting wcnssfilter\n");
                 system("wcnssfilter &");
+            }
+        }
+        if (!strncmp(prop_name, "bluetooth.startbtsnoop", strlen(prop_name))) {
+            if (!strncmp(prop_value, "true", strlen(prop_value))) {
+                LOG_DEBUG("starting btsnoop\n");
+                system("btsnoop &");
+            } else {
+                LOG_DEBUG("stopping btsnoop\n");
+                system("killall -KILL btsnoop");
+            }
+        }
+
+        if (!strncmp(prop_name, "bluetooth.isEnabled", strlen(prop_name))) {
+            if (!strncmp(prop_value, "true", strlen(prop_value))) {
+                LOG_DEBUG("starting abtfilter\n");
+                system("abtfilt -d -z -n -m -a -w wlan0 &");
             } else {
-                LOG_DEBUG("stopping wcnssfilter\n");
-                system("killall -KILL wcnssfilter");
+                LOG_DEBUG("stopping abtfilter\n");
+                system("killall -KILL abtfilt");
             }
         }
         result = set_property_value_bt(prop_name, prop_value);
@@ -275,6 +292,7 @@ int separate_recvd_commands(unsigned char * command)
 
 {
     char delimiter[] = ",";
+    char *ptr1;
     /* read if buffer has more than one properties */
     int iter = 0;
     int i = 0;
@@ -283,12 +301,12 @@ int separate_recvd_commands(unsigned char * command)
     LOG_DEBUG("Command Received (%s)\n", command);
     memset(prop_string, 0, sizeof(prop_string));
 
-    token = strtok(command, delimiter);
+    token = strtok_r(command, delimiter, &ptr1);
     while (token)
     {
         LOG_DEBUG("(%s) \n", token);
-        strncpy(prop_string[iter ++], token, strlen(token));
-        token = strtok(NULL, delimiter);
+        strlcpy(prop_string[iter ++], token, (strlen(token) + 1));
+        token = strtok_r(NULL, delimiter, &ptr1);
     }
 
     LOG_DEBUG("Found multiple commands (%d) \n", iter);
@@ -381,9 +399,11 @@ void *io_thread_handler (void *param)
                     bytes_available = recv(sdata.conn_fd[selectloop], buf,
                             sizeof(buf), 0);
 
-                    if(bytes_available == 0){
+                    if(bytes_available == 0) {
                        /* LOG_DEBUG("I/O Done EOF counter=(%d)selectloop =(%d)\n",
                                 counter, selectloop);*/
+                        shutdown(sdata.conn_fd[selectloop], SHUT_RDWR);
+                        close(sdata.conn_fd[selectloop]);
                         sdata.conn_fd[selectloop] = 0;
                     } else {
                         //LOG_DEBUG("I/O data on fd, at index(%d)=%s\n",
diff --git a/property-ops/test/test_sock.c b/property-ops/test/test_sock.c
index ea0e652..cfc4b3c 100644
--- a/property-ops/test/test_sock.c
+++ b/property-ops/test/test_sock.c
@@ -39,7 +39,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include "../include/property_ops.h"
-#define SOCKETNAME  "/etc/bluetooth/btprop"
+#define SOCKETNAME  "/data/misc/bluetooth/btprop"
 #define STDIN       0
 #define STDOUT       1
 #define MAX_LEN     (1024)
