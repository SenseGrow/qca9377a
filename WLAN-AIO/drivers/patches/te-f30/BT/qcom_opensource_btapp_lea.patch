diff --git a/bt-app/a2dp_sink/include/A2dp_Sink_Streaming.hpp b/bt-app/a2dp_sink/include/A2dp_Sink_Streaming.hpp
index 2f4bab9..4022fdb 100644
--- a/bt-app/a2dp_sink/include/A2dp_Sink_Streaming.hpp
+++ b/bt-app/a2dp_sink/include/A2dp_Sink_Streaming.hpp
@@ -54,6 +54,10 @@
 #include "utils.h"
 #include "hardware/bt_av_vendor.h"
 
+#define USE_ALSA TRUE
+#if (defined(USE_ALSA))
+#include "Alsa_Handler.h"
+#endif
 
 typedef void (*A2dpSinkStreamingThreadHandler) (void *msg);
 
@@ -82,6 +86,7 @@ class A2dp_Sink_Streaming {
     bt_bdaddr_t mStreamingDevice;
     bt_bdaddr_t mResumingDevice;
     const btav_sink_vendor_interface_t *mBtA2dpSinkStreamingVendorInterface;
+    const btav_interface_t *mBtA2dpSinkStreamingInterface;
     ControlStatusType controlStatus;
     A2dpSinkStreamingThreadInfo threadInfo;
     uint32_t sample_rate;
@@ -98,6 +103,9 @@ class A2dp_Sink_Streaming {
 #if (defined USE_GST)
     uint8_t *gbuff;
 #endif
+#if (defined(USE_ALSA))
+    CAlsaHandler alsaHandlrObj;
+#endif
     //apis for in_stream bt a2dp HAL, to read data.
     void LoadBtA2dpHAL();
     void UnLoadBtA2dpHAL();
@@ -125,6 +133,7 @@ class A2dp_Sink_Streaming {
     void StopDataFetchTimer();
     void OnDisconnected();
     void GetLibInterface(const btav_sink_vendor_interface_t *sBtA2dpSinkStrVendorInterface);
+    void GetLibInterface(const btav_interface_t *sBtA2dpSinkStrInterface);
     uint16_t codec_type;
     btav_codec_config_t codec_config;
     uint32_t get_a2dp_sbc_sampling_rate(uint8_t frequency);
diff --git a/bt-app/a2dp_sink/include/Alsa_Handler.h b/bt-app/a2dp_sink/include/Alsa_Handler.h
new file mode 100644
index 0000000..53c3eb8
--- /dev/null
+++ b/bt-app/a2dp_sink/include/Alsa_Handler.h
@@ -0,0 +1,84 @@
+ /*
+  * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#ifndef ALSA_HANDLER_H
+#define ALSA_HANDLER_H
+
+#include <iostream>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <getopt.h>
+#include <asoundlib.h>
+
+#define PERIODS             4                  /* Number of ALSA driver buffers */
+#define PERIOD_SIZE         1024               /* Size of each ALSA driver buffer */
+
+typedef enum CsrBool_en{
+    FALSE = 0,
+    TRUE = 1,
+}CsrBool;
+
+typedef enum PCM_format_en{
+        SIGNED_16BIT_LITTLE_ENDIAN = 1,
+        SIGNED_32BIT_LITTLE_ENDIAN = 2,
+}PCM_format;
+
+class CAlsaHandler
+{
+    private:
+        char    *mpsz_alsadevice;
+        snd_pcm_t    *mphandle;
+        snd_pcm_sframes_t    mframesize;
+        unsigned int    msample_rate;
+        unsigned int    mchannels;
+        unsigned int    merrors;
+    public:
+    CAlsaHandler();
+
+    ~CAlsaHandler();
+
+    CsrBool AlsaInit(char* alsalpName);
+
+    CsrBool AlsaDeinit();
+
+    CsrBool AlsaOpen(unsigned int channels,unsigned int freq,PCM_format pcm_format = SIGNED_32BIT_LITTLE_ENDIAN);
+
+    CsrBool AlsaClose();
+
+    CsrBool AlsaStart();
+
+    CsrBool AlsaStop();
+
+    int AlsaProcessPlay(void *data, unsigned int length);
+
+    int AlsaXrun(int err);
+};
+
+#endif /* ALSA_HANDLER_H */
diff --git a/bt-app/a2dp_sink/src/A2dp_Sink.cpp b/bt-app/a2dp_sink/src/A2dp_Sink.cpp
index c56bcb2..54863b2 100644
--- a/bt-app/a2dp_sink/src/A2dp_Sink.cpp
+++ b/bt-app/a2dp_sink/src/A2dp_Sink.cpp
@@ -193,7 +193,7 @@ static void bta2dp_audio_state_callback(btav_audio_state_t state, bt_bdaddr_t* b
 }
 
 static void bta2dp_audio_config_callback(bt_bdaddr_t *bd_addr, uint32_t sample_rate,
-        uint8_t channel_count) {
+        uint8_t channel_count, uint8_t codec_type, btav_snk_sbc_codec_config_t codec_config) {
     ALOGD(LOGTAG " Audio Config CB sample_rate %d, channel_count %d", sample_rate, channel_count);
     list<A2dp_Device>::iterator iter = FindDeviceByAddr(pA2dpSink->pA2dpDeviceList, *bd_addr);
     if(iter != pA2dpSink->pA2dpDeviceList.end())
@@ -201,6 +201,23 @@ static void bta2dp_audio_config_callback(bt_bdaddr_t *bd_addr, uint32_t sample_r
         ALOGD(LOGTAG " Audio Config CB: found matching device");
         iter->av_config.sample_rate = sample_rate;
         iter->av_config.channel_count = channel_count;
+
+        BtEvent *pEvent = new BtEvent;
+        btav_codec_config_t codec_conf;
+        codec_conf.sbc_config.samp_freq = codec_config.samp_freq;
+        codec_conf.sbc_config.ch_mode = codec_config.ch_mode;
+        codec_conf.sbc_config.block_len = codec_config.block_len;
+        codec_conf.sbc_config.alloc_mthd = codec_config.alloc_mthd;
+        codec_conf.sbc_config.min_bitpool = codec_config.min_bitpool;
+        codec_conf.sbc_config.max_bitpool = codec_config.max_bitpool;
+
+        pEvent->a2dpSinkEvent.event_id = A2DP_SINK_CODEC_CONFIG;
+        memcpy(&pEvent->a2dpSinkEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+        pEvent->a2dpSinkEvent.buf_size = sizeof(btav_codec_config_t);
+        pEvent->a2dpSinkEvent.buf_ptr = (uint8_t*)osi_malloc(pEvent->a2dpSinkEvent.buf_size);
+        memcpy(pEvent->a2dpSinkEvent.buf_ptr, (btav_codec_config_t*)&codec_conf, pEvent->a2dpSinkEvent.buf_size);
+        pEvent->a2dpSinkEvent.arg1 = codec_type;
+        PostMessage(THREAD_ID_A2DP_SINK, pEvent);
     }
     else
     {
@@ -275,9 +292,9 @@ void A2dp_Sink::HandleEnableSink(void) {
         pA2dpSinkStream->enable_delay_report = config_get_bool (config,CONFIG_DEFAULT_SECTION, "BtA2dpDelayReportEnable", false);
         ALOGD(LOGTAG " ~~ enable_delay_report  %d ", pA2dpSinkStream->enable_delay_report);
 #ifdef USE_LIBHW_AOSP
-        sBtA2dpSinkInterface->init(&sBluetoothA2dpSinkCallbacks);
+        //sBtA2dpSinkInterface->init(&sBluetoothA2dpSinkCallbacks);
 #else
-        sBtA2dpSinkInterface->init(&sBluetoothA2dpSinkCallbacks, max_a2dp_conn, 0);
+       // sBtA2dpSinkInterface->init(&sBluetoothA2dpSinkCallbacks, max_a2dp_conn, 0);
 #endif
         if (pA2dpSinkStream->fetch_rtp_info)
             streaming_prarm |= A2DP_SINK_RETREIVE_RTP_HEADER;
@@ -286,14 +303,22 @@ void A2dp_Sink::HandleEnableSink(void) {
         if (pA2dpSinkStream->enable_delay_report)
             streaming_prarm |= A2DP_SINK_ENABLE_DELAY_REPORTING;
 
+#ifdef USE_VENDOR_INTERFACE
         sBtA2dpSinkVendorInterface->init_vendor(&sBluetoothA2dpSinkVendorCallbacks,
                     max_a2dp_conn, 0,
                     streaming_prarm);
+        pA2dpSinkStream->GetLibInterface(sBtA2dpSinkVendorInterface);
+#else   /* AV INTERFACE */
+        sBtA2dpSinkInterface->init(&sBluetoothA2dpSinkCallbacks,
+                    max_a2dp_conn, 0,
+                    NULL);
+        pA2dpSinkStream->GetLibInterface(sBtA2dpSinkInterface);
+
+#endif /* USE_VENDOR_INTERFACE */
 
         pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
         pEvent->profile_start_event.profile_id = PROFILE_ID_A2DP_SINK;
         pEvent->profile_start_event.status = true;
-        pA2dpSinkStream->GetLibInterface(sBtA2dpSinkVendorInterface);
 
         PostMessage(THREAD_ID_GAP, pEvent);
     }
@@ -402,7 +427,7 @@ void A2dp_Sink::ConnectionManager(BtEvent* pEvent, bt_bdaddr_t dev) {
                 fprintf(stdout, "Already %d device connected\n", max_a2dp_conn);
                 return;
             }
-            if (!pAvrcp->rc_only_devices.empty())
+            if ((NULL!= pAvrcp) && (!pAvrcp->rc_only_devices.empty()))
             {
                 bdaddr_to_string(&iter->mDevice, &bd_str[0], sizeof(bd_str));
                 std::string deviceAddress(bd_str);
@@ -719,8 +744,11 @@ void A2dp_Sink::state_connected_handler(BtEvent* pEvent, list<A2dp_Device>::iter
             bdaddr_to_string(&pA2dpSinkStream->mStreamingDevice, str, 18);
             ALOGD(LOGTAG " A2DP_SINK_AUDIO_STARTED - set current streaming device as %s", str);
 
-            sBtA2dpSinkVendorInterface->
+            if( NULL != sBtA2dpSinkVendorInterface )
+            {
+                sBtA2dpSinkVendorInterface->
                     update_streaming_device_vendor(&pA2dpSinkStream->mStreamingDevice);
+            }
 
             pAMRequestControl = new BtEvent;
             pAMRequestControl->a2dpSinkStreamingEvent.event_id =
diff --git a/bt-app/a2dp_sink/src/A2dp_Sink_Streaming.cpp b/bt-app/a2dp_sink/src/A2dp_Sink_Streaming.cpp
index bd1424e..ebf11a8 100644
--- a/bt-app/a2dp_sink/src/A2dp_Sink_Streaming.cpp
+++ b/bt-app/a2dp_sink/src/A2dp_Sink_Streaming.cpp
@@ -69,7 +69,7 @@ extern BT_Audio_Manager *pBTAM;
 extern Avrcp *pAvrcp;
 extern Gap *g_gap;
 
-#if (!defined(BT_AUDIO_HAL_INTEGRATION))
+#if ((!defined(BT_AUDIO_HAL_INTEGRATION)) && (!defined(USE_ALSA)))
 #define DUMP_PCM_DATA TRUE
 #endif
 
@@ -84,6 +84,11 @@ FILE *outputPcmSampleFile;
 char outputFilename [50] = "/etc/bluetooth/output_sample.pcm";
 #endif
 
+#if (defined(USE_ALSA))
+FILE* sbcFd = NULL;
+char Filename [128] = "/etc/bluetooth/output.sbc";
+#endif
+
 static const bt_bdaddr_t bd_addr_null= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 extern void enque_relay_data(uint8_t* buffer, size_t size, uint8_t codec_type);
 #ifdef __cplusplus
@@ -156,11 +161,13 @@ void BtA2dpSinkStreamingMsgHandler(void *msg) {
             break;
         case A2DP_SINK_STREAMING_FETCH_PCM_DATA:
             ALOGD(LOGTAG " A2DP_SINK_STREAMING_FETCH_PCM_DATA");
+#if (!defined(USE_ALSA))
             if (!pA2dpSinkStream->pcm_timer) {
                 ALOGD(LOGTAG " pcm_timer already false, don't fetch data");
                 break;
             }
             pA2dpSinkStream->pcm_timer = false;
+#endif
 #if (defined USE_GST)
             uint8_t * data;
             int size;
@@ -187,8 +194,10 @@ void BtA2dpSinkStreamingMsgHandler(void *msg) {
                 // pcm buffer is null, closeStream or streaming device null have been called earlier
                 break;
             }
+#if (!defined(USE_ALSA))
             // first start next timer
             pA2dpSinkStream->StartPcmTimer();
+#endif
 
             if ((pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL) &&
                     (pA2dpSinkStream->pcm_buf != NULL)) {
@@ -221,8 +230,24 @@ void BtA2dpSinkStreamingMsgHandler(void *msg) {
                          rtp_offset = get_rtp_offset( pA2dpSinkStream->pcm_buf, A2DP_SINK_AUDIO_CODEC_SBC);
                      }
                  }
-                ALOGD(LOGTAG " fluoried stored_data_read = %d", pcm_data_read);
+                ALOGD(LOGTAG " fluoride stored_data_read = %d", pcm_data_read);
              }
+
+            if(  ( NULL == pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface )  &&
+                 ( NULL != pA2dpSinkStream->pcm_buf )                              &&
+                 ( NULL != pA2dpSinkStream->mBtA2dpSinkStreamingInterface ) )
+            {
+                        pcm_data_read =  pA2dpSinkStream->mBtA2dpSinkStreamingInterface->
+                        get_sink_pcm_data(pA2dpSinkStream->pcm_buf, pA2dpSinkStream->pcm_buf_size);
+
+                        if ( pA2dpSinkStream->fetch_rtp_info && ( pcm_data_read > 12) ) {
+                             if( !pA2dpSinkStream->sbc_decoding )
+                             {
+                                 rtp_offset = get_rtp_offset( pA2dpSinkStream->pcm_buf, A2DP_SINK_AUDIO_CODEC_SBC);
+                             }
+                         }
+            }
+
 #if (defined(BT_AUDIO_HAL_INTEGRATION))
             if ((pBTAM->GetAudioDevice() != NULL) && (pA2dpSinkStream->out_stream != NULL) &&
                     (pcm_data_read)) {
@@ -248,6 +273,13 @@ void BtA2dpSinkStreamingMsgHandler(void *msg) {
                 fwrite ((void*)pA2dpSinkStream->pcm_buf, 1, (size_t)(pcm_data_read), outputPcmSampleFile);
             }
 #endif
+#if (defined(USE_ALSA))
+            if((pcm_data_read) && (pA2dpSinkStream->pcm_buf != NULL) && (pA2dpSinkStream->pcm_timer))
+            {
+                pA2dpSinkStream->alsaHandlrObj.AlsaProcessPlay((void*)pA2dpSinkStream->pcm_buf,pcm_data_read);
+                //fwrite ((void*)pA2dpSinkStream->pcm_buf, 1, (size_t)(pcm_data_read), sbcFd);
+            }
+#endif
 #endif
             break;
         case A2DP_SINK_STREAMING_AM_RELEASE_CONTROL:
@@ -372,6 +404,15 @@ void BtA2dpSinkStreamingMsgHandler(void *msg) {
             qahw_out_pause(pA2dpSinkStream->out_stream);
             qahw_out_flush(pA2dpSinkStream->out_stream);
 #endif
+#if (defined(USE_ALSA))
+            if( sbcFd != NULL)
+            {
+                fclose(sbcFd);
+                sbcFd = NULL;
+            }
+            pA2dpSinkStream->alsaHandlrObj.AlsaStop();
+            pA2dpSinkStream->alsaHandlrObj.AlsaClose();
+#endif
             pA2dpSinkStream->StopDataFetchTimer();
             if (pA2dpSinkStream->mBtA2dpSinkStreamingVendorInterface != NULL)
             {
@@ -619,9 +660,14 @@ void A2dp_Sink_Streaming::StartPcmTimer() {
         ALOGD(LOGTAG " PCM Timer still running + ");
         return;
     }
+#if (defined(USE_ALSA))
+    alarm_set_periodic(pcm_data_fetch_timer, A2DP_SINK_PCM_FETCH_TIMER_DURATION,
+           pcm_fetch_timer_handler, NULL);
+#else
     alarm_set(pcm_data_fetch_timer, A2DP_SINK_PCM_FETCH_TIMER_DURATION,
            pcm_fetch_timer_handler, NULL);
-    pcm_timer = true;
+ #endif
+     pcm_timer = true;
 }
 
 void A2dp_Sink_Streaming::StopDataFetchTimer() {
@@ -914,6 +960,48 @@ void A2dp_Sink_Streaming::ConfigureAudioHal() {
         outputPcmSampleFile = fopen(outputFilename, "ab");
 #endif
 #endif
+#if (defined(USE_ALSA))
+    ALOGD(LOGTAG " ConfigureAudioHal:USE_ALSA  codec_type = %d", codec_type);
+    switch(codec_type)
+    {
+        case A2DP_SINK_AUDIO_CODEC_SBC:
+            sample_rate = get_a2dp_sbc_sampling_rate(codec_config.sbc_config.samp_freq);
+            channel_count = get_a2dp_sbc_channel_mode(codec_config.sbc_config.ch_mode);
+            fprintf(stdout,"\nIt is  SBC codec \n");
+            break;
+        case A2DP_SINK_AUDIO_CODEC_AAC:
+            sample_rate = get_a2dp_aac_sampling_rate(codec_config.aac_config.sampling_freq);
+            channel_count = get_a2dp_aac_channel_mode(codec_config.aac_config.channel_count);
+            fprintf(stdout,"\nIt is  AAC codec-Not supported as of now\n");
+            break;
+        case A2DP_SINK_AUDIO_CODEC_MP3:
+            sample_rate = get_a2dp_mp3_sampling_rate(codec_config.mp3_config.sampling_freq);
+            channel_count = get_a2dp_mp3_channel_mode(codec_config.mp3_config.channel_count);
+            fprintf(stdout,"\nIt is  MP3 codec-Not supported as of now\n");
+            break;
+        case A2DP_SINK_AUDIO_CODEC_APTX:
+            sample_rate = get_a2dp_aptx_sampling_rate(codec_config.aptx_config.sampling_freq);
+            channel_count = get_a2dp_aptx_channel_mode(codec_config.aptx_config.channel_count);
+            fprintf(stdout,"\nIt is  APTX codec-Not supported as of now\n");
+            break;
+    }
+    ALOGD(LOGTAG " sample_rate = %d, channel_count = %d", sample_rate, channel_count);
+
+    switch(sample_rate) {
+    case 44100:
+        pcm_buf_size = 7500;
+        break;
+    case 48000:
+        pcm_buf_size = 9000;
+        break;
+    }
+    pcm_buf = (uint8_t*)osi_malloc(pcm_buf_size);
+
+    //sbcFd = fopen(Filename,"w");
+    alsaHandlrObj.AlsaOpen(channel_count,sample_rate,SIGNED_16BIT_LITTLE_ENDIAN);
+    alsaHandlrObj.AlsaStart();
+#endif
+
 }
 
 void A2dp_Sink_Streaming::CloseAudioStream() {
@@ -929,10 +1017,6 @@ void A2dp_Sink_Streaming::CloseAudioStream() {
             residual_compress_data = 0;
             out_stream = NULL;
         }
-        if (pcm_buf != NULL) {
-            osi_free(pcm_buf);
-            pcm_buf = NULL;
-        }
     }
 #endif
 #if (defined(DUMP_PCM_DATA) && (DUMP_PCM_DATA == TRUE))
@@ -941,10 +1025,6 @@ void A2dp_Sink_Streaming::CloseAudioStream() {
         fclose(outputPcmSampleFile);
     }
     outputPcmSampleFile = NULL;
-    if (pcm_buf != NULL) {
-        osi_free(pcm_buf);
-        pcm_buf = NULL;
-    }
 #endif
 #if (defined(DUMP_COMPRESSED_DATA) && (DUMP_COMPRESSED_DATA == TRUE))
     if (outputPcmSampleFile)
@@ -953,6 +1033,19 @@ void A2dp_Sink_Streaming::CloseAudioStream() {
     }
     outputPcmSampleFile = NULL;
 #endif
+#if (defined (USE_ALSA))
+    if( sbcFd != NULL)
+    {
+        fclose(sbcFd);
+        sbcFd = NULL;
+    }
+    alsaHandlrObj.AlsaClose();
+#endif
+    if (pcm_buf != NULL)
+    {
+        osi_free(pcm_buf);
+        pcm_buf = NULL;
+    }
 }
 void A2dp_Sink_Streaming::LoadBtA2dpHAL() {
 #if (defined(BT_AUDIO_HAL_INTEGRATION))
@@ -1003,6 +1096,9 @@ void A2dp_Sink_Streaming::OpenInputStream()
     }
     ALOGD(LOGTAG " A2dp Input Stream successfully opened ");
 #endif
+#if (defined(USE_ALSA))
+    alsaHandlrObj.AlsaStart();
+#endif
 }
 
 void A2dp_Sink_Streaming::CloseInputStream()
@@ -1017,6 +1113,15 @@ void A2dp_Sink_Streaming::CloseInputStream()
     input_stream = NULL;
     ALOGD(LOGTAG " A2dp Input Stream successfully closed ");
 #endif
+#if (defined(USE_ALSA))
+    if( sbcFd != NULL)
+    {
+        fclose(sbcFd);
+        sbcFd = NULL;
+    }
+    alsaHandlrObj.AlsaStop();
+    alsaHandlrObj.AlsaClose();
+#endif
 }
 
 void A2dp_Sink_Streaming::SuspendInputStream()
@@ -1031,6 +1136,9 @@ void A2dp_Sink_Streaming::SuspendInputStream()
     qahw_in_standby(input_stream);
     ALOGD(LOGTAG " A2dp Stream suspended successfully");
 #endif
+#if (defined(USE_ALSA))
+    alsaHandlrObj.AlsaStop();
+#endif
 }
 
 void A2dp_Sink_Streaming::SetStreamVol(int curr_audio_index)
@@ -1096,10 +1204,16 @@ void A2dp_Sink_Streaming::OnDisconnected() {
 }
 
 void A2dp_Sink_Streaming::GetLibInterface(const btav_sink_vendor_interface_t *sBtA2dpSinkStrVendorInterface) {
-    ALOGD(LOGTAG " GetLibInterface ");
+    ALOGD(LOGTAG " GetLibInterface -Vendor ");
     mBtA2dpSinkStreamingVendorInterface = sBtA2dpSinkStrVendorInterface;
 }
 
+void A2dp_Sink_Streaming::GetLibInterface(const btav_interface_t *sBtA2dpSinkStrInterface) {
+    ALOGD(LOGTAG " GetLibInterface -AV ");
+    mBtA2dpSinkStreamingInterface = sBtA2dpSinkStrInterface;
+}
+
+
 A2dp_Sink_Streaming :: A2dp_Sink_Streaming( config_t *config) {
     this->config = config;
     controlStatus = STATUS_LOSS;
@@ -1111,6 +1225,7 @@ A2dp_Sink_Streaming :: A2dp_Sink_Streaming( config_t *config) {
     threadInfo.thread_handler = &BtA2dpSinkStreamingMsgHandler;
     threadInfo.thread_name = "A2dp_Sink_Streaming_Thread";
     mBtA2dpSinkStreamingVendorInterface = NULL;
+    mBtA2dpSinkStreamingInterface = NULL;
     memset(&mStreamingDevice, 0, sizeof(bt_bdaddr_t));
     memset(&mResumingDevice, 0, sizeof(bt_bdaddr_t));
     pthread_mutex_init(&this->lock, NULL);
@@ -1136,6 +1251,9 @@ A2dp_Sink_Streaming :: A2dp_Sink_Streaming( config_t *config) {
 #if (defined(DUMP_COMPRESSED_DATA) && (DUMP_COMPRESSED_DATA == TRUE))
     outputPcmSampleFile =  NULL;
 #endif
+#if (defined (USE_ALSA))
+    alsaHandlrObj.AlsaInit("default");
+#endif
 
 }
 
@@ -1153,6 +1271,7 @@ A2dp_Sink_Streaming :: ~A2dp_Sink_Streaming() {
     memset(&mStreamingDevice, 0, sizeof(bt_bdaddr_t));
     memset(&mResumingDevice, 0, sizeof(bt_bdaddr_t));
     mBtA2dpSinkStreamingVendorInterface = NULL;
+    mBtA2dpSinkStreamingInterface = NULL;
 #if (defined BT_AUDIO_HAL_INTEGRATION)
 #if (defined USE_GST)
     free(gbuff);
@@ -1162,6 +1281,9 @@ A2dp_Sink_Streaming :: ~A2dp_Sink_Streaming() {
     input_stream = NULL;
     a2dp_input_device = NULL;
 #endif
+#if (defined (USE_ALSA))
+    alsaHandlrObj.AlsaDeinit();
+#endif
     if (pcm_buf != NULL) {
         osi_free(pcm_buf);
         pcm_buf = NULL;
diff --git a/bt-app/a2dp_sink/src/Alsa_Handler.cpp b/bt-app/a2dp_sink/src/Alsa_Handler.cpp
new file mode 100644
index 0000000..a21e270
--- /dev/null
+++ b/bt-app/a2dp_sink/src/Alsa_Handler.cpp
@@ -0,0 +1,337 @@
+ /*
+  * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#include "Alsa_Handler.h"
+
+using namespace std;
+
+CAlsaHandler::CAlsaHandler()
+{
+    mphandle = 0;
+}
+
+CAlsaHandler::~CAlsaHandler()
+{
+
+}
+
+
+/* Initialise alsa filter */
+CsrBool CAlsaHandler::AlsaInit(char* alsalpName)
+{
+    mpsz_alsadevice = (char*)strdup((const char*)alsalpName);
+    return TRUE;
+}
+
+
+
+CsrBool CAlsaHandler::AlsaDeinit()
+{
+    if(mpsz_alsadevice != NULL)
+    {
+        free(mpsz_alsadevice);
+        mpsz_alsadevice = NULL;
+    }
+    return TRUE;
+}
+
+
+
+
+/* Open alsa with current configuration */
+CsrBool CAlsaHandler::AlsaOpen(unsigned int channels,unsigned int freq,PCM_format pcm_format)
+{
+    CsrBool result = TRUE;
+    int dir,ret;
+    int err;
+    snd_pcm_hw_params_t *hwp;
+    snd_pcm_uframes_t period_size_min;
+    snd_pcm_uframes_t period_size_max;
+    snd_pcm_uframes_t buffer_size_min;
+    snd_pcm_uframes_t buffer_size_max;
+    snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t buffer_size;
+
+
+    if(mphandle != 0)
+    {
+       cout << __FUNCTION__ << ":filter already open" << endl;
+       return result;
+    }
+
+    /* Get global AV2 configuration */
+    mchannels = channels;
+    msample_rate = freq;
+
+    cout  << "channels=" << mchannels << ", sample_rate=" << msample_rate << endl;
+    /* Open PCM device */
+    if(result && (snd_pcm_open(&(mphandle), mpsz_alsadevice, SND_PCM_STREAM_PLAYBACK, 0) < 0))
+    {
+       cout << __FUNCTION__ << ":could not open PCM device:" << mpsz_alsadevice << endl;
+       return FALSE;
+    }
+    hwp = (snd_pcm_hw_params_t *)alloca(snd_pcm_hw_params_sizeof());
+    memset(hwp, 0, snd_pcm_hw_params_sizeof());
+    snd_pcm_hw_params_any(mphandle, hwp);
+
+    ret = snd_pcm_nonblock(mphandle, 0);
+    if (ret < 0)
+    {
+        cout << __FUNCTION__ << ":Error setting block mode:" << snd_strerror(err) << endl;
+    }
+
+    snd_pcm_hw_params_set_access(mphandle, hwp, SND_PCM_ACCESS_RW_INTERLEAVED);
+
+    if(pcm_format = SIGNED_16BIT_LITTLE_ENDIAN)
+    {
+        snd_pcm_hw_params_set_format(mphandle, hwp, SND_PCM_FORMAT_S16_LE);
+        mframesize = 2 * 2;
+    }
+    else if(pcm_format = SIGNED_32BIT_LITTLE_ENDIAN)
+    {
+        snd_pcm_hw_params_set_format(mphandle, hwp, SND_PCM_FORMAT_S32_LE);
+        mframesize = 4 * 2;
+    }
+
+    snd_pcm_hw_params_set_rate(mphandle, hwp, msample_rate, 0);
+    snd_pcm_hw_params_set_channels(mphandle, hwp, mchannels);
+
+
+    dir = 0;
+    snd_pcm_hw_params_get_period_size_min(hwp, &period_size_min, &dir);
+    dir = 0;
+    snd_pcm_hw_params_get_period_size_max(hwp, &period_size_max, &dir);
+    period_size = 256;
+    dir = 0;
+    ret = snd_pcm_hw_params_set_period_size_near(mphandle, hwp, &period_size, &dir);
+
+    if (ret < 0)
+    {
+        cout << __FUNCTION__ << ":audio: Unable to set period size:" << period_size << " (" << snd_strerror(ret) << ")" << endl;
+        snd_pcm_close(mphandle);
+        return FALSE;
+    }
+
+    dir = 0;
+    ret = snd_pcm_hw_params_get_period_size(hwp, &period_size, &dir);
+
+    if (ret < 0) {
+        cout << __FUNCTION__ << ": audio: Unable to get period size:" << snd_strerror(ret) << endl;
+        snd_pcm_close(mphandle);
+        return FALSE;
+    }
+
+    /* Configurue buffer size */
+    snd_pcm_hw_params_get_buffer_size_min(hwp, &buffer_size_min);
+    snd_pcm_hw_params_get_buffer_size_max(hwp, &buffer_size_max);
+    buffer_size = period_size * mframesize;
+
+    dir = 0;
+    ret = snd_pcm_hw_params_set_buffer_size_near(mphandle, hwp, &buffer_size);
+
+    if (ret < 0) {
+        cout << __FUNCTION__ << ":audio: Unable to set buffer size:" << buffer_size << "(" << snd_strerror(ret) << ")" << endl;
+        snd_pcm_close(mphandle);
+        return FALSE;
+    }
+
+    ret = snd_pcm_hw_params_get_buffer_size(hwp, &buffer_size);
+    if (ret < 0) {
+        cout << __FUNCTION__ << ":audio: Unable to get buffer size (" << snd_strerror(ret) << ")" << endl;
+        snd_pcm_close(mphandle);
+        return FALSE;
+    }
+
+    /* write the hw params */
+    ret = snd_pcm_hw_params(mphandle, hwp);
+
+    if (ret < 0) {
+        cout << __FUNCTION__ << ":audio: Unable to configure hardware parameters (" << snd_strerror(ret) << ")" << endl;
+        snd_pcm_close(mphandle);
+        return FALSE;
+    }
+
+    return result;
+}
+
+
+
+/* Close alsa configuration */
+CsrBool CAlsaHandler::AlsaClose()
+{
+    int code;
+    CsrBool result = TRUE;
+
+    if(mphandle != 0)
+    {
+        code = snd_pcm_close(mphandle);
+        mphandle = 0;
+        if(code < 0)
+        {
+           cout << __FUNCTION__ << ":error closing PCM handle, code:" << code << endl;
+           result = FALSE;
+        }
+    }
+
+    return result;
+}
+
+
+
+
+/* Start alsa streaming */
+CsrBool CAlsaHandler::AlsaStart()
+{
+    int code;
+    CsrBool result;
+
+    /* Prepare the handle */
+    code = snd_pcm_prepare(mphandle);
+    if(code < 0)
+    {
+        cout << __FUNCTION__ << ":error preparing PCM handle, code" << code << endl;
+        result = FALSE;
+    }
+    return result;
+}
+
+
+
+/* Stop alsa streaming */
+CsrBool CAlsaHandler::AlsaStop()
+{
+    int code;
+    CsrBool result;
+
+    /* Drain the handle */
+    code = snd_pcm_drain(mphandle);
+    if(code < 0)
+    {
+        cout << __FUNCTION__ << ":error draining (stopping) PCM handle, code" << code << endl;
+        result = FALSE;
+    }
+    else
+    {
+        result = TRUE;
+    }
+
+    return result;
+}
+
+
+
+/* Process alsa playback data */
+int CAlsaHandler::AlsaProcessPlay(void *data, unsigned int length)
+{
+    int frames,check;
+    int res;
+    frames = length / mframesize;
+
+    //cout << __FUNCTION__ << ":Entry" << endl;
+    check = snd_pcm_wait(mphandle,1000);
+    if ( check >= 0 )
+    {
+        check = snd_pcm_avail_update(mphandle);
+    }
+
+    if ( check == -EPIPE )
+    {
+        snd_pcm_prepare(mphandle);
+    }
+
+    res = snd_pcm_writei(mphandle, data, frames);
+    if(res < 0)
+    {
+        AlsaXrun(res);
+    }
+    else if(res != frames)
+    {
+        if (res< 0)
+            res = snd_pcm_recover(mphandle, res, 0);
+        cout << __FUNCTION__ << ":playback device did not consume all frames, sent:" << frames << " , consumed:" << res << endl;
+    }
+
+    return res>0?res*mframesize:0;
+}
+
+
+/* ALSA xrun handler */
+int CAlsaHandler::AlsaXrun(int err)
+{
+    int res;
+
+    merrors++;
+    res = 0;
+    switch(err)
+    {
+        case -EAGAIN:
+            if((merrors % 10) == 0)
+            {
+               cout << __FUNCTION__ << ":device has more data, error count:" << merrors << endl;
+            }
+            snd_pcm_wait(mphandle, 1000);
+            break;
+
+        case -EBADFD:
+            if((merrors % 10) == 0)
+            {
+               cout << __FUNCTION__ << ":device not in right state, error count:" << merrors << endl;
+            }
+            snd_pcm_prepare(mphandle);
+            break;
+
+        case -EPIPE:
+            if((merrors % 10) == 0)
+            {
+               cout << __FUNCTION__ << ":device over/under-run, error count:" << merrors << endl;
+            }
+            snd_pcm_prepare(mphandle);
+            snd_pcm_pause(mphandle, 1);
+            break;
+
+        case -ESTRPIPE:
+            if((merrors % 10) == 0)
+            {
+               cout << __FUNCTION__ << ":device suspend error, error count:" << merrors << endl;
+            }
+            snd_pcm_prepare(mphandle);
+            break;
+
+        default:
+            if((merrors % 10) == 0)
+            {
+               cout << __FUNCTION__ << ":playback thread, unknown error, code:" << res << " , error count:" << merrors << endl;
+            }
+            res = err;
+            snd_pcm_prepare(mphandle);
+            break;
+    }
+
+    return res;
+}
diff --git a/bt-app/a2dp_src/include/A2dp_Src.hpp b/bt-app/a2dp_src/include/A2dp_Src.hpp
index 6826d0e..a284c60 100644
--- a/bt-app/a2dp_src/include/A2dp_Src.hpp
+++ b/bt-app/a2dp_src/include/A2dp_Src.hpp
@@ -138,6 +138,7 @@ class A2dp_Source {
     const bt_interface_t * bluetooth_interface;
     const btav_interface_t *sBtA2dpSourceInterface;
     const btrc_interface_t *sBtAvrcpTargetInterface;
+    const btrc_ctrl_interface_t *sBtAvrcpControlInterface;
     A2dpSourceState mSourceState;
     bool mAvrcpConnected;
     const btav_vendor_interface_t *sBtA2dpSourceVendorInterface;
diff --git a/bt-app/a2dp_src/src/A2dp_Src.cpp b/bt-app/a2dp_src/src/A2dp_Src.cpp
index f7ad27d..850bd24 100644
--- a/bt-app/a2dp_src/src/A2dp_Src.cpp
+++ b/bt-app/a2dp_src/src/A2dp_Src.cpp
@@ -29,6 +29,7 @@
 
 #include <iostream>
 #include <string.h>
+#define BT_AUDIO_HAL_INTEGRATION
 #include <hardware/bluetooth.h>
 #if (defined(BT_AUDIO_HAL_INTEGRATION))
 #include <hardware/hardware.h>
@@ -46,7 +47,6 @@
 #include "hardware/bt_rc_vendor.h"
 #include <math.h>
 #include <algorithm>
-#include <cutils/properties.h>
 #include "osi/include/list.h"
 #include "osi/include/allocator.h"
 
@@ -90,7 +90,7 @@ typedef enum
     SRC_NO_STREAMING,
 }SrcStreamStatus;
 
-#define AUDIO_STREAM_OUTPUT_BUFFER_SZ      (20*512)
+#define AUDIO_STREAM_OUTPUT_BUFFER_SZ      (28*512)
 #define INVALID_CODEC    -1
 #define NON_A2DP_MEDIA_CT    0xFF
 #define DEBUGPRINTBIT
@@ -528,7 +528,7 @@ static void *thread_func(void *in_param)
     ssize_t write_len = 0;
     FILE *in_file = (FILE *)in_param;
     size_t out_buffer_size = 0;
-    int codec_type;
+    int codec_type= A2DP_SINK_AUDIO_CODEC_PCM;;
     short buffer[AUDIO_STREAM_OUTPUT_BUFFER_SZ];
     btav_codec_config_t src_codec_cfg;
     btav_codec_config_t snk_codec_cfg;
@@ -675,8 +675,8 @@ static void *thread_func(void *in_param)
             }
             else
             {
-                write_len = output_stream->write(output_stream, &codec_type, sizeof(codec_type));
-                write_len = output_stream->write(output_stream, &len, sizeof(len));
+                //write_len = output_stream->write(output_stream, &codec_type, sizeof(codec_type));
+                //write_len = output_stream->write(output_stream, &len, sizeof(len));
                 write_len = output_stream->write(output_stream, buffer, len);
             }
         }
@@ -696,7 +696,7 @@ static void BtA2dpStartStreaming()
 
     ALOGD(LOGTAG_A2DP "Start A2dp Stream");
     if (true || !is_sink_relay_enabled) {
-        in_file = fopen("/data/misc/bluetooth/pcmtest.wav", "r");
+        in_file = fopen("/usr/local/pcm.wav", "r");
         if (!in_file) {
             ALOGE(LOGTAG_A2DP "Cannot open input file. Bail out!!");
             return;
@@ -755,6 +755,13 @@ static void bta2dp_audio_state_callback(btav_audio_state_t state, bt_bdaddr_t* b
     PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
 }
 
+static void bta2dp_connection_priority_callback(bt_bdaddr_t* bd_addr) {
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->a2dpSourceEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    pEvent->a2dpSourceEvent.event_id = A2DP_SOURCE_CONNECTION_PRIORITY_REQ;
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
 static void bta2dp_connection_priority_vendor_callback(bt_bdaddr_t* bd_addr) {
     BtEvent *pEvent = new BtEvent;
     memcpy(&pEvent->a2dpSourceEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
@@ -777,6 +784,7 @@ static btav_callbacks_t sBluetoothA2dpSourceCallbacks = {
     bta2dp_connection_state_callback,
     bta2dp_audio_state_callback,
     NULL,
+    bta2dp_connection_priority_callback,
 };
 
 static btav_vendor_callbacks_t sBluetoothA2dpSourceVendorCallbacks = {
@@ -793,9 +801,6 @@ static void btavrc_target_passthrough_cmd_vendor_callback(int id, int key_state,
     if (key_state == KEY_PRESSED) {
         BtEvent *event = new BtEvent;
         event->avrcpTargetEvent.event_id = A2DP_SOURCE_AUDIO_CMD_REQ;
-        /*As there is no player impl available at this point hence STOP/PAUSE has got same functionality*/
-        if(id == CMD_ID_PAUSE)
-            id = CMD_ID_STOP;
         event->avrcpTargetEvent.key_id = id;
         PostMessage (THREAD_ID_A2DP_SOURCE, event);
     }
@@ -859,6 +864,27 @@ static void btavrcp_target_rcfeatures_callback( bt_bdaddr_t* bd_addr, btrc_remot
     pA2dpSource->mLocalVolume = -1;
 }
 
+static void btavrcp_target_connection_state_callback(bool state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_connection_state_callback state = %d", state);
+    BtEvent *pEvent = new BtEvent;
+    memcpy(&pEvent->avrcpTargetEvent.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    if (state == true)
+        pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_CONNECTED_CB;
+    else
+        pEvent->avrcpTargetEvent.event_id = AVRCP_TARGET_DISCONNECTED_CB;
+    PostMessage(THREAD_ID_A2DP_SOURCE, pEvent);
+}
+
+static void btavrcp_target_passthrough_cmd_callback(int id, int key_state, bt_bdaddr_t* bd_addr) {
+    ALOGD(LOGTAG_AVRCP " btavrcp_target_passthrough_cmd_callback id = %d key_state = %d", id, key_state);
+    if (key_state == KEY_PRESSED) {
+        BtEvent *event = new BtEvent;
+        event->avrcpTargetEvent.event_id = A2DP_SOURCE_AUDIO_CMD_REQ;
+        event->avrcpTargetEvent.key_id = id;
+        PostMessage (THREAD_ID_A2DP_SOURCE, event);
+    }
+}
+
 static void btavrcp_target_getelemattr_vendor_callback(uint8_t num_attr,
         btrc_vendor_media_attr_t *p_attrs, bt_bdaddr_t *bd_addr) {
     ALOGD(LOGTAG_AVRCP " btavrcp_target_getelemattr_vendor_callback ");
@@ -931,6 +957,14 @@ static btrc_callbacks_t sBluetoothAvrcpTargetCallbacks = {
    NULL,
    NULL,
    NULL,
+   btavrcp_target_passthrough_cmd_callback,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   NULL,
+   btavrcp_target_connection_state_callback,
    NULL,
 };
 
@@ -1235,15 +1269,15 @@ void A2dp_Source::HandleAvrcpEvents(BtEvent* pEvent) {
             ALOGD(LOGTAG_AVRCP " AVRCP_TARGET_SEND_VOL_UP_DOWN, dir = %d ", dir);
             if (dir == AVRC_KEY_UP)
             {
-                sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice, CMD_ID_VOL_UP, 0);
-                sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice, CMD_ID_VOL_UP, 1);
+                //sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice, CMD_ID_VOL_UP, 0);
+                //sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice, CMD_ID_VOL_UP, 1);
             }
             else if (dir == AVRC_KEY_DOWN)
             {
-                sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice,
+                /*sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice,
                                                                         CMD_ID_VOL_DOWN, 0);
                 sBtAvrcpTargetInterface->send_pass_through_cmd(&mConnectedDevice,
-                                                                        CMD_ID_VOL_DOWN, 1);
+                                                                        CMD_ID_VOL_DOWN, 1);*/
             }
             else
             {
@@ -1567,25 +1601,50 @@ void A2dp_Source::HandleEnableSource(void) {
         ALOGD(LOGTAG_A2DP " ~~ Try to get config , enable_delay_report %d", enable_delay_report);
         //TODO: check and update
 #ifdef USE_LIBHW_AOSP
-        sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks);
+       // sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks);
 #else
-        sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks, 1, 0);
+        //sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks, 1, 0);
 #endif
-        property_get("persist.bt.a2dp_offload_cap", value, "false");
+        //property_get("persist.bt.a2dp_offload_cap", value, "false");
+        strcpy(value,"false");
         ALOGD(LOGTAG_A2DP "offload_cap:%s", value);
         if (strcmp(value, "false") == 0)
         {
             if(enable_delay_report)
-                sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, A2DP_SRC_ENABLE_DELAY_REPORTING, NULL);
+            {
+                #ifdef ANDROID
+                    sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, A2DP_SRC_ENABLE_DELAY_REPORTING, NULL);
+                #else
+                    sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks,1,0,NULL);
+                #endif
+             }
             else
-                sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, 0, NULL);
+             {
+                 #ifdef ANDROID
+                     sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, 0, NULL);
+                 #else
+                     sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks,1,0,NULL);
+                 #endif
+              }
         }
         else
         {
             if(enable_delay_report)
-                sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, A2DP_SRC_ENABLE_DELAY_REPORTING, value);
+            {
+                #ifdef ANDROID
+                    sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, A2DP_SRC_ENABLE_DELAY_REPORTING, value);
+                #else
+                    sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks,1,0,NULL);
+                #endif
+             }
             else
-                sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, 0, value);
+            {
+                #ifdef ANDROID
+                     sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, 0, value);
+                #else
+                     sBtA2dpSourceInterface->init(&sBluetoothA2dpSourceCallbacks,1,0,NULL);
+                #endif
+             }
         }
         //sBtA2dpSourceVendorInterface->init_vendor(&sBluetoothA2dpSourceVendorCallbacks, 1, 0, NULL);
         pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
@@ -1595,11 +1654,14 @@ void A2dp_Source::HandleEnableSource(void) {
         sBtAvrcpTargetInterface = (btrc_interface_t *)bluetooth_interface->
                 get_profile_interface(BT_PROFILE_AV_RC_ID);
         if (sBtAvrcpTargetInterface != NULL) {
+#ifndef ANDROID
+            sBtAvrcpTargetInterface->init(&sBluetoothAvrcpTargetCallbacks, 1);
+#endif
         //TODO: check and update
 #ifdef USE_LIBHW_AOSP
-            sBtAvrcpTargetInterface->init(&sBluetoothAvrcpTargetCallbacks);
+           // sBtAvrcpTargetInterface->init(&sBluetoothAvrcpTargetCallbacks);
 #else
-            sBtAvrcpTargetInterface->init(&sBluetoothAvrcpTargetCallbacks, 1);
+            //sBtAvrcpTargetInterface->init(&sBluetoothAvrcpTargetCallbacks, 1);
 #endif
         }
         // AVRCP TG vendor Initialization
@@ -1750,6 +1812,9 @@ void A2dp_Source::state_disconnected_handler(BtEvent* pEvent) {
             if (sBtA2dpSourceVendorInterface != NULL) {
                 sBtA2dpSourceVendorInterface->allow_connection_vendor(1, &pEvent->a2dpSourceEvent.bd_addr);
             }
+            if (sBtA2dpSourceInterface != NULL) {
+                sBtA2dpSourceInterface->allow_connection(1, &pEvent->a2dpSourceEvent.bd_addr);
+            }
             break;
         default:
             fprintf(stdout, "Event not processed in disconnected state %d ", pEvent->event_id);
@@ -1791,6 +1856,9 @@ void A2dp_Source::state_pending_handler(BtEvent* pEvent) {
             if (sBtA2dpSourceVendorInterface != NULL) {
                 sBtA2dpSourceVendorInterface->allow_connection_vendor(1, &pEvent->a2dpSourceEvent.bd_addr);
             }
+            if (sBtA2dpSourceInterface != NULL) {
+                sBtA2dpSourceInterface->allow_connection(1, &pEvent->a2dpSourceEvent.bd_addr);
+            }
             break;
         default:
             fprintf(stdout, "Event not processed in pending state %d ", pEvent->event_id);
@@ -1831,6 +1899,9 @@ void A2dp_Source::state_connected_handler(BtEvent* pEvent) {
             if (sBtA2dpSourceVendorInterface != NULL) {
                 sBtA2dpSourceVendorInterface->allow_connection_vendor(1, &pEvent->a2dpSourceEvent.bd_addr);
             }
+            if (sBtA2dpSourceInterface != NULL) {
+                sBtA2dpSourceInterface->allow_connection(1, &pEvent->a2dpSourceEvent.bd_addr);
+            }
             break;
         case A2DP_SOURCE_DISCONNECTED_CB:
             media_playing = false;
@@ -1855,7 +1926,7 @@ void A2dp_Source::state_connected_handler(BtEvent* pEvent) {
             fprintf(stdout, "A2DP Source Audio state changes to: %d	\n",pEvent->event_id);
             break;
         case A2DP_SOURCE_AUDIO_STOPPED:
-            fprintf(stdout, "A2DP Source Audio state changes to: %d ", pEvent->event_id);
+            fprintf(stdout, "A2DP Source Audio state changes to: %d     \n", pEvent->event_id);
             break;
         default:
             fprintf(stdout, "Event not processed in connected state %d ", pEvent->event_id);
@@ -1871,7 +1942,11 @@ A2dpSourceState A2dp_Source::get_state() {
 
 bool A2dp_Source::get_codec_cfg(uint8_t* info, uint8_t* type)
 {
-    return sBtA2dpSourceVendorInterface-> get_src_codec_config(info,type);
+    #ifdef USE_VENDOR_INTERFACE
+        return sBtA2dpSourceVendorInterface-> get_src_codec_config(info,type);
+    #else
+       return NULL;
+    #endif
 }
 
 void A2dp_Source::change_state(A2dpSourceState mState) {
diff --git a/bt-app/avrcp/src/Avrcp.cpp b/bt-app/avrcp/src/Avrcp.cpp
index 6eb3039..db936ef 100644
--- a/bt-app/avrcp/src/Avrcp.cpp
+++ b/bt-app/avrcp/src/Avrcp.cpp
@@ -505,7 +505,7 @@ void Avrcp::HandleEnableAvrcp(void) {
         sBtAvrcpCtrlVendorInterface = (btrc_ctrl_vendor_interface_t *)bluetooth_interface->
                 get_profile_interface(BT_PROFILE_AV_RC_CTRL_VENDOR_ID);
 
-        if (sBtAvrcpCtrlInterface == NULL || sBtAvrcpCtrlVendorInterface == NULL)
+        if (sBtAvrcpCtrlInterface == NULL )
         {
              pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
              pEvent->profile_start_event.profile_id = PROFILE_ID_AVRCP;
@@ -565,6 +565,7 @@ Avrcp :: Avrcp(const bt_interface_t *bt_interface, config_t *config) {
     this->bluetooth_interface = bt_interface;
     this->config = config;
     sBtAvrcpCtrlInterface = NULL;
+    sBtAvrcpCtrlVendorInterface = NULL;
     max_avrcp_conn = 0;
     memset(&mConnectedAvrcpDevice, 0, sizeof(bt_bdaddr_t));
     pthread_mutex_init(&this->lock, NULL);
diff --git a/bt-app/conf/bt_app.conf b/bt-app/conf/bt_app.conf
index de952f7..0f27dce 100644
--- a/bt-app/conf/bt_app.conf
+++ b/bt-app/conf/bt_app.conf
@@ -17,15 +17,15 @@ BtSockInputEnabled=true
 
 # Enable Pan by default
 # valid value : true, false
-BtPanEnable=true
+BtPanEnable=false
 
 # NAP role Support
 # valid value : true, false
-BtPanNapRoleSupported=true
+BtPanNapRoleSupported=false
 
 # PANU role Support
 # valid value : true, false
-BtPanPanuRoleSupported=true
+BtPanPanuRoleSupported=false
 
 # Enable GATT by default
 # valid value : true, false
@@ -33,7 +33,7 @@ BtGattEnable=true
 
 # Enable OBEX by default
 # valid value : true, false
-BtObexEnable=true
+BtObexEnable=false
 
 # OBEX logging levels
 # valid value: 1-6
@@ -48,11 +48,11 @@ BtObexLogLevel=3
 
 # Enable Pbap Client by default
 # valid value : true, false
-BtPbapClientEnable=true
+BtPbapClientEnable=false
 
 # Enable OPP Client & Server by default
 # valid value : true, false
-BtOppEnable=true
+BtOppEnable=false
 
 # Enable BLE Supported Profiles
 # valid value : Even Bits per profile
@@ -74,15 +74,15 @@ BtScanMode=2
 
 # A2DP Sink Enable
 # valid value : true, false
-BtA2dpSinkEnable=true
+BtA2dpSinkEnable=false
 
 # AVRCP Enable
 # valid value : true, false
-BtAvrcpEnable=true
+BtAvrcpEnable=false
 
 # HFP client Enable
 # valid value : true, false
-BtHfClientEnable=true
+BtHfClientEnable=false
 
 # HFP AG Enable
 # valid value : true, false
@@ -107,3 +107,14 @@ BtMaxA2dpConn=1
 # Relay data from src to sink
 # valid value : true, false
 BtRelaySinkDatatoSrc=false 
+
+# SPP Server Enable
+# valid value : true, false
+BtSppServerEnable=false
+
+# SPP Client Enable
+# valid value : true, false
+BtSppClientEnable=false
+
+#HID Enable
+BtHidEnable=true
diff --git a/bt-app/configure.ac b/bt-app/configure.ac
index 15f529c..5ac0640 100644
--- a/bt-app/configure.ac
+++ b/bt-app/configure.ac
@@ -32,17 +32,6 @@ if (test "x${with_glib}" = "xyes"); then
 
        AC_ARG_WITH([gstreamer],
            AS_HELP_STRING([--with-gstreamer],[use gstreamer pipeline for audio playback]))
-       USE_GST=NO
-       if test "x$with_gstreamer" = "xyes"; then
-           PKG_CHECK_MODULES(GSTREAMER, [gstreamer-1.0 gstreamer-tag-1.0], USE_GST=yes, USE_GST=no)
-       fi
-       AC_SUBST(GSTREAMER_LIBS)
-       AC_SUBST(GSTREAMER_CFLAGS)
-       AC_SUBST(USE_GST)
-       AM_CONDITIONAL(USE_GST, test "x$USE_GST" = "xyes")
-       if test "x$USE_GST" = "xyes"; then
-           AC_DEFINE(USE_GST, 1, [Define if use GStreamer])
-       fi
 fi
 
 AM_CONDITIONAL(USE_GLIB, test "x${with_glib}" = "xyes")
diff --git a/bt-app/gap/src/AdapterProperties.cpp b/bt-app/gap/src/AdapterProperties.cpp
index 5d492ed..1cec5a9 100644
--- a/bt-app/gap/src/AdapterProperties.cpp
+++ b/bt-app/gap/src/AdapterProperties.cpp
@@ -57,7 +57,9 @@ AdapterProperties :: ~AdapterProperties() {
 
 
 void AdapterProperties::FlushBondedDeviceList() {
+    pthread_mutex_lock(&lock_);
     bonded_devices.clear();
+    pthread_mutex_unlock(&lock_);
 }
 
 
@@ -148,19 +150,23 @@ void AdapterProperties :: OnbondStateChanged( bt_bdaddr_t bd_addr,
 
     if (!remote_device_prop)
         remote_device_prop = remote_devices_obj_->AddDeviceProperties(bd_addr);
-
+    printf("on Bond Change Search bd %d\n",new_state); 
     remote_device_prop->bond_state = new_state;
-
     bdstring = std::find(bonded_devices.begin(), bonded_devices.end(), deviceAddress);
-
+    printf("on Bond Change Search bd %s\n",deviceAddress.c_str());
     switch (new_state) {
+        
         case BT_BOND_STATE_BONDED:
             if (bdstring == bonded_devices.end())
-                bonded_devices.push_back (deviceAddress);
+                pthread_mutex_lock(&lock_);
+                    bonded_devices.push_back (deviceAddress);
+                pthread_mutex_unlock(&lock_);
             break;
         case BT_BOND_STATE_NONE:
             if (bdstring != bonded_devices.end())
-                bonded_devices.remove(deviceAddress);
+		pthread_mutex_lock(&lock_);
+                   bonded_devices.remove(deviceAddress);
+                pthread_mutex_unlock(&lock_);
             break;
     }
 
diff --git a/bt-app/gap/src/Gap.cpp b/bt-app/gap/src/Gap.cpp
old mode 100644
new mode 100755
index 7e824f2..fc88844
--- a/bt-app/gap/src/Gap.cpp
+++ b/bt-app/gap/src/Gap.cpp
@@ -43,6 +43,7 @@ const char *BT_A2DP_SOURCE_ENABLED_STRING  = "BtA2dpSourceEnable";
 const char *BT_HFP_CLIENT_ENABLED_STRING  = "BtHfClientEnable";
 const char *BT_PAN_ENABLED    = "BtPanEnable";
 const char *BT_GATT_ENABLED   = "BtGattEnable";
+const char *BT_HID_ENABLED_STRING    = "BtHidEnable";
 #ifdef USE_BT_OBEX
 const char *BT_OBEX_ENABLED    = "BtObexEnable";
 const char *BT_OBEX_LOG_LEVEL    = "BtObexLogLevel";
@@ -51,6 +52,8 @@ const char *BT_OPP_ENABLED   = "BtOppEnable";
 #endif
 const char *BT_HFP_AG_ENABLED_STRING  = "BtHfpAGEnable";
 const char *BT_AVRCP_ENABLED_STRING  = "BtAvrcpEnable";
+const char *BT_SPP_SERVER_ENABLED_STRING  = "BtSppServerEnable";
+const char *BT_SPP_CLIENT_ENABLED_STRING  = "BtSppClientEnable";
 
 #define LOGTAG "GAP "
 
@@ -164,6 +167,7 @@ static void BondStateChangedCb(bt_status_t status, bt_bdaddr_t *bd_addr,
     BtEvent *event = new BtEvent;
 
     ALOGV (LOGTAG " BondStateChangedCb: %d", state);
+    printf("Bond state Change  %d\n",state);
     event->event_id = GAP_EVENT_BOND_STATE_INT;
     memcpy(&event->bond_state_event_int.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
     event->bond_state_event_int.state = state;
@@ -263,17 +267,19 @@ static bt_callbacks_t sBluetoothCallbacks = {
     NULL,
 };
 
-static void SsrCleanupCb() {
+static void SsrCleanupCb(bool status) {
     ALOGV (LOGTAG " SsrCleanupCb: ");
     BtEvent *event = new BtEvent;
     event->event_id = GAP_EVENT_SSR_CLEANUP;
     PostMessage(THREAD_ID_GAP, event);
 }
-
+static void updateSnoopCb(bool status) {
+ALOGV (LOGTAG " updateSnoopCb: ");
+}
 static btvendor_callbacks_t sVendorCallbacks = {
     sizeof(sVendorCallbacks),
-    NULL,
     SsrCleanupCb,
+    updateSnoopCb,
 };
 
 void BtGapMsgHandler(void *msg) {
@@ -300,7 +306,7 @@ void profile_startup_timer_expired(void *context) {
 
     BtEvent *event = new BtEvent;
     event->event_id = GAP_EVENT_PROFILE_START_TIMEOUT;
-    PostMessage(THREAD_ID_GAP, event);
+    //PostMessage(THREAD_ID_GAP, event);
 }
 
 void profile_stop_timer_expired(void *context) {
@@ -308,7 +314,7 @@ void profile_stop_timer_expired(void *context) {
 
     BtEvent *event = new BtEvent;
     event->event_id = GAP_EVENT_PROFILE_STOP_TIMEOUT;
-    PostMessage(THREAD_ID_GAP, event);
+    //PostMessage(THREAD_ID_GAP, event);
 }
 
 void enable_timer_expired(void *context) {
@@ -396,13 +402,14 @@ void Gap::HandleBondStateEvent(DeviceBondStateEventInt *event) {
     remote_dev_prop = remote_devices_obj_->GetDeviceProperties(event->bd_addr);
 
     if (remote_dev_prop == NULL ) {
+	printf("Adding prop in this case Alarm!!!!/n");
         remote_dev_prop = remote_devices_obj_->AddDeviceProperties(event->bd_addr);
     }
-
+    printf("Handle Bond State ..0 %d\n",event->state);
     if (remote_dev_prop->bond_state == event->state)
         return;
-
-    adapter_properties_obj_->OnbondStateChanged(event->bd_addr, event->state, true);
+    printf("Handle Bond State %d\n",event->state);
+    adapter_properties_obj_->OnbondStateChanged(event->bd_addr,event->state, true);
 }
 
 void Gap::HandleEnable(void) {
@@ -507,7 +514,7 @@ void Gap::ProcessEvent(BtEvent* event) {
                 bluetooth_interface_->set_adapter_property(&prop);
 
                 prop.type = BT_PROPERTY_BDNAME;
-                strlcpy((char*)&bd_name.name[0], config_get_string (config_,
+                strncpy((char*)&bd_name.name[0], config_get_string (config_,
                    CONFIG_DEFAULT_SECTION, BT_LOCAL_DEV_NAME, "MDM_Fluoride"), sizeof(bd_name));
                 prop.val = &bd_name;
                 prop.len = strlen((char*)bd_name.name);
@@ -533,8 +540,6 @@ void Gap::ProcessEvent(BtEvent* event) {
 
                 adapter_properties_obj_->FlushBondedDeviceList();
                 remote_devices_obj_->FlushDiscoveredDeviceList();
-                // cleanup the stack
-                bluetooth_interface_->cleanup();
 #ifdef USE_BT_OBEX
                 if (is_obex_enabled_) {
                     OI_OBEX_LOWER_SetSocketInterface(NULL);
@@ -549,13 +554,13 @@ void Gap::ProcessEvent(BtEvent* event) {
 
             }
             break;
-
+	case GAP_API_INIT:
+	    ALOGV("Bluetooth Interface Initialised\n");
+	    bluetooth_interface_->init(&sBluetoothCallbacks);
+	    break;
         case GAP_API_ENABLE:
 
-            if (adapter_properties_obj_->GetState() == BT_ADAPTER_STATE_OFF) {
-                bluetooth_interface_->init(&sBluetoothCallbacks);
-            }
-            else {
+            if (adapter_properties_obj_->GetState() == BT_ADAPTER_STATE_ON) {           
                 ALOGV (LOGTAG "Ignoring GAP_API_ENABLE command state : %d",
                                 adapter_properties_obj_->GetState());
                 fprintf(stdout, "Ignoring GAP_API_ENABLE command state : %d\n",
@@ -568,15 +573,11 @@ void Gap::ProcessEvent(BtEvent* event) {
                 PostMessage(THREAD_ID_MAIN, bt_event);
                 break;
             }
-
-            // check if there are profiles enabled
-            if(!supported_profiles_count) {
-                HandleEnable();
-                break;
-            }
-
+#ifdef ANDROID
             ALOGV (LOGTAG "Start QC BT Daemon");
             system("qcbtdaemon &");
+#endif
+	    HandleEnable();
 
 #ifdef USE_BT_OBEX
             /* Initialize OBEX if enabled in config */
@@ -609,8 +610,8 @@ void Gap::ProcessEvent(BtEvent* event) {
                 if(profile_config[profile_id].is_enabled) {
                     bt_event = new BtEvent;
                     bt_event->event_id = PROFILE_API_START;
-                    ALOGD(LOGTAG " sending start to Profile %d",
-                        profile_id);
+                    /*printf(" sending start to Profile %d\n",
+                        profile_id);*/
                     PostMessage(profile_config[profile_id].thread_id, bt_event);
                 }
             }
@@ -624,8 +625,6 @@ void Gap::ProcessEvent(BtEvent* event) {
                 if((profile_config[profile_id].is_enabled)  &&
                    ((profile_config[profile_id].profile_id ==
                             event->profile_start_event.profile_id))) {
-                    ALOGD(LOGTAG " Profile %d started with status %d",
-                        profile_id, event->profile_stop_event.status);
                     profile_config[profile_id].start_status =
                     event->profile_start_event.status;
                 }
@@ -643,7 +642,6 @@ void Gap::ProcessEvent(BtEvent* event) {
             ALOGD(LOGTAG " All profiles started");
             //stoping profile_startup_timer
             alarm_cancel(profile_startup_timer);
-            HandleEnable();
 
             break;
         case PROFILE_EVENT_STOP_DONE:
@@ -685,7 +683,7 @@ void Gap::ProcessEvent(BtEvent* event) {
             kill(getpid(), SIGKILL);
             break;
         case GAP_API_DISABLE:
-            if (adapter_properties_obj_->GetState() != BT_ADAPTER_STATE_ON) {
+            if (adapter_properties_obj_->GetState() == BT_ADAPTER_STATE_OFF) {
                 ALOGV (LOGTAG "Ignoring GAP_API_DISABLE command state : %d",
                                             adapter_properties_obj_->GetState());
                 fprintf(stdout, "Ignoring GAP_API_DISABLE command state : %d\n",
@@ -699,6 +697,8 @@ void Gap::ProcessEvent(BtEvent* event) {
                 break;
 
             }
+	     HandleDisable();
+
             if (profile_config[PROFILE_ID_A2DP_SINK].is_enabled)
             {
                 bt_event = new BtEvent;
@@ -709,14 +709,6 @@ void Gap::ProcessEvent(BtEvent* event) {
 
             /*Fall through*/
         case A2DP_SINK_CLEANUP_DONE:
-            // check if there are profiles enabled
-            if(!supported_profiles_count) {
-                HandleDisable();
-                ALOGV (LOGTAG "Stop QC BT Daemon");
-                system("killall -s SIGTERM qcbtdaemon");
-                break;
-            }
-
             ALOGV (LOGTAG "Stop QC BT Daemon");
             system("killall -s SIGTERM qcbtdaemon");
 
@@ -878,14 +870,19 @@ Gap :: Gap(const bt_interface_t *bt_interface, config_t *config) {
             this->profile_config[profile_id].thread_id = THREAD_ID_HFP_AG;
         else if(profile_id == PROFILE_ID_AVRCP)
             this->profile_config[profile_id].thread_id = THREAD_ID_AVRCP;
-
+        else if(profile_id == PROFILE_ID_SPP_SERVER)
+            this->profile_config[profile_id].thread_id = THREAD_ID_SPP_SERVER;
+        else if(profile_id == PROFILE_ID_SPP_CLIENT)
+            this->profile_config[profile_id].thread_id = THREAD_ID_SPP_CLIENT;
+        else if(profile_id == PROFILE_ID_HID)
+            this->profile_config[profile_id].thread_id = THREAD_ID_HID;
     }
 
     this->profile_config[PROFILE_ID_A2DP_SINK].is_enabled = config_get_bool (config,
                      CONFIG_DEFAULT_SECTION, BT_A2DP_SINK_ENABLED_STRING, false);
 
-    this->profile_config[PROFILE_ID_A2DP_SOURCE].is_enabled = config_get_bool (config,
-                     CONFIG_DEFAULT_SECTION, BT_A2DP_SOURCE_ENABLED_STRING, false);
+    this->profile_config[PROFILE_ID_A2DP_SOURCE].is_enabled =config_get_bool (config,
+                    CONFIG_DEFAULT_SECTION, BT_A2DP_SOURCE_ENABLED_STRING, false);
 
     this->profile_config[PROFILE_ID_HFP_CLIENT].is_enabled = config_get_bool (config,
                      CONFIG_DEFAULT_SECTION, BT_HFP_CLIENT_ENABLED_STRING, false);
@@ -896,6 +893,12 @@ Gap :: Gap(const bt_interface_t *bt_interface, config_t *config) {
     this->profile_config[PROFILE_ID_AVRCP].is_enabled = config_get_bool (config,
                      CONFIG_DEFAULT_SECTION, BT_AVRCP_ENABLED_STRING, false);
 
+    this->profile_config[PROFILE_ID_SPP_SERVER].is_enabled = config_get_bool (config,
+                     CONFIG_DEFAULT_SECTION, BT_SPP_SERVER_ENABLED_STRING, false);
+
+    this->profile_config[PROFILE_ID_SPP_CLIENT].is_enabled = config_get_bool (config,
+                     CONFIG_DEFAULT_SECTION, BT_SPP_CLIENT_ENABLED_STRING, false);
+
     if ((this->profile_config[PROFILE_ID_A2DP_SINK].is_enabled) ||
         (this->profile_config[PROFILE_ID_HFP_CLIENT].is_enabled)) {
         this->profile_config[PROFILE_ID_BT_AM].is_enabled = true;
@@ -909,6 +912,8 @@ Gap :: Gap(const bt_interface_t *bt_interface, config_t *config) {
 
     // SDP Client should be enabled and is not configurable to be disabled
     this->profile_config[PROFILE_ID_SDP_CLIENT].is_enabled = true;
+	this->profile_config[PROFILE_ID_HID].is_enabled = config_get_bool (config,
+                   CONFIG_DEFAULT_SECTION, BT_HID_ENABLED_STRING, false);
 
 #ifdef USE_BT_OBEX
     this->profile_config[PROFILE_ID_PBAP_CLIENT].is_enabled = config_get_bool (config,
diff --git a/bt-app/gap/src/RemoteDevices.cpp b/bt-app/gap/src/RemoteDevices.cpp
index 7a278c7..dcde49c 100644
--- a/bt-app/gap/src/RemoteDevices.cpp
+++ b/bt-app/gap/src/RemoteDevices.cpp
@@ -76,6 +76,10 @@ DeviceProperties *RemoteDevices:: GetDeviceProperties(bt_bdaddr_t bd_addr) {
 
 void RemoteDevices :: HandleAclStateChange(int status, bt_bdaddr_t bd_addr,
         int newState) {
+    bdstr_t bd_str;
+    bdaddr_to_string(&bd_addr, &bd_str[0], sizeof(bd_str));
+    printf ("ACL State Of Device %s State %d\n", bd_str,newState);
+
 }
 
 bool RemoteDevices::GetValueFromPropertyList(int num_properties,
@@ -167,7 +171,10 @@ void RemoteDevices::DeviceFound(DeviceFoundEventInt *dev_found) {
 
     /* Free the memory used for properties */
     ClearPropertyList(dev_found->num_properties, dev_found->properties);
-
+	if(strlen(rem_dev_prop->name) == 0)
+	{
+	   strncpy(rem_dev_prop->name ,"No Name",7);
+	}
     /* Update only if remote device Name is available for Now */
     if (strlen(rem_dev_prop->name) > 0) {
         bt_event = new BtEvent;
@@ -188,7 +195,6 @@ void RemoteDevices::RemoteDeviceProperties(RemotePropertiesEvent *event) {
     if (!rem_dev_prop) {
         rem_dev_prop = AddDeviceProperties(event->bd_addr);
     }
-
     memset(rem_dev_prop->name, 0, sizeof(rem_dev_prop->name));
     GetValueFromPropertyList(event->num_properties, event->properties,
             BT_PROPERTY_BDADDR, &rem_dev_prop->address);
@@ -209,6 +215,16 @@ void RemoteDevices::RemoteDeviceProperties(RemotePropertiesEvent *event) {
         PostMessage(THREAD_ID_MAIN, bt_event);
         rem_dev_prop->broadcast = false;
     }
+    else if ((rem_dev_prop->name[0] != '\0') &&
+            (rem_dev_prop->bond_state != BT_BOND_STATE_BONDED) )
+    {
+        bt_event = new BtEvent;
+        bt_event->event_id = MAIN_EVENT_DEVICE_FOUND;
+        memcpy(&bt_event->device_found_event.remoteDevice, rem_dev_prop,
+                sizeof(DeviceProperties));
+        fprintf(stdout, "Update inquiry_list with device Name: %s\n", rem_dev_prop->name);
+        PostMessage(THREAD_ID_MAIN, bt_event);
+    }
 
     GetValueFromPropertyList(event->num_properties, event->properties,
             BT_PROPERTY_CLASS_OF_DEVICE, &rem_dev_prop->bluetooth_class);
diff --git a/bt-app/hid/include/Hid.hpp b/bt-app/hid/include/Hid.hpp
new file mode 100644
index 0000000..5a1c0c7
--- /dev/null
+++ b/bt-app/hid/include/Hid.hpp
@@ -0,0 +1,82 @@
+ /*
+  * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#ifndef HID_APP_H
+#define HID_APP_H
+
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_rc.h>
+#include <pthread.h>
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/allocator.h"
+#include "ipc.h"
+#include "utils.h"
+#include "hardware/bt_rc_vendor.h"
+#include "hardware/bt_hh.h"
+#include <list>
+
+typedef enum {
+    HID_STATE_IDLE = 0,
+    HID_STATE_DISCONNECTED,
+    HID_STATE_DISCONNECTING,
+    HID_STATE_CONNECTING,
+    HID_STATE_CONNECTED,
+    HID_STATE_UNKNOWN
+}HIDConnectiontState;
+
+class Hid {
+
+  private:
+   config_t *config;
+    const bt_interface_t * bluetooth_interface;
+	const bthh_interface_t *sBluetoothHidInterface;
+	//const bthd_interface_t  *sBluetoothHidDevInterface;
+	HIDConnectiontState mConnectionState;
+	bt_bdaddr_t mConnectingDevice;
+    bt_bdaddr_t mConnectedDevice;
+	
+  public:
+    Hid(const bt_interface_t *bt_interface, config_t *config);
+    ~Hid();
+	void ChangeConnectionState(HIDConnectiontState mState);
+	void HandleEnableHID(void);
+	void HandleDisableHID(void);
+	void EventManager(BtEvent* pEvent, bt_bdaddr_t dev);
+	void state_disconnected_handler(BtEvent* pEvent);
+	void state_connecting_handler(BtEvent* pEvent);
+	void state_connected_handler(BtEvent* pEvent) ;
+        void ProcessEvent (BtEvent* pEvent);
+         pthread_mutex_t lock;
+};
+#endif
diff --git a/bt-app/hid/src/Hid.cpp b/bt-app/hid/src/Hid.cpp
new file mode 100644
index 0000000..0673e8e
--- /dev/null
+++ b/bt-app/hid/src/Hid.cpp
@@ -0,0 +1,413 @@
+ /*
+  * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#include <list>
+#include <map>
+#include <iostream>
+#include <string.h>
+#include <hardware/bluetooth.h>
+#include <hardware/hardware.h>
+#include <hardware/bt_hh.h>
+//#include <hardware/bt_rc.h>
+#include <algorithm>
+
+//#include "Ipc.h"
+#include "Hid.hpp"
+#include "Gap.hpp"
+#include "hardware/bt_rc_vendor.h"
+
+#define LOGTAG "HID"
+#define LOGTAG_CTRL "HID_CTRL"
+
+static const bt_bdaddr_t bd_addr_null= {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+Hid *pHid = NULL;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void BtHidMsgHandler(void *msg) {
+    ALOGD(LOGTAG " Process Event for BtHidMsgHandler");
+    BtEvent* pEvent = NULL;
+    BtEvent* pCleanupEvent = NULL;
+    if(!msg) {
+        printf("Msg is NULL, return.\n");
+        return;
+    }
+
+    pEvent = ( BtEvent *) msg;
+    switch(pEvent->event_id) {
+
+        case PROFILE_API_START:
+            ALOGD(LOGTAG " enable hid");
+            if (pHid) {
+                pHid->HandleEnableHID();
+            }
+            break;
+        case PROFILE_API_STOP:
+            ALOGD(LOGTAG " disable hid");
+            if (pHid) {
+                pHid->HandleDisableHID();
+            }
+            break;
+
+        default:
+			if(pHid) {
+               pHid->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+            break;
+    }
+    delete pEvent;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+static void connection_state_cb(bt_bdaddr_t *bd_addr, bthh_connection_state_t state) {
+    BtEvent *pEvent = new BtEvent;
+	char str[18];
+	bdstr_t bd_str;
+    std::list<std::string>::iterator bdstring;
+    memcpy(&pEvent->hid_profile_event.bd_addr, bd_addr, sizeof(bt_bdaddr_t));
+    bdaddr_to_string(&pEvent->hid_profile_event.bd_addr, &bd_str[0], sizeof(bd_str));
+    std::string deviceAddress(bd_str);
+    switch( state ) {
+
+		case BTHH_CONN_STATE_CONNECTED:
+		{
+			pEvent->hid_profile_event.event_id = HID_API_CONNECTED_CB;
+			printf("Connected\n");
+		/*	bdstring = std::find(connected_device.begin(), connected_device.end(), deviceAddress);
+		    if (bdstring == connected_device.end())
+		    {
+		        ALOGE(LOGTAG_CTRL " RC connected for this dev w/o HID, cache this device in list");
+		        connected_device.push_back(deviceAddress);
+		    }
+		    else
+		    {
+		        ALOGE(LOGTAG_CTRL " this RC device already in list, should never hit here, ERROR!!!");
+		    }*/
+		}
+		break;
+        case BTHH_CONN_STATE_CONNECTING:
+                         printf("Connecting!! \n");
+			//pEvent->hid_profile_event.event_id = HID_API_CONNECTING_CB;
+			break;
+        case BTHH_CONN_STATE_DISCONNECTED:
+	    {
+			printf("Disconnected\n");
+			pEvent->hid_profile_event.event_id = HID_API_DISCONNECTED_CB;
+		/*	bdstring = std::find(connected_device.begin(), connected_device.end(), deviceAddress);
+		    if (bdstring == connected_device.end())
+		    {
+		        ALOGE(LOGTAG_CTRL " RC connected for this dev w/o HID, cache this device in list");
+		        connected_device.remove(deviceAddress);
+		    }
+		    else
+		    {
+		        ALOGE(LOGTAG_CTRL " this RC device already in list, should never hit here, ERROR!!!");
+		    }*/
+		}
+		break;
+        case BTHH_CONN_STATE_DISCONNECTING:
+			pEvent->hid_profile_event.event_id = HID_API_DISCONNECTING_CB;
+			break;
+        case BTHH_CONN_STATE_FAILED_MOUSE_FROM_HOST:
+		    break;
+		
+	    case BTHH_CONN_STATE_FAILED_KBD_FROM_HOST:
+			break;
+	    case BTHH_CONN_STATE_FAILED_TOO_MANY_DEVICES:
+			break;
+	    case BTHH_CONN_STATE_FAILED_NO_BTHID_DRIVER:
+			break;
+	    case BTHH_CONN_STATE_FAILED_GENERIC:
+			break;
+	    case BTHH_CONN_STATE_UNKNOWN:
+			break;
+        default:
+        break;
+    }
+    PostMessage(THREAD_ID_HID, pEvent);
+}
+static void get_report_cb(bt_bdaddr_t *bd_addr, bthh_status_t hh_status, uint8_t *rpt_data, int rpt_size) {
+   char str[18];
+   int i;
+   if((hh_status != BTHH_OK) || (rpt_size ==0 ) || (rpt_size > 15))/*Handle only Release Event, check for size*/
+     return;
+}
+static void handshake_cb(bt_bdaddr_t *bd_addr, bthh_status_t hh_status){
+	char str[18];
+    if(hh_status !=   BTHH_OK )
+		return;
+    bdaddr_to_string(bd_addr, str, 18);
+	fprintf(stdout, "handshake callback for device %s\n", str);
+	ALOGD(LOGTAG "handshake for device %s ",str);
+}
+
+static void protocol_mode_cb(bt_bdaddr_t *bd_addr, bthh_status_t hh_status,bthh_protocol_mode_t mode) {
+    char str[18];
+    if(hh_status !=   BTHH_OK )
+		return;
+    bdaddr_to_string(bd_addr, str, 18);
+	fprintf(stdout, "Protocol Mode for device %s\n", str);
+	ALOGD(LOGTAG "Protocol mode for device %s is: %d",str,mode);
+}
+
+static void virtual_unplug_cb(bt_bdaddr_t *bd_addr, bthh_status_t hh_status) {
+	char str[18];
+    if(hh_status !=   BTHH_OK )
+		return;
+    bdaddr_to_string(bd_addr, str, 18);
+	fprintf(stdout, "virtual unplug callback for device %s\n", str);
+	ALOGD(LOGTAG "Initiating disconnect for device %s ",str);
+   /*TODO if (sBluetoothHidInterface != NULL) {
+    sBluetoothHidInterface->disconnect(&bd_addr);
+	}*/
+}
+
+static bthh_callbacks_t sBluetoothHidCallbacks = {
+    sizeof(sBluetoothHidCallbacks),
+    connection_state_cb,
+    NULL,
+    protocol_mode_cb,
+    NULL,
+    get_report_cb,
+    virtual_unplug_cb,
+    handshake_cb
+};
+/*Constructor and Destructor Structure of the Class*/
+Hid::Hid(const bt_interface_t *bt_interface, config_t *config)
+{
+    ALOGD(LOGTAG "(%s) Starting Up HID Instance",__FUNCTION__);
+    this->sBluetoothHidInterface = NULL;
+    this->bluetooth_interface = bt_interface;
+    this->config = config;
+}
+Hid::~Hid()
+{
+    ALOGD(LOGTAG  "(%s) Cleaning up HID Interface",__FUNCTION__);
+    //GattInterfaceCleanup();
+}
+/*****************************************************************/
+
+void Hid::ChangeConnectionState(HIDConnectiontState mState) {
+   ALOGD(LOGTAG " current State = %d, new state = %d", mConnectionState, mState);
+   fprintf(stdout, " current State = %d, new state = %d\n", mConnectionState, mState);
+   pthread_mutex_lock(&lock);
+   mConnectionState = mState;
+   ALOGD(LOGTAG " state changes to %d ", mState);
+   pthread_mutex_unlock(&lock);
+}
+void Hid::HandleEnableHID(void) {
+    BtEvent *pEvent = new BtEvent;
+    ALOGD(LOGTAG "%s HandleEnableHID ",__func__);
+
+    /*max_avrcp_conn = config_get_int (config,
+            CONFIG_DEFAULT_SECTION, "BtMaxA2dpConn", 1);*/
+
+    if (bluetooth_interface != NULL)
+    {
+        // AVRCP CT Initialization
+        sBluetoothHidInterface = (bthh_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_HIDHOST_ID);
+		/*sBluetoothHidDevInterface = (bthd_interface_t *)bluetooth_interface->
+                get_profile_interface(BT_PROFILE_HIDDEV_ID);*/
+
+        if (sBluetoothHidInterface != NULL) {
+            sBluetoothHidInterface->init(&sBluetoothHidCallbacks);
+        }
+
+        /*ChangeConnectionState(HID_STATE_DISCONNECTED);
+        pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+        pEvent->profile_start_event.profile_id = PROFILE_ID_HID;
+        pEvent->profile_start_event.status = true;
+
+        PostMessage(THREAD_ID_GAP, pEvent);*/
+		
+		/*if (sBluetoothHidDevInterface != NULL) {
+            sBluetoothHidDevInterface->init(&sBluetoothHidDevCallbacks);
+        }*/
+		ALOGD(LOGTAG "%s Enable HID  ",__func__);
+        pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+        pEvent->profile_start_event.profile_id = PROFILE_ID_HID;
+        pEvent->profile_start_event.status = true;
+        ChangeConnectionState(HID_STATE_DISCONNECTED);
+        PostMessage(THREAD_ID_GAP, pEvent);
+		
+    }
+}
+void Hid::HandleDisableHID(void) {
+    ALOGD(LOGTAG_CTRL " HandleDisableHID ");
+
+   if (sBluetoothHidInterface != NULL) {
+       sBluetoothHidInterface->cleanup();
+       sBluetoothHidInterface = NULL;
+   }
+   BtEvent *pEvent = new BtEvent;
+   ChangeConnectionState(HID_STATE_IDLE);
+   pEvent->profile_stop_event.event_id = PROFILE_EVENT_STOP_DONE;
+   pEvent->profile_stop_event.profile_id = PROFILE_ID_HID;
+   pEvent->profile_stop_event.status = true;
+   PostMessage(THREAD_ID_GAP, pEvent);
+}
+
+void Hid::ProcessEvent(BtEvent* pEvent) {
+    ALOGD(LOGTAG " Processing event %d in state %d", pEvent->event_id, mConnectionState);
+    fprintf(stdout, " Processing event %d in state %d\n", pEvent->event_id, mConnectionState);
+    switch(mConnectionState) {
+		
+        case HID_STATE_DISCONNECTED:
+            state_disconnected_handler(pEvent);
+            break;
+        case HID_STATE_CONNECTING:
+            state_connecting_handler(pEvent);
+            break;
+        case HID_STATE_CONNECTED:
+            state_connected_handler(pEvent);
+            break;
+        case HID_STATE_UNKNOWN:
+            ALOGE(LOGTAG," STATE UNINITIALIZED, return");
+            break;
+    }
+}
+void Hid::state_connected_handler(BtEvent* pEvent) {
+	char str[18];
+    ALOGD(LOGTAG "state_connected_handler Processing event %d", pEvent->event_id);
+    switch(pEvent->event_id) {
+        case HID_API_CONNECT_REQ:/*Strictly for Multi Device Case*/     
+            if (sBluetoothHidInterface != NULL) {
+	        printf("Multidevice connection\n");					
+                sBluetoothHidInterface->connect(&pEvent->hid_profile_event.bd_addr);
+            }
+            ChangeConnectionState(HID_STATE_CONNECTING);
+	break;
+        case HID_API_DISCONNECT_REQ:
+
+            if (sBluetoothHidInterface != NULL) {
+                sBluetoothHidInterface->disconnect(&pEvent->hid_profile_event.bd_addr);
+            }
+            //ChangeConnectionState(HID_STATE_DISCONNECTING);
+            break;
+        case HID_API_DISCONNECTED_CB:
+	    printf("HID Device is Successfully Disconnected!!!!!!!!\n");
+            ChangeConnectionState(HID_STATE_DISCONNECTED);
+            break;
+	    case HID_API_CONNECTED_CB:
+            printf("HID Device is Successfully Connected!!!!!!!!\n");
+            break;
+        case HID_API_DISCONNECTING_CB:
+            //PostMessage(THREAD_ID_BT_AM, pReleaseControlReq);
+            break;
+		case HID_API_SET_REPORT_REQ:
+            memcpy(&mConnectedDevice, &pEvent->hid_profile_event.bd_addr, sizeof(bt_bdaddr_t));
+            if (sBluetoothHidInterface != NULL) {
+                sBluetoothHidInterface->set_report(&pEvent->hid_profile_event.bd_addr,(bthh_report_type_t)pEvent->hid_profile_event.reportType,pEvent->hid_profile_event.report);
+            }
+            bdaddr_to_string(&mConnectingDevice, str, 18);
+            fprintf(stdout, "Handling SET RPT for HID device %s\n", str);
+            ALOGD(LOGTAG "Sending SET Report for device%s", str);
+
+			break;
+		case HID_API_GET_REPORT_REQ:
+			memcpy(&mConnectedDevice, &pEvent->hid_profile_event.bd_addr, sizeof(bt_bdaddr_t));
+
+            if (sBluetoothHidInterface != NULL) {
+       /*         sBluetoothHidInterface->get_report(&pEvent->hid_profile_event.bd_addr,pEvent->hid_profile_event.reportType\
+					,&pEvent->hid_profile_event.report,&pEvent->hid_profile_event.buf_size);*/
+            }
+		    bdaddr_to_string(&mConnectingDevice, str, 18);
+            fprintf(stdout, "Handling GET RPT for HID device %s\n", str);
+            ALOGD(LOGTAG "Sending GET Report for device%s", str);
+			break;
+		 case HID_API_SET_PROTOCOL_REQ:
+            memcpy(&mConnectedDevice, &pEvent->hid_profile_event.bd_addr, sizeof(bt_bdaddr_t));
+            if (sBluetoothHidInterface != NULL) {
+                sBluetoothHidInterface->set_protocol(&pEvent->hid_profile_event.bd_addr,(bthh_protocol_mode_t)pEvent->hid_profile_event.reportType);
+            }
+			bdaddr_to_string(&mConnectingDevice, str, 18);
+            fprintf(stdout, "Handling SET Protocolfor HID device %s\n", str);
+            ALOGD(LOGTAG "Sending SET Protocol for device%s", str);
+
+			break;
+		case HID_API_VIRTUAL_UNPLUG_REQ:
+			memcpy(&mConnectedDevice, &pEvent->hid_profile_event.bd_addr, sizeof(bt_bdaddr_t));
+
+            if (sBluetoothHidInterface != NULL) {
+                sBluetoothHidInterface->virtual_unplug(&pEvent->hid_profile_event.bd_addr);
+            }
+		    bdaddr_to_string(&mConnectedDevice, str, 18);
+            fprintf(stdout, "Handling Virtual Unplug for HID device %s\n", str);
+            ALOGD(LOGTAG "Sending Disconnect for device %s", str);
+			break;
+        default:
+            ALOGD(LOGTAG," event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+void Hid::state_disconnected_handler(BtEvent* pEvent) {
+
+    ALOGD(LOGTAG "state_disconnected_handler Processing event %d", pEvent->event_id);
+    switch(pEvent->event_id) {
+        case HID_API_CONNECT_REQ:       
+            if (sBluetoothHidInterface != NULL) {
+								
+                sBluetoothHidInterface->connect(&pEvent->hid_profile_event.bd_addr);
+            }
+            ChangeConnectionState(HID_STATE_CONNECTING);
+            break;
+	    case HID_API_CONNECTED_CB:
+            ChangeConnectionState(HID_STATE_CONNECTED);
+            break;
+		break;
+        default:
+            ALOGD(LOGTAG," event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+void Hid::state_connecting_handler(BtEvent* pEvent) {
+    char str[18];
+    ALOGD(LOGTAG "state_connecting_handler Processing event %d", pEvent->event_id);
+    switch(pEvent->event_id) {
+        case HID_API_CONNECTING_CB:
+        // intentional fall through
+        case HID_API_CONNECTED_CB:
+            ChangeConnectionState(HID_STATE_CONNECTED);
+            break;
+        case HID_API_DISCONNECTED_CB:
+            ChangeConnectionState(HID_STATE_DISCONNECTED);
+            break;
+        default:
+            ALOGD(LOGTAG," event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
diff --git a/bt-app/include/ipc.h b/bt-app/include/ipc.h
old mode 100644
new mode 100755
index 845fc7d..8cf57ab
--- a/bt-app/include/ipc.h
+++ b/bt-app/include/ipc.h
@@ -50,6 +50,9 @@ extern thread_t *g_pbapc_thread;
 #define SDP_CLIENT_MSG_BASE     (5000)
 #define PBAP_CLIENT_MSG_BASE    (6000)
 #define OPP_MSG_BASE            (7000)
+#define SPP_MSG_BASE            (8000)
+
+#define HID_API_MSG_BASE        (9000)
 
 #define AUDIO_MANAGER_MSG_BASE  (250)
 #define A2DP_SINK_MSG_BASE      (300)
@@ -85,6 +88,9 @@ typedef enum {
     THREAD_ID_GATT,
     THREAD_ID_BT_AM,
     THREAD_ID_SDP_CLIENT,
+    THREAD_ID_SPP_SERVER,
+    THREAD_ID_SPP_CLIENT,
+    THREAD_ID_HID,
 #ifdef USE_BT_OBEX
     THREAD_ID_PBAP_CLIENT,
     THREAD_ID_OPP,
@@ -105,6 +111,9 @@ typedef enum {
     PROFILE_ID_PAN,
     PROFILE_ID_GATT,
     PROFILE_ID_SDP_CLIENT,
+    PROFILE_ID_SPP_SERVER,
+    PROFILE_ID_SPP_CLIENT,
+    PROFILE_ID_HID,
 #ifdef USE_BT_OBEX
     PROFILE_ID_PBAP_CLIENT,
     PROFILE_ID_OPP,
@@ -343,6 +352,7 @@ typedef enum {
 
     GAP_API_ENABLE = GAP_MSG_BASE,
     GAP_API_DISABLE,
+    GAP_API_INIT,
     GAP_API_START_INQUIRY,
     GAP_API_STOP_INQUIRY,
     GAP_API_CREATE_BOND,
@@ -482,6 +492,30 @@ typedef enum {
     OPP_INTERNAL_DISCONNECTION,
     OPP_INCOMING_FILE_RESPONSE,
     OPP_CONNECT_TIMEOUT,
+
+    SPP_SRV_START = SPP_MSG_BASE,
+    SPP_SRV_RECV_FILE,
+    SPP_SRV_SEND_FILE,
+    SPP_SRV_DISCONNECT,
+    SPP_CLI_START_THREADS,
+    SPP_CLI_CONNECT,
+    SPP_CLI_SEND_FILE,
+    SPP_CLI_RECV_FILE,
+    SPP_CLI_DISCONNECT,
+
+    HID_API_CONNECT_REQ = HID_API_MSG_BASE,
+    HID_API_DISCONNECT_REQ,
+    HID_API_DISCONNECTED_CB,
+    HID_API_CONNECTING_CB,
+    HID_API_CONNECTED_CB,
+    HID_API_DISCONNECTING_CB,
+    HID_API_SET_REPORT_REQ,
+    HID_API_GET_REPORT_REQ,
+    HID_API_SET_PROTOCOL_REQ,
+    HID_API_GET_PROTOCOL_REQ,
+    HID_API_VIRTUAL_UNPLUG_REQ,
+    HID_API_BONDED_HID_LIST,
+    HID_API_BONDED_LIST_REQ
 } BluetoothEventId;
 
 typedef struct {
@@ -1278,6 +1312,17 @@ typedef struct {
 } OppEvent;
 #endif
 
+typedef struct {
+    BluetoothEventId    event_id;
+    char                value[256];
+} SppSrvEvent;
+
+typedef struct {
+    BluetoothEventId    event_id;
+    bt_bdaddr_t         bd_addr;
+    char                value[256];
+} SppCliEvent;
+
 /**
   * @brief BT IPC message between qcbtdaemon & btapp
   */
@@ -1313,6 +1358,17 @@ typedef struct {
     ProfileIdType      profile_id;
 } BTAMControlRelease;
 
+typedef struct {
+    BluetoothEventId   event_id;
+    bt_bdaddr_t        bd_addr;
+    char               report[20];
+    int                reportType;
+    int                reportID;
+    int                bufSize;
+    int                protocolMode;
+    int                idleTime;
+} HIDProfileEvent;
+
 typedef union {
     BluetoothEventId                        event_id;
     GapAppEvent                             state_event;
@@ -1409,10 +1465,13 @@ typedef union {
     RspEnableEvent                          rsp_enable_event;
     RspDisableEvent                         rsp_disable_event;
     SdpClientEvent                          sdp_client_event;
+    HIDProfileEvent                         hid_profile_event;
 #ifdef USE_BT_OBEX
     PbapClientEvent                         pbap_client_event;
     OppEvent                                opp_event;
 #endif
+    SppSrvEvent                             spp_srv_event;
+    SppCliEvent                             spp_cli_event;
     BtIpcMsgEvent                           bt_ipc_msg_event;
 } BtEvent;
 
@@ -1471,11 +1530,14 @@ void BtHfpAgMsgHandler (void *context);
 void BtAudioManagerHandler(void *msg);
 void BtSdpClientMsgHandler(void *context);
 void BtAvrcpMsgHandler(void *msg);
+void BtHidMsgHandler(void *msg);
 #ifdef USE_BT_OBEX
 void BtPbapClientMsgHandler(void *context);
 void BtOppMsgHandler(void *context);
 #endif
 void BtA2dpSourceMsgHandler(void *msg);
+void BtSppServerMsgHandler(void *msg);
+void BtSppClientMsgHandler(void *msg);
 #ifdef __cplusplus
 }
 #endif
diff --git a/bt-app/main/Makefile.am b/bt-app/main/Makefile.am
index 7c9c22c..35ef83f 100644
--- a/bt-app/main/Makefile.am
+++ b/bt-app/main/Makefile.am
@@ -8,42 +8,48 @@ AM_CFLAGS = -Wall \
             -std=c99
 
 if USE_BT_OBEX
-AM_CFLAGS += -DOI_CPU_TYPE=19
+AM_CFLAGS += -DOI_CPU_TYPE=1
 endif
 ACLOCAL_AMFLAGS = -I m4
 
-AM_CPPFLAGS += -I${WORKSPACE}/qcom-opensource/bt/bt-app \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/utils/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/audio_manager/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/a2dp_sink/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/avrcp/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/a2dp_src/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/osi/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/gap/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/pan/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/rsp/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/main/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/hfp_client/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/hfp_ag/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/include \
-               -I${WORKSPACE}/qcom-opensource/bt/gatt/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/sdp_client/include \
+AM_CPPFLAGS += -I../../bt-app \
+               -I../../../../qcom-opensource/bt/bt-app/utils/include \
+               -I../../bt-app/audio_manager/include \
+               -I../../bt-app/a2dp_sink/include \
+               -I../../bt-app/avrcp/include \
+               -I../../bt-app/a2dp_src/include \
+               -I../../bt-app/osi/include \
+               -I../../bt-app/gap/include \
+               -I../../bt-app/pan/include \
+               -I../../bt-app/hid/include \
+               -I../../bt-app/rsp/include \
+               -I../../../../vendor/qcom/opensource/bluetooth/hal/include \
+               -I../../bt-app/main/include \
+               -I../../bt-app/hfp_client/include \
+               -I../../bt-app/hfp_ag/include \
+               -I../../bt-app/include \
+               -I../../gatt/include \
+               -I../../bt-app/sdp_client/include \
                -I${WORKSPACE}/system/media/audio/include \
                -I${WORKSPACE}/hardware/qcom/audio/qahw_api/inc \
-               -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/hal/include \
-               -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/vhal/include \
-               -I${WORKSPACE}/mcm-api/api
+               -I../../../../vendor/qcom/opensource/bluetooth/hal/include \
+               -I../../../../vendor/qcom/opensource/bluetooth/vhal/include \
+               -I../../../../hardware/libhardware/include \
+               -I${WORKSPACE}/mcm-api/api \
+               -I../../../../qcom-opensource/bt/bt-app/spp_server/include \
+               -I../../../../qcom-opensource/bt/bt-app/spp_client/include \
+               -I/usr/include/alsa
 
 if USE_BT_OBEX
-AM_CPPFLAGS += -DOI_CPU_TYPE=19 \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/pbap_client/include \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/opp/include \
-               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/include \
-               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/include/profiles \
-               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/profiles/obex \
-               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/include \
-               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/include/profiles \
-               -I${WORKSPACE}/qcom-opensource/bt/obex_profiles/sdk/oem
+AM_CPPFLAGS += -DOI_CPU_TYPE=1 \
+               -I../bt-app/pbap_client/include \
+               -I../bt-app/opp/include \
+               -I../obex_profiles/include \
+               -I../obex_profiles/include/profiles \
+               -I../obex_profiles/profiles/obex \
+               -I../obex_profiles/sdk/include \
+               -I../obex_profiles/sdk/include/profiles \
+               -I../obex_profiles/sdk/oem
 endif
 
 if AUDIO_HAL_SUPPORTED
@@ -59,26 +65,27 @@ c_sources = ../utils/src/utils.c \
             ../audio_manager/src/Audio_Manager.cpp \
             ../a2dp_sink/src/A2dp_Sink.cpp \
             ../a2dp_sink/src/A2dp_Sink_Streaming.cpp \
+            ../a2dp_sink/src/Alsa_Handler.cpp \
             ../avrcp/src/Avrcp.cpp \
             ../a2dp_src/src/A2dp_Src.cpp \
             ../hfp_client/src/HfpClient.cpp \
             ../hfp_ag/src/HfpAG.cpp \
             ../pan/src/Pan.cpp \
             ../sdp_client/src/SdpClient.cpp\
-            ../rsp/src/Rsp.cpp
+            ../rsp/src/Rsp.cpp \
+            ../spp_server/src/spp_server.cpp \
+            ../spp_client/src/spp_client.cpp \
+	    ../hid/src/Hid.cpp
 
 if USE_BT_OBEX
 c_sources +=  ../pbap_client/src/PbapClient.cpp \
               ../opp/src/Opp.cpp
 endif
 
-if USE_GST
-requiredlibs = ../osi/libgstbtapposi.la -lpthread -lm -ldl -lrt -lhardware
-else
-requiredlibs = ../osi/libbtapposi.la -lpthread -lm -ldl -lrt -lhardware
-endif
+requiredlibs = ../osi/libbtapposi.la -lpthread -lasound -lm -ldl -lrt -lhardware
 
-requiredlibs += $(SYS_LIB)/libgengatt.la
+requiredlibs += ../../gatt/libgengatt.la
+#requiredlibs += $(SYS_LIB)/libgengatt.la
 if AUDIO_HAL_SUPPORTED
 requiredlibs += $(SYS_LIB)/libqahw.la
 endif
@@ -89,43 +96,22 @@ endif
 
 if USE_GLIB
 
-if USE_GST
- gstbtapp_CFLAGS  = $(AM_CFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
- gstbtapp_CPPFLAGS  = $(AM_CPPFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
- gstbtapp_LDFLAGS = $(requiredlibs) @GLIB_LIBS@
- gstbtapp_CPPFLAGS += $(GSTREAMER_CFLAGS) -DUSE_GST
-else
  btapp_CFLAGS  = $(AM_CFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
  btapp_CPPFLAGS  = $(AM_CPPFLAGS) -DUSE_GLIB @GLIB_CFLAGS@
  btapp_LDFLAGS = $(requiredlibs) @GLIB_LIBS@
-endif
 
 else
 
-if USE_GST
- gstbtapp_CFLAGS = $(AM_CFLAGS)
- gstbtapp_LDFLAGS = $(requiredlibs)
-else
  btapp_CFLAGS = $(AM_CFLAGS)
  btapp_LDFLAGS = $(requiredlibs)
-endif
 
 endif
 
-if USE_GST
-gstbtapp_CFLAGS += $(GSTREAMER_CFLAGS)
-gstbtapp_LDFLAGS += $(GSTREAMER_LIBS) -lgstaudio-1.0 -lgstapp-1.0 -lgstbthelper
-endif
 
 AM_LDFLAGS = $(LDFLAFGS)
 
-if USE_GST
-bin_PROGRAMS = gstbtapp
-gstbtapp_CC = @CC@
-gstbtapp_SOURCES = $(c_sources)
-else
 bin_PROGRAMS = btapp
 btapp_CC = @CC@
 btapp_SOURCES = $(c_sources)
-endif
+btapp_CPPFLAGS =$(AM_CPPFLAGS)
 pkgconfigdir = $(libdir)/pkgconfig
diff --git a/bt-app/main/include/Main.hpp b/bt-app/main/include/Main.hpp
index c333f67..dd1e3ae 100644
--- a/bt-app/main/include/Main.hpp
+++ b/bt-app/main/include/Main.hpp
@@ -32,7 +32,6 @@
 #include "utils.h"
 #include "Rsp.hpp"
 
-#include <cutils/sockets.h>
 #include <sys/un.h>
 #include <sys/poll.h>
 #include <errno.h>
@@ -88,11 +87,13 @@ const char *BT_A2DP_SOURCE_ENABLED = "BtA2dpSourceEnable";
 const char *BT_HFP_CLIENT_ENABLED  = "BtHfClientEnable";
 const char *BT_HFP_AG_ENABLED      = "BtHfpAGEnable";
 const char *BT_AVRCP_ENABLED       = "BtAvrcpEnable";
-
+const char *BT_SPP_SERVER_ENABLED  = "BtSppServerEnable";
+const char *BT_SPP_CLIENT_ENABLED  = "BtSppClientEnable";
+const char *BT_HID_ENABLED         = "BtHidEnable";
 /**
  * The Configuration file path
  */
-const char *CONFIG_FILE_PATH       = "/data/misc/bluetooth/bt_app.conf";
+const char *CONFIG_FILE_PATH       = "/etc/bluetooth/bt_app.conf";
 
 /**
  * To track user command status
@@ -224,6 +225,21 @@ typedef enum {
     DISABLE_NREC_ON_AG,
     SEND_AT_CMD,
     HFP_AG,
+    SPP_SERVER_OPTION,
+    SPPS_START,
+    SPPS_RECV,
+    SPPS_SEND,
+    SPP_CLIENT_OPTION,
+    SPPC_SEND,
+    SPPC_RECV,
+    HID_CLIENT,
+    HID_HOST,
+    SET_PROTOCOL,
+    GET_PROTOCOL,
+    SET_REPORT,
+    GET_REPORT,
+    VIRTUAL_UNPLUG,
+    HID_BONDED_LIST,
     BACK_TO_MAIN,
     END,
 } CommandList;
@@ -235,6 +251,8 @@ typedef enum {
     ZERO_PARAM,
     ONE_PARAM,
     TWO_PARAM,
+    THREE_PARAM,
+    FOUR_PARAM
 } MaxParamCount;
 
 typedef enum {
@@ -245,12 +263,15 @@ typedef enum {
     HFP_CLIENT_MENU,
     PAN_MENU,
     RSP_MENU,
+	HIDH_MENU,
 #ifdef USE_BT_OBEX
     PBAP_CLIENT_MENU,
     OPP_MENU,
 #endif
     HFP_AG_MENU,
-    A2DP_SOURCE_MENU
+    A2DP_SOURCE_MENU,
+    SPP_SERVER_MENU,
+    SPP_CLIENT_MENU
 } MenuType;
 
 /**
@@ -300,12 +321,15 @@ UserMenuList MainMenu[] = {
     {TEST_MODE,             "test_menu",        ZERO_PARAM,   "test_menu"},
     {A2DP_SINK,             "a2dp_sink_menu",   ZERO_PARAM,   "a2dp_sink_menu"},
     {HFP_CLIENT,            "hfp_client_menu",  ZERO_PARAM,   "hfp_client_menu"},
+    {HID_HOST,              "hid_menu",         ZERO_PARAM,   "hid_menu"},
 #ifdef USE_BT_OBEX
     {PBAP_CLIENT_OPTION,    "pbap_client_menu", ZERO_PARAM,   "pbap_client_menu"},
     {OPP_OPTION,            "opp_menu",         ZERO_PARAM,   "opp_menu"},
 #endif
     {HFP_AG,                "hfp_ag_menu",      ZERO_PARAM,   "hfp_ag_menu"},
     {A2DP_SOURCE,           "a2dp_source_menu", ZERO_PARAM,   "a2dp_source_menu"},
+    {SPP_SERVER_OPTION,     "spp_server_menu",  ZERO_PARAM,   "spp_server_menu"},
+    {SPP_CLIENT_OPTION,     "spp_client_menu",  ZERO_PARAM,   "spp_client_menu"},
     {MAIN_EXIT,             "exit",             ZERO_PARAM,   "exit"},
 };
 
@@ -353,9 +377,11 @@ UserMenuList A2dpSinkMenu[] = {
     {FASTFORWARD,           "fastforward",      ONE_PARAM,    "fastforward<space><bt_address>"},
     {FORWARD,               "forward",          ONE_PARAM,    "forward<space><bt_address>"},
     {BACKWARD,              "backward",         ONE_PARAM,    "backward<space><bt_address>"},
+#ifdef SUPPORTED
     {VOL_UP,                "volup",            ONE_PARAM,    "volup<space><bt_address>"},
     {VOL_DOWN,              "voldown",          ONE_PARAM,    "voldown<space><bt_address>"},
     {VOL_CHANGED_NOTI,      "volchangednoti",   ONE_PARAM,    "volchangednoti<space><vol level>"},
+#endif
     {BACK_TO_MAIN,          "main_menu",        ZERO_PARAM,   "main_menu"},
 };
 
@@ -368,6 +394,7 @@ UserMenuList A2dpSourceMenu[] = {
     {PLAY,                  "start",            ZERO_PARAM,   "start"},
     {PAUSE,                 "suspend",          ZERO_PARAM,   "suspend"},
     {STOP,                  "stop",             ZERO_PARAM,   "stop"},
+#ifdef SUPPORTED
     {TRACK_CHANGE,          "trackchange",      ZERO_PARAM,   "trackchange"},
     {SET_ABS_VOL,           "setabsolutevol",   ONE_PARAM,
             "setabsolutevol<space><volstep>  eg: setabsolutevol 10 (range 0-15)"},
@@ -377,6 +404,7 @@ UserMenuList A2dpSourceMenu[] = {
             "addrplayerchange<space><1/0>  eg: addrplayerchange 1 "},
     {AVAIL_PLAYER_CHANGE,   "availplayerchange",ZERO_PARAM,   "availplayerchange"},
     {BIGGER_METADATA,       "biggermetadata",   ZERO_PARAM,   "biggermetadata"},
+#endif
     {BACK_TO_MAIN,          "main_menu",        ZERO_PARAM,   "main_menu"},
 };
 
@@ -419,6 +447,21 @@ UserMenuList HfpClientMenu[] = {
     {BACK_TO_MAIN,          "main_menu",     ZERO_PARAM,   "main_menu"},
 };
 
+
+/**
+ * list of supported commands for HID
+ */
+UserMenuList HidMenu[] = {
+    {CONNECT,         "connect",           ONE_PARAM,    "connect<space><bt_address>"},
+    {DISCONNECT,      "disconnect",        ONE_PARAM,    "disconnect<space><bt_address>"},
+    {HID_BONDED_LIST, "hid_list",          ZERO_PARAM,   "hid_list"},
+    {GET_PROTOCOL,    "get_protocol",      TWO_PARAM,    "get_protocol<space><bt_address><protocolMode>"},
+	{SET_PROTOCOL,    "set_protocol",      TWO_PARAM,    "set_protocol<space><bt_address><protocolMode> eg:0-REPORTMODE,1-BOOTMODE"},
+	{VIRTUAL_UNPLUG,  "virtual_unplug",    ONE_PARAM,    "virtual_unplug<space><bt_address>"},
+	{GET_REPORT,	  "get_report",        FOUR_PARAM,   "get_report<space>bt_address<space><reportType><space><reportId><space><bufSize>"},
+	{SET_REPORT,	  "set_report",        FOUR_PARAM,   "set_report<space>bt_address<space><reportType><space><reportString><space><size>"},
+    {BACK_TO_MAIN,    "main_menu",         ZERO_PARAM,   "main_menu"},
+};
 #ifdef USE_BT_OBEX
 /**
  * list of supported commands for PBAP_CLIENT Menu
@@ -492,6 +535,82 @@ UserMenuList HfpAGMenu[] = {
     {BACK_TO_MAIN,          "main_menu",     ZERO_PARAM,   "main_menu"},
 };
 
+/**
+ * list of supported commands for SPP Server
+ */
+
+UserMenuList SppServerInActiveMenu[] = {
+    {SPPS_START,           "start",       ZERO_PARAM,   "start"},
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "main_menu"},
+};
+
+UserMenuList SppServerActiveMenu[] = {
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "No cli conns goto -> main_menu"},
+};
+
+
+UserMenuList SppServerConnectedMenu[] = {
+    {SPPS_RECV,            "receive",     ONE_PARAM,    "receive<space><file_name>"},
+    {SPPS_SEND,            "send",        ONE_PARAM,    "send<space><file_name>"},
+    {DISCONNECT,           "disconnect",  ZERO_PARAM,   "disconnect"},
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "main_menu"},
+};
+
+UserMenuList SppServerReceiveMenu[] = {
+    {DISCONNECT,           "disconnect",       ZERO_PARAM,   "disconnect ( Receiving file...)"},
+    {BACK_TO_MAIN,         "main_menu",        ZERO_PARAM,   "main_menu"},
+};
+
+UserMenuList SppServerSendMenu[] = {
+    {DISCONNECT,           "disconnect",       ZERO_PARAM,   "disconnect ( Sending file...)"},
+    {BACK_TO_MAIN,         "main_menu",        ZERO_PARAM,   "main_menu"},
+};
+
+UserMenuList SppServerDisconnectedMenu[] = {
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "No cli conns goto -> main_menu"},
+};
+
+/**
+ * list of supported commands for SPP Client
+ */
+
+UserMenuList SppClientIdleMenu[] = {
+    {CONNECT,              "connect",     ONE_PARAM,    "connect<space><bt_address>"},
+    {SPPC_SEND,            "send",        ONE_PARAM,    "send<space><file_name>"},
+    {SPPC_RECV,            "receive",     ONE_PARAM,    "receive<space><file_name>"},
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "main_menu"},
+};
+
+UserMenuList SppClientConnectingMenu[] = {
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "Connecting... , Go back to main_menu"},
+};
+
+UserMenuList SppClientConnectedMenu[] = {
+    {SPPC_SEND,            "send",        ONE_PARAM,    "send<space><file_name>"},
+    {SPPC_RECV,            "receive",     ONE_PARAM,    "receive<space><file_name>"},
+    {DISCONNECT,           "disconnect",  ZERO_PARAM,   "disconnect"},
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "main_menu"},
+};
+
+UserMenuList SppClientSendMenu[] = {
+    {DISCONNECT,           "disconnect",  ZERO_PARAM,   "disconnect ( Sending file...)"},
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "main_menu"},
+};
+
+
+UserMenuList SppClientReceiveMenu[] = {
+    {DISCONNECT,           "disconnect",  ZERO_PARAM,   "disconnect ( Receiving file...)"},
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "main_menu"},
+};
+
+UserMenuList SppClientDisconnectedMenu[] = {
+    {CONNECT,              "connect",     ONE_PARAM,    "connect<space><bt_address>"},
+    {SPPC_SEND,            "send",        ONE_PARAM,    "send<space><file_name>"},
+    {SPPC_RECV,            "receive",     ONE_PARAM,    "receive<space><file_name>"},
+    {BACK_TO_MAIN,         "main_menu",   ZERO_PARAM,   "main_menu"},
+};
+
+
 #ifdef __cplusplus
 extern "C"
 {
@@ -629,6 +748,9 @@ class BluetoothApp {
     bool is_hfp_ag_enabled_;
     bool is_pan_enable_default_;
     bool is_gatt_enable_default_;
+    bool is_spp_server_enabled_;
+    bool is_spp_client_enabled_;
+    bool is_hid_enable_default_;
 #ifdef USE_BT_OBEX
     bool is_obex_enabled_;
     bool is_pbap_client_enabled_;
diff --git a/bt-app/main/src/Main.cpp b/bt-app/main/src/Main.cpp
old mode 100644
new mode 100755
index fcd8d10..6de475b
--- a/bt-app/main/src/Main.cpp
+++ b/bt-app/main/src/Main.cpp
@@ -42,6 +42,7 @@
 #include "Audio_Manager.hpp"
 #include "SdpClient.hpp"
 #include "Rsp.hpp"
+#include "Hid.hpp"
 #ifdef USE_BT_OBEX
 #include "PbapClient.hpp"
 #include "Opp.hpp"
@@ -51,11 +52,15 @@
 #include "Avrcp.hpp"
 
 #include "utils.h"
+#include "spp_server.hpp"
+#include "spp_client.hpp"
+
 
 #define LOGTAG  "MAIN "
-#define LOCAL_SOCKET_NAME "/data/misc/bluetooth/btappsocket"
+#define LOCAL_SOCKET_NAME "/etc/bluetooth/btappsocket"
 
 extern Gap *g_gap;
+extern Hid *pHid;
 extern A2dp_Sink *pA2dpSink;
 extern A2dp_Source *pA2dpSource;
 extern Pan *g_pan;
@@ -74,6 +79,9 @@ extern ThreadInfo threadInfo[THREAD_ID_MAX];
 extern Hfp_Client *pHfpClient;
 extern Hfp_Ag *pHfpAG;
 extern Avrcp *pAvrcp;
+extern Spp_Server *pSppServer;
+extern Spp_Client *pSppClient;
+
 #ifdef USE_BT_OBEX
 static alarm_t *opp_incoming_file_accept_timer = NULL;
 #define USER_ACCEPTANCE_TIMEOUT 25000
@@ -172,6 +180,10 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
             menu = &HfpClientMenu[0];
             num_cmds  = NO_OF_COMMANDS(HfpClientMenu);
             break;
+	   case HIDH_MENU:
+            menu = &HidMenu[0];
+            num_cmds  = NO_OF_COMMANDS(HidMenu);
+            break;
 #ifdef USE_BT_OBEX
         case PBAP_CLIENT_MENU:
             menu = &PbapClientMenu[0];
@@ -186,6 +198,108 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
             menu = &HfpAGMenu[0];
             num_cmds  = NO_OF_COMMANDS(HfpAGMenu);
             break;
+
+        case SPP_SERVER_MENU:
+            switch(pSppServer->getState())
+            {
+                case STATE_SPP_SERVER_CONNECTED:
+                   {
+                       menu = &SppServerConnectedMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppServerConnectedMenu);
+                   }
+                   break;
+
+                case STATE_SPP_SERVER_RECEIVE_FILE:
+                   {
+                       menu = &SppServerReceiveMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppServerReceiveMenu);
+                   }
+                   break;
+
+                case STATE_SPP_SERVER_SEND_FILE:
+                   {
+                       menu = &SppServerSendMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppServerSendMenu);
+                   }
+                   break;
+
+                case STATE_SPP_SERVER_INACTIVE:
+                   {
+                       menu = &SppServerInActiveMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppServerInActiveMenu);
+                   }
+                   break;
+
+                case STATE_SPP_SERVER_ACTIVE:
+                   {
+                       menu = &SppServerActiveMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppServerActiveMenu);
+                   }
+                   break;
+
+                case STATE_SPP_SERVER_DISCONNECTED:
+                   {
+                       menu = &SppServerDisconnectedMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppServerDisconnectedMenu);
+                   }
+                   break;
+
+
+               default: fprintf (stdout, " \n*** Error SPP Server Invalid state ***\n");
+            }
+            break;
+
+        case SPP_CLIENT_MENU:
+            switch(pSppClient->getState())
+            {
+                case STATE_SPP_CLIENT_IDLE:
+                   {
+                       menu = &SppClientIdleMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppClientIdleMenu);
+                   }
+                   break;
+
+                case STATE_SPP_CLIENT_CONNECTING:
+                   {
+                       menu = &SppClientConnectingMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppClientConnectingMenu);
+                   }
+                   break;
+
+
+                case STATE_SPP_CLIENT_CONNECTED:
+                   {
+                       menu = &SppClientConnectedMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppClientConnectedMenu);
+                   }
+                   break;
+
+
+                case STATE_SPP_CLIENT_SEND_FILE:
+                   {
+                       menu = &SppClientSendMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppClientSendMenu);
+                   }
+                   break;
+
+                case STATE_SPP_CLIENT_RECEIVE_FILE:
+                   {
+                       menu = &SppClientReceiveMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppClientReceiveMenu);
+                   }
+                   break;
+
+                case STATE_SPP_CLIENT_DISCONNECTED:
+                   {
+                       menu = &SppClientDisconnectedMenu[0];
+                       num_cmds  = NO_OF_COMMANDS(SppClientDisconnectedMenu);
+                   }
+                   break;
+
+               default: fprintf (stdout, " \n*** Error SPP Client Invalid state ***\n");
+            }
+            break;
+
         case MAIN_MENU:
         // fallback to default main menu
         default:
@@ -200,7 +314,7 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
             if(!strcasecmp (menu[index].cmd_name, temp_arg)) {
                 *cmd_id = menu[index].cmd_id;
                 found_index = index;
-                strlcpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
+                strncpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
                 input_args[param_count++][COMMAND_ARG_SIZE - 1] = '\0';
                 break;
             }
@@ -211,7 +325,7 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
             max_param = menu[found_index].max_param;
             while ((temp_arg = strtok_r(NULL, delim, &ptr1)) &&
                     (param_count < max_param + 1)) {
-                strlcpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
+                strncpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
                 input_args[param_count++][COMMAND_ARG_SIZE - 1] = '\0';
             }
 
@@ -230,7 +344,7 @@ static bool HandleUserInput (int *cmd_id, char input_args[][COMMAND_ARG_SIZE],
         } else {
             // to handle the paring inputs
             if(temp_arg != NULL) {
-                strlcpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
+                strncpy(input_args[param_count], temp_arg, COMMAND_ARG_SIZE);
                 input_args[param_count++][COMMAND_ARG_SIZE - 1] = '\0';
             }
         }
@@ -276,6 +390,10 @@ static void DisplayMenu(MenuType menu_type) {
             menu = &HfpClientMenu[0];
             num_cmds  = NO_OF_COMMANDS(HfpClientMenu);
             break;
+	    case HIDH_MENU:
+            menu = &HidMenu[0];
+            num_cmds  = NO_OF_COMMANDS(HidMenu);
+            break;
 #ifdef USE_BT_OBEX
         case PBAP_CLIENT_MENU:
             menu = &PbapClientMenu[0];
@@ -290,6 +408,109 @@ static void DisplayMenu(MenuType menu_type) {
             menu = &HfpAGMenu[0];
             num_cmds  = NO_OF_COMMANDS(HfpAGMenu);
             break;
+
+        case SPP_SERVER_MENU:
+            switch(pSppServer->getState())
+                {
+                    case STATE_SPP_SERVER_CONNECTED:
+                       {
+                           menu = &SppServerConnectedMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppServerConnectedMenu);
+                       }
+                       break;
+
+                    case STATE_SPP_SERVER_RECEIVE_FILE:
+                       {
+                           menu = &SppServerReceiveMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppServerReceiveMenu);
+                       }
+                       break;
+
+                    case STATE_SPP_SERVER_SEND_FILE:
+                       {
+                           menu = &SppServerSendMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppServerSendMenu);
+                       }
+                       break;
+
+                    case STATE_SPP_SERVER_INACTIVE:
+                       {
+                           menu = &SppServerInActiveMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppServerInActiveMenu);
+                       }
+                       break;
+
+                    case STATE_SPP_SERVER_ACTIVE:
+                       {
+                           menu = &SppServerActiveMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppServerActiveMenu);
+                       }
+                       break;
+
+                    case STATE_SPP_SERVER_DISCONNECTED:
+                       {
+                           menu = &SppServerDisconnectedMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppServerDisconnectedMenu);
+                       }
+                       break;
+
+                   default: fprintf (stdout, " \n*** Error SPP Server Invalid state ***\n");
+                }
+                break;
+
+        case SPP_CLIENT_MENU:
+
+            switch(pSppClient->getState())
+                {
+                    case STATE_SPP_CLIENT_IDLE:
+                       {
+                           menu = &SppClientIdleMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppClientIdleMenu);
+                       }
+                       break;
+
+                    case STATE_SPP_CLIENT_CONNECTING:
+                       {
+                           menu = &SppClientConnectingMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppClientConnectingMenu);
+                       }
+                       break;
+
+
+                    case STATE_SPP_CLIENT_CONNECTED:
+                       {
+                           menu = &SppClientConnectedMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppClientConnectedMenu);
+                       }
+                       break;
+
+
+                    case STATE_SPP_CLIENT_SEND_FILE:
+                       {
+                           menu = &SppClientSendMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppClientSendMenu);
+                       }
+                       break;
+
+                    case STATE_SPP_CLIENT_RECEIVE_FILE:
+                       {
+                           menu = &SppClientReceiveMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppClientReceiveMenu);
+                       }
+                       break;
+
+                    case STATE_SPP_CLIENT_DISCONNECTED:
+                       {
+                           menu = &SppClientDisconnectedMenu[0];
+                           num_cmds  = NO_OF_COMMANDS(SppClientDisconnectedMenu);
+                       }
+                       break;
+
+                   default: fprintf (stdout, " \n*** Error SPP Client Invalid state ***\n");
+
+
+                }
+
     }
     fprintf (stdout, " \n***************** Menu *******************\n");
     for (index = 0; index < num_cmds; index++)
@@ -591,7 +812,7 @@ static void HandleHfpClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]
         case DIAL:
             event = new BtEvent;
             event->hfp_client_event.event_id = HFP_CLIENT_API_DIAL_REQ;
-            strlcpy(event->hfp_client_event.str, user_cmd[ONE_PARAM], 20);
+            strncpy(event->hfp_client_event.str, user_cmd[ONE_PARAM], 20);
             PostMessage (THREAD_ID_HFP_CLIENT, event);
             break;
         case REDIAL:
@@ -659,7 +880,7 @@ static void HandleHfpClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]
         case SEND_DTMF:
             event = new BtEvent;
             event->hfp_client_event.event_id = HFP_CLIENT_API_SEND_DTMF_REQ;
-            strlcpy(event->hfp_client_event.str, user_cmd[ONE_PARAM], 20);
+            strncpy(event->hfp_client_event.str, user_cmd[ONE_PARAM], 20);
             PostMessage (THREAD_ID_HFP_CLIENT, event);
             break;
         case DISABLE_NREC_ON_AG:
@@ -804,6 +1025,10 @@ static void HandleMainCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
             menu_type = HFP_CLIENT_MENU;
             DisplayMenu(menu_type);
             break;
+	    case HID_HOST:
+            menu_type = HIDH_MENU;
+            DisplayMenu(menu_type);
+            break;
 #ifdef USE_BT_OBEX
         case PBAP_CLIENT_OPTION:
             menu_type = PBAP_CLIENT_MENU;
@@ -818,6 +1043,17 @@ static void HandleMainCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
             menu_type = HFP_AG_MENU;
             DisplayMenu(menu_type);
             break;
+
+        case SPP_SERVER_OPTION:
+            menu_type = SPP_SERVER_MENU;
+            DisplayMenu(menu_type);
+            break;
+
+        case SPP_CLIENT_OPTION:
+            menu_type = SPP_CLIENT_MENU;
+            DisplayMenu(menu_type);
+            break;
+
         case MAIN_EXIT:
             ALOGV (LOGTAG " Self exit of Main thread");
             ExitHandler();
@@ -939,7 +1175,77 @@ static void HandleRspCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
             break;
     }
 }
-
+static void HandleHIDCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
+    ALOGD(LOGTAG "HandleHIDCommand cmd_id = %d", cmd_id);
+    BtEvent *event = NULL;
+    switch (cmd_id) {
+        case CONNECT:
+            event = new BtEvent;
+            event->hid_profile_event.event_id = HID_API_CONNECT_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->hid_profile_event.bd_addr);
+            PostMessage (THREAD_ID_HID, event);
+            break;
+        case DISCONNECT:
+            event = new BtEvent;
+            event->hid_profile_event.event_id = HID_API_DISCONNECT_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->hid_profile_event.bd_addr);
+            PostMessage (THREAD_ID_HID, event);
+            break;
+	case VIRTUAL_UNPLUG:
+			event = new BtEvent;
+			event->hid_profile_event.event_id = HID_API_VIRTUAL_UNPLUG_REQ;
+			string_to_bdaddr(user_cmd[ONE_PARAM], &event->hid_profile_event.bd_addr);
+			PostMessage (THREAD_ID_HID, event);
+			break;
+	case GET_PROTOCOL:
+		    event = new BtEvent;
+            event->hid_profile_event.event_id = HID_API_GET_PROTOCOL_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->hid_profile_event.bd_addr);
+			event->hid_profile_event.protocolMode = atoi(user_cmd[TWO_PARAM]);
+            PostMessage (THREAD_ID_HID, event);
+            break;
+        case SET_PROTOCOL:
+		    event = new BtEvent;
+            event->hid_profile_event.event_id = HID_API_SET_PROTOCOL_REQ;
+            string_to_bdaddr(user_cmd[ONE_PARAM], &event->hid_profile_event.bd_addr);
+			event->hid_profile_event.protocolMode = atoi(user_cmd[TWO_PARAM]);
+            PostMessage (THREAD_ID_HID, event);
+            break;
+	case GET_REPORT:
+			event = new BtEvent;
+			event->hid_profile_event.event_id = HID_API_GET_REPORT_REQ;
+			string_to_bdaddr(user_cmd[ONE_PARAM], &event->hid_profile_event.bd_addr);
+			event->hid_profile_event.reportType= atoi(user_cmd[TWO_PARAM]);
+			event->hid_profile_event.reportID  = atoi(user_cmd[THREE_PARAM]);
+			event->hid_profile_event.bufSize   = atoi(user_cmd[FOUR_PARAM]);
+			PostMessage (THREAD_ID_HID, event);
+		    break;
+	    case SET_REPORT:
+			event = new BtEvent;
+			event->hid_profile_event.event_id = HID_API_SET_REPORT_REQ;
+			string_to_bdaddr(user_cmd[ONE_PARAM], &event->hid_profile_event.bd_addr);
+			event->hid_profile_event.reportType= atoi(user_cmd[TWO_PARAM]);
+			event->hid_profile_event.bufSize   = atoi(user_cmd[FOUR_PARAM]);
+			strncpy(event->hid_profile_event.report , user_cmd[THREE_PARAM], 20);	
+			PostMessage (THREAD_ID_HID, event);
+		    break;
+		case HID_BONDED_LIST:
+			event = new BtEvent;
+			event->hid_profile_event.event_id = HID_API_BONDED_LIST_REQ;
+			PostMessage (THREAD_ID_HID, event);
+			break;
+        case BACK_TO_MAIN:
+            menu_type = MAIN_MENU;
+            DisplayMenu(menu_type);
+            break;
+    }
+}
+static void SendInitToGap(){
+	 BtEvent *event = new BtEvent;
+        event->event_id = GAP_API_INIT;
+        ALOGV (LOGTAG " Posting BT Init  to GAP thread");
+        PostMessage (THREAD_ID_GAP, event);	
+}
 static void SendEnableCmdToGap() {
 
     if ((g_bt_app->status.enable_cmd != COMMAND_INPROGRESS) &&
@@ -1071,6 +1377,7 @@ static void HandleGapCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
                     bt_bdaddr_t bd_addr;
                     string_to_bdaddr(user_cmd[ONE_PARAM], &bd_addr);
                     g_bt_app->HandleUnPair(bd_addr);
+					
                 } else {
                     fprintf( stdout, " BD address is NULL/Invalid \n");
                 }
@@ -1240,6 +1547,155 @@ static void HandlePanCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
     }
 }
 
+static void HandleSppServerCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
+
+    ALOGD(LOGTAG, "HandleSppServerCommand cmd_id = %d", cmd_id);
+
+    BtEvent *event = NULL;
+
+    switch (cmd_id) {
+
+        case SPPS_START:
+            {
+                if ((g_bt_app->bt_state == BT_STATE_ON))
+                {
+                    BtEvent *event = new BtEvent;
+                    event->event_id = SPP_SRV_START;
+                    PostMessage (THREAD_ID_SPP_SERVER, event);
+                }
+                else
+                {
+                    fprintf(stdout, " Currently BT is in OFF state\n");
+                }
+            }
+            break;
+
+        case SPPS_RECV:
+            {
+                event = new BtEvent;
+                event->spp_srv_event.event_id = SPP_SRV_RECV_FILE;
+                memset( (void *) event->spp_srv_event.value, 0,
+                    sizeof(event->spp_srv_event.value));
+                strncpy(event->spp_srv_event.value, user_cmd[ONE_PARAM],
+                    COMMAND_SIZE);
+
+                PostMessage (THREAD_ID_SPP_SERVER, event);
+            }
+            break;
+
+        case SPPS_SEND:
+            {
+                event = new BtEvent;
+                event->spp_srv_event.event_id = SPP_SRV_SEND_FILE;
+                memset( (void *) event->spp_srv_event.value, 0,
+                    sizeof(event->spp_srv_event.value));
+                strncpy(event->spp_srv_event.value, user_cmd[ONE_PARAM],
+                    COMMAND_SIZE);
+
+                PostMessage (THREAD_ID_SPP_SERVER, event);
+            }
+            break;
+
+        case DISCONNECT:
+            {
+                event = new BtEvent;
+                event->spp_srv_event.event_id = SPP_SRV_DISCONNECT;
+                PostMessage (THREAD_ID_SPP_SERVER, event);
+            }
+            break;
+
+        case BACK_TO_MAIN:
+            menu_type = MAIN_MENU;
+            DisplayMenu(menu_type);
+            break;
+
+        default:
+        ALOGE(LOGTAG " Command not handled: %d", cmd_id);
+        break;
+
+    }
+}
+
+static void HandleSppClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
+
+    ALOGD(LOGTAG, "HandleSppClientCommand cmd_id = %d", cmd_id);
+
+    BtEvent *event = NULL;
+
+    switch (cmd_id) {
+
+        case CONNECT:
+
+            if ((g_bt_app->bt_state == BT_STATE_ON))
+            {
+                if (string_is_bdaddr(user_cmd[ONE_PARAM]))
+                {
+                    BtEvent *event = new BtEvent;
+                    event->event_id = SPP_CLI_CONNECT;
+                    string_to_bdaddr(user_cmd[ONE_PARAM],
+                            &event->spp_cli_event.bd_addr);
+
+                    PostMessage (THREAD_ID_SPP_CLIENT, event);
+                }
+                else
+                {
+                    fprintf(stdout, " BD address is NULL/Invalid \n");
+                }
+            }
+            else
+            {
+                fprintf(stdout, " Currently BT is in OFF state\n");
+            }
+            break;
+
+        case SPPC_SEND:
+            {
+
+                event = new BtEvent;
+                event->spp_cli_event.event_id = SPP_CLI_SEND_FILE;
+                memset( (void *) event->spp_cli_event.value, 0,
+                    sizeof(event->spp_cli_event.value));
+                strncpy(event->spp_cli_event.value, user_cmd[ONE_PARAM],
+                    COMMAND_SIZE);
+
+                PostMessage (THREAD_ID_SPP_CLIENT, event);
+            }
+            break;
+
+        case SPPC_RECV:
+            {
+
+                event = new BtEvent;
+                event->spp_cli_event.event_id = SPP_CLI_RECV_FILE;
+                memset( (void *) event->spp_cli_event.value, 0,
+                    sizeof(event->spp_cli_event.value));
+                strncpy(event->spp_cli_event.value, user_cmd[ONE_PARAM],
+                    COMMAND_SIZE);
+
+                PostMessage (THREAD_ID_SPP_CLIENT, event);
+            }
+            break;
+
+        case DISCONNECT:
+            {
+                event = new BtEvent;
+                event->spp_srv_event.event_id = SPP_CLI_DISCONNECT;
+                PostMessage (THREAD_ID_SPP_CLIENT, event);
+            }
+            break;
+
+        case BACK_TO_MAIN:
+            menu_type = MAIN_MENU;
+            DisplayMenu(menu_type);
+            break;
+
+        default:
+        ALOGE(LOGTAG " Command not handled: %d", cmd_id);
+        break;
+
+    }
+}
+
 #ifdef USE_BT_OBEX
 static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
 
@@ -1292,7 +1748,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_GET_VCARD;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1306,7 +1762,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_SET_PATH;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1315,7 +1771,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_SET_FILTER;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1329,7 +1785,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_SET_ORDER;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1343,7 +1799,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_SET_SEARCH_ATTRIBUTE;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1357,7 +1813,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_SET_SEARCH_VALUE;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1366,7 +1822,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_SET_PHONE_BOOK;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1380,7 +1836,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_SET_REPOSITORY;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1394,7 +1850,7 @@ static void HandlePbapClientCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE
             event->pbap_client_event.event_id = PBAP_CLIENT_SET_VCARD_FORMAT;
             memset( (void *) event->pbap_client_event.value, '\0',
                 sizeof(event->pbap_client_event.value));
-            strlcpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
+            strncpy(event->pbap_client_event.value, user_cmd[ONE_PARAM],
                 COMMAND_SIZE);
             PostMessage (THREAD_ID_PBAP_CLIENT, event);
             break;
@@ -1462,7 +1918,7 @@ static void HandleOppCommand(int cmd_id, char user_cmd[][COMMAND_ARG_SIZE]) {
                 &event->opp_event.bd_addr)) {
                 memset( (void *) event->opp_event.value, 0,
                     sizeof(event->opp_event.value));
-                strlcpy(event->opp_event.value, user_cmd[TWO_PARAM],
+                strncpy(event->opp_event.value, user_cmd[TWO_PARAM],
                     COMMAND_SIZE);
                 PostMessage (THREAD_ID_OPP, event);
             } else {
@@ -1583,6 +2039,9 @@ static void BtCmdHandler (void *context) {
             case HFP_CLIENT_MENU:
                 HandleHfpClientCommand(cmd_id,user_cmd );
                 break;
+		    case HIDH_MENU:
+                HandleHIDCommand(cmd_id,user_cmd );
+                break;
 #ifdef USE_BT_OBEX
             case PBAP_CLIENT_MENU:
                 HandlePbapClientCommand(cmd_id,user_cmd );
@@ -1594,6 +2053,15 @@ static void BtCmdHandler (void *context) {
             case HFP_AG_MENU:
                 HandleHfpAGCommand(cmd_id, user_cmd );
                 break;
+
+            case SPP_SERVER_MENU:
+                HandleSppServerCommand(cmd_id, user_cmd );
+                break;
+
+            case SPP_CLIENT_MENU:
+                HandleSppClientCommand(cmd_id, user_cmd );
+                break;
+
         }
     } else if (g_bt_app->ssp_notification && user_cmd[0][0] &&
                         (!strcasecmp (user_cmd[ZERO_PARAM], "yes") ||
@@ -1763,6 +2231,7 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
     switch (event->event_id) {
         case MAIN_API_INIT:
             InitHandler();
+	     SendInitToGap();
             break;
 
         case MAIN_API_DEINIT:
@@ -1799,7 +2268,7 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
                 // clearing bond_devices list and inquiry_list
                 bonded_devices.clear();
                 inquiry_list.clear();
-                system("killall -KILL wcnssfilter");
+                //system("killall -KILL wcnssfilter");
                 usleep(200);
                 fprintf(stdout, " BT State is OFF\n");
             }
@@ -1858,13 +2327,15 @@ void BluetoothApp :: ProcessEvent (BtEvent * event) {
                                         remoteDevice.bluetooth_class);
             break;
         }
-        case MAIN_EVENT_BOND_STATE: {
+        case MAIN_EVENT_BOND_STATE:{ 
+			char str[18];
+			BtEvent *hidEvent = new BtEvent;
             std::string bd_name((const char*)event->bond_state_event.bd_name.name);
             HandleBondState(event->bond_state_event.state,
                                     event->bond_state_event.bd_addr, bd_name);
-            }
+    	
             break;
-
+        	}
         case MAIN_EVENT_SSP_REQUEST:
             memcpy(&ssp_data.bd_addr, &event->ssp_request_event.bd_addr,
                                             sizeof(bt_bdaddr_t));
@@ -1928,12 +2399,15 @@ void BluetoothApp:: HandleBondState(bt_bond_state_t new_state, const bt_bdaddr_t
     std::map<std::string, std::string>::iterator it;
     std::map<std::string, std::string>::iterator it_inquiry;
     bdstr_t bd_str;
+    
     bdaddr_to_string(&bd_addr, &bd_str[0], sizeof(bd_str));
     std::string deviceAddress(bd_str);
-    it = bonded_devices.find(deviceAddress);
-    it_inquiry= inquiry_list.find(deviceAddress);
+    printf("Bond State** State %d addr %s Name %s\n",new_state,bd_str,bd_name.c_str());
+        it = bonded_devices.find(deviceAddress);
+        it_inquiry= inquiry_list.find(deviceAddress);
     if(new_state == BT_BOND_STATE_BONDED) {
         if (it == bonded_devices.end()) {
+            printf("Reach here with bdname %s*\n",bd_name.c_str());
             bonded_devices[deviceAddress] = bd_name;
         }
        if(it_inquiry!=inquiry_list.end())
@@ -1980,6 +2454,9 @@ bt_bdaddr_t BluetoothApp:: AddFoundedDevice(std::string bd_name, bt_bdaddr_t bd_
 
     it = inquiry_list.find(deviceAddress);
     if (it != inquiry_list.end()) {
+        if(strcmp(bd_name.c_str(), "No Name") != 0)
+            inquiry_list[deviceAddress] = bd_name;
+
         return (bd_addr);
     } else {
         inquiry_list[deviceAddress] = bd_name;
@@ -2018,10 +2495,13 @@ void BluetoothApp:: PrintBondedDeviceList() {
 bool BluetoothApp :: LoadBtStack (void) {
     hw_module_t *module;
 
+    ALOGV (LOGTAG "LoadBtStack");
+
     if (hw_get_module (BT_STACK_MODULE_ID, (hw_module_t const **) &module)) {
         ALOGE(LOGTAG " hw_get_module failed");
         return false;
     }
+    ALOGV (LOGTAG "open stack");
 
     if (module->methods->open (module, BT_STACK_MODULE_ID, &device_)) {
         return false;
@@ -2120,6 +2600,30 @@ void BluetoothApp :: InitHandler (void) {
         }
     }
 
+    if(is_spp_server_enabled_) {
+
+        ALOGV (LOGTAG "  Init:: SPP Server - thread_new");
+        threadInfo[THREAD_ID_SPP_SERVER].thread_id = thread_new (
+                threadInfo[THREAD_ID_SPP_SERVER].thread_name);
+
+        if (threadInfo[THREAD_ID_SPP_SERVER].thread_id) {
+            ALOGV (LOGTAG "  Init:: new Spp_Server ");
+            pSppServer = new Spp_Server ( bt_interface, config );
+        }
+    }
+
+    if(is_spp_client_enabled_) {
+
+        ALOGV (LOGTAG "  Init:: SPP Client- thread_new");
+        threadInfo[THREAD_ID_SPP_CLIENT].thread_id = thread_new (
+                threadInfo[THREAD_ID_SPP_CLIENT].thread_name);
+
+        if (threadInfo[THREAD_ID_SPP_CLIENT].thread_id) {
+            ALOGV (LOGTAG "  Init:: new Spp_Client ");
+            pSppClient = new Spp_Client ( bt_interface, config );
+        }
+    }
+
     // registers reactors for socket
     if (is_socket_input_enabled_) {
         if(LocalSocketCreate() != -1) {
@@ -2129,6 +2633,7 @@ void BluetoothApp :: InitHandler (void) {
         }
     }
 
+ALOGV (LOGTAG "GAP Enable");
     // Enable Bluetooth
     if (is_bt_enable_default_) {
 
@@ -2163,6 +2668,15 @@ void BluetoothApp :: InitHandler (void) {
             g_gatt = new Gatt(bt_interface, config);
     }
 
+	if (is_hid_enable_default_) {
+        ALOGV (LOGTAG "  Starting HID thread");
+        threadInfo[THREAD_ID_HID].thread_id = thread_new (
+            threadInfo[THREAD_ID_HID].thread_name);
+
+        if (threadInfo[THREAD_ID_HID].thread_id)
+            pHid = new Hid(bt_interface, config);
+    }
+
 #ifdef USE_BT_OBEX
     if (is_obex_enabled_ && is_pbap_client_enabled_) {
         threadInfo[THREAD_ID_PBAP_CLIENT].thread_id = thread_new (
@@ -2295,7 +2809,13 @@ void BluetoothApp :: DeInitHandler (void) {
                 delete g_gatt;
         }
     }
-
+    if (is_hid_enable_default_) {
+        if (threadInfo[THREAD_ID_HID].thread_id != NULL){
+            thread_free(threadInfo[THREAD_ID_HID].thread_id);
+            if (pHid != NULL)
+                delete pHid;
+        }
+    }
 #ifdef USE_BT_OBEX
     if (opp_incoming_file_accept_timer) {
         alarm_free(opp_incoming_file_accept_timer);
@@ -2346,6 +2866,8 @@ BluetoothApp :: BluetoothApp () {
 
     if (!LoadConfigParameters (CONFIG_FILE_PATH))
         ALOGE (LOGTAG " Error in Loading config file");
+
+   ALOGE (LOGTAG " BluetoothApp done");
 }
 
 BluetoothApp :: ~BluetoothApp () {
@@ -2368,13 +2890,13 @@ int BluetoothApp:: LocalSocketCreate(void) {
 
   memset(&addr, 0, sizeof(addr));
   addr.sun_family = AF_LOCAL;
-  strlcpy(addr.sun_path, LOCAL_SOCKET_NAME, sizeof(addr.sun_path));
+  strncpy(addr.sun_path, LOCAL_SOCKET_NAME, sizeof(addr.sun_path));
   unlink(LOCAL_SOCKET_NAME);
   if (bind(listen_socket_local_, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
     ALOGE (LOGTAG "Failed to create Local Socket (%s)", strerror(errno));
     return -1;
   }
-
+  is_user_input_enabled_ = true;
   if (listen(listen_socket_local_, 1) < 0) {
     ALOGE (LOGTAG "Local socket listen failed (%s)", strerror(errno));
     close(listen_socket_local_);
@@ -2390,7 +2912,6 @@ bool BluetoothApp::LoadConfigParameters (const char *configpath) {
         ALOGE (LOGTAG " Unable to open config file");
         return false;
     }
-
     // checking for the BT Enable option in config file
     is_bt_enable_default_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
                                     BT_ENABLE_DEFAULT, false);
@@ -2410,8 +2931,9 @@ bool BluetoothApp::LoadConfigParameters (const char *configpath) {
                                     BT_AVRCP_ENABLED, false);
 
     //checking for a2dp source
-    is_a2dp_source_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
-                                    BT_A2DP_SOURCE_ENABLED, false);
+    is_a2dp_source_enabled_ = true;
+    //config_get_bool (config, CONFIG_DEFAULT_SECTION,
+      //                              BT_A2DP_SOURCE_ENABLED, false);
 
     //checking for hfp client
     is_hfp_client_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
@@ -2419,7 +2941,9 @@ bool BluetoothApp::LoadConfigParameters (const char *configpath) {
     //checking for hfp ag
     is_hfp_ag_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
                                     BT_HFP_AG_ENABLED, false);
-
+    is_hid_enable_default_ = true;
+	//config_get_bool (config, CONFIG_DEFAULT_SECTION,
+      //                              BT_HID_ENABLED, false);
     if (is_hfp_client_enabled_ == true && is_hfp_ag_enabled_ == true) {
         ALOGE (LOGTAG " Both HFP AG and Client are enabled, disabling AG. Set \
            BtHfpAGEnable to true, BtHfClientEnable to false in bt_app.conf to \
@@ -2437,6 +2961,14 @@ bool BluetoothApp::LoadConfigParameters (const char *configpath) {
     is_gatt_enable_default_= config_get_bool (config, CONFIG_DEFAULT_SECTION,
                                     BT_GATT_ENABLED, false);
 
+    is_spp_server_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
+                                    BT_SPP_SERVER_ENABLED, false);
+    ALOGE (LOGTAG " is_spp_server_enabled_=%d",is_spp_server_enabled_);
+
+    is_spp_client_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
+                                    BT_SPP_CLIENT_ENABLED, false);
+    ALOGE (LOGTAG " is_spp_client_enabled_=%d",is_spp_client_enabled_);
+
 #ifdef USE_BT_OBEX
     //checking for OBEX handler
     is_obex_enabled_ = config_get_bool (config, CONFIG_DEFAULT_SECTION,
diff --git a/bt-app/main/src/ipc.c b/bt-app/main/src/ipc.c
index 1b71fb0..4f1c9c0 100644
--- a/bt-app/main/src/ipc.c
+++ b/bt-app/main/src/ipc.c
@@ -26,18 +26,21 @@ ThreadInfo threadInfo[THREAD_ID_MAX] = {
     //thread_id thread type            Thread Message Handler    Thread Name
     { NULL ,    THREAD_ID_MAIN,        &BtMainMsgHandler,        "Main_Thread" } ,
     { NULL ,    THREAD_ID_GAP,         &BtGapMsgHandler,         "Gap_Thread" } ,
-    { NULL ,    THREAD_ID_A2DP_SINK,   &BtA2dpSinkMsgHandler,    "A2dp_Sink_Thread" } ,
-    { NULL ,    THREAD_ID_HFP_CLIENT,  &BtHfpClientMsgHandler,   "Hfp_Client_Thread" } ,
+    { NULL ,    THREAD_ID_A2DP_SINK,   &BtA2dpSinkMsgHandler,    "A2dp_Sink" } ,
+    { NULL ,    THREAD_ID_HFP_CLIENT,  &BtHfpClientMsgHandler,   "Hfp_Client" } ,
     { NULL ,    THREAD_ID_PAN,         &BtPanMsgHandler,         "Pan_Thread" } ,
     { NULL ,    THREAD_ID_GATT,        &BtGattMsgHandler,        "Gatt_Thread" } ,
-    { NULL ,    THREAD_ID_BT_AM,       &BtAudioManagerHandler,   "BT_AUDIO_MANAGER_Thread" } ,
-    { NULL ,    THREAD_ID_SDP_CLIENT,  &BtSdpClientMsgHandler,   "Sdp_Client_Thread" } ,
+    { NULL ,    THREAD_ID_BT_AM,       &BtAudioManagerHandler,   "BT_AUDIO_MGR" } ,
+    { NULL ,    THREAD_ID_SDP_CLIENT,  &BtSdpClientMsgHandler,   "Sdp_Client" } ,
+    { NULL ,    THREAD_ID_SPP_SERVER,  &BtSppServerMsgHandler,   "Spp_Server_Thread" } ,
+    { NULL ,    THREAD_ID_SPP_CLIENT,  &BtSppClientMsgHandler,   "Spp_Client_Thread" } ,
+    { NULL ,    THREAD_ID_HID,         &BtHidMsgHandler,         "HID_Thread" } ,
 #ifdef USE_BT_OBEX
-    { NULL ,    THREAD_ID_PBAP_CLIENT, &BtPbapClientMsgHandler,  "Pbap_Client_Thread" } ,
+    { NULL ,    THREAD_ID_PBAP_CLIENT, &BtPbapClientMsgHandler,  "Pbap_Client" } ,
     { NULL ,    THREAD_ID_OPP,         &BtOppMsgHandler,         "Opp_Thread" } ,
 #endif
-    { NULL ,    THREAD_ID_HFP_AG,      &BtHfpAgMsgHandler,       "Hfp_AG_Thread" } ,
-    { NULL ,    THREAD_ID_A2DP_SOURCE, &BtA2dpSourceMsgHandler,  "A2dp_Source_Thread" } ,
+    { NULL ,    THREAD_ID_HFP_AG,      &BtHfpAgMsgHandler,       "Hfp_AG" } ,
+    { NULL ,    THREAD_ID_A2DP_SOURCE, &BtA2dpSourceMsgHandler,  "A2dp_Src" } ,
     { NULL ,    THREAD_ID_AVRCP,       &BtAvrcpMsgHandler,       "Avrcp_Thread" } ,
 };
 
diff --git a/bt-app/opp/src/Opp.cpp b/bt-app/opp/src/Opp.cpp
index 6ae1da1..0d1aa71 100644
--- a/bt-app/opp/src/Opp.cpp
+++ b/bt-app/opp/src/Opp.cpp
@@ -212,7 +212,7 @@ void read_config_file(char* config_filename) {
         token = strtok_r(buf, ",", &ctx);
         if (token != NULL) {
             count ++;
-            strlcpy(opp.fileTypeData[opp.numOfEntries].ext,
+            strncpy(opp.fileTypeData[opp.numOfEntries].ext,
                 token, strlen(token) +  1);
         }
         /* walk through other tokens */
@@ -223,7 +223,7 @@ void read_config_file(char* config_filename) {
             }
             token = strtok_r(NULL, ",", &ctx);
             if (token != NULL) {
-                strlcpy(opp.fileTypeData[opp.numOfEntries].mimeType,
+                strncpy(opp.fileTypeData[opp.numOfEntries].mimeType,
                 token, strlen(token) + 1);
                 count ++;
             }
@@ -348,7 +348,7 @@ static OI_STATUS OFS_OpenRead(const OI_OBEX_UNICODE *name,
      * Get name as an ascii string. This would not be done by an implementation
      * that has native support for unicode object names.
      */
-    strlcpy(fileName, storageDir, strlen(storageDir) + 1);
+    strncpy(fileName, storageDir, strlen(storageDir) + 1);
     OI_Utf16ToUtf8((const OI_UTF16*)name->str, name->len,
                             (OI_UTF8*)fileName + strlen(storageDir),
                             sizeof(fileName));
@@ -439,7 +439,7 @@ static OI_STATUS OFS_OpenWrite(const OI_OBEX_UNICODE *name,
      * Get name as an ascii string. This would not be done by an implementation
      * that has native support for unicode object names.
      */
-    strlcpy(fileName, storageDir, strlen(storageDir) + 1);
+    strncpy(fileName, storageDir, strlen(storageDir) + 1);
     OI_Utf16ToUtf8((const OI_UTF16*)name->str, object.nameLen,
                             (OI_UTF8*)fileName + strlen(storageDir),
                             sizeof(fileName));
@@ -1151,7 +1151,7 @@ bool getMimeTypeFromFileExt(OI_CHAR * fileExt)
     for (i = 0; i < opp.numOfEntries; i ++) {
         if (!strncmp (opp.fileTypeData[i].ext, fileExt, strlen(fileExt))) {
             /* Match Found */
-            strlcpy(opp.mimeType, opp.fileTypeData[i].mimeType,
+            strncpy(opp.mimeType, opp.fileTypeData[i].mimeType,
                 strlen(opp.fileTypeData[i].mimeType));
             return true;
         }
@@ -1170,7 +1170,7 @@ void Opp::ProcessEvent(BtEvent* pEvent)
             break;
 
         case OPP_SEND_DATA:
-            strlcpy((char *)opp.fileName, pEvent->opp_event.value, MAX_NAME_LEN);
+            strncpy((char *)opp.fileName, pEvent->opp_event.value, MAX_NAME_LEN);
             opp.fileExt = strrchr(opp.fileName, '.');
             if (opp.fileExt != NULL) {
                 opp.fileExt = opp.fileExt+ 1;
diff --git a/bt-app/osi/Makefile.am b/bt-app/osi/Makefile.am
index 1a52804..915aa3a 100644
--- a/bt-app/osi/Makefile.am
+++ b/bt-app/osi/Makefile.am
@@ -8,8 +8,9 @@ AM_CFLAGS = -Wall \
             -DHAS_NO_BDROID_BUILDCFG \
             -D__GLIBC__
 
-AM_CPPFLAGS = -I${WORKSPACE}/qcom-opensource/bt/bt-app \
-               -I${WORKSPACE}/qcom-opensource/bt/bt-app/osi/include
+AM_CPPFLAGS = -I../ \
+              -I./include \
+              -I../../../../hardware/libhardware/include  
 
 c_sources = \
     src/alarm.c \
@@ -28,15 +29,6 @@ c_sources = \
 requiredlibs = -lpthread
 library_includedir = $(pkgincludedir)\
 library_include_HEADERS = $(h_sources)
-if USE_GST
-lib_LTLIBRARIES = libgstbtapposi.la
-libgstbtapposi_la_CC = @CC@
-libgstbtapposi_la_SOURCES = $(c_sources)
-libgstbtapposi_la_CPPFLAGS =$(AM_CPPFLAGS)
-libgstbtapposi_la_LIBADD = $(requiredlibs)
-libgstbtapposi_la_CFLAGS = $(AM_CFLAGS) -fPIC -D_GNU_SOURCE -DUSE_GLIB
-libgstbtapposi_la_LDFLAGS = -static
-else
 lib_LTLIBRARIES = libbtapposi.la
 libbtapposi_la_CC = @CC@
 libbtapposi_la_SOURCES = $(c_sources)
@@ -44,4 +36,3 @@ libbtapposi_la_CPPFLAGS =$(AM_CPPFLAGS)
 libbtapposi_la_LIBADD = $(requiredlibs)
 libbtapposi_la_CFLAGS = $(AM_CFLAGS) -fPIC -D_GNU_SOURCE -DUSE_GLIB
 libbtapposi_la_LDFLAGS = -static
-endif
diff --git a/bt-app/osi/src/thread.c b/bt-app/osi/src/thread.c
index 2457702..8ed49da 100644
--- a/bt-app/osi/src/thread.c
+++ b/bt-app/osi/src/thread.c
@@ -88,7 +88,8 @@ thread_t *thread_new_sized(const char *name, size_t work_queue_capacity) {
   if (!start.start_sem)
     goto error;
 
-  strlcpy(ret->name, name, THREAD_NAME_MAX);
+  strncpy(ret->name, name, THREAD_NAME_MAX);
+  
   start.thread = ret;
   start.error = 0;
   pthread_create(&ret->pthread, NULL, run_thread, &start);
diff --git a/bt-app/pan/src/Pan.cpp b/bt-app/pan/src/Pan.cpp
index 69673b4..2c9832b 100644
--- a/bt-app/pan/src/Pan.cpp
+++ b/bt-app/pan/src/Pan.cpp
@@ -382,7 +382,7 @@ void Pan::HandlePanControlStateEvent(PanControlStateEvent *event)
 {
     ALOGV(LOGTAG "%s", __FUNCTION__);
 
-    strlcpy(pan_interface_name, event->ifname, sizeof(pan_interface_name));
+    strncpy(pan_interface_name, event->ifname, sizeof(pan_interface_name));
 }
 
 void Pan::HandlePanConnectionStateEvent(PanConnectionStateEvent *event)
@@ -523,7 +523,7 @@ void Pan::HandlePanSetTetheringEvent(PanSetTetheringEvent *event)
 
         if (pan_interface !=NULL) {
             ALOGE(LOGTAG "%s: Notifying BT tethering UI status to BNEP layer", __FUNCTION__);
-            pan_interface->set_tethering(is_tethering_on);
+            //pan_interface->set_tethering(is_tethering_on);
         }
 
         PAN_APP_UI_PRINT("\n*****TETHER MODE UI OPTION SUCCESSFULLY CHANGED*****\n");
diff --git a/bt-app/pbap_client/src/PbapClient.cpp b/bt-app/pbap_client/src/PbapClient.cpp
index ed2249f..6877e68 100644
--- a/bt-app/pbap_client/src/PbapClient.cpp
+++ b/bt-app/pbap_client/src/PbapClient.cpp
@@ -398,7 +398,7 @@ static void get_repository()
     OI_CHAR str[256];
     OI_UINT str_len = 256;
 
-    strlcpy(str, valid_repositories[pbap_client.repository], str_len);
+    strncpy(str, valid_repositories[pbap_client.repository], str_len);
     fprintf(stdout, "Current repository = %s\n", str);
     ALOGV(LOGTAG "%s: Current repository: %s", __FUNCTION__, str);
     print_help(&variable_list[0]);
@@ -446,7 +446,7 @@ static void get_phonebook()
     OI_CHAR str[256];
     OI_UINT str_len = 256;
 
-    strlcpy(str, valid_phonebooks[pbap_client.phonebook], str_len);
+    strncpy(str, valid_phonebooks[pbap_client.phonebook], str_len);
     fprintf(stdout, "Current phonebook = %s\n", str);
     ALOGV(LOGTAG "%s: Current phonebook: %s", __FUNCTION__, str);
     print_help(&variable_list[1]);
@@ -493,7 +493,7 @@ static void get_format()
     OI_CHAR str[256];
     OI_UINT str_len = 256;
 
-    strlcpy(str, valid_formats[pbap_client.format], str_len);
+    strncpy(str, valid_formats[pbap_client.format], str_len);
     fprintf(stdout, "Current format = %s\n", str);
     ALOGV(LOGTAG "%s: Current format: %s", __FUNCTION__, str);
     print_help(&variable_list[2]);
@@ -558,13 +558,13 @@ static void get_filter()
     memset(str, 0, sizeof(string));
     if (OI_PBAP_VCARD_ATTRIBUTE_CHECK_ALL(&pbap_client.filter)) {
         i = OI_ARRAYSIZE(valid_filters) - 1;
-        strlcpy(str + pos, valid_filters[i], str_len);
+        strncpy(str + pos, valid_filters[i], str_len);
         pos += strlen(valid_filters[i]) + 1;
     } else {
         for (i = 0; i < OI_ARRAYSIZE(valid_filters); i++) {
             if (pbap_client.filter.I2 & (1 << i)) {
                 if (str_len > strlen(valid_filters[i])) {
-                    strlcpy(str + pos, valid_filters[i], str_len);
+                    strncpy(str + pos, valid_filters[i], str_len);
                     str_len -= strlen(valid_filters[i]);
                     pos += strlen(valid_filters[i]);
                     str[pos] = ' ';
@@ -633,7 +633,7 @@ static void get_order()
     OI_CHAR str[256];
     OI_UINT str_len = 256;
 
-    strlcpy(str, valid_orders[pbap_client.order], str_len);
+    strncpy(str, valid_orders[pbap_client.order], str_len);
     fprintf(stdout, "Current search order = %s\n", str);
     ALOGV(LOGTAG "%s: Current search order: %s", __FUNCTION__, str);
     print_help(&variable_list[4]);
@@ -658,7 +658,7 @@ static void set_search_value(const OI_CHAR *str)
         pbap_client.searchValueLen = 0;
     }
     pbap_client.searchValue = new OI_BYTE[strlen(str) + 1];
-    strlcpy((OI_CHAR *)pbap_client.searchValue, str, strlen(str) + 1);
+    strncpy((OI_CHAR *)pbap_client.searchValue, str, strlen(str) + 1);
     pbap_client.searchValueLen = strlen(str);
 }
 
@@ -712,7 +712,7 @@ static void get_search_attribute()
     OI_CHAR str[256];
     OI_UINT str_len = 256;
 
-    strlcpy(str, valid_search_attribs[pbap_client.searchAttribute], str_len);
+    strncpy(str, valid_search_attribs[pbap_client.searchAttribute], str_len);
     fprintf(stdout, "Current search attribute = %s\n", str);
     ALOGV(LOGTAG "%s: Current search attribute: %s", __FUNCTION__, str);
     print_help(&variable_list[5]);
@@ -829,7 +829,7 @@ static OI_STATUS pb_open(const OI_OBEX_UNICODE *name, OI_PBAP_OPEN_CFM open_cfm,
     }
     pbap_client.fileName = new char[strlen(filename) + 1];
     if (pbap_client.fileName != NULL) {
-        strlcpy(pbap_client.fileName, filename, strlen(filename) + 1);
+        strncpy(pbap_client.fileName, filename, strlen(filename) + 1);
         pbap_client.fileName[strlen(filename)] = '\0';
         ALOGD(LOGTAG "Opening file: %s\n", pbap_client.fileName);
         stream = fopen(pbap_client.fileName, "w+b");
diff --git a/bt-app/spp_client/include/spp_client.hpp b/bt-app/spp_client/include/spp_client.hpp
new file mode 100755
index 0000000..26b01e2
--- /dev/null
+++ b/bt-app/spp_client/include/spp_client.hpp
@@ -0,0 +1,114 @@
+ /*
+  * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#ifndef SPP_CLIENT_APP_H
+#define SPP_CLIENT_APP_H
+
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/allocator.h"
+#include "ipc.h"
+#include "utils.h"
+
+
+typedef enum {
+    STATE_SPP_CLIENT_INACTIVE = 0,
+    STATE_SPP_CLIENT_IDLE,
+    STATE_SPP_CLIENT_CONNECTING,
+    STATE_SPP_CLIENT_CONNECTED,
+    STATE_SPP_CLIENT_SEND_FILE,
+    STATE_SPP_CLIENT_RECEIVE_FILE,
+    STATE_SPP_CLIENT_DISCONNECTED,
+
+}SppClientState;
+
+#define SPP_CLIENT_CHANNEL (6)
+#define NETLINK_SPP         31
+#define NL_MSG_CTL          0
+
+class Spp_Client {
+
+  private:
+    config_t *config;
+    const bt_interface_t * bluetooth_interface;
+    btsock_interface_t * btsock_interface;
+    int listen_data_socfd;
+    std::string file_name;
+    SppClientState mClientState;
+
+    pthread_t client_read_thread = -1;
+    pthread_t client_write_thread = -1;
+    pthread_mutex_t client_read_thread_mutex;
+    pthread_mutex_t client_write_thread_mutex;
+    bool client_read_thread_stop_thread = false;
+    bool client_write_thread_stop_thread = false;
+     int client_write_thread_exit = 0;
+    int client_read_thread_exit = 0;
+    int kernel_sock_fd=0;
+    int spp_max_frame_size = 0;
+    bool tty_opened = false;
+
+  public:
+
+    Spp_Client(const bt_interface_t *bt_interface, config_t *config);
+    ~Spp_Client();
+    void ProcessEvent(BtEvent* pEvent);
+    void state_inactive_handler(BtEvent* pEvent);
+    void state_active_handler(BtEvent* pEvent);
+    void state_connected_handler(BtEvent* pEvent);
+    void state_send_receive_handler(BtEvent * pEvent);
+    void state_disconnected_handler(BtEvent* pEvent);
+    void change_state(SppClientState mState);
+    char* dump_message(BluetoothEventId event_id);
+    pthread_mutex_t lock;
+    void HandleEnableClient();
+    void HandleDisableClient();
+    SppClientState getState() { return mClientState; }
+    int receive_file(const char* fname, int &soc_fd);
+    int snd_file(const char* fname, int &soc_fd);
+    void process_connect_message();
+    void connect(bt_bdaddr_t baddr);
+    void start_send_recv_threads();
+    void sppcli_send_thread_handler();
+    void sppcli_recv_thread_handler();
+    int spp_client_create_socket();
+    int spp_start_socket_threads();
+    void spp_client_read_thread_handler();
+    void spp_client_write_thread_handler();
+    int spp_client_set_tty_driver_state(uint8_t ttyState);
+    void  spp_client_read_thread_close();
+    void  spp_client_write_thread_close();
+};
+
+#endif /* SPP_CLIENT_APP_H */
diff --git a/bt-app/spp_client/src/spp_client.cpp b/bt-app/spp_client/src/spp_client.cpp
new file mode 100755
index 0000000..a8ca40b
--- /dev/null
+++ b/bt-app/spp_client/src/spp_client.cpp
@@ -0,0 +1,1112 @@
+ /*
+  * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#include <iostream>
+#include <string.h>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_sock.h>
+#include "osi/include/alarm.h"
+#include "spp_client.hpp"
+#include "Gap.hpp"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <iostream>
+#include <fstream>
+#include <linux/netlink.h>
+#include <pthread.h>
+
+#define LOGTAG_SPP_CLIENT "SPP_CLIENT "
+
+
+#define SPP_CLIENT_APP_UID (2)
+
+#define VALID_CLI_SOCFD(FD) (-1 == FD?0:1)
+#define RESET_CLI_SOCFD(FD) (FD=-1)
+
+#define NETLINK_SPP         31
+#define SPP_CTL_ON         1
+#define SPP_CTL_OFF        2
+#define SPP_CTL_DATA_LEN   9
+#define SPP_CTL_OP_POS     0
+#define SPP_CTL_INS_POS    1
+#define SPP_CTL_MTU_POS    5
+#define SPP_DATA_MTU       500
+
+using namespace std;
+using std::list;
+using std::string;
+
+Spp_Client *pSppClient = NULL;
+typedef struct
+{
+    struct nlmsghdr n;
+    uint8_t data[0];
+} data_st;
+
+static const uint8_t  SPP_UUID[]              = {0x00, 0x00, 0x11, 0x01, 0x00, 0x00, 0x10, 0x00,
+                                                 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB};
+
+/* SPP client receive thread */
+static pthread_t client_recv_thread = NULL;
+static pthread_mutex_t client_recv_mutex;
+static pthread_cond_t start_client_recv_cv;
+
+/* SPP client send thread */
+static pthread_t client_send_thread = NULL;
+static pthread_mutex_t client_send_mutex;
+static pthread_cond_t start_client_send_cv;
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void BtSppClientMsgHandler(void *msg) {
+
+    BtEvent* pEvent = NULL;
+
+    if(!msg) {
+        ALOGE("Msg is NULL, bail out!!");
+        return;
+    }
+
+    pEvent = ( BtEvent *) msg;
+
+    switch(pEvent->event_id) {
+
+        case PROFILE_API_START:
+
+            ALOGD(LOGTAG_SPP_CLIENT "enable spp client");
+
+            if (pSppClient) {
+                pSppClient->HandleEnableClient();
+            }
+            break;
+
+        case PROFILE_API_STOP:
+
+            ALOGD(LOGTAG_SPP_CLIENT "Disable spp client");
+            if (pSppClient) {
+                pSppClient->HandleDisableClient();
+            }
+            break;
+
+        default:
+
+            ALOGD(LOGTAG_SPP_CLIENT "default event_id");
+            if(pSppClient) {
+               pSppClient->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+    }
+
+    delete pEvent;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+static void *spp_client_send_thread_func(void *in_param)
+{
+
+    pSppClient->sppcli_send_thread_handler();
+    return NULL;
+
+}
+
+
+static void *spp_client_recv_thread_func(void *in_param)
+{
+
+    pSppClient->sppcli_recv_thread_handler();
+    return NULL;
+
+}
+
+
+void Spp_Client::sppcli_send_thread_handler()
+{
+
+    while ( mClientState != STATE_SPP_CLIENT_INACTIVE )
+    {
+        /* Wait for receive command from the user */
+        while ( mClientState != STATE_SPP_CLIENT_SEND_FILE )
+            pthread_cond_wait(&start_client_send_cv,&client_send_mutex);
+        pthread_mutex_unlock(&client_send_mutex);
+
+        /* Send File */
+        if(VALID_CLI_SOCFD(listen_data_socfd))
+        {
+            int status = snd_file(file_name.c_str(),listen_data_socfd);
+
+            if(status != SUCCESS)
+            {
+                ALOGD(LOGTAG_SPP_CLIENT "Send file failed \n");
+            }
+        }
+        else
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "In-valid socfd, Connection may be lost");
+        }
+
+        if( !VALID_CLI_SOCFD(listen_data_socfd) )
+        {
+            change_state(STATE_SPP_CLIENT_DISCONNECTED);
+        }
+        else
+        {
+            change_state(STATE_SPP_CLIENT_CONNECTED);
+        }
+    }
+
+    pthread_mutex_destroy(&client_send_mutex);
+    pthread_cond_destroy(&start_client_send_cv);
+
+}
+
+void Spp_Client::sppcli_recv_thread_handler()
+{
+
+    while ( mClientState != STATE_SPP_CLIENT_INACTIVE )
+    {
+        /* Wait for receive command from the user */
+        while ( mClientState != STATE_SPP_CLIENT_RECEIVE_FILE )
+            pthread_cond_wait(&start_client_recv_cv,&client_recv_mutex);
+        pthread_mutex_unlock(&client_recv_mutex);
+
+        /* Receive File */
+        receive_file(file_name.c_str(),listen_data_socfd);
+
+        if( !VALID_CLI_SOCFD(listen_data_socfd) )
+        {
+            change_state(STATE_SPP_CLIENT_DISCONNECTED);
+        }
+        else
+        {
+            change_state(STATE_SPP_CLIENT_CONNECTED);
+        }
+    }
+
+    pthread_mutex_destroy(&client_recv_mutex);
+    pthread_cond_destroy(&start_client_recv_cv);
+
+}
+
+static void *spp_client_write_thread_func(void *arg)
+{
+    pSppClient->spp_client_write_thread_handler();
+    return NULL;
+}
+
+static void *spp_client_read_thread_func(void *arg)
+{
+    pSppClient->spp_client_read_thread_handler();
+    return NULL;
+}
+
+void Spp_Client::spp_client_write_thread_close()
+{
+    ALOGD(LOGTAG_SPP_CLIENT "spp_client_write_thread_close");
+    pthread_mutex_lock(&client_write_thread_mutex);
+    client_write_thread_stop_thread = true;
+    pthread_mutex_unlock(&client_write_thread_mutex);
+}
+
+void Spp_Client::spp_client_read_thread_close()
+{
+    ALOGD(LOGTAG_SPP_CLIENT "spp_client_read_thread_close");
+    pthread_mutex_lock(&client_read_thread_mutex);
+    client_read_thread_stop_thread = true;
+    pthread_mutex_unlock(&client_read_thread_mutex);
+}
+
+int Spp_Client::spp_client_set_tty_driver_state(uint8_t ttyState)
+{
+    int instanceId = 1;//Only one Instance is used!!
+    int maxFrame = spp_max_frame_size;
+    int retVal = -1;
+    struct
+    {
+        struct nlmsghdr n;
+        uint8_t data[SPP_CTL_DATA_LEN];
+    } ctl;
+
+    ALOGD(LOGTAG_SPP_CLIENT "spp_client_set_tty_driver_state");
+
+    memset(&ctl, 0x00, sizeof(ctl));
+
+    ctl.data[SPP_CTL_OP_POS] = ttyState;
+    memcpy(ctl.data + SPP_CTL_INS_POS, &instanceId, sizeof(instanceId));
+
+    if (ttyState == SPP_CTL_ON)
+    {
+        memcpy(ctl.data + SPP_CTL_MTU_POS, &maxFrame, sizeof(maxFrame));
+    }
+
+    ctl.n.nlmsg_len = NLMSG_LENGTH(SPP_CTL_DATA_LEN);
+    ctl.n.nlmsg_pid = client_read_thread;  /* self pid */
+    ctl.n.nlmsg_type  = NETLINK_SPP;
+    ctl.n.nlmsg_flags = NL_MSG_CTL;
+
+    ALOGD(LOGTAG_SPP_CLIENT "instanceId is %d, maxFrame is %d, nlmsg_pid is %lu, serverSocket is %d, ctl.n.nlmsg_len is %d",
+    instanceId, maxFrame, client_read_thread, kernel_sock_fd,  ctl.n.nlmsg_len);
+
+    retVal = send(kernel_sock_fd, &ctl, ctl.n.nlmsg_len, 0);
+    return retVal;
+}
+
+void Spp_Client::spp_client_write_thread_handler()
+{
+    char buffer[1024];
+    char ctrl_msgbuf[CMSG_SPACE(1)];
+    struct sockaddr_storage src_addr;
+    struct iovec iov[1];
+    iov[0].iov_base=buffer;
+    iov[0].iov_len=sizeof(buffer);
+    int count;
+
+    struct msghdr message;
+    message.msg_name=&src_addr;
+    message.msg_namelen=sizeof(src_addr);
+    message.msg_iov=iov;
+    message.msg_iovlen=1;
+    message.msg_control= ctrl_msgbuf;
+    message.msg_controllen= sizeof(ctrl_msgbuf);
+    int retVal;
+
+    ALOGD(LOGTAG_SPP_CLIENT "spp_client_write_thread_handler");
+    while (1)
+    {
+        pthread_mutex_lock(&client_write_thread_mutex);
+
+        if (client_write_thread_stop_thread)
+        {
+            if (tty_opened)
+            {
+                retVal = spp_client_set_tty_driver_state(SPP_CTL_OFF);
+
+                if (retVal < 0)
+                {
+                    ALOGD(LOGTAG_SPP_CLIENT "spp_client_write_thread_handler sendmsg ctl message failed!!");
+                    pthread_mutex_unlock(&client_write_thread_mutex);
+                    continue;
+                }
+                tty_opened = false;
+            }
+            pthread_mutex_unlock(&client_write_thread_mutex);
+            pthread_mutex_destroy(&client_write_thread_mutex);
+
+           ALOGD(LOGTAG_SPP_CLIENT "spp_client_write_thread_handler Exiting Write Thread");
+
+            if (client_read_thread_exit == 1)
+            {
+                ALOGD(LOGTAG_SPP_CLIENT "write thread close the socket");
+                shutdown(kernel_sock_fd, SHUT_RDWR);
+                close(kernel_sock_fd);
+                kernel_sock_fd = 0;
+            }
+
+            client_write_thread_exit = 1;
+            pthread_exit(NULL);
+        }
+
+        if (!tty_opened)
+        {
+            retVal = spp_client_set_tty_driver_state(SPP_CTL_ON);
+            if (retVal < 0)
+            {
+                ALOGD(LOGTAG_SPP_CLIENT "spp_client_write_thread_handler retVal is %d, Sendmsg ctl message failed,%s", retVal, strerror(errno));
+                pthread_mutex_unlock(&client_write_thread_mutex);
+                continue;
+            }
+            tty_opened = true;
+            ALOGD(LOGTAG_SPP_CLIENT "spp_client_write_thread_handler retVal is %d, Sendmsg ctl message successed", retVal);
+        }
+
+        pthread_mutex_unlock(&client_write_thread_mutex);
+        ALOGD(LOGTAG_SPP_CLIENT "%s listen_data_socfd is %d", __func__, listen_data_socfd);
+        count = recvmsg(listen_data_socfd, &message,0);
+
+        ALOGD(LOGTAG_SPP_CLIENT "RECVD DATA, count=%d", (int)count);
+        for(int i =0; i< count ; i++)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "buffer[%d]=%c",i, buffer[i]);
+        }
+
+        if( count > 0 )
+        {
+            int bytesSent = 0;
+
+            while (bytesSent != count)
+            {
+                if (tty_opened)
+                {
+                    int currentSend = count - bytesSent;
+                    data_st *send_data = (data_st *)osi_malloc(sizeof(data_st) + currentSend);
+
+                    memset(send_data, 0x00, sizeof(data_st));
+                    memcpy(send_data->data, buffer + bytesSent, currentSend);
+                    send_data->n.nlmsg_len = NLMSG_LENGTH(currentSend);
+                    send_data->n.nlmsg_pid = client_read_thread;         /* self pid */
+                    send_data->n.nlmsg_type  = NETLINK_SPP;
+                    send_data->n.nlmsg_flags = NL_MSG_CTL + 1;       /*data flags*/
+
+                    retVal = send(kernel_sock_fd, send_data,
+                                  send_data->n.nlmsg_len, 0);
+
+                    ALOGD(LOGTAG_SPP_CLIENT "send ret is %d,currentSend is %d",  retVal, currentSend);
+                    retVal = (int)(currentSend & 0x0000ffff);
+                    osi_free(send_data);
+                    send_data = NULL;
+                }
+                else
+                {
+                    ALOGD(LOGTAG_SPP_CLIENT "tty_opened is false");
+                }
+                bytesSent += retVal;
+            }
+        }
+        else if( count == 0 )
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "connection closed by the remote");
+            RESET_CLI_SOCFD(listen_data_socfd);
+            client_write_thread_stop_thread = true;
+        }
+        else
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "Receive Error count=%d", count);
+        }
+    }
+}
+
+void Spp_Client::spp_client_read_thread_handler()
+{
+    uint8_t *buffer = NULL;
+    int retVal = 0;
+    pthread_attr_t client_write_thread_attr;
+
+    ALOGD(LOGTAG_SPP_CLIENT "spp_client_read_thread_handler");
+
+    pthread_mutex_init(&client_write_thread_mutex, NULL);
+    client_write_thread_stop_thread = false;
+
+    pthread_attr_init(&client_write_thread_attr);
+    pthread_attr_setdetachstate(&client_write_thread_attr, PTHREAD_CREATE_DETACHED);
+    retVal = pthread_create(&client_write_thread, &client_write_thread_attr, spp_client_write_thread_func, NULL);
+    pthread_attr_destroy(&client_write_thread_attr);
+    if (retVal != 0)
+   {
+        shutdown(kernel_sock_fd, SHUT_RDWR);
+        close(kernel_sock_fd);
+        kernel_sock_fd = 0;
+        ALOGD(LOGTAG_SPP_CLIENT "!! ERROR !! Cannot create client_write_thread!\n");
+
+        pthread_mutex_destroy(&client_write_thread_mutex);
+        pthread_mutex_destroy(&client_read_thread_mutex);
+
+        pthread_exit(NULL);
+        return;
+    }
+    while (1)
+    {
+        if (client_read_thread_stop_thread)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "Exiting Read Thread!!");
+
+            pthread_mutex_destroy(&client_read_thread_mutex);
+
+            if (client_write_thread_exit == 1)
+            {
+                ALOGD(LOGTAG_SPP_CLIENT "read thread close the socket\n");
+                shutdown(kernel_sock_fd, SHUT_RDWR);
+                close(kernel_sock_fd);
+                kernel_sock_fd = 0;
+            }
+            client_read_thread_exit =1;
+            pthread_exit(NULL);
+        }
+        buffer = (uint8_t *)osi_malloc(spp_max_frame_size+ NLMSG_LENGTH(0));
+        if (buffer == NULL)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "osi_malloc Failed!!\n");
+        }
+        memset(buffer, 0, spp_max_frame_size + NLMSG_LENGTH(0));
+
+        retVal = recv(kernel_sock_fd, buffer, spp_max_frame_size, 0);
+        if (retVal <= 0)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT " retVal : %d \n",retVal);
+            pthread_mutex_destroy(&client_read_thread_mutex);
+            if (buffer != NULL)
+            {
+                osi_free(buffer);
+            }
+            break;
+        }
+
+        ALOGD(LOGTAG_SPP_CLIENT "read thread retVal : %d \n",retVal);
+        ALOGD(LOGTAG_SPP_CLIENT "read buffer is : %s \n",buffer);
+
+        if (buffer && strstr((char *)buffer, "client_read_thread_exit") != NULL)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "%s client_read_thread_exit !!!!\n",__func__);
+            client_read_thread_stop_thread = true;
+            osi_free(buffer);
+            buffer = NULL;
+        }
+        else if (buffer && strstr((char *)buffer, "ttySpp") != NULL)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "%s ttySpp!!!!\n",__func__);
+            osi_free(buffer);
+            buffer = NULL;
+        }
+        else
+        {
+            int count=0 ;
+            char send_buffer[1024];
+            char extra_char[10] = {0xD, 0xA};  // 0XD:Carriage Return, 0xA: New Line Feed
+
+            memcpy(send_buffer,buffer,retVal);
+            memcpy(send_buffer+retVal, extra_char, 2);
+            for(int i =0; i< retVal+2 ; i++)
+            {
+                ALOGD(LOGTAG_SPP_CLIENT "send_buffer[%d]=%c %d",i, send_buffer[i], send_buffer[i]);
+            }
+
+            pthread_mutex_lock(&client_read_thread_mutex);
+
+            ALOGD(LOGTAG_SPP_CLIENT "%s listen_data_socfd is %d", __func__, listen_data_socfd);
+
+            count = write(listen_data_socfd,&send_buffer,retVal+2);
+            if(count < 0)
+            {
+                ALOGD(LOGTAG_SPP_CLIENT " sendmsg failed (ret=%d,errno=%d,err=%s)",count,errno,strerror(errno));
+            }
+            else
+            {
+                ALOGD(LOGTAG_SPP_CLIENT " sent bytes (%d)",count);
+            }
+            pthread_mutex_unlock(&client_read_thread_mutex);
+            osi_free(buffer);
+        }
+    }
+}
+
+int Spp_Client::spp_start_socket_threads()
+{
+    pthread_attr_t client_read_thread_attr;
+    int retVal = 0;
+
+    client_write_thread_exit = 0;
+    client_read_thread_exit = 0;
+
+   ALOGD(LOGTAG_SPP_CLIENT "spp_start_socket_threads");
+
+    pthread_mutex_init(&client_read_thread_mutex, NULL);
+    client_read_thread_stop_thread = false;
+
+    pthread_mutex_init(&client_read_thread_mutex, NULL);
+
+    pthread_attr_init(&client_read_thread_attr);
+    pthread_attr_setdetachstate(&client_read_thread_attr, PTHREAD_CREATE_DETACHED);
+    retVal =  pthread_create(&client_read_thread, &client_read_thread_attr, spp_client_read_thread_func, NULL);
+    pthread_attr_destroy(&client_read_thread_attr);
+    if (retVal != 0) {
+        ALOGD(LOGTAG_SPP_CLIENT "!! ERROR !! Cannot create client_read_thread!\n");
+        pthread_mutex_destroy(&client_read_thread_mutex);
+        return -1 ;
+    }
+    return 0;
+}
+
+
+int Spp_Client::spp_client_create_socket()
+{
+    struct sockaddr_nl nladdr;
+    int sz = 64 * 1024;
+    int on = 1;
+    int random = rand();
+
+    ALOGD(LOGTAG_SPP_CLIENT "spp_client_create_socket random value:%d\n",random);
+    memset(&nladdr, 0, sizeof(nladdr));
+    nladdr.nl_family = AF_NETLINK;
+    nladdr.nl_pid = (unsigned int)random;
+    nladdr.nl_pad = 0;
+    nladdr.nl_groups = 0;
+
+    if ((kernel_sock_fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_SPP)) < 0)
+    {
+         ALOGD(LOGTAG_SPP_CLIENT "Unable to create uevent socket");
+        return -1;
+    }
+
+    if (setsockopt(kernel_sock_fd, SOL_SOCKET, SO_RCVBUFFORCE, &sz, sizeof(sz)) < 0)
+    {
+        ALOGD(LOGTAG_SPP_CLIENT "Unable to set uevent socket SO_RECBUFFORCE option");
+        close(kernel_sock_fd);
+        return -1;
+    }
+
+    if (setsockopt(kernel_sock_fd, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on)) < 0)
+    {
+        ALOGD(LOGTAG_SPP_CLIENT "Unable to set uevent socket SO_PASSCRED option");
+        close(kernel_sock_fd);
+        return -1;
+    }
+
+    if ((setsockopt(kernel_sock_fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))) < 0)
+    {
+        ALOGD(LOGTAG_SPP_CLIENT "Unable to set uevent socket SO_REUSEADDR option");
+        close(kernel_sock_fd);
+        return -1;
+    }
+
+    ALOGD(LOGTAG_SPP_CLIENT "netlink nladdr.nl_pid is %d", nladdr.nl_pid);
+
+    if (bind(kernel_sock_fd, (struct sockaddr *) &nladdr, sizeof(nladdr)) < 0)
+    {
+        ALOGD(LOGTAG_SPP_CLIENT "Unable to bind nladdr %s", strerror(errno));
+        close(kernel_sock_fd);
+        return -1;
+    }
+
+    ALOGD(LOGTAG_SPP_CLIENT "kernel_sock_fd is %d", kernel_sock_fd);
+
+    return kernel_sock_fd;
+}
+
+void Spp_Client::process_connect_message()
+{
+
+    ALOGD(LOGTAG_SPP_CLIENT "process_connect_message");
+
+    char buffer[1024];
+    char ctrl_msgbuf[CMSG_SPACE(1)];
+    struct cmsghdr *pcmsg;
+    int* p_acc_fd = NULL;
+    struct sockaddr_storage src_addr;
+    sock_connect_signal_t *pConnect_Sig = NULL;
+    int i =0;
+
+    struct iovec iov[1];
+    iov[0].iov_base=buffer;
+    iov[0].iov_len=sizeof(buffer);
+
+    struct msghdr message;
+    message.msg_name=&src_addr;
+    message.msg_namelen=sizeof(src_addr);
+    message.msg_iov=iov;
+    message.msg_iovlen=1;
+    message.msg_control= ctrl_msgbuf;
+    message.msg_controllen= sizeof(ctrl_msgbuf);
+
+    while ( mClientState == STATE_SPP_CLIENT_CONNECTING )
+    {
+
+        // Wait for sock_connect_signal_t message
+        int count = recvmsg(listen_data_socfd,&message,0);
+
+        if (count==-1)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "recvmsg returned -1");
+        }
+        else if (message.msg_flags&MSG_TRUNC)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB]MSG_TRUNC\n");
+        }
+        else if ( 0 == count )
+        {
+           ALOGE(LOGTAG_SPP_CLIENT "ERROR listen sockfd closed");
+           RESET_CLI_SOCFD(listen_data_socfd);
+           change_state(STATE_SPP_CLIENT_IDLE);
+           return;
+        }
+
+        if(count == 4)
+        {
+            for(i =0 ; i < count ; i++)
+            ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] Received SCN msg[%d]= %02X\n",i, buffer[i]);
+
+            memset(buffer,0,sizeof(buffer));
+            continue;
+        }
+
+        // Handle the sock_connect_signal - remote address, server channel and status is received.
+
+        ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] count=%d", (int)count);
+        ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB]Received sock_connect_signal_t");
+        pConnect_Sig = (sock_connect_signal_t *) buffer;
+
+        ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] size=%d", pConnect_Sig->size);
+        ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] channel=%d", pConnect_Sig->channel);
+        ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] status=%d", pConnect_Sig->status);
+        for(i =0; i< 6 ; i++)
+        ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] bdadd[%d]= %02X\n",i, pConnect_Sig->bd_addr.address[i]);
+
+        spp_max_frame_size  = SPP_DATA_MTU;
+
+        if(spp_client_create_socket() == -1)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "!! ERROR !! spp_client_create_socket FAILED!!\n");
+        }
+        else if (spp_start_socket_threads() == -1)
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "!! ERROR !! spp_start_socket_threads FAILED!!\n");
+        }
+        else
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "spp_server socket, threads creation is SUCCESS!!\n");
+        }
+        ALOGD(LOGTAG_SPP_CLIENT "\n [AKK_DEBUB] Moving to connected state.\n");
+        change_state(STATE_SPP_CLIENT_CONNECTED);
+    }
+
+    ALOGD(LOGTAG_SPP_CLIENT "\n [AKK_DEBUB] Out of while loop \n");
+
+}
+
+void Spp_Client::connect(bt_bdaddr_t baddr)
+{
+
+    bt_bdaddr_t bd_addr = baddr;
+
+
+    btsock_interface = (btsock_interface_t *)bluetooth_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);
+
+    change_state(STATE_SPP_CLIENT_CONNECTING);
+
+    // Invoke connect with socket type as RFCOMM, SPP UUID
+    int status = btsock_interface->connect(&bd_addr,BTSOCK_RFCOMM,SPP_UUID,SPP_CLIENT_CHANNEL,&listen_data_socfd,0,SPP_CLIENT_APP_UID);
+
+    if(status == BT_STATUS_SUCCESS)
+    {
+        process_connect_message();
+    }
+    else
+    {
+        ALOGE(LOGTAG_SPP_CLIENT "Error -btsock_interface->connect, returned %d", status);
+    }
+
+}
+
+void Spp_Client::HandleEnableClient(void) {
+
+    BtEvent *pEvent = new BtEvent;
+    pEvent->profile_start_event.status = true;
+    change_state(STATE_SPP_CLIENT_IDLE);
+    pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+    pEvent->profile_start_event.profile_id = PROFILE_ID_SPP_CLIENT;
+    PostMessage(THREAD_ID_GAP, pEvent);
+
+    BtEvent *pStartThrdsEvent = new BtEvent;
+    pStartThrdsEvent->spp_cli_event.event_id = SPP_CLI_START_THREADS;
+    PostMessage (THREAD_ID_SPP_CLIENT, pStartThrdsEvent);
+}
+
+
+void Spp_Client::HandleDisableClient(void) {
+
+   change_state(STATE_SPP_CLIENT_INACTIVE);
+
+   BtEvent *pEvent = new BtEvent;
+   pEvent->profile_stop_event.event_id = PROFILE_EVENT_STOP_DONE;
+   pEvent->profile_stop_event.profile_id = PROFILE_ID_SPP_CLIENT;
+   pEvent->profile_stop_event.status = true;
+   PostMessage(THREAD_ID_GAP, pEvent);
+}
+
+void Spp_Client::ProcessEvent(BtEvent* pEvent) {
+
+    switch(mClientState) {
+
+        case STATE_SPP_CLIENT_INACTIVE:
+            state_inactive_handler(pEvent);
+            break;
+        case STATE_SPP_CLIENT_IDLE:
+            state_active_handler(pEvent);
+            break;
+
+        case STATE_SPP_CLIENT_CONNECTING:
+            {
+                fprintf(stdout, "Event not processed in in-connecting state %d ", pEvent->event_id);
+                ALOGE(LOGTAG_SPP_CLIENT " event not handled %d (%s) ", pEvent->event_id,dump_message(pEvent->event_id) );
+            }
+            break;
+
+        case STATE_SPP_CLIENT_CONNECTED:
+            state_connected_handler(pEvent);
+            break;
+
+        case STATE_SPP_CLIENT_SEND_FILE:
+            state_send_receive_handler(pEvent);
+            break;
+
+        case STATE_SPP_CLIENT_RECEIVE_FILE:
+            state_send_receive_handler(pEvent);
+            break;
+
+        case STATE_SPP_CLIENT_DISCONNECTED:
+            state_disconnected_handler(pEvent);
+            break;
+    }
+}
+
+char* Spp_Client::dump_message(BluetoothEventId event_id) {
+
+    switch(event_id) {
+
+        case SPP_CLI_CONNECT:
+            return (char*)"SPP_CLI_CONNECT";
+
+        case SPP_CLI_SEND_FILE:
+            return (char*)"SPP_CLI_SEND_FILE";
+
+        case SPP_CLI_RECV_FILE:
+            return (char*)"SPP_CLI_RECV_FILE";
+
+        case SPP_CLI_DISCONNECT:
+            return (char*)"SPP_CLI_DISCONNECT";
+
+        case SPP_CLI_START_THREADS:
+            return (char*)"SPP_CLI_START_THREADS";
+
+    }
+    return (char*)"UNKNOWN";
+}
+
+void Spp_Client::state_inactive_handler(BtEvent* pEvent) {
+
+    ALOGD(LOGTAG_SPP_CLIENT "state_inactive_handler Processing event %s", dump_message(pEvent->event_id));
+
+    switch(pEvent->event_id) {
+
+
+        default:
+            fprintf(stdout, "Event not processed in in-active state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_SPP_CLIENT " event not handled %d (%s) ", pEvent->event_id,dump_message(pEvent->event_id) );
+            break;
+    }
+}
+
+void Spp_Client::state_active_handler(BtEvent* pEvent) {
+
+    ALOGD(LOGTAG_SPP_CLIENT "state_active_handler Processing event %s", dump_message(pEvent->event_id));
+
+    switch(pEvent->event_id) {
+
+        case SPP_CLI_START_THREADS:
+            {
+                start_send_recv_threads();
+            }
+            break;
+
+        case SPP_CLI_CONNECT:
+            {
+                connect(pEvent->spp_cli_event.bd_addr);
+            }
+            break;
+
+        default:
+            fprintf(stdout, "Event not processed in active state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_SPP_CLIENT " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+
+int Spp_Client::receive_file(const char* fname, int &soc_fd)
+{
+    int count  = 0;
+    int status = SUCCESS;
+    int i      = 0;
+    char buffer[1024];
+
+    char ctrl_msgbuf[CMSG_SPACE(1)];
+    struct cmsghdr *pcmsg;
+    struct sockaddr_storage src_addr;
+    struct iovec iov[1];
+    iov[0].iov_base=buffer;
+    iov[0].iov_len=sizeof(buffer);
+
+    struct msghdr message;
+    message.msg_name=&src_addr;
+    message.msg_namelen=sizeof(src_addr);
+    message.msg_iov=iov;
+    message.msg_iovlen=1;
+    message.msg_control= ctrl_msgbuf;
+    message.msg_controllen= sizeof(ctrl_msgbuf);
+
+    ALOGD(LOGTAG_SPP_CLIENT "--> receive_file, fname=%s, soc_fd=%d\n", fname, soc_fd);
+
+
+    ofstream recv_file(fname,ios::out | ios::binary);
+
+    if( recv_file.is_open())
+    {
+        while ((count = recvmsg(soc_fd,&message,0)) > 0 )
+        {
+            recv_file.write(buffer,count);
+            recv_file.flush();
+            ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB]RECVD DATA, count=%d", (int)count);
+            for(i =0; i< count ; i++)
+            {
+                ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] buffer[%d]=%c",i, buffer[i]);
+            }
+        }
+
+        recv_file.flush();
+        recv_file.close();
+
+        if( count == 0 )
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] connection closed by the remote");
+            RESET_CLI_SOCFD(soc_fd);
+            spp_client_write_thread_close();
+        }
+        else
+        {
+            ALOGD(LOGTAG_SPP_CLIENT "[AKK_DEBUB] Receive Error count=%d", count);
+            status = FAILED;
+        }
+    }
+    else
+    {
+        ALOGE(LOGTAG_SPP_CLIENT "Error opening file=%s\n", fname);
+        status = FAILED;
+    }
+
+    ALOGD(LOGTAG_SPP_CLIENT "<-- receive_file, fname=%s, soc_fd=%d\n", fname, soc_fd);
+
+    return status;
+
+}
+
+int Spp_Client::snd_file(const char* fname, int &soc_fd)
+{
+    int count  = 0;
+    int status = SUCCESS;
+    char buffer[1024];
+    int max_read_size=500;
+
+    ALOGD(LOGTAG_SPP_CLIENT "--> snd_file, fname=%s, soc_fd=%d\n", fname, soc_fd);
+
+
+    ifstream snd_file(fname,ios::in | ios::binary);
+
+    if( snd_file.is_open())
+    {
+        while (!snd_file.eof())
+        {
+            snd_file.read(buffer,max_read_size);
+
+            count = send(soc_fd,&buffer,snd_file.gcount(),MSG_NOSIGNAL);
+
+            if(count < 0)
+            {
+                ALOGD(LOGTAG_SPP_CLIENT " sendmsg failed (ret=%d,errno=%d,err=%s)",count,errno,strerror(errno));
+                ALOGE(LOGTAG_SPP_CLIENT " Aborting send_file, Invalid data socfd, connection may be lost\n");
+                fprintf(stderr, " Aborting send_file, Invalid data socfd, connection may be lost, error(%s) \n",strerror(errno));
+                RESET_CLI_SOCFD(soc_fd);
+                status = FAILED;
+                break;
+            }
+            else
+            {
+                ALOGD(LOGTAG_SPP_CLIENT " sent bytes (%d)",count);
+            }
+        }
+
+        snd_file.close();
+    }
+    else
+    {
+        ALOGE(LOGTAG_SPP_CLIENT "Error opening file=%s\n", fname);
+        status = FAILED;
+    }
+
+    ALOGD(LOGTAG_SPP_CLIENT "<-- snd_file, fname=%s, soc_fd=%d\n", fname, soc_fd);
+
+    return status;
+
+}
+
+void Spp_Client::state_connected_handler(BtEvent* pEvent) {
+
+    ALOGD(LOGTAG_SPP_CLIENT "state_connected_handler Processing event %s", dump_message(pEvent->event_id));
+
+    switch(pEvent->event_id) {
+
+        case SPP_CLI_SEND_FILE:
+            {
+                file_name = pEvent->spp_cli_event.value;
+                change_state(STATE_SPP_CLIENT_SEND_FILE);
+                pthread_mutex_lock(&client_send_mutex);
+                pthread_cond_signal(&start_client_send_cv);
+                pthread_mutex_unlock(&client_send_mutex);
+            }
+            break;
+
+        case SPP_CLI_RECV_FILE:
+            {
+                file_name = pEvent->spp_cli_event.value;
+                change_state(STATE_SPP_CLIENT_RECEIVE_FILE);
+                pthread_mutex_lock(&client_recv_mutex);
+                pthread_cond_signal(&start_client_recv_cv);
+                pthread_mutex_unlock(&client_recv_mutex);
+            }
+            break;
+
+        case SPP_CLI_DISCONNECT:
+            {
+                spp_client_write_thread_close();
+                shutdown(listen_data_socfd, SHUT_RDWR);
+                close(listen_data_socfd);
+                RESET_CLI_SOCFD(listen_data_socfd);
+                change_state(STATE_SPP_CLIENT_DISCONNECTED);
+            }
+            break;
+
+        default:
+            ALOGE(LOGTAG_SPP_CLIENT " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+void Spp_Client::state_send_receive_handler(BtEvent* pEvent) {
+
+    if(mClientState == STATE_SPP_CLIENT_SEND_FILE)
+    {
+        ALOGD(LOGTAG_SPP_CLIENT " SPP-CLI 'SEND' state, Processing event %s", dump_message(pEvent->event_id));
+    }
+    else
+    {
+        ALOGD(LOGTAG_SPP_CLIENT " SPP-CLI 'RECEIVE' state Processing event %s", dump_message(pEvent->event_id));
+    }
+
+    switch(pEvent->event_id) {
+
+        case SPP_CLI_DISCONNECT:
+            {
+                spp_client_write_thread_close();
+                shutdown(listen_data_socfd, SHUT_RDWR);
+                close(listen_data_socfd);
+                RESET_CLI_SOCFD(listen_data_socfd);
+                change_state(STATE_SPP_CLIENT_DISCONNECTED);
+            }
+            break;
+
+        default:
+        {
+            if(mClientState == STATE_SPP_CLIENT_SEND_FILE)
+            {
+                fprintf(stdout, "Event not processed in 'SEND' state %d ", pEvent->event_id);
+            }
+            else
+            {
+                fprintf(stdout, "Event not processed in 'RECEIVE' state %d ", pEvent->event_id);
+            }
+
+            ALOGE(LOGTAG_SPP_CLIENT " event not handled %d ", pEvent->event_id);
+        }
+        break;
+    }
+}
+
+void Spp_Client::state_disconnected_handler(BtEvent* pEvent) {
+
+    ALOGD(LOGTAG_SPP_CLIENT "state_disconnected_handler Processing event %s", dump_message(pEvent->event_id));
+
+    switch(pEvent->event_id) {
+
+        case SPP_CLI_CONNECT:
+            {
+                connect(pEvent->spp_cli_event.bd_addr);
+            }
+            break;
+
+        default:
+            fprintf(stdout, "Event not processed in disconnected state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_SPP_CLIENT " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+
+void Spp_Client::start_send_recv_threads()
+{
+
+    ALOGD(LOGTAG_SPP_CLIENT "--> start_send_recv_threads");
+
+    pthread_mutex_init(&client_recv_mutex, NULL);
+    pthread_cond_init(&start_client_recv_cv, NULL);
+    if (pthread_create(&client_recv_thread, NULL, spp_client_recv_thread_func, NULL) != 0) {
+        ALOGD(LOGTAG_SPP_CLIENT "!! ERROR !! Cannot create spp client receive thread!\n");
+        return;
+    }
+
+    pthread_mutex_init(&client_send_mutex, NULL);
+    pthread_cond_init(&start_client_send_cv, NULL);
+    if (pthread_create(&client_send_thread, NULL, spp_client_send_thread_func, NULL) != 0) {
+        ALOGD(LOGTAG_SPP_CLIENT "!! ERROR !! Cannot create spp client send thread!\n");
+        return;
+    }
+
+    ALOGD(LOGTAG_SPP_CLIENT "<-- start_send_recv_threads");
+
+}
+
+void Spp_Client::change_state(SppClientState mState) {
+   ALOGD(LOGTAG_SPP_CLIENT " current State = %d, new state = %d", mClientState, mState);
+   pthread_mutex_lock(&lock);
+   mClientState = mState;
+   pthread_mutex_unlock(&lock);
+   ALOGD(LOGTAG_SPP_CLIENT " state changed to %d ", mState);
+}
+
+Spp_Client :: Spp_Client(const bt_interface_t *bt_interface, config_t *config) {
+    ALOGD(LOGTAG_SPP_CLIENT " Spp_Client constructor");
+    this->bluetooth_interface = bt_interface;
+    this->config              = config;
+    RESET_CLI_SOCFD(listen_data_socfd);
+    pthread_mutex_init(&this->lock, NULL);
+    change_state(STATE_SPP_CLIENT_INACTIVE);
+}
+
+Spp_Client :: ~Spp_Client() {
+    change_state(STATE_SPP_CLIENT_INACTIVE);
+    pthread_mutex_destroy(&lock);
+}
+
diff --git a/bt-app/spp_server/include/spp_server.hpp b/bt-app/spp_server/include/spp_server.hpp
new file mode 100755
index 0000000..66e991a
--- /dev/null
+++ b/bt-app/spp_server/include/spp_server.hpp
@@ -0,0 +1,112 @@
+ /*
+  * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#ifndef SPP_SERVER_APP_H
+#define SPP_SERVER_APP_H
+
+#include <map>
+#include <string>
+#include <hardware/bluetooth.h>
+
+#include "osi/include/log.h"
+#include "osi/include/thread.h"
+#include "osi/include/config.h"
+#include "osi/include/allocator.h"
+#include "ipc.h"
+#include "utils.h"
+
+
+typedef enum {
+    STATE_SPP_SERVER_INACTIVE = 0,
+    STATE_SPP_SERVER_ACTIVE,
+    STATE_SPP_SERVER_CONNECTED,
+    STATE_SPP_SERVER_RECEIVE_FILE,
+    STATE_SPP_SERVER_SEND_FILE,
+    STATE_SPP_SERVER_DISCONNECTED,
+}SppServerState;
+
+#define SPP_SERVER_CHANNEL (5)
+#define NETLINK_SPP         31
+#define NL_MSG_CTL          0
+class Spp_Server {
+
+  private:
+    config_t *config;
+    const bt_interface_t * bluetooth_interface;
+    btsock_interface_t * btsock_interface;
+    int listen_socfd;
+    int data_socfd;
+    std::string file_name;
+    SppServerState mServerState;
+
+    pthread_t server_read_thread = -1;
+    pthread_t server_write_thread = -1;
+    pthread_mutex_t server_read_thread_mutex;
+    pthread_mutex_t server_write_thread_mutex;
+    bool server_read_thread_stop_thread = false;
+    bool server_write_thread_stop_thread = false;
+    int write_thread_exit = 0;
+    int read_thread_exit = 0;
+    int kernel_sock_fd = 0;
+    int spp_max_frame_size = 0;
+    bool tty_opened = false;
+
+  public:
+
+    Spp_Server(const bt_interface_t *bt_interface, config_t *config);
+    ~Spp_Server();
+    void ProcessEvent(BtEvent* pEvent);
+    void state_inactive_handler(BtEvent* pEvent);
+    void state_connected_handler(BtEvent* pEvent);
+    void state_send_receive_handler(BtEvent* pEvent);
+    void change_state(SppServerState mState);
+    char* dump_message(BluetoothEventId event_id);
+    pthread_mutex_t lock;
+    void HandleEnableServer();
+    void HandleDisableServer();
+    void server_init();
+    void register_sdp_get_accept_socfd();
+    void receive_server_channel_info();
+    SppServerState getState() { return mServerState; }
+    int receive_file(const char* fname, int &soc_fd);
+    int snd_file(const char* fname, int &soc_fd);
+    void state_disconnected_active_handler(BtEvent* pEvent);
+    void sppsrv_send_thread_handler();
+    void sppsrv_recv_thread_handler();
+    void spp_server_thread_handler(int accept_sockfd);
+    int spp_server_create_socket();
+    int spp_start_socket_threads();
+    void spp_server_read_thread_handler();
+    void spp_server_write_thread_handler();
+    int spp_server_set_tty_driver_state(uint8_t ttyState);
+    void spp_server_read_thread_close();
+    void spp_server_write_thread_close();
+};
+
+#endif /* SPP_SERVER_APP_H */
\ No newline at end of file
diff --git a/bt-app/spp_server/src/spp_server.cpp b/bt-app/spp_server/src/spp_server.cpp
new file mode 100755
index 0000000..9f04a35
--- /dev/null
+++ b/bt-app/spp_server/src/spp_server.cpp
@@ -0,0 +1,1186 @@
+ /*
+  * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are
+  * met:
+  *  * Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *  * Redistributions in binary form must reproduce the above
+  *    copyright notice, this list of conditions and the following
+  *    disclaimer in the documentation and/or other materials provided
+  *    with the distribution.
+  *  * Neither the name of The Linux Foundation nor the names of its
+  *    contributors may be used to endorse or promote products derived
+  *    from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+
+#include <iostream>
+#include <string.h>
+#include <hardware/bluetooth.h>
+#include <hardware/bt_sock.h>
+#include "osi/include/alarm.h"
+#include "spp_server.hpp"
+#include "Gap.hpp"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <iostream>
+#include <fstream>
+#include <linux/netlink.h>
+#include <pthread.h>
+
+#define LOGTAG_SPP_SERVER "SPP_SERVER "
+
+#define WAIT_TIME_FOR_RFCOMM_INIT (1000) //
+
+#define SPP_SERVER_APP_UID (1)
+
+#define VALID_SRV_SOCFD(FD) (-1 == FD?0:1)
+#define RESET_SRV_SOCFD(FD) (FD=-1)
+
+#define NETLINK_SPP         31
+#define SPP_CTL_ON         1
+#define SPP_CTL_OFF        2
+#define SPP_CTL_DATA_LEN   9
+#define SPP_CTL_OP_POS     0
+#define SPP_CTL_INS_POS    1
+#define SPP_CTL_MTU_POS    5
+#define SPP_DATA_MTU    500
+
+using namespace std;
+using std::list;
+using std::string;
+
+Spp_Server *pSppServer = NULL;
+static pthread_t server_thread = NULL;
+typedef struct
+{
+    struct nlmsghdr n;
+    uint8_t data[0];
+} data_st;
+
+/* SPP server receive thread */
+static pthread_t server_recv_thread = NULL;
+static pthread_mutex_t recv_mutex;
+static pthread_cond_t start_recv_cv;
+
+/* SPP server send thread */
+static pthread_t server_send_thread = NULL;
+static pthread_mutex_t send_mutex;
+static pthread_cond_t start_send_cv;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void BtSppServerMsgHandler(void *msg) {
+
+    BtEvent* pEvent = NULL;
+
+    if(!msg) {
+        ALOGE("Msg is NULL, bail out!!");
+        return;
+    }
+
+    pEvent = ( BtEvent *) msg;
+
+    switch(pEvent->event_id) {
+
+        case PROFILE_API_START:
+            {
+                BtEvent *pEvent = new BtEvent;
+
+                pEvent->profile_start_event.event_id = PROFILE_EVENT_START_DONE;
+                pEvent->profile_start_event.profile_id = PROFILE_ID_SPP_SERVER;
+                PostMessage(THREAD_ID_GAP, pEvent);
+            }
+            break;
+
+        case PROFILE_API_STOP:
+
+            ALOGD(LOGTAG_SPP_SERVER "Disable spp server");
+            if (pSppServer) {
+                pSppServer->HandleDisableServer();
+            }
+            break;
+
+        default:
+
+            ALOGD(LOGTAG_SPP_SERVER "default event_id");
+            if(pSppServer) {
+               pSppServer->ProcessEvent(( BtEvent *) msg);
+            }
+            break;
+    }
+
+    delete pEvent;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+static void *spp_server_send_thread_func(void *in_param)
+{
+
+    pSppServer->sppsrv_send_thread_handler();
+    return NULL;
+
+}
+
+void Spp_Server::sppsrv_send_thread_handler()
+{
+
+    while ( mServerState != STATE_SPP_SERVER_INACTIVE )
+    {
+        /* Wait for receive command from the user */
+        while ( mServerState != STATE_SPP_SERVER_SEND_FILE )
+            pthread_cond_wait(&start_send_cv,&send_mutex);
+        pthread_mutex_unlock(&send_mutex);
+
+        /* Send File */
+        if(VALID_SRV_SOCFD(data_socfd))
+        {
+            int status = snd_file(file_name.c_str(),data_socfd);
+
+            if(status != SUCCESS)
+            {
+                ALOGD(LOGTAG_SPP_SERVER "Send file failed \n");
+            }
+
+        }
+        else
+        {
+            ALOGD(LOGTAG_SPP_SERVER "In-valid socfd, Connection may be lost");
+        }
+
+        if( !VALID_SRV_SOCFD(data_socfd) )
+        {
+            change_state(STATE_SPP_SERVER_DISCONNECTED);
+        }
+        else
+        {
+            change_state(STATE_SPP_SERVER_CONNECTED);
+        }
+    }
+
+    pthread_mutex_destroy(&send_mutex);
+    pthread_cond_destroy(&start_send_cv);
+
+}
+
+
+static void *spp_server_recv_thread_func(void *in_param)
+{
+
+    pSppServer->sppsrv_recv_thread_handler();
+    return NULL;
+
+}
+
+void Spp_Server::sppsrv_recv_thread_handler()
+{
+
+    while ( mServerState != STATE_SPP_SERVER_INACTIVE )
+    {
+        /* Wait for receive command from the user */
+        while ( mServerState != STATE_SPP_SERVER_RECEIVE_FILE )
+            pthread_cond_wait(&start_recv_cv,&recv_mutex);
+        pthread_mutex_unlock(&recv_mutex);
+
+        /* Receive File */
+        receive_file(file_name.c_str(),data_socfd);
+
+        if( !VALID_SRV_SOCFD(data_socfd) )
+        {
+            change_state(STATE_SPP_SERVER_DISCONNECTED);
+        }
+        else
+        {
+            change_state(STATE_SPP_SERVER_CONNECTED);
+        }
+    }
+
+    pthread_mutex_destroy(&recv_mutex);
+    pthread_cond_destroy(&start_recv_cv);
+
+}
+
+
+static void *spp_server_thread_func(void *in_param)
+{
+
+    int accept_sockfd = *((int*) in_param);
+    pSppServer->spp_server_thread_handler(accept_sockfd);
+    return NULL;
+
+}
+
+static void *spp_server_write_thread_func(void *arg)
+{
+    pSppServer->spp_server_write_thread_handler();
+    return NULL;
+}
+
+static void *spp_server_read_thread_func(void *arg)
+{
+    pSppServer->spp_server_read_thread_handler();
+    return NULL;
+}
+
+void Spp_Server::spp_server_write_thread_close()
+{
+    ALOGD(LOGTAG_SPP_SERVER "spp_server_write_thread_close");
+    pthread_mutex_lock(&server_write_thread_mutex);
+    server_write_thread_stop_thread = true;
+    pthread_mutex_unlock(&server_write_thread_mutex);
+}
+
+void Spp_Server::spp_server_read_thread_close()
+{
+    ALOGD(LOGTAG_SPP_SERVER "spp_server_read_thread_close");
+    pthread_mutex_lock(&server_read_thread_mutex);
+    server_read_thread_stop_thread = true;
+    pthread_mutex_unlock(&server_read_thread_mutex);
+}
+
+int Spp_Server::spp_server_set_tty_driver_state(uint8_t ttyState)
+{
+    int instanceId = 1;//Only one Instance is used!!
+    int maxFrame = spp_max_frame_size;
+    int retVal = -1;
+    struct
+    {
+        struct nlmsghdr n;
+        uint8_t data[SPP_CTL_DATA_LEN];
+    } ctl;
+
+    ALOGD(LOGTAG_SPP_SERVER "spp_server_set_tty_driver_state");
+
+    memset(&ctl, 0x00, sizeof(ctl));
+
+    ctl.data[SPP_CTL_OP_POS] = ttyState;
+    memcpy(ctl.data + SPP_CTL_INS_POS, &instanceId, sizeof(instanceId));
+
+    if (ttyState == SPP_CTL_ON)
+    {
+        memcpy(ctl.data + SPP_CTL_MTU_POS, &maxFrame, sizeof(maxFrame));
+    }
+
+    ctl.n.nlmsg_len = NLMSG_LENGTH(SPP_CTL_DATA_LEN);
+    ctl.n.nlmsg_pid = server_read_thread;  /* self pid */
+    ctl.n.nlmsg_type  = NETLINK_SPP;
+    ctl.n.nlmsg_flags = NL_MSG_CTL;
+
+    ALOGD(LOGTAG_SPP_SERVER "instanceId is %d, maxFrame is %d, nlmsg_pid is %lu, serverSocket is %d, ctl.n.nlmsg_len is %d",
+    instanceId, maxFrame, server_read_thread, kernel_sock_fd,  ctl.n.nlmsg_len);
+
+    retVal = send(kernel_sock_fd, &ctl, ctl.n.nlmsg_len, 0);
+    return retVal;
+}
+
+void Spp_Server::spp_server_write_thread_handler()
+{
+    char buffer[1024];
+    char ctrl_msgbuf[CMSG_SPACE(1)];
+    struct sockaddr_storage src_addr;
+    struct iovec iov[1];
+    iov[0].iov_base=buffer;
+    iov[0].iov_len=sizeof(buffer);
+    int count;
+
+    struct msghdr message;
+    message.msg_name=&src_addr;
+    message.msg_namelen=sizeof(src_addr);
+    message.msg_iov=iov;
+    message.msg_iovlen=1;
+    message.msg_control= ctrl_msgbuf;
+    message.msg_controllen= sizeof(ctrl_msgbuf);
+    int retVal;
+
+    ALOGD(LOGTAG_SPP_SERVER "spp_server_write_thread_handler");
+    while (1)
+    {
+        pthread_mutex_lock(&server_write_thread_mutex);
+
+        if (server_write_thread_stop_thread)
+        {
+            if (tty_opened)
+            {
+                retVal = spp_server_set_tty_driver_state(SPP_CTL_OFF);
+
+                if (retVal < 0)
+                {
+                    ALOGD(LOGTAG_SPP_SERVER "spp_server_write_thread_handler sendmsg ctl message failed!!");
+                    pthread_mutex_unlock(&server_write_thread_mutex);
+                    continue;
+                }
+                tty_opened = false;
+            }
+            pthread_mutex_unlock(&server_write_thread_mutex);
+            pthread_mutex_destroy(&server_write_thread_mutex);
+
+           ALOGD(LOGTAG_SPP_SERVER "spp_server_write_thread_handler Exiting Write Thread");
+
+            if (read_thread_exit == 1)
+            {
+                ALOGD(LOGTAG_SPP_SERVER "write thread close the socket");
+                shutdown(kernel_sock_fd, SHUT_RDWR);
+                close(kernel_sock_fd);
+                kernel_sock_fd = 0;
+            }
+
+            write_thread_exit = 1;
+            pthread_exit(NULL);
+        }
+
+        if (!tty_opened)
+        {
+            retVal = spp_server_set_tty_driver_state(SPP_CTL_ON);
+            if (retVal < 0)
+            {
+                ALOGD(LOGTAG_SPP_SERVER "spp_server_write_thread_handler retVal is %d, Sendmsg ctl message failed,%s", retVal, strerror(errno));
+                pthread_mutex_unlock(&server_write_thread_mutex);
+                continue;
+            }
+            tty_opened = true;
+            ALOGD(LOGTAG_SPP_SERVER "spp_server_write_thread_handler retVal is %d, Sendmsg ctl message successed", retVal);
+        }
+
+        pthread_mutex_unlock(&server_write_thread_mutex);
+
+        ALOGD(LOGTAG_SPP_SERVER "%s data_socfd is %d", __func__, data_socfd);
+        count = recvmsg(data_socfd, &message,0);
+
+        ALOGD(LOGTAG_SPP_SERVER "RECVD DATA, count=%d", (int)count);
+        for(int i =0; i< count ; i++)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "buffer[%d]=%c %d",i, buffer[i], buffer[i]);
+        }
+
+        if( count > 0 )
+        {
+            int bytesSent = 0;
+
+            while (bytesSent != count)
+            {
+                if (tty_opened)
+                {
+                    int currentSend = count - bytesSent;
+                    data_st *send_data = (data_st *)osi_malloc(sizeof(data_st) + currentSend);
+
+                    memset(send_data, 0x00, sizeof(data_st));
+                    memcpy(send_data->data, buffer + bytesSent, currentSend);
+                    send_data->n.nlmsg_len = NLMSG_LENGTH(currentSend);
+                    send_data->n.nlmsg_pid = server_read_thread;         /* self pid */
+                    send_data->n.nlmsg_type  = NETLINK_SPP;
+                    send_data->n.nlmsg_flags = NL_MSG_CTL + 1;       /*data flags*/
+
+                    retVal = send(kernel_sock_fd, send_data,
+                                  send_data->n.nlmsg_len, 0);
+
+                    ALOGD(LOGTAG_SPP_SERVER "send ret is %d,currentSend is %d",  retVal, currentSend);
+                    retVal = (int)(currentSend & 0x0000ffff);
+                    osi_free(send_data);
+                    send_data = NULL;
+                }
+                else
+                {
+                    ALOGD(LOGTAG_SPP_SERVER "tty_opened is false");
+                }
+                bytesSent += retVal;
+            }
+        }
+        else if( count == 0 )
+        {
+            ALOGD(LOGTAG_SPP_SERVER " connection closed by the remote");
+            RESET_SRV_SOCFD(data_socfd);
+            server_write_thread_stop_thread = true;
+        }
+        else
+        {
+            ALOGD(LOGTAG_SPP_SERVER "Receive Error count=%d", count);
+        }
+    }
+}
+
+void Spp_Server::spp_server_read_thread_handler()
+{
+    uint8_t *buffer = NULL;
+    int retVal = 0;
+    pthread_attr_t server_write_thread_attr;
+
+    ALOGD(LOGTAG_SPP_SERVER "spp_server_read_thread_handler");
+
+    pthread_mutex_init(&server_write_thread_mutex, NULL);
+    server_write_thread_stop_thread = false;
+
+    pthread_attr_init(&server_write_thread_attr);
+    pthread_attr_setdetachstate(&server_write_thread_attr, PTHREAD_CREATE_DETACHED);
+    retVal = pthread_create(&server_write_thread, &server_write_thread_attr, spp_server_write_thread_func, NULL);
+    pthread_attr_destroy(&server_write_thread_attr);
+    if (retVal != 0)
+   {
+        shutdown(kernel_sock_fd, SHUT_RDWR);
+        close(kernel_sock_fd);
+        kernel_sock_fd = 0;
+        ALOGD(LOGTAG_SPP_SERVER "!! ERROR !! Cannot create server_write_thread!\n");
+
+        pthread_mutex_destroy(&server_write_thread_mutex);
+        pthread_mutex_destroy(&server_read_thread_mutex);
+
+        pthread_exit(NULL);
+        return;
+    }
+
+    while (1)
+    {
+        if (server_read_thread_stop_thread)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "Exiting Read Thread!!");
+            pthread_mutex_destroy(&server_read_thread_mutex);
+
+            if (write_thread_exit == 1)
+            {
+                ALOGD(LOGTAG_SPP_SERVER "read thread close the socket\n");
+                shutdown(kernel_sock_fd, SHUT_RDWR);
+                close(kernel_sock_fd);
+                kernel_sock_fd = 0;
+            }
+            read_thread_exit =1;
+            pthread_exit(NULL);
+        }
+
+        buffer = (uint8_t *)osi_malloc(spp_max_frame_size+ NLMSG_LENGTH(0));
+        if (buffer == NULL)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "osi_malloc Failed!!\n");
+        }
+        memset(buffer, 0, spp_max_frame_size + NLMSG_LENGTH(0));
+
+        retVal = recv(kernel_sock_fd, buffer, spp_max_frame_size, 0);
+        if (retVal <= 0)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "retVal is %d!!\n",retVal);
+            pthread_mutex_destroy(&server_read_thread_mutex);
+            if (buffer != NULL)
+            {
+                osi_free(buffer);
+            }
+            break;
+        }
+
+        ALOGD(LOGTAG_SPP_SERVER "read thread retVal : %d \n",retVal);
+        ALOGD(LOGTAG_SPP_SERVER "read buffer is : %s \n",buffer);
+
+        if (buffer && strstr((char *)buffer, "Read_Thread_Exit") != NULL)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "%s Read_Thread_Exit!!!!\n",__func__);
+            server_read_thread_stop_thread = true;
+            osi_free(buffer);
+            buffer = NULL;
+        }
+        else if (buffer && strstr((char *)buffer, "ttySpp") != NULL)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "%s ttySpp !!!!\n",__func__);
+            osi_free(buffer);
+            buffer = NULL;
+        }
+        else
+        {
+            int count=0 ;
+
+            char send_buffer[1024];
+            char extra_char[10] = {0xD, 0xA};// 0XD:Carriage Return, 0xA: New Line Feed
+
+            memcpy(send_buffer,buffer,retVal);
+            memcpy(send_buffer+retVal, extra_char, 2);
+            for(int i =0; i< retVal+2 ; i++)
+            {
+                ALOGD(LOGTAG_SPP_SERVER "send_buffer[%d]=%c %d",i, send_buffer[i], send_buffer[i]);
+            }
+
+            pthread_mutex_lock(&server_read_thread_mutex);
+
+            ALOGD(LOGTAG_SPP_SERVER "%s data_socfd is %d", __func__, data_socfd);
+
+            count = write(data_socfd, &send_buffer,retVal+2);
+            if(count < 0)
+            {
+                ALOGD(LOGTAG_SPP_SERVER " sendmsg failed (ret=%d,errno=%d,err=%s)",count,errno,strerror(errno));
+            }
+            else
+            {
+                ALOGD(LOGTAG_SPP_SERVER " sent bytes (%d)",count);
+            }
+            pthread_mutex_unlock(&server_read_thread_mutex);
+            osi_free(buffer);
+        }
+    }
+}
+
+int Spp_Server::spp_start_socket_threads()
+{
+    pthread_attr_t server_read_thread_attr;
+    int retVal = 0;
+
+    write_thread_exit = 0;
+    read_thread_exit = 0;
+
+   ALOGD(LOGTAG_SPP_SERVER "spp_start_socket_threads!!");
+
+    pthread_mutex_init(&server_read_thread_mutex, NULL);
+    server_read_thread_stop_thread = false;
+
+    pthread_attr_init(&server_read_thread_attr);
+    pthread_attr_setdetachstate(&server_read_thread_attr, PTHREAD_CREATE_DETACHED);
+    retVal =  pthread_create(&server_read_thread, &server_read_thread_attr, spp_server_read_thread_func, NULL);
+    pthread_attr_destroy(&server_read_thread_attr);
+    if (retVal != 0) {
+        ALOGD(LOGTAG_SPP_SERVER "!! ERROR !! Cannot create server_read_thread!\n");
+        pthread_mutex_destroy(&server_read_thread_mutex);
+        return -1 ;
+    }
+    return 0;
+}
+
+int Spp_Server::spp_server_create_socket()
+{
+    struct sockaddr_nl nladdr;
+    int sz = 64 * 1024;
+    int on = 1;
+    int random = rand();
+
+    ALOGD(LOGTAG_SPP_SERVER "spp_server_create_socket random value:%d\n",random);
+    memset(&nladdr, 0, sizeof(nladdr));
+    nladdr.nl_family = AF_NETLINK;
+    nladdr.nl_pid = (unsigned int)random;
+    nladdr.nl_pad = 0;
+    nladdr.nl_groups = 0;
+
+    if ((kernel_sock_fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_SPP)) < 0)
+    {
+         ALOGD(LOGTAG_SPP_SERVER "Unable to create uevent socket");
+        return -1;
+    }
+
+    if (setsockopt(kernel_sock_fd, SOL_SOCKET, SO_RCVBUFFORCE, &sz, sizeof(sz)) < 0)
+    {
+        ALOGD(LOGTAG_SPP_SERVER "Unable to set uevent socket SO_RECBUFFORCE option");
+        close(kernel_sock_fd);
+        return -1;
+    }
+
+    if (setsockopt(kernel_sock_fd, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on)) < 0)
+    {
+        ALOGD(LOGTAG_SPP_SERVER "Unable to set uevent socket SO_PASSCRED option");
+        close(kernel_sock_fd);
+        return -1;
+    }
+
+    if ((setsockopt(kernel_sock_fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))) < 0)
+    {
+        ALOGD(LOGTAG_SPP_SERVER "Unable to set uevent socket SO_REUSEADDR option");
+        close(kernel_sock_fd);
+        return -1;
+    }
+
+    ALOGD(LOGTAG_SPP_SERVER "netlink nladdr.nl_pid is %d", nladdr.nl_pid);
+
+    if (bind(kernel_sock_fd, (struct sockaddr *) &nladdr, sizeof(nladdr)) < 0)
+    {
+        ALOGD(LOGTAG_SPP_SERVER "Unable to bind nladdr %s", strerror(errno));
+        close(kernel_sock_fd);
+        return -1;
+    }
+
+    ALOGD(LOGTAG_SPP_SERVER "kernel_sock_fd is %d", kernel_sock_fd);
+
+    return kernel_sock_fd;
+}
+
+void Spp_Server::spp_server_thread_handler(int accept_sockfd)
+{
+    char buffer[1024];
+    char ctrl_msgbuf[CMSG_SPACE(1)];
+    struct cmsghdr *pcmsg;
+    int* p_acc_fd = NULL;
+    struct sockaddr_storage src_addr;
+    sock_connect_signal_t *pConnect_Sig = NULL;
+    int i =0;
+
+    struct iovec iov[1];
+    iov[0].iov_base=buffer;
+    iov[0].iov_len=sizeof(buffer);
+
+    struct msghdr message;
+    message.msg_name=&src_addr;
+    message.msg_namelen=sizeof(src_addr);
+    message.msg_iov=iov;
+    message.msg_iovlen=1;
+    message.msg_control= ctrl_msgbuf;
+    message.msg_controllen= sizeof(ctrl_msgbuf);
+
+    ALOGD(LOGTAG_SPP_SERVER "spp_server_thread_handler started");
+    while (mServerState != STATE_SPP_SERVER_INACTIVE)
+    {
+
+        // Wait for sock_connect_signal_t message
+        int count = recvmsg(accept_sockfd,&message,0);
+
+        if (count==-1)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "recvmsg returned -1");
+            //die("%s",strerror(errno));
+        }
+        else if (message.msg_flags&MSG_TRUNC)
+        {
+            //warn("datagram too large for buffer: truncated");
+            ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB]MSG_TRUNC\n");
+        }
+        else if ( 0 == count )
+        {
+           ALOGE(LOGTAG_SPP_SERVER "ERROR listen sockfd closed");
+           spp_server_write_thread_close();
+           break;
+        }
+
+        // Handle the sock_connect_signal - remote address, server channel and status is received.
+
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] count=%d", (int)count);
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB]Received sock_connect_signal_t");
+        pConnect_Sig = (sock_connect_signal_t *) buffer;
+
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] size=%d", pConnect_Sig->size);
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] channel=%d", pConnect_Sig->channel);
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] status=%d", pConnect_Sig->status);
+
+        spp_max_frame_size  = SPP_DATA_MTU;
+
+        for(i =0; i< 6 ; i++)
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] bdadd[%d]= %02X\n",i, pConnect_Sig->bd_addr.address[i]);
+
+        pcmsg = CMSG_FIRSTHDR(&message);
+        p_acc_fd = (int*)CMSG_DATA(pcmsg);
+        ALOGD(LOGTAG_SPP_SERVER "\n [AKK_DEBUB] CTRL msg len=%d, accept_fd =%d", pcmsg->cmsg_len,*p_acc_fd);
+
+        // Send data structures
+        char send_buffer[1024];
+        struct iovec send_iov[1];
+        send_iov[0].iov_base=send_buffer;
+        send_iov[0].iov_len=sizeof(send_buffer);
+
+        struct msghdr send_message;
+        send_message.msg_name=&src_addr;
+        send_message.msg_namelen=sizeof(src_addr);
+        send_message.msg_iov=send_iov;
+        send_message.msg_iovlen=1;
+
+        if( !VALID_SRV_SOCFD(data_socfd) )
+        {
+            ALOGD(LOGTAG_SPP_SERVER "\n [AKK_DEBUB] set data_socfd and move to connected state.\n");
+            data_socfd = *p_acc_fd;
+            change_state(STATE_SPP_SERVER_CONNECTED);
+        }
+        else
+        {
+           ALOGD(LOGTAG_SPP_SERVER "Error -Active data soc fd is present, closing the existing fd(%d)", data_socfd);
+           close(data_socfd);
+           data_socfd= *p_acc_fd;
+           change_state(STATE_SPP_SERVER_CONNECTED);
+        }
+
+        if(kernel_sock_fd == 0)   //Below code needs to executed when there is no connection i.e STATE_SPP_SERVER_INACTIVE
+        {
+            if(spp_server_create_socket() == -1)
+            {
+                ALOGD(LOGTAG_SPP_SERVER "!! ERROR !! spp_server_create_socket FAILED!!\n");
+            }
+            else if (spp_start_socket_threads() == -1)
+            {
+                ALOGD(LOGTAG_SPP_SERVER "!! ERROR !! spp_start_socket_threads FAILED!!\n");
+            }
+            else
+            {
+                ALOGD(LOGTAG_SPP_SERVER "spp_server socket, threads creation is SUCCESS!!\n");
+            }
+        }
+    }
+
+
+    ALOGD(LOGTAG_SPP_SERVER "server thread about to finish");
+}
+
+void Spp_Server::register_sdp_get_accept_socfd()
+{
+
+    // Invoke listen with socket type as RFCOMM, NULL UUID - This will map to SPP UUID
+    btsock_interface = (btsock_interface_t *)bluetooth_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);
+
+    int error = btsock_interface->listen(BTSOCK_RFCOMM,"SPP_SERVER",NULL,SPP_SERVER_CHANNEL,&listen_socfd,0,SPP_SERVER_APP_UID);
+
+    if( error != BT_STATUS_SUCCESS )
+    {
+        ALOGE(LOGTAG_SPP_SERVER "Error !!!!! SPP server init failed -Unable to listen for incoming RFCOMM socket: %d\n", error);
+        fprintf(stderr, "Unable to listen for incoming RFCOMM socket: %d\n", error);
+    }
+    else
+    {
+        change_state(STATE_SPP_SERVER_ACTIVE);
+    }
+}
+
+void Spp_Server::receive_server_channel_info()
+{
+    char buffer[1024];
+    struct sockaddr_storage src_addr;
+    struct iovec iov[1];
+    iov[0].iov_base=buffer;
+    iov[0].iov_len=sizeof(buffer);
+    int i =0;
+
+    struct msghdr message;
+    message.msg_name=&src_addr;
+    message.msg_namelen=sizeof(src_addr);
+    message.msg_iov=iov;
+    message.msg_iovlen=1;
+    message.msg_control=0;
+    message.msg_controllen=0;
+
+    // Wait for Server channel number message
+    int count = recvmsg(listen_socfd,&message,0);
+
+    if (count==-1)
+    {
+        ALOGD(LOGTAG_SPP_SERVER "recvmsg returned -1");
+        //die("%s",strerror(errno));
+    }
+    else if (message.msg_flags&MSG_TRUNC)
+    {
+        //warn("datagram too large for buffer: truncated");
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB]MSG_TRUNC, count=%d", (int)count);
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB]Received Server channel ID");
+        for(i =0; i< count ; i++)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] buffer[%d]=%d",i, buffer[i]);
+        }
+
+    }
+    else
+    {
+        // Handle the sock_connect_signal - remote address, server channel and status is received.
+        //handle_datagram(buffer,count);
+
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] count=%d", (int)count);
+        ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB]Received Server channel ID");
+        for(i =0; i< count ; i++)
+        {
+            ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] buffer[%d]=%d",i, buffer[i]);
+        }
+
+    }
+
+    if( mServerState == STATE_SPP_SERVER_ACTIVE )
+    {
+        if (pthread_create(&server_thread, NULL, spp_server_thread_func, &listen_socfd) != 0) {
+            ALOGD(LOGTAG_SPP_SERVER "!! ERROR !! Cannot create spp server thread!\n");
+            return;
+        }
+
+        pthread_mutex_init(&recv_mutex, NULL);
+        pthread_cond_init(&start_recv_cv, NULL);
+        if (pthread_create(&server_recv_thread, NULL, spp_server_recv_thread_func, NULL) != 0) {
+            ALOGD(LOGTAG_SPP_SERVER "!! ERROR !! Cannot create spp server receive thread!\n");
+            return;
+        }
+
+        pthread_mutex_init(&send_mutex, NULL);
+        pthread_cond_init(&start_send_cv, NULL);
+        if (pthread_create(&server_send_thread, NULL, spp_server_send_thread_func, NULL) != 0) {
+            ALOGD(LOGTAG_SPP_SERVER "!! ERROR !! Cannot create spp server send thread!\n");
+            return;
+        }
+    }
+    else
+    {
+        ALOGE(LOGTAG_SPP_SERVER "Error !!!!! SPP server enable failed\n");
+    }
+
+}
+
+void Spp_Server::server_init()
+{
+
+    register_sdp_get_accept_socfd();
+
+    receive_server_channel_info();
+
+    ALOGD(LOGTAG_SPP_SERVER "Check looks like connection is established");
+
+}
+
+void Spp_Server::HandleEnableServer(void) {
+
+    BtEvent *pEvent = new BtEvent;
+
+    if (bluetooth_interface != NULL)
+    {
+        server_init();
+    }
+    else
+    {
+        fprintf(stdout, "Error - bluetooth_interface is NULL, Enable SPP server failed");
+        ALOGE(LOGTAG_SPP_SERVER "Error - bluetooth_interface is NULL, Enable SPP server failed");
+    }
+}
+
+void Spp_Server::HandleDisableServer(void) {
+
+   change_state(STATE_SPP_SERVER_INACTIVE);
+
+   BtEvent *pEvent = new BtEvent;
+   pEvent->profile_stop_event.event_id = PROFILE_EVENT_STOP_DONE;
+   pEvent->profile_stop_event.profile_id = PROFILE_ID_SPP_SERVER;
+   pEvent->profile_stop_event.status = true;
+   PostMessage(THREAD_ID_GAP, pEvent);
+}
+
+void Spp_Server::ProcessEvent(BtEvent* pEvent) {
+
+    switch(mServerState) {
+
+        case STATE_SPP_SERVER_INACTIVE:
+            state_inactive_handler(pEvent);
+            break;
+
+        case STATE_SPP_SERVER_ACTIVE:
+            state_disconnected_active_handler(pEvent);
+            break;
+
+        case STATE_SPP_SERVER_CONNECTED:
+            state_connected_handler(pEvent);
+            break;
+
+        case STATE_SPP_SERVER_RECEIVE_FILE:
+            state_send_receive_handler(pEvent);
+            break;
+
+        case STATE_SPP_SERVER_SEND_FILE:
+            state_send_receive_handler(pEvent);
+            break;
+
+        case STATE_SPP_SERVER_DISCONNECTED:
+            state_disconnected_active_handler(pEvent);
+            break;
+
+    }
+}
+
+char* Spp_Server::dump_message(BluetoothEventId event_id) {
+
+    switch(event_id) {
+
+        case SPP_SRV_START:
+            return (char*)"SPP_SRV_START";
+
+        case SPP_SRV_RECV_FILE:
+            return (char*)"SPP_SRV_RECV_FILE";
+
+        case SPP_SRV_SEND_FILE:
+            return (char*)"SPP_SRV_SEND_FILE";
+
+        case SPP_SRV_DISCONNECT:
+            return (char*)"SPP_SRV_DISCONNECT";
+
+    }
+    return (char*)"UNKNOWN";
+}
+
+void Spp_Server::state_inactive_handler(BtEvent* pEvent) {
+
+    ALOGD(LOGTAG_SPP_SERVER "state_inactive_handler Processing event %s", dump_message(pEvent->event_id));
+
+    switch(pEvent->event_id) {
+
+        case SPP_SRV_START:
+            {
+                if (bluetooth_interface != NULL)
+                {
+                    server_init();
+                }
+                else
+                {
+                    fprintf(stdout, "Error - bluetooth_interface is NULL, Enable SPP server failed");
+                    ALOGE(LOGTAG_SPP_SERVER "Error - bluetooth_interface is NULL, Enable SPP server failed");
+                }
+            }
+            break;
+
+        default:
+            fprintf(stdout, "Event not processed in in-active state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_SPP_SERVER " event not handled %d (%s) ", pEvent->event_id,dump_message(pEvent->event_id) );
+            break;
+    }
+}
+
+
+
+int Spp_Server::receive_file(const char* fname, int &soc_fd)
+{
+    int count  = 0;
+    int status = SUCCESS;
+    int i      = 0;
+    char buffer[1024];
+
+    char ctrl_msgbuf[CMSG_SPACE(1)];
+    struct cmsghdr *pcmsg;
+    struct sockaddr_storage src_addr;
+    struct iovec iov[1];
+    iov[0].iov_base=buffer;
+    iov[0].iov_len=sizeof(buffer);
+
+    struct msghdr message;
+    message.msg_name=&src_addr;
+    message.msg_namelen=sizeof(src_addr);
+    message.msg_iov=iov;
+    message.msg_iovlen=1;
+    message.msg_control= ctrl_msgbuf;
+    message.msg_controllen= sizeof(ctrl_msgbuf);
+
+    ALOGD(LOGTAG_SPP_SERVER "--> receive_file, fname=%s, soc_fd=%d\n", fname, soc_fd);
+
+
+    ofstream recv_file(fname,ios::out | ios::binary);
+
+    if( recv_file.is_open())
+    {
+        while ((count = recvmsg(soc_fd,&message,0)) > 0 )
+        {
+            recv_file.write(buffer,count);
+            recv_file.flush();
+            ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB]RECVD DATA, count=%d", (int)count);
+            for(i =0; i< count ; i++)
+            {
+                ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] buffer[%d]=%c",i, buffer[i]);
+            }
+        }
+
+        recv_file.flush();
+        recv_file.close();
+
+        if( count == 0 )
+        {
+            ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] connection closed by the remote");
+            spp_server_write_thread_close();
+            RESET_SRV_SOCFD(data_socfd);
+        }
+        else
+        {
+            ALOGD(LOGTAG_SPP_SERVER "[AKK_DEBUB] Receive Error count=%d", count);
+            status = FAILED;
+        }
+    }
+    else
+    {
+        ALOGE(LOGTAG_SPP_SERVER "Error opening file=%s\n", fname);
+        status = FAILED;
+    }
+
+    ALOGD(LOGTAG_SPP_SERVER "<-- receive_file, fname=%s, soc_fd=%d\n", fname, soc_fd);
+
+    return status;
+
+}
+
+int Spp_Server::snd_file(const char* fname, int &soc_fd)
+{
+    int count  = 0;
+    int status = SUCCESS;
+    char buffer[1024];
+    int max_read_size=500;
+
+    ALOGD(LOGTAG_SPP_SERVER "--> snd_file, fname=%s, soc_fd=%d\n", fname, soc_fd);
+
+
+    ifstream snd_file(fname,ios::in | ios::binary);
+
+    if( snd_file.is_open())
+    {
+        while (!snd_file.eof())
+        {
+            snd_file.read(buffer,max_read_size);
+
+            count = send(soc_fd,&buffer,snd_file.gcount(),MSG_NOSIGNAL);
+
+            if(count < 0)
+            {
+                ALOGD(LOGTAG_SPP_SERVER " sendmsg failed (ret=%d,errno=%d,err=%s)",count,errno,strerror(errno));
+                ALOGE(LOGTAG_SPP_SERVER " Aborting send_file, Invalid data socfd, connection may be lost\n");
+                fprintf(stderr, " Aborting send_file, Invalid data socfd, connection may be lost, error(%s) \n",strerror(errno));
+                RESET_SRV_SOCFD(soc_fd);
+                status = FAILED;
+                break;
+            }
+            else
+            {
+                ALOGD(LOGTAG_SPP_SERVER " sent bytes (%d)",count);
+            }
+        }
+
+        snd_file.close();
+    }
+    else
+    {
+        ALOGE(LOGTAG_SPP_SERVER "Error opening file=%s\n", fname);
+        status = FAILED;
+    }
+
+    ALOGD(LOGTAG_SPP_SERVER "<-- receive_file, fname=%s, soc_fd=%d\n", fname, soc_fd);
+
+    return status;
+
+}
+
+void Spp_Server::state_connected_handler(BtEvent* pEvent) {
+
+    ALOGD(LOGTAG_SPP_SERVER "state_connected_handler Processing event %s", dump_message(pEvent->event_id));
+
+    switch(pEvent->event_id) {
+
+        case SPP_SRV_RECV_FILE:
+            {
+                file_name = pEvent->spp_srv_event.value;
+                change_state(STATE_SPP_SERVER_RECEIVE_FILE);
+                pthread_mutex_lock(&recv_mutex);
+                pthread_cond_signal(&start_recv_cv);
+                pthread_mutex_unlock(&recv_mutex);
+            }
+            break;
+
+        case SPP_SRV_SEND_FILE:
+            {
+                file_name = pEvent->spp_srv_event.value;
+                change_state(STATE_SPP_SERVER_SEND_FILE);
+                pthread_mutex_lock(&send_mutex);
+                pthread_cond_signal(&start_send_cv);
+                pthread_mutex_unlock(&send_mutex);
+            }
+            break;
+
+        case SPP_SRV_DISCONNECT:
+            {
+                spp_server_write_thread_close();
+                shutdown(data_socfd, SHUT_RDWR);
+                close(data_socfd);
+                RESET_SRV_SOCFD(data_socfd);
+                change_state(STATE_SPP_SERVER_ACTIVE);
+            }
+            break;
+
+
+        default:
+            fprintf(stdout, "Event not processed in connected state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_SPP_SERVER " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+void Spp_Server::state_send_receive_handler(BtEvent* pEvent) {
+
+    if(mServerState == STATE_SPP_SERVER_SEND_FILE)
+    {
+        ALOGD(LOGTAG_SPP_SERVER " SPP-SRV 'SEND' state, Processing event %s", dump_message(pEvent->event_id));
+    }
+    else
+    {
+        ALOGD(LOGTAG_SPP_SERVER " SPP-SRV 'RECEIVE' state Processing event %s", dump_message(pEvent->event_id));
+    }
+
+    switch(pEvent->event_id) {
+
+        case SPP_SRV_DISCONNECT:
+            {
+                spp_server_write_thread_close();
+                shutdown(data_socfd, SHUT_RDWR);
+                close(data_socfd);
+                RESET_SRV_SOCFD(data_socfd);
+                change_state(STATE_SPP_SERVER_ACTIVE);
+            }
+            break;
+
+
+        default:
+        {
+            if(mServerState == STATE_SPP_SERVER_SEND_FILE)
+            {
+                fprintf(stdout, "Event not processed in 'SEND' state %d ", pEvent->event_id);
+            }
+            else
+            {
+                fprintf(stdout, "Event not processed in 'RECEIVE' state %d ", pEvent->event_id);
+            }
+
+            ALOGE(LOGTAG_SPP_SERVER " event not handled %d ", pEvent->event_id);
+        }
+        break;
+    }
+}
+
+
+void Spp_Server::state_disconnected_active_handler(BtEvent* pEvent) {
+
+    ALOGD(LOGTAG_SPP_SERVER "state Disconnected or Active Processing event %s", dump_message(pEvent->event_id));
+
+    switch(pEvent->event_id) {
+
+        default:
+            fprintf(stdout, "Event not processed in Disconnected or Active state %d ", pEvent->event_id);
+            ALOGE(LOGTAG_SPP_SERVER " event not handled %d ", pEvent->event_id);
+            break;
+    }
+}
+
+void Spp_Server::change_state(SppServerState mState) {
+   ALOGD(LOGTAG_SPP_SERVER " current State = %d, new state = %d", mServerState, mState);
+   pthread_mutex_lock(&lock);
+   mServerState = mState;
+   pthread_mutex_unlock(&lock);
+   ALOGD(LOGTAG_SPP_SERVER " state changed to %d ", mState);
+}
+
+Spp_Server :: Spp_Server(const bt_interface_t *bt_interface, config_t *config) {
+    ALOGD(LOGTAG_SPP_SERVER " Spp_Server constructor");
+    this->bluetooth_interface = bt_interface;
+    this->config              = config;
+    RESET_SRV_SOCFD(listen_socfd);
+    RESET_SRV_SOCFD(data_socfd);
+    pthread_mutex_init(&this->lock, NULL);
+    change_state(STATE_SPP_SERVER_INACTIVE);
+}
+
+Spp_Server :: ~Spp_Server() {
+    change_state(STATE_SPP_SERVER_INACTIVE);
+    pthread_mutex_destroy(&lock);
+    close(listen_socfd);
+    close(data_socfd);
+    RESET_SRV_SOCFD(listen_socfd);
+    RESET_SRV_SOCFD(data_socfd);
+}
+
diff --git a/gatt/Makefile.am b/gatt/Makefile.am
index 4b788bd..7b52499 100644
--- a/gatt/Makefile.am
+++ b/gatt/Makefile.am
@@ -1,12 +1,17 @@
 AM_CPPFLAGS = -O2 \
               -D_GNU_SOURCE \
-             -I${WORKSPACE}/qcom-opensource/bt/gatt/include \
-             -I${WORKSPACE}/qcom-opensource/bt/bt-app/include \
-             -I${WORKSPACE}/qcom-opensource/bt/bt-app/ \
-             -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/hal/include/ \
-             -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/vhal/include \
-             -I${WORKSPACE}/system/bt \
-             -I${WORKSPACE}/system/core/include
+             -I../../../qcom-opensource/bt/gatt/include \
+             -I../../../qcom-opensource/bt/bt-app/include \
+             -I../../../qcom-opensource/bt/bt-app/ \
+             -I../../../vendor/qcom/opensource/bluetooth/hal/include/ \
+             -I../../../vendor/qcom/opensource/bluetooth/vhal/include \
+             -I../../../system/bt \
+             -I../../../system/core/include \
+             -I../bt-app/include \
+             -I../bt-app \
+             -I../gatt/include \
+             -I../../../hardware/libhardware \
+             -I../../../hardware/libhardware/include/
 
 AM_CFLAGS = -Wall \
         -Wundef \
@@ -14,12 +19,12 @@ AM_CFLAGS = -Wall \
         -Wno-trigraphs \
         -DLINUX \
         -std=c99 \
-        -I${WORKSPACE}/qcom-opensource/bt/gatt/include \
-        -I${WORKSPACE}/qcom-opensource/bt/bt-app/include \
-        -I${WORKSPACE}/qcom-opensource/bt/bt-app/ \
-        -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/hal/include/ \
-        -I${WORKSPACE}/vendor/qcom/opensource/bluetooth/vhal/include \
-        -I${WORKSPACE}/system/core/include
+        -I../../../qcom-opensource/bt/gatt/include \
+        -I../../../qcom-opensource/bt/bt-app/include \
+        -I../../../qcom-opensource/bt/bt-app/ \
+        -I../../../vendor/qcom/opensource/bluetooth/hal/include/ \
+        -I../../../vendor/qcom/opensource/bluetooth/vhal/include \
+        -I../../../system/core/include
 
 ACLOCAL_AMFLAGS = -I m4
 
diff --git a/property-ops/include/property_ops.h b/property-ops/include/property_ops.h
index cafd82b..9652182 100644
--- a/property-ops/include/property_ops.h
+++ b/property-ops/include/property_ops.h
@@ -55,7 +55,7 @@ extern const char *path;
 #define PRI_DEBUG " D"
 #define PRI_VERB " V"
 
-#define ALOG(pri, tag, fmt, arg...) //syslog (LOG_WARNING, fmt, ##arg)
+#define ALOG(pri, tag, fmt, arg...) syslog (LOG_WARNING, fmt, ##arg)
 #define LOG_DEBUG(fmt, arg...) ALOG(PRI_VERB, LOG_TAG, fmt, ##arg)
 
 
diff --git a/property-ops/src/ll.c b/property-ops/src/ll.c
index 00ce6d5..4cc4370 100644
--- a/property-ops/src/ll.c
+++ b/property-ops/src/ll.c
@@ -72,8 +72,8 @@ bool __create_list_and_add( const char* search_name, const char* property_value)
     if (ln == NULL )
         return false;
 
-    strlcpy(ln->unit.property_name, search_name, (strlen(search_name) + 1));
-    strlcpy(ln->unit.property_value, property_value, (strlen(property_value) +1));
+    strncpy(ln->unit.property_name, search_name, (strlen(search_name) + 1));
+    strncpy(ln->unit.property_value, property_value, (strlen(property_value) +1));
 
     ln->next = NULL;
 
@@ -90,7 +90,7 @@ bool __update_prop_value(const char* search_name, const char* property_value)
     {
         LOG_DEBUG("List Matches property Updating Value\n");
         memset(ln->unit.property_value, 0, sizeof(ln->unit.property_value));
-        strlcpy(ln->unit.property_value,  property_value,
+        strncpy(ln->unit.property_value,  property_value,
             (strlen(property_value) + 1));
         LOG_DEBUG("Value copied to the db prop name %s", search_name);
         retval =0;
diff --git a/property-ops/src/property_ops.c b/property-ops/src/property_ops.c
index ec8e1c2..26fe96d 100644
--- a/property-ops/src/property_ops.c
+++ b/property-ops/src/property_ops.c
@@ -39,7 +39,7 @@
 #define LOG //LOG_DEBUG
 
 FILE *fp = NULL;
-const char *path = "../src/property_config.prop";
+const char *path = "/etc/bluetooth/property_config.prop";
 char line[MAX_ALLOWED_LINE_LEN];
 char pulled[MAX_ALLOWED_LINE_LEN];
 
@@ -181,14 +181,14 @@ property_db* __pull_one_line_data(const char* line)
             switch (iterator)
             {
                 case EXT_NAME:
-                    strlcpy(extracted_val->unit.property_name,
+                    strncpy(extracted_val->unit.property_name,
                             curr_line_ptr, (curr_length + 1) );
                     LOG_DEBUG("[%s] => Extracted Name =%s\n", __func__,
                             extracted_val->unit.property_name);
                     break;
 
                 case EXT_VAL:
-                    strlcpy(extracted_val->unit.property_value,
+                    strncpy(extracted_val->unit.property_value,
                             curr_line_ptr, (curr_length + 1));
                     LOG_DEBUG("[%s] => Extracted Value =%s\n", __func__
                             ,extracted_val->unit.property_value);
diff --git a/property-ops/src/sock_ops.c b/property-ops/src/sock_ops.c
index dfa119e..1bb6f5c 100644
--- a/property-ops/src/sock_ops.c
+++ b/property-ops/src/sock_ops.c
@@ -48,9 +48,9 @@
 
 #include "../include/property_ops.h"
 
-#define SOCK_NAMED_ADDR  "/data/misc/bluetooth/btprop"
+#define  SOCK_NAMED_ADDR  "/etc/bluetooth/btprop"
 #define TRIGGER_CONNECTION_INDEX    (1)
-#define MAX_LISTENERS               (4)
+#define MAX_LISTENERS               (20)
 //500ms, unless MAX_LISTENERS are connected
 #define INITIAL_POLLING_INTERVAL    (500000)
 
@@ -94,7 +94,7 @@ int init_local_socket(void)
     memset(&un_sock_name, 0, sizeof(struct sockaddr_un));
 
     un_sock_name.sun_family = AF_UNIX;
-    strlcpy(un_sock_name.sun_path, SOCK_NAMED_ADDR, sizeof(un_sock_name.sun_path));
+    strncpy(un_sock_name.sun_path, SOCK_NAMED_ADDR, sizeof(un_sock_name.sun_path));
     len = sizeof(un_sock_name.sun_family) + strlen(un_sock_name.sun_path);
 
     /*Bind the socket to the address.*/
@@ -104,7 +104,7 @@ int init_local_socket(void)
         unlink(SOCK_NAMED_ADDR);
         return -1;
     }
-
+    LOG_DEBUG(" listening ");
     if (listen(listening_fd,MAX_LISTENERS) < 0) {
         LOG_DEBUG("Listening failed with error (%s)\n", strerror(errno));
         close(listening_fd);
@@ -130,7 +130,7 @@ void *sock_thread_handler (void *param)
         /* Accept a connection.*/
         int len = sizeof(un_sock_name.sun_family) +
             strlen(un_sock_name.sun_path);
-
+        printf(" Thread Listener Started \n");
         if ((sdata.conn_fd[sdata.connection_counter] =
                     accept(listening_fd,(struct sockaddr *)&un_sock_name,&len))< 0)
         {
@@ -233,29 +233,30 @@ bool parse_and_exec(int cmd, unsigned char* command, unsigned char* prop_val)
     char prop_value[MAX_ALLOWED_LINE_LEN];
     char parsed_data[MAX_PROPERTY_ITER][MAX_ALLOWED_LINE_LEN] = {};
 
-    LOG_DEBUG("Command Received (%s)\n", command);
+    LOG_DEBUG("Command Received (%s) command is %d\n", command,cmd);
     memset(parsed_data, 0, sizeof(parsed_data));
     memset(prop_value, 0, sizeof(prop_value));
     memset(prop_name, 0, sizeof(prop_name));
 
-    token = strtok_r(command, delimiter, &ptr1);
+    token = strtok(command, delimiter);
     while (token) {
         LOG_DEBUG("(%s) \n", token);
-        strlcpy(parsed_data[iter ++], token, (strlen(token) + 1));
-        token = strtok_r(NULL, delimiter, &ptr1);
+        strncpy(parsed_data[iter ++], token, (strlen(token) + 1));
+        token = strtok(NULL, delimiter);
     }
 
     if (cmd == GET_PROP_VALUE) {
-        strlcpy(prop_name,parsed_data[1], (strlen(parsed_data[1]) + 1));
+        strcpy(prop_name,parsed_data[1]);
+        LOG_DEBUG("Get Prop name (%s) Prop Val (%s)\n", prop_name, prop_value);
         result = get_property_value_bt(prop_name, prop_val);
     } else if (cmd == SET_PROP_VALUE) {
-        strlcpy(prop_name,parsed_data[1], (strlen(parsed_data[1]) + 1));
-        strlcpy(prop_value,parsed_data[2], (strlen(parsed_data[2]) + 1));
+        strncpy(prop_name,parsed_data[1], (strlen(parsed_data[1]) + 1));
+        strncpy(prop_value,parsed_data[2], (strlen(parsed_data[2]) + 1));
         LOG_DEBUG("Set Prop name (%s) Prop Val (%s)\n", prop_name, prop_value);
         if (!strncmp(prop_name, "wc_transport.start_hci", strlen(prop_name))) {
             if (!strncmp(prop_value, "true", strlen(prop_value))) {
-                LOG_DEBUG("starting wcnssfilter\n");
-                system("wcnssfilter &");
+                //LOG_DEBUG("starting wcnssfilter\n");
+                //system("wcnssfilter &");
             }
         }
         if (!strncmp(prop_name, "bluetooth.startbtsnoop", strlen(prop_name))) {
@@ -296,20 +297,18 @@ int separate_recvd_commands(unsigned char * command)
     /* read if buffer has more than one properties */
     int iter = 0;
     int i = 0;
-    char *token ;
-
-    LOG_DEBUG("Command Received (%s)\n", command);
-    memset(prop_string, 0, sizeof(prop_string));
-
-    token = strtok_r(command, delimiter, &ptr1);
+    char *token  = NULL;
+    LOG_DEBUG("Local Command Received is (%s)\n", command);
+    token = strtok(command, delimiter);
+     memset(prop_string, 0, sizeof(prop_string));
     while (token)
     {
-        LOG_DEBUG("(%s) \n", token);
-        strlcpy(prop_string[iter ++], token, (strlen(token) + 1));
-        token = strtok_r(NULL, delimiter, &ptr1);
+        LOG_DEBUG("(stoken %s) \n", token);
+        strcpy(prop_string[iter ++], token);
+        token = strtok(NULL, delimiter);
     }
 
-    LOG_DEBUG("Found multiple commands (%d) \n", iter);
+     LOG_DEBUG("Found multiple commands (%d) \n", iter);
     return iter;
 }
 
@@ -317,7 +316,7 @@ bool issue_property_command(unsigned char *command, unsigned char *prop_val)
 {
     bool retval = false;
 
-    LOG_DEBUG("command string (%s) \n", command);
+    printf("command string (%s) \n", command);
 
     if(strstr(command, "get_property")!= NULL) {
         LOG_DEBUG("Command is get \n");
@@ -338,7 +337,6 @@ void *io_thread_handler (void *param)
     int descriptor_set = -1;
     int bytes_available = 0;
     int selectloop =0;
-    unsigned char buf[1024];
     int counter = 0;
     int max = 0;
     int i = 0;
@@ -346,7 +344,7 @@ void *io_thread_handler (void *param)
     struct timeval to;
     bool result = false;
     char prop_val[MAX_ALLOWED_LINE_LEN];
-
+    unsigned char buf[1024];
     //Atleast let 1 Listener start and then we can keep adding
     //and polling on the others
 
@@ -394,12 +392,10 @@ void *io_thread_handler (void *param)
                 if(FD_ISSET(sdata.conn_fd[selectloop], &sdata.socket_set))
                 {
                     //LOG_DEBUG("Data set available on (%d)\n",selectloop);
-                    memset(&buf[0], 0, sizeof(buf));
-
-                    bytes_available = recv(sdata.conn_fd[selectloop], buf,
+                   bytes_available = recv(sdata.conn_fd[selectloop], buf,
                             sizeof(buf), 0);
 
-                    if(bytes_available == 0) {
+                    if(bytes_available  == 0) {
                        /* LOG_DEBUG("I/O Done EOF counter=(%d)selectloop =(%d)\n",
                                 counter, selectloop);*/
                         shutdown(sdata.conn_fd[selectloop], SHUT_RDWR);
@@ -409,8 +405,9 @@ void *io_thread_handler (void *param)
                         //LOG_DEBUG("I/O data on fd, at index(%d)=%s\n",
                         //        selectloop,buf);
                         /* Read out the property Value */
+                        //buf[bytes_available] = NULL;
+                        //char *data = strdup(buf);
                         memset(prop_val, 0, MAX_ALLOWED_LINE_LEN);
-
                         no_of_separate_strings = separate_recvd_commands(buf);
                         if (no_of_separate_strings == 1)
                         {
@@ -468,8 +465,9 @@ int main()
 {
     void **retval;
     bool result = false;
-
     /* Database Initializer */
+    
+    printf("\n SOCKET INITIALIZER \n");
     result = create_node_from_persist(path);
     openlog ("bt_property", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
     if (result ==true)
diff --git a/property-ops/test/test_sock.c b/property-ops/test/test_sock.c
index cfc4b3c..ea0e652 100644
--- a/property-ops/test/test_sock.c
+++ b/property-ops/test/test_sock.c
@@ -39,7 +39,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include "../include/property_ops.h"
-#define SOCKETNAME  "/data/misc/bluetooth/btprop"
+#define SOCKETNAME  "/etc/bluetooth/btprop"
 #define STDIN       0
 #define STDOUT       1
 #define MAX_LEN     (1024)
